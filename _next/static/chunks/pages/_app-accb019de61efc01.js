(self.webpackChunk_N_E = self.webpackChunk_N_E || []).push([[636], {
  2805: (e, t, i) => { "use strict"; i.d(t, { N: () => x }); var r = i(9183), n = i(2111), s = i(6540), a = i(4922), o = Object.defineProperty, l = (e, t, i) => t in e ? o(e, t, { enumerable: !0, configurable: !0, writable: !0, value: i }) : e[t] = i, u = (e, t, i) => (l(e, "symbol" != typeof t ? t + "" : t, i), i); class h { constructor() { u(this, "_listeners") } addEventListener(e, t) { void 0 === this._listeners && (this._listeners = {}); let i = this._listeners; void 0 === i[e] && (i[e] = []), -1 === i[e].indexOf(t) && i[e].push(t) } hasEventListener(e, t) { if (void 0 === this._listeners) return !1; let i = this._listeners; return void 0 !== i[e] && -1 !== i[e].indexOf(t) } removeEventListener(e, t) { if (void 0 === this._listeners) return; let i = this._listeners[e]; if (void 0 !== i) { let e = i.indexOf(t); -1 !== e && i.splice(e, 1) } } dispatchEvent(e) { if (void 0 === this._listeners) return; let t = this._listeners[e.type]; if (void 0 !== t) { e.target = this; let i = t.slice(0); for (let t = 0, r = i.length; t < r; t++)i[t].call(this, e); e.target = null } } } var c = Object.defineProperty, d = (e, t, i) => t in e ? c(e, t, { enumerable: !0, configurable: !0, writable: !0, value: i }) : e[t] = i, f = (e, t, i) => (d(e, "symbol" != typeof t ? t + "" : t, i), i); let p = new a.RlV, m = new a.Zcv, g = Math.cos(Math.PI / 180 * 70), v = (e, t) => (e % t + t) % t; class y extends h { constructor(e, t) { super(), f(this, "object"), f(this, "domElement"), f(this, "enabled", !0), f(this, "target", new a.Pq0), f(this, "minDistance", 0), f(this, "maxDistance", 1 / 0), f(this, "minZoom", 0), f(this, "maxZoom", 1 / 0), f(this, "minPolarAngle", 0), f(this, "maxPolarAngle", Math.PI), f(this, "minAzimuthAngle", -1 / 0), f(this, "maxAzimuthAngle", 1 / 0), f(this, "enableDamping", !1), f(this, "dampingFactor", .05), f(this, "enableZoom", !0), f(this, "zoomSpeed", 1), f(this, "enableRotate", !0), f(this, "rotateSpeed", 1), f(this, "enablePan", !0), f(this, "panSpeed", 1), f(this, "screenSpacePanning", !0), f(this, "keyPanSpeed", 7), f(this, "zoomToCursor", !1), f(this, "autoRotate", !1), f(this, "autoRotateSpeed", 2), f(this, "reverseOrbit", !1), f(this, "reverseHorizontalOrbit", !1), f(this, "reverseVerticalOrbit", !1), f(this, "keys", { LEFT: "ArrowLeft", UP: "ArrowUp", RIGHT: "ArrowRight", BOTTOM: "ArrowDown" }), f(this, "mouseButtons", { LEFT: a.kBv.ROTATE, MIDDLE: a.kBv.DOLLY, RIGHT: a.kBv.PAN }), f(this, "touches", { ONE: a.wtR.ROTATE, TWO: a.wtR.DOLLY_PAN }), f(this, "target0"), f(this, "position0"), f(this, "zoom0"), f(this, "_domElementKeyEvents", null), f(this, "getPolarAngle"), f(this, "getAzimuthalAngle"), f(this, "setPolarAngle"), f(this, "setAzimuthalAngle"), f(this, "getDistance"), f(this, "getZoomScale"), f(this, "listenToKeyEvents"), f(this, "stopListenToKeyEvents"), f(this, "saveState"), f(this, "reset"), f(this, "update"), f(this, "connect"), f(this, "dispose"), f(this, "dollyIn"), f(this, "dollyOut"), f(this, "getScale"), f(this, "setScale"), this.object = e, this.domElement = t, this.target0 = this.target.clone(), this.position0 = this.object.position.clone(), this.zoom0 = this.object.zoom, this.getPolarAngle = () => h.phi, this.getAzimuthalAngle = () => h.theta, this.setPolarAngle = e => { let t = v(e, 2 * Math.PI), r = h.phi; r < 0 && (r += 2 * Math.PI), t < 0 && (t += 2 * Math.PI); let n = Math.abs(t - r); 2 * Math.PI - n < n && (t < r ? t += 2 * Math.PI : r += 2 * Math.PI), c.phi = t - r, i.update() }, this.setAzimuthalAngle = e => { let t = v(e, 2 * Math.PI), r = h.theta; r < 0 && (r += 2 * Math.PI), t < 0 && (t += 2 * Math.PI); let n = Math.abs(t - r); 2 * Math.PI - n < n && (t < r ? t += 2 * Math.PI : r += 2 * Math.PI), c.theta = t - r, i.update() }, this.getDistance = () => i.object.position.distanceTo(i.target), this.listenToKeyEvents = e => { e.addEventListener("keydown", ee), this._domElementKeyEvents = e }, this.stopListenToKeyEvents = () => { this._domElementKeyEvents.removeEventListener("keydown", ee), this._domElementKeyEvents = null }, this.saveState = () => { i.target0.copy(i.target), i.position0.copy(i.object.position), i.zoom0 = i.object.zoom }, this.reset = () => { i.target.copy(i.target0), i.object.position.copy(i.position0), i.object.zoom = i.zoom0, i.object.updateProjectionMatrix(), i.dispatchEvent(r), i.update(), l = o.NONE }, this.update = (() => { let t = new a.Pq0, n = new a.Pq0(0, 1, 0), s = new a.PTz().setFromUnitVectors(e.up, n), f = s.clone().invert(), v = new a.Pq0, x = new a.PTz, S = 2 * Math.PI; return function () { let A = i.object.position; s.setFromUnitVectors(e.up, n), f.copy(s).invert(), t.copy(A).sub(i.target), t.applyQuaternion(s), h.setFromVector3(t), i.autoRotate && l === o.NONE && O(2 * Math.PI / 60 / 60 * i.autoRotateSpeed), i.enableDamping ? (h.theta += c.theta * i.dampingFactor, h.phi += c.phi * i.dampingFactor) : (h.theta += c.theta, h.phi += c.phi); let _ = i.minAzimuthAngle, E = i.maxAzimuthAngle; isFinite(_) && isFinite(E) && (_ < -Math.PI ? _ += S : _ > Math.PI && (_ -= S), E < -Math.PI ? E += S : E > Math.PI && (E -= S), _ <= E ? h.theta = Math.max(_, Math.min(E, h.theta)) : h.theta = h.theta > (_ + E) / 2 ? Math.max(_, h.theta) : Math.min(E, h.theta)), h.phi = Math.max(i.minPolarAngle, Math.min(i.maxPolarAngle, h.phi)), h.makeSafe(), !0 === i.enableDamping ? i.target.addScaledVector(y, i.dampingFactor) : i.target.add(y), i.zoomToCursor && I || i.object.isOrthographicCamera ? h.radius = G(h.radius) : h.radius = G(h.radius * d), t.setFromSpherical(h), t.applyQuaternion(f), A.copy(i.target).add(t), i.object.matrixAutoUpdate || i.object.updateMatrix(), i.object.lookAt(i.target), !0 === i.enableDamping ? (c.theta *= 1 - i.dampingFactor, c.phi *= 1 - i.dampingFactor, y.multiplyScalar(1 - i.dampingFactor)) : (c.set(0, 0, 0), y.set(0, 0, 0)); let b = !1; if (i.zoomToCursor && I) { let r = null; if (i.object instanceof a.ubm && i.object.isPerspectiveCamera) { let e = t.length(); r = G(e * d); let n = e - r; i.object.position.addScaledVector(R, n), i.object.updateMatrixWorld() } else if (i.object.isOrthographicCamera) { let e = new a.Pq0(C.x, C.y, 0); e.unproject(i.object), i.object.zoom = Math.max(i.minZoom, Math.min(i.maxZoom, i.object.zoom / d)), i.object.updateProjectionMatrix(), b = !0; let n = new a.Pq0(C.x, C.y, 0); n.unproject(i.object), i.object.position.sub(n).add(e), i.object.updateMatrixWorld(), r = t.length() } else console.warn("WARNING: OrbitControls.js encountered an unknown camera type - zoom to cursor disabled."), i.zoomToCursor = !1; null !== r && (i.screenSpacePanning ? i.target.set(0, 0, -1).transformDirection(i.object.matrix).multiplyScalar(r).add(i.object.position) : (p.origin.copy(i.object.position), p.direction.set(0, 0, -1).transformDirection(i.object.matrix), Math.abs(i.object.up.dot(p.direction)) < g ? e.lookAt(i.target) : (m.setFromNormalAndCoplanarPoint(i.object.up, i.target), p.intersectPlane(m, i.target)))) } else i.object instanceof a.qUd && i.object.isOrthographicCamera && (b = 1 !== d) && (i.object.zoom = Math.max(i.minZoom, Math.min(i.maxZoom, i.object.zoom / d)), i.object.updateProjectionMatrix()); return d = 1, I = !1, !!(b || v.distanceToSquared(i.object.position) > u || 8 * (1 - x.dot(i.object.quaternion)) > u) && (i.dispatchEvent(r), v.copy(i.object.position), x.copy(i.object.quaternion), b = !1, !0) } })(), this.connect = e => { i.domElement = e, i.domElement.style.touchAction = "none", i.domElement.addEventListener("contextmenu", et), i.domElement.addEventListener("pointerdown", Q), i.domElement.addEventListener("pointercancel", $), i.domElement.addEventListener("wheel", J) }, this.dispose = () => { var e, t, r, n, s, a; i.domElement && (i.domElement.style.touchAction = "auto"), null == (e = i.domElement) || e.removeEventListener("contextmenu", et), null == (t = i.domElement) || t.removeEventListener("pointerdown", Q), null == (r = i.domElement) || r.removeEventListener("pointercancel", $), null == (n = i.domElement) || n.removeEventListener("wheel", J), null == (s = i.domElement) || s.ownerDocument.removeEventListener("pointermove", Z), null == (a = i.domElement) || a.ownerDocument.removeEventListener("pointerup", $), null !== i._domElementKeyEvents && i._domElementKeyEvents.removeEventListener("keydown", ee) }; let i = this, r = { type: "change" }, n = { type: "start" }, s = { type: "end" }, o = { NONE: -1, ROTATE: 0, DOLLY: 1, PAN: 2, TOUCH_ROTATE: 3, TOUCH_PAN: 4, TOUCH_DOLLY_PAN: 5, TOUCH_DOLLY_ROTATE: 6 }, l = o.NONE, u = 1e-6, h = new a.YHV, c = new a.YHV, d = 1, y = new a.Pq0, x = new a.I9Y, S = new a.I9Y, A = new a.I9Y, _ = new a.I9Y, E = new a.I9Y, b = new a.I9Y, T = new a.I9Y, w = new a.I9Y, M = new a.I9Y, R = new a.Pq0, C = new a.I9Y, I = !1, L = [], P = {}; function D() { return Math.pow(.95, i.zoomSpeed) } function O(e) { i.reverseOrbit || i.reverseHorizontalOrbit ? c.theta += e : c.theta -= e } function k(e) { i.reverseOrbit || i.reverseVerticalOrbit ? c.phi += e : c.phi -= e } let F = (() => { let e = new a.Pq0; return function (t, i) { e.setFromMatrixColumn(i, 0), e.multiplyScalar(-t), y.add(e) } })(), U = (() => { let e = new a.Pq0; return function (t, r) { !0 === i.screenSpacePanning ? e.setFromMatrixColumn(r, 1) : (e.setFromMatrixColumn(r, 0), e.crossVectors(i.object.up, e)), e.multiplyScalar(t), y.add(e) } })(), N = (() => { let e = new a.Pq0; return function (t, r) { let n = i.domElement; if (n && i.object instanceof a.ubm && i.object.isPerspectiveCamera) { let s = i.object.position; e.copy(s).sub(i.target); let a = e.length(); F(2 * t * (a *= Math.tan(i.object.fov / 2 * Math.PI / 180)) / n.clientHeight, i.object.matrix), U(2 * r * a / n.clientHeight, i.object.matrix) } else n && i.object instanceof a.qUd && i.object.isOrthographicCamera ? (F(t * (i.object.right - i.object.left) / i.object.zoom / n.clientWidth, i.object.matrix), U(r * (i.object.top - i.object.bottom) / i.object.zoom / n.clientHeight, i.object.matrix)) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."), i.enablePan = !1) } })(); function B(e) { i.object instanceof a.ubm && i.object.isPerspectiveCamera || i.object instanceof a.qUd && i.object.isOrthographicCamera ? d = e : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."), i.enableZoom = !1) } function z(e) { if (!i.zoomToCursor || !i.domElement) return; I = !0; let t = i.domElement.getBoundingClientRect(), r = e.clientX - t.left, n = e.clientY - t.top, s = t.width, a = t.height; C.x = r / s * 2 - 1, C.y = -(n / a * 2) + 1, R.set(C.x, C.y, 1).unproject(i.object).sub(i.object.position).normalize() } function G(e) { return Math.max(i.minDistance, Math.min(i.maxDistance, e)) } function H(e) { x.set(e.clientX, e.clientY) } function V(e) { _.set(e.clientX, e.clientY) } function W() { if (1 == L.length) x.set(L[0].pageX, L[0].pageY); else { let e = .5 * (L[0].pageX + L[1].pageX), t = .5 * (L[0].pageY + L[1].pageY); x.set(e, t) } } function j() { if (1 == L.length) _.set(L[0].pageX, L[0].pageY); else { let e = .5 * (L[0].pageX + L[1].pageX), t = .5 * (L[0].pageY + L[1].pageY); _.set(e, t) } } function Y() { let e = L[0].pageX - L[1].pageX, t = L[0].pageY - L[1].pageY, i = Math.sqrt(e * e + t * t); T.set(0, i) } function X(e) { if (1 == L.length) S.set(e.pageX, e.pageY); else { let t = er(e), i = .5 * (e.pageX + t.x), r = .5 * (e.pageY + t.y); S.set(i, r) } A.subVectors(S, x).multiplyScalar(i.rotateSpeed); let t = i.domElement; t && (O(2 * Math.PI * A.x / t.clientHeight), k(2 * Math.PI * A.y / t.clientHeight)), x.copy(S) } function K(e) { if (1 == L.length) E.set(e.pageX, e.pageY); else { let t = er(e), i = .5 * (e.pageX + t.x), r = .5 * (e.pageY + t.y); E.set(i, r) } b.subVectors(E, _).multiplyScalar(i.panSpeed), N(b.x, b.y), _.copy(E) } function q(e) { var t; let r = er(e), n = e.pageX - r.x, s = e.pageY - r.y, a = Math.sqrt(n * n + s * s); w.set(0, a), M.set(0, Math.pow(w.y / T.y, i.zoomSpeed)), t = M.y, B(d / t), T.copy(w) } function Q(e) { var t, r; !1 !== i.enabled && (0 === L.length && (null == (t = i.domElement) || t.ownerDocument.addEventListener("pointermove", Z), null == (r = i.domElement) || r.ownerDocument.addEventListener("pointerup", $)), L.push(e), "touch" === e.pointerType ? function (e) { switch (ei(e), L.length) { case 1: switch (i.touches.ONE) { case a.wtR.ROTATE: if (!1 === i.enableRotate) return; W(), l = o.TOUCH_ROTATE; break; case a.wtR.PAN: if (!1 === i.enablePan) return; j(), l = o.TOUCH_PAN; break; default: l = o.NONE }break; case 2: switch (i.touches.TWO) { case a.wtR.DOLLY_PAN: if (!1 === i.enableZoom && !1 === i.enablePan) return; i.enableZoom && Y(), i.enablePan && j(), l = o.TOUCH_DOLLY_PAN; break; case a.wtR.DOLLY_ROTATE: if (!1 === i.enableZoom && !1 === i.enableRotate) return; i.enableZoom && Y(), i.enableRotate && W(), l = o.TOUCH_DOLLY_ROTATE; break; default: l = o.NONE }break; default: l = o.NONE }l !== o.NONE && i.dispatchEvent(n) }(e) : function (e) { let t; switch (e.button) { case 0: t = i.mouseButtons.LEFT; break; case 1: t = i.mouseButtons.MIDDLE; break; case 2: t = i.mouseButtons.RIGHT; break; default: t = -1 }switch (t) { case a.kBv.DOLLY: if (!1 === i.enableZoom) return; z(e), T.set(e.clientX, e.clientY), l = o.DOLLY; break; case a.kBv.ROTATE: if (e.ctrlKey || e.metaKey || e.shiftKey) { if (!1 === i.enablePan) return; V(e), l = o.PAN } else { if (!1 === i.enableRotate) return; H(e), l = o.ROTATE } break; case a.kBv.PAN: if (e.ctrlKey || e.metaKey || e.shiftKey) { if (!1 === i.enableRotate) return; H(e), l = o.ROTATE } else { if (!1 === i.enablePan) return; V(e), l = o.PAN } break; default: l = o.NONE }l !== o.NONE && i.dispatchEvent(n) }(e)) } function Z(e) { !1 !== i.enabled && ("touch" === e.pointerType ? function (e) { switch (ei(e), l) { case o.TOUCH_ROTATE: if (!1 === i.enableRotate) return; X(e), i.update(); break; case o.TOUCH_PAN: if (!1 === i.enablePan) return; K(e), i.update(); break; case o.TOUCH_DOLLY_PAN: if (!1 === i.enableZoom && !1 === i.enablePan) return; i.enableZoom && q(e), i.enablePan && K(e), i.update(); break; case o.TOUCH_DOLLY_ROTATE: if (!1 === i.enableZoom && !1 === i.enableRotate) return; i.enableZoom && q(e), i.enableRotate && X(e), i.update(); break; default: l = o.NONE } }(e) : function (e) { if (!1 !== i.enabled) switch (l) { case o.ROTATE: if (!1 === i.enableRotate) return; !function (e) { S.set(e.clientX, e.clientY), A.subVectors(S, x).multiplyScalar(i.rotateSpeed); let t = i.domElement; t && (O(2 * Math.PI * A.x / t.clientHeight), k(2 * Math.PI * A.y / t.clientHeight)), x.copy(S), i.update() }(e); break; case o.DOLLY: var t, r; if (!1 === i.enableZoom) return; (w.set(e.clientX, e.clientY), M.subVectors(w, T), M.y > 0) ? (t = D(), B(d / t)) : M.y < 0 && (r = D(), B(d * r)), T.copy(w), i.update(); break; case o.PAN: if (!1 === i.enablePan) return; E.set(e.clientX, e.clientY), b.subVectors(E, _).multiplyScalar(i.panSpeed), N(b.x, b.y), _.copy(E), i.update() } }(e)) } function $(e) { var t, r, n; (function (e) { delete P[e.pointerId]; for (let t = 0; t < L.length; t++)if (L[t].pointerId == e.pointerId) { L.splice(t, 1); return } })(e), 0 === L.length && (null == (t = i.domElement) || t.releasePointerCapture(e.pointerId), null == (r = i.domElement) || r.ownerDocument.removeEventListener("pointermove", Z), null == (n = i.domElement) || n.ownerDocument.removeEventListener("pointerup", $)), i.dispatchEvent(s), l = o.NONE } function J(e) { if (!1 !== i.enabled && !1 !== i.enableZoom && (l === o.NONE || l === o.ROTATE)) { var t, r; e.preventDefault(), i.dispatchEvent(n), (z(e), e.deltaY < 0) ? (t = D(), B(d * t)) : e.deltaY > 0 && (r = D(), B(d / r)), i.update(), i.dispatchEvent(s) } } function ee(e) { !1 !== i.enabled && !1 !== i.enablePan && function (e) { let t = !1; switch (e.code) { case i.keys.UP: N(0, i.keyPanSpeed), t = !0; break; case i.keys.BOTTOM: N(0, -i.keyPanSpeed), t = !0; break; case i.keys.LEFT: N(i.keyPanSpeed, 0), t = !0; break; case i.keys.RIGHT: N(-i.keyPanSpeed, 0), t = !0 }t && (e.preventDefault(), i.update()) }(e) } function et(e) { !1 !== i.enabled && e.preventDefault() } function ei(e) { let t = P[e.pointerId]; void 0 === t && (t = new a.I9Y, P[e.pointerId] = t), t.set(e.pageX, e.pageY) } function er(e) { return P[(e.pointerId === L[0].pointerId ? L[1] : L[0]).pointerId] } this.dollyIn = (e = D()) => { B(d * e), i.update() }, this.dollyOut = (e = D()) => { B(d / e), i.update() }, this.getScale = () => d, this.setScale = e => { B(e), i.update() }, this.getZoomScale = () => D(), void 0 !== t && this.connect(t), this.update() } } let x = s.forwardRef(({ makeDefault: e, camera: t, regress: i, domElement: a, enableDamping: o = !0, keyEvents: l = !1, onChange: u, onStart: h, onEnd: c, ...d }, f) => { let p = (0, n.A)(e => e.invalidate), m = (0, n.A)(e => e.camera), g = (0, n.A)(e => e.gl), v = (0, n.A)(e => e.events), x = (0, n.A)(e => e.setEvents), S = (0, n.A)(e => e.set), A = (0, n.A)(e => e.get), _ = (0, n.A)(e => e.performance), E = t || m, b = a || v.connected || g.domElement, T = s.useMemo(() => new y(E), [E]); return (0, n.C)(() => { T.enabled && T.update() }, -1), s.useEffect(() => (l && T.connect(!0 === l ? b : l), T.connect(b), () => void T.dispose()), [l, b, i, T, p]), s.useEffect(() => { let e = e => { p(), i && _.regress(), u && u(e) }, t = e => { h && h(e) }, r = e => { c && c(e) }; return T.addEventListener("change", e), T.addEventListener("start", t), T.addEventListener("end", r), () => { T.removeEventListener("start", t), T.removeEventListener("end", r), T.removeEventListener("change", e) } }, [u, h, c, T, p, x]), s.useEffect(() => { if (e) { let e = A().controls; return S({ controls: T }), () => S({ controls: e }) } }, [e, T]), s.createElement("primitive", (0, r.A)({ ref: f, object: T, enableDamping: o }, d)) }) }, 7443: (e, t, i) => { "use strict"; i.d(t, { p: () => a }), i(6540); var r = i(4922), n = i(1323); let s = 0, a = (0, n.v)(e => (r.h_9.onStart = (t, i, r) => { e({ active: !0, item: t, loaded: i, total: r, progress: (i - s) / (r - s) * 100 }) }, r.h_9.onLoad = () => { e({ active: !1 }) }, r.h_9.onError = t => e(e => ({ errors: [...e.errors, t] })), r.h_9.onProgress = (t, i, r) => { i === r && (s = r), e({ active: !0, item: t, loaded: i, total: r, progress: (i - s) / (r - s) * 100 || 100 }) }, { errors: [], active: !1, progress: 0, item: "", loaded: 0, total: 0 })) }, 2445: (e, t, i) => { "use strict"; i.d(t, { zo: () => o }); var r = i(6540), n = i(4922), s = i(2111); let a = e => e === Object(e) && !Array.isArray(e) && "function" != typeof e; function o(e, t) { let i = (0, s.A)(e => e.gl), o = (0, s.F)(n.Tap, a(e) ? Object.values(e) : e); return (0, r.useLayoutEffect)(() => { null == t || t(o) }, [t]), (0, r.useEffect)(() => { if ("initTexture" in i) { let e = []; Array.isArray(o) ? e = o : o instanceof n.gPd ? e = [o] : a(o) && (e = Object.values(o)), e.forEach(e => { e instanceof n.gPd && i.initTexture(e) }) } }, [i, o]), (0, r.useMemo)(() => { if (!a(e)) return o; { let t = {}, i = 0; for (let r in e) t[r] = o[i++]; return t } }, [e, o]) } o.preload = e => s.F.preload(n.Tap, e), o.clear = e => s.F.clear(n.Tap, e) }, 2111: (e, t, i) => { "use strict"; let r, n, s, a, o; i.d(t, { A: () => ei, B: () => L, C: () => er, E: () => P, F: () => eo, _: () => ew, a: () => C, b: () => R, c: () => eR, d: () => eI, e: () => ef, f: () => eq, i: () => w, j: () => eU, k: () => eN, l: () => eB, o: () => eL, u: () => I }); var l = i(4922), u = i(9437), h = i(6540), c = i(772), d = i(9242), f = i(7283); let { useSyncExternalStoreWithSelector: p } = d, m = e => e, g = (e, t) => { let i = (0, f.y)(e), r = (e, r = t) => (function (e, t = m, i) { let r = p(e.subscribe, e.getState, e.getInitialState, t, i); return h.useDebugValue(r), r })(i, e, r); return Object.assign(r, i), r }, v = (e, t) => e ? g(e, t) : g; var y = i(4845), x = i.n(y), S = i(9982), A = i(6749), _ = i(4848), E = i(9318); function b(e) { let t = e.root; for (; t.getState().previousRoot;)t = t.getState().previousRoot; return t } i(7836), h.act; let T = e => e && e.isOrthographicCamera, w = e => e && e.hasOwnProperty("current"), M = e => null != e && ("string" == typeof e || "number" == typeof e || e.isColor), R = ((e, t) => "undefined" != typeof window && ((null == (e = window.document) ? void 0 : e.createElement) || (null == (t = window.navigator) ? void 0 : t.product) === "ReactNative"))() ? h.useLayoutEffect : h.useEffect; function C(e) { let t = h.useRef(e); return R(() => void (t.current = e), [e]), t } function I() { let e = (0, E.u5)(), t = (0, E.y3)(); return h.useMemo(() => ({ children: i }) => { let r = (0, E.Nz)(e, !0, e => e.type === h.StrictMode) ? h.StrictMode : h.Fragment; return (0, _.jsx)(r, { children: (0, _.jsx)(t, { children: i }) }) }, [e, t]) } function L({ set: e }) { return R(() => (e(new Promise(() => null)), () => e(!1)), [e]), null } let P = (e => ((e = class extends h.Component { constructor(...e) { super(...e), this.state = { error: !1 } } componentDidCatch(e) { this.props.set(e) } render() { return this.state.error ? null : this.props.children } }).getDerivedStateFromError = () => ({ error: !0 }), e))(); function D(e) { var t; let i = "undefined" != typeof window ? null != (t = window.devicePixelRatio) ? t : 2 : 1; return Array.isArray(e) ? Math.min(Math.max(e[0], i), e[1]) : e } function O(e) { var t; return null == (t = e.__r3f) ? void 0 : t.root.getState() } let k = { obj: e => e === Object(e) && !k.arr(e) && "function" != typeof e, fun: e => "function" == typeof e, str: e => "string" == typeof e, num: e => "number" == typeof e, boo: e => "boolean" == typeof e, und: e => void 0 === e, nul: e => null === e, arr: e => Array.isArray(e), equ(e, t, { arrays: i = "shallow", objects: r = "reference", strict: n = !0 } = {}) { let s; if (typeof e != typeof t || !!e != !!t) return !1; if (k.str(e) || k.num(e) || k.boo(e)) return e === t; let a = k.obj(e); if (a && "reference" === r) return e === t; let o = k.arr(e); if (o && "reference" === i) return e === t; if ((o || a) && e === t) return !0; for (s in e) if (!(s in t)) return !1; if (a && "shallow" === i && "shallow" === r) { for (s in n ? t : e) if (!k.equ(e[s], t[s], { strict: n, objects: "reference" })) return !1 } else for (s in n ? t : e) if (e[s] !== t[s]) return !1; if (k.und(s)) { if (o && 0 === e.length && 0 === t.length || a && 0 === Object.keys(e).length && 0 === Object.keys(t).length) return !0; if (e !== t) return !1 } return !0 } }, F = ["children", "key", "ref"]; function U(e, t, i, r) { let n = null == e ? void 0 : e.__r3f; return !n && (n = { root: t, type: i, parent: null, children: [], props: function (e) { let t = {}; for (let i in e) F.includes(i) || (t[i] = e[i]); return t }(r), object: e, eventCount: 0, handlers: {}, isHidden: !1 }, e && (e.__r3f = n)), n } function N(e, t) { var i; let r = e[t]; if (!t.includes("-")) return { root: e, key: t, target: r }; let n = t.split("-"); return r = n.reduce((e, t) => e[t], e), t = n.pop(), null != (i = r) && i.set || (e = n.reduce((e, t) => e[t], e)), { root: e, key: t, target: r } } let B = /-\d+$/; function z(e, t) { if (k.str(t.props.attach)) { if (B.test(t.props.attach)) { let i = t.props.attach.replace(B, ""), { root: r, key: n } = N(e.object, i); Array.isArray(r[n]) || (r[n] = []) } let { root: i, key: r } = N(e.object, t.props.attach); t.previousAttach = i[r], i[r] = t.object } else k.fun(t.props.attach) && (t.previousAttach = t.props.attach(e.object, t.object)) } function G(e, t) { if (k.str(t.props.attach)) { let { root: i, key: r } = N(e.object, t.props.attach), n = t.previousAttach; void 0 === n ? delete i[r] : i[r] = n } else null == t.previousAttach || t.previousAttach(e.object, t.object); delete t.previousAttach } let H = [...F, "args", "dispose", "attach", "object", "onUpdate", "dispose"], V = new Map, W = ["map", "emissiveMap", "sheenColorMap", "specularColorMap", "envMap"], j = /^on(Pointer|Click|DoubleClick|ContextMenu|Wheel)/; function Y(e, t) { var i, r; let n = e.__r3f, s = n && b(n).getState(), a = null == n ? void 0 : n.eventCount; for (let i in t) { let a = t[i]; if (H.includes(i)) continue; if (n && j.test(i)) { "function" == typeof a ? n.handlers[i] = a : delete n.handlers[i], n.eventCount = Object.keys(n.handlers).length; continue } if (void 0 === a) continue; let { root: o, key: u, target: h } = N(e, i); h instanceof l.zgK && a instanceof l.zgK ? h.mask = a.mask : h instanceof l.Q1f && M(a) ? h.set(a) : null !== h && "object" == typeof h && "function" == typeof h.set && "function" == typeof h.copy && null != a && a.constructor && h.constructor === a.constructor ? h.copy(a) : null !== h && "object" == typeof h && "function" == typeof h.set && Array.isArray(a) ? "function" == typeof h.fromArray ? h.fromArray(a) : h.set(...a) : null !== h && "object" == typeof h && "function" == typeof h.set && "number" == typeof a ? "function" == typeof h.setScalar ? h.setScalar(a) : h.set(a) : (o[u] = a, s && !s.linear && W.includes(u) && null != (r = o[u]) && r.isTexture && o[u].format === l.GWd && o[u].type === l.OUM && (o[u].colorSpace = l.er$)) } if (null != n && n.parent && null != s && s.internal && null != (i = n.object) && i.isObject3D && a !== n.eventCount) { let e = n.object, t = s.internal.interaction.indexOf(e); t > -1 && s.internal.interaction.splice(t, 1), n.eventCount && null !== e.raycast && s.internal.interaction.push(e) } return n && void 0 === n.props.attach && (n.object.isBufferGeometry ? n.props.attach = "geometry" : n.object.isMaterial && (n.props.attach = "material")), n && X(n), e } function X(e) { var t; if (!e.parent) return; null == e.props.onUpdate || e.props.onUpdate(e.object); let i = null == (t = e.root) ? void 0 : null == t.getState ? void 0 : t.getState(); i && 0 === i.internal.frames && i.invalidate() } function K(e, t) { e.manual || (T(e) ? (e.left = -(t.width / 2), e.right = t.width / 2, e.top = t.height / 2, e.bottom = -(t.height / 2)) : e.aspect = t.width / t.height, e.updateProjectionMatrix()) } let q = e => null == e ? void 0 : e.isObject3D; function Q(e) { return (e.eventObject || e.object).uuid + "/" + e.index + e.instanceId } function Z(e, t, i, r) { let n = i.get(t); n && (i.delete(t), 0 === i.size && (e.delete(r), n.target.releasePointerCapture(r))) } let $ = e => !!(null != e && e.render), J = h.createContext(null), ee = (e, t) => { let i = v((i, r) => { let n; let s = new l.Pq0, a = new l.Pq0, o = new l.Pq0; function u(e = r().camera, t = a, i = r().size) { let { width: n, height: l, top: h, left: c } = i, d = n / l; t.isVector3 ? o.copy(t) : o.set(...t); let f = e.getWorldPosition(s).distanceTo(o); if (T(e)) return { width: n / e.zoom, height: l / e.zoom, top: h, left: c, factor: 1, distance: f, aspect: d }; { let t = 2 * Math.tan(e.fov * Math.PI / 180 / 2) * f, i = n / l * t; return { width: i, height: t, top: h, left: c, factor: n / i, distance: f, aspect: d } } } let c = e => i(t => ({ performance: { ...t.performance, current: e } })), d = new l.I9Y; return { set: i, get: r, gl: null, camera: null, raycaster: null, events: { priority: 1, enabled: !0, connected: !1 }, scene: null, xr: null, invalidate: (t = 1) => e(r(), t), advance: (e, i) => t(e, i, r()), legacy: !1, linear: !1, flat: !1, controls: null, clock: new l.zD7, pointer: d, mouse: d, frameloop: "always", onPointerMissed: void 0, performance: { current: 1, min: .5, max: 1, debounce: 200, regress: () => { let e = r(); n && clearTimeout(n), e.performance.current !== e.performance.min && c(e.performance.min), n = setTimeout(() => c(r().performance.max), e.performance.debounce) } }, size: { width: 0, height: 0, top: 0, left: 0 }, viewport: { initialDpr: 0, dpr: 0, width: 0, height: 0, top: 0, left: 0, aspect: 0, distance: 0, factor: 0, getCurrentViewport: u }, setEvents: e => i(t => ({ ...t, events: { ...t.events, ...e } })), setSize: (e, t, n = 0, s = 0) => { let o = r().camera, l = { width: e, height: t, top: n, left: s }; i(e => ({ size: l, viewport: { ...e.viewport, ...u(o, a, l) } })) }, setDpr: e => i(t => { let i = D(e); return { viewport: { ...t.viewport, dpr: i, initialDpr: t.viewport.initialDpr || i } } }), setFrameloop: (e = "always") => { let t = r().clock; t.stop(), t.elapsedTime = 0, "never" !== e && (t.start(), t.elapsedTime = 0), i(() => ({ frameloop: e })) }, previousRoot: void 0, internal: { interaction: [], hovered: new Map, subscribers: [], initialClick: [0, 0], initialHits: [], capturedMap: new Map, lastEvent: h.createRef(), active: !1, frames: 0, priority: 0, subscribe: (e, t, i) => { let n = r().internal; return n.priority = n.priority + (t > 0 ? 1 : 0), n.subscribers.push({ ref: e, priority: t, store: i }), n.subscribers = n.subscribers.sort((e, t) => e.priority - t.priority), () => { let i = r().internal; null != i && i.subscribers && (i.priority = i.priority - (t > 0 ? 1 : 0), i.subscribers = i.subscribers.filter(t => t.ref !== e)) } } } } }), r = i.getState(), n = r.size, s = r.viewport.dpr, a = r.camera; return i.subscribe(() => { let { camera: e, size: t, viewport: r, gl: o, set: l } = i.getState(); if (t.width !== n.width || t.height !== n.height || r.dpr !== s) { n = t, s = r.dpr, K(e, t), r.dpr > 0 && o.setPixelRatio(r.dpr); let i = "undefined" != typeof HTMLCanvasElement && o.domElement instanceof HTMLCanvasElement; o.setSize(t.width, t.height, i) } e !== a && (a = e, l(t => ({ viewport: { ...t.viewport, ...t.viewport.getCurrentViewport(e) } }))) }), i.subscribe(t => e(t)), i }; function et() { let e = h.useContext(J); if (!e) throw Error("R3F: Hooks can only be used within the Canvas component!"); return e } function ei(e = e => e, t) { return et()(e, t) } function er(e, t = 0) { let i = et(), r = i.getState().internal.subscribe, n = C(e); return R(() => r(n, t, i), [t, r, i]), null } let en = new WeakMap, es = e => { var t; return "function" == typeof e && (null == e ? void 0 : null == (t = e.prototype) ? void 0 : t.constructor) === e }; function ea(e, t) { return function (i, ...r) { let n; return es(i) ? (n = en.get(i)) || (n = new i, en.set(i, n)) : n = i, e && e(n), Promise.all(r.map(e => new Promise((i, r) => n.load(e, e => { q(null == e ? void 0 : e.scene) && Object.assign(e, function (e) { let t = { nodes: {}, materials: {} }; return e && e.traverse(e => { e.name && (t.nodes[e.name] = e), e.material && !t.materials[e.material.name] && (t.materials[e.material.name] = e.material) }), t }(e.scene)), i(e) }, t, t => r(Error(`Could not load ${e}: ${null == t ? void 0 : t.message}`)))))) } } function eo(e, t, i, r) { let n = Array.isArray(t) ? t : [t], s = (0, A.DY)(ea(i, r), [e, ...n], { equal: k.equ }); return Array.isArray(t) ? s : s[0] } eo.preload = function (e, t, i) { let r = Array.isArray(t) ? t : [t]; return (0, A.uv)(ea(i), [e, ...r]) }, eo.clear = function (e, t) { let i = Array.isArray(t) ? t : [t]; return (0, A.IU)([e, ...i]) }; let el = {}, eu = /^three(?=[A-Z])/, eh = e => `${e[0].toUpperCase()}${e.slice(1)}`, ec = 0, ed = e => "function" == typeof e; function ef(e) { if (ed(e)) { let t = `${ec++}`; return el[t] = e, t } Object.assign(el, e) } function ep(e, t) { let i = eh(e), r = el[i]; if ("primitive" !== e && !r) throw Error(`R3F: ${i} is not part of the THREE namespace! Did you forget to extend? See: https://docs.pmnd.rs/react-three-fiber/api/objects#using-3rd-party-objects-declaratively`); if ("primitive" === e && !t.object) throw Error("R3F: Primitives without 'object' are invalid!"); if (void 0 !== t.args && !Array.isArray(t.args)) throw Error("R3F: The args prop must be an array!") } function em(e) { if (e.isHidden) { var t; e.props.attach && null != (t = e.parent) && t.object ? z(e.parent, e) : q(e.object) && !1 !== e.props.visible && (e.object.visible = !0), e.isHidden = !1, X(e) } } function eg(e, t, i) { let r = t.root.getState(); if (e.parent || e.object === r.scene) { if (!t.object) { var n, s; let e = el[eh(t.type)]; t.object = null != (n = t.props.object) ? n : new e(...null != (s = t.props.args) ? s : []), t.object.__r3f = t } if (Y(t.object, t.props), t.props.attach) z(e, t); else if (q(t.object) && q(e.object)) { let r = e.object.children.indexOf(null == i ? void 0 : i.object); i && -1 !== r ? (t.object.parent = e.object, e.object.children.splice(r, 0, t.object), t.object.dispatchEvent({ type: "added" }), e.object.dispatchEvent({ type: "childadded", child: t.object })) : e.object.add(t.object) } for (let e of t.children) eg(t, e); X(t) } } function ev(e, t) { t && (t.parent = e, e.children.push(t), eg(e, t)) } function ey(e, t, i) { if (!t || !i) return; t.parent = e; let r = e.children.indexOf(i); -1 !== r ? e.children.splice(r, 0, t) : e.children.push(t), eg(e, t, i) } function ex(e) { if ("function" == typeof e.dispose) { let t = () => { try { e.dispose() } catch { } }; "undefined" != typeof IS_REACT_ACT_ENVIRONMENT ? t() : (0, S.unstable_scheduleCallback)(S.unstable_IdlePriority, t) } } function eS(e, t, i) { if (!t) return; t.parent = null; let r = e.children.indexOf(t); -1 !== r && e.children.splice(r, 1), t.props.attach ? G(e, t) : q(t.object) && q(e.object) && (e.object.remove(t.object), function (e, t) { let { internal: i } = e.getState(); i.interaction = i.interaction.filter(e => e !== t), i.initialHits = i.initialHits.filter(e => e !== t), i.hovered.forEach((e, r) => { (e.eventObject === t || e.object === t) && i.hovered.delete(r) }), i.capturedMap.forEach((e, r) => { Z(i.capturedMap, t, e, r) }) }(b(t), t.object)); let n = null !== t.props.dispose && !1 !== i; for (let e = t.children.length - 1; e >= 0; e--) { let i = t.children[e]; eS(t, i, n) } t.children.length = 0, delete t.object.__r3f, n && "primitive" !== t.type && "Scene" !== t.object.type && ex(t.object), void 0 === i && X(t) } let eA = [], e_ = () => { }, eE = {}, eb = 0, eT = function (e) { let t = x()(e); return t.injectIntoDevTools({ bundleType: 0, rendererPackageName: "@react-three/fiber", version: h.version }), t }({ isPrimaryRenderer: !1, warnsIfNotActing: !1, supportsMutation: !0, supportsPersistence: !1, supportsHydration: !1, createInstance: function (e, t, i) { var r; return ep(e = eh(e) in el ? e : e.replace(eu, ""), t), "primitive" === e && null != (r = t.object) && r.__r3f && delete t.object.__r3f, U(t.object, i, e, t) }, removeChild: eS, appendChild: ev, appendInitialChild: ev, insertBefore: ey, appendChildToContainer(e, t) { let i = e.getState().scene.__r3f; t && i && ev(i, t) }, removeChildFromContainer(e, t) { let i = e.getState().scene.__r3f; t && i && eS(i, t) }, insertInContainerBefore(e, t, i) { let r = e.getState().scene.__r3f; t && i && r && ey(r, t, i) }, getRootHostContext: () => eE, getChildHostContext: () => eE, commitUpdate(e, t, i, r, n) { var s, a, o; ep(t, r); let l = !1; if ("primitive" === e.type && i.object !== r.object ? l = !0 : (null == (s = r.args) ? void 0 : s.length) !== (null == (a = i.args) ? void 0 : a.length) ? l = !0 : null != (o = r.args) && o.some((e, t) => { var r; return e !== (null == (r = i.args) ? void 0 : r[t]) }) && (l = !0), l) eA.push([e, { ...r }, n]); else { let t = function (e, t) { let i = {}; for (let r in t) if (!H.includes(r) && !k.equ(t[r], e.props[r])) for (let e in i[r] = t[r], t) e.startsWith(`${r}-`) && (i[e] = t[e]); for (let r in e.props) { if (H.includes(r) || t.hasOwnProperty(r)) continue; let { root: n, key: s } = N(e.object, r); if (n.constructor && 0 === n.constructor.length) { let e = function (e) { let t = V.get(e.constructor); try { t || (t = new e.constructor, V.set(e.constructor, t)) } catch (e) { } return t }(n); k.und(e) || (i[s] = e[s]) } else i[s] = 0 } return i }(e, r); Object.keys(t).length && (Object.assign(e.props, t), Y(e.object, t)) } (null === n.sibling || (4 & n.flags) == 0) && function () { for (let [e] of eA) { let t = e.parent; if (t) for (let i of (e.props.attach ? G(t, e) : q(e.object) && q(t.object) && t.object.remove(e.object), e.children)) i.props.attach ? G(e, i) : q(i.object) && q(e.object) && e.object.remove(i.object); e.isHidden && em(e), e.object.__r3f && delete e.object.__r3f, "primitive" !== e.type && ex(e.object) } for (let [i, r, n] of eA) { i.props = r; let s = i.parent; if (s) { var e, t; let r = el[eh(i.type)]; for (let a of (i.object = null != (e = i.props.object) ? e : new r(...null != (t = i.props.args) ? t : []), i.object.__r3f = i, !function (e, t) { for (let i of [e, e.alternate]) if (null !== i) { if ("function" == typeof i.ref) { null == i.refCleanup || i.refCleanup(); let e = i.ref(t); "function" == typeof e && (i.refCleanup = e) } else i.ref && (i.ref.current = t) } }(n, i.object), Y(i.object, i.props), i.props.attach ? z(s, i) : q(i.object) && q(s.object) && s.object.add(i.object), i.children)) a.props.attach ? z(i, a) : q(a.object) && q(i.object) && i.object.add(a.object); X(i) } } eA.length = 0 }() }, finalizeInitialChildren: () => !1, commitMount() { }, getPublicInstance: e => null == e ? void 0 : e.object, prepareForCommit: () => null, preparePortalMount: e => U(e.getState().scene, e, "", {}), resetAfterCommit: () => { }, shouldSetTextContent: () => !1, clearContainer: () => !1, hideInstance: function (e) { if (!e.isHidden) { var t; e.props.attach && null != (t = e.parent) && t.object ? G(e.parent, e) : q(e.object) && (e.object.visible = !1), e.isHidden = !0, X(e) } }, unhideInstance: em, createTextInstance: e_, hideTextInstance: e_, unhideTextInstance: e_, scheduleTimeout: "function" == typeof setTimeout ? setTimeout : void 0, cancelTimeout: "function" == typeof clearTimeout ? clearTimeout : void 0, noTimeout: -1, getInstanceFromNode: () => null, beforeActiveInstanceBlur() { }, afterActiveInstanceBlur() { }, detachDeletedInstance() { }, prepareScopeUpdate() { }, getInstanceFromScope: () => null, shouldAttemptEagerTransition: () => !1, trackSchedulerEvent: () => { }, resolveEventType: () => null, resolveEventTimeStamp: () => -1.1, requestPostPaintCallback() { }, maySuspendCommit: () => !1, preloadInstance: () => !0, startSuspendingCommit() { }, suspendInstance() { }, waitForCommitToBeReady: () => null, NotPendingTransition: null, HostTransitionContext: h.createContext(null), setCurrentUpdatePriority(e) { eb = e }, getCurrentUpdatePriority: () => eb, resolveUpdatePriority() { var e; if (0 !== eb) return eb; switch ("undefined" != typeof window && (null == (e = window.event) ? void 0 : e.type)) { case "click": case "contextmenu": case "dblclick": case "pointercancel": case "pointerdown": case "pointerup": return c.DiscreteEventPriority; case "pointermove": case "pointerout": case "pointerover": case "pointerenter": case "pointerleave": case "wheel": return c.ContinuousEventPriority; default: return c.DefaultEventPriority } }, resetFormInstance() { } }), ew = new Map, eM = { objects: "shallow", strict: !1 }; function eR(e) { let t, i; let r = ew.get(e), n = null == r ? void 0 : r.fiber, s = null == r ? void 0 : r.store; r && console.warn("R3F.createRoot should only be called once!"); let a = "function" == typeof reportError ? reportError : console.error, o = s || ee(eY, eX), h = n || eT.createContainer(o, c.ConcurrentRoot, null, !1, null, "", a, a, a, null); r || ew.set(e, { fiber: h, store: o }); let d = !1, f = null; return { async configure(r = {}) { var n, s; let a; f = new Promise(e => a = e); let { gl: h, size: c, scene: p, events: m, onCreated: g, shadows: v = !1, linear: y = !1, flat: x = !1, legacy: S = !1, orthographic: A = !1, frameloop: _ = "always", dpr: E = [1, 2], performance: b, raycaster: T, camera: w, onPointerMissed: M } = r, R = o.getState(), C = R.gl; if (!R.gl) { let t = { canvas: e, powerPreference: "high-performance", antialias: !0, alpha: !0 }, i = "function" == typeof h ? await h(t) : h; C = $(i) ? i : new u.WebGLRenderer({ ...t, ...h }), R.set({ gl: C }) } let I = R.raycaster; I || R.set({ raycaster: I = new l.tBo }); let { params: L, ...P } = T || {}; if (k.equ(P, I, eM) || Y(I, { ...P }), k.equ(L, I.params, eM) || Y(I, { params: { ...I.params, ...L } }), !R.camera || R.camera === i && !k.equ(i, w, eM)) { i = w; let e = null == w ? void 0 : w.isCamera, t = e ? w : A ? new l.qUd(0, 0, 0, 0, .1, 1e3) : new l.ubm(75, 0, .1, 1e3); e || (t.position.z = 5, w && (Y(t, w), !t.manual && ("aspect" in w || "left" in w || "right" in w || "bottom" in w || "top" in w) && (t.manual = !0, t.updateProjectionMatrix())), R.camera || null != w && w.rotation || t.lookAt(0, 0, 0)), R.set({ camera: t }), I.camera = t } if (!R.scene) { let e; null != p && p.isScene ? U(e = p, o, "", {}) : (U(e = new l.Z58, o, "", {}), p && Y(e, p)), R.set({ scene: e }) } m && !R.events.handlers && R.set({ events: m(o) }); let O = function (e, t) { if (!t && "undefined" != typeof HTMLCanvasElement && e instanceof HTMLCanvasElement && e.parentElement) { let { width: t, height: i, top: r, left: n } = e.parentElement.getBoundingClientRect(); return { width: t, height: i, top: r, left: n } } return !t && "undefined" != typeof OffscreenCanvas && e instanceof OffscreenCanvas ? { width: e.width, height: e.height, top: 0, left: 0 } : { width: 0, height: 0, top: 0, left: 0, ...t } }(e, c); if (k.equ(O, R.size, eM) || R.setSize(O.width, O.height, O.top, O.left), E && R.viewport.dpr !== D(E) && R.setDpr(E), R.frameloop !== _ && R.setFrameloop(_), R.onPointerMissed || R.set({ onPointerMissed: M }), b && !k.equ(b, R.performance, eM) && R.set(e => ({ performance: { ...e.performance, ...b } })), !R.xr) { let e = (e, t) => { let i = o.getState(); "never" !== i.frameloop && eX(e, !0, i, t) }, t = () => { let t = o.getState(); t.gl.xr.enabled = t.gl.xr.isPresenting, t.gl.xr.setAnimationLoop(t.gl.xr.isPresenting ? e : null), t.gl.xr.isPresenting || eY(t) }, i = { connect() { let e = o.getState().gl; e.xr.addEventListener("sessionstart", t), e.xr.addEventListener("sessionend", t) }, disconnect() { let e = o.getState().gl; e.xr.removeEventListener("sessionstart", t), e.xr.removeEventListener("sessionend", t) } }; "function" == typeof (null == (n = C.xr) ? void 0 : n.addEventListener) && i.connect(), R.set({ xr: i }) } if (C.shadowMap) { let e = C.shadowMap.enabled, t = C.shadowMap.type; if (C.shadowMap.enabled = !!v, k.boo(v)) C.shadowMap.type = l.Wk7; else if (k.str(v)) { let e = { basic: l.bTm, percentage: l.QP0, soft: l.Wk7, variance: l.RyA }; C.shadowMap.type = null != (s = e[v]) ? s : l.Wk7 } else k.obj(v) && Object.assign(C.shadowMap, v); (e !== C.shadowMap.enabled || t !== C.shadowMap.type) && (C.shadowMap.needsUpdate = !0) } return l.ppV.enabled = !S, d || (C.outputColorSpace = y ? l.Zr2 : l.er$, C.toneMapping = x ? l.y_p : l.FV), R.legacy !== S && R.set(() => ({ legacy: S })), R.linear !== y && R.set(() => ({ linear: y })), R.flat !== x && R.set(() => ({ flat: x })), !h || k.fun(h) || $(h) || k.equ(h, C, eM) || Y(C, h), t = g, d = !0, a(), this }, render(i) { return d || f || this.configure(), f.then(() => { eT.updateContainer((0, _.jsx)(eC, { store: o, children: i, onCreated: t, rootElement: e }), h, null, () => void 0) }), o }, unmount() { eI(e) } } } function eC({ store: e, children: t, onCreated: i, rootElement: r }) { return R(() => { let t = e.getState(); t.set(e => ({ internal: { ...e.internal, active: !0 } })), i && i(t), e.getState().events.connected || null == t.events.connect || t.events.connect(r) }, []), (0, _.jsx)(J.Provider, { value: e, children: t }) } function eI(e, t) { let i = ew.get(e), r = null == i ? void 0 : i.fiber; if (r) { let n = null == i ? void 0 : i.store.getState(); n && (n.internal.active = !1), eT.updateContainer(null, r, null, () => { n && setTimeout(() => { try { var i, r, s, a; null == n.events.disconnect || n.events.disconnect(), null == (i = n.gl) || null == (r = i.renderLists) || null == r.dispose || r.dispose(), null == (s = n.gl) || null == s.forceContextLoss || s.forceContextLoss(), null != (a = n.gl) && a.xr && n.xr.disconnect(), function (e) { for (let t in "Scene" !== e.type && (null == e.dispose || e.dispose()), e) { let i = e[t]; (null == i ? void 0 : i.type) !== "Scene" && (null == i || null == i.dispose || i.dispose()) } }(n.scene), ew.delete(e), t && t(e) } catch (e) { } }, 500) }) } } function eL(e, t, i) { return (0, _.jsx)(eP, { children: e, container: t, state: i }) } function eP({ state: e = {}, children: t, container: i }) { let { events: r, size: n, ...s } = e, a = et(), [o] = h.useState(() => new l.tBo), [u] = h.useState(() => new l.I9Y), c = C((e, t) => { let s; if (t.camera && n) { let i = t.camera; s = e.viewport.getCurrentViewport(i, new l.Pq0, n), i !== e.camera && K(i, n) } return { ...e, ...t, scene: i, raycaster: o, pointer: u, mouse: u, previousRoot: a, events: { ...e.events, ...t.events, ...r }, size: { ...e.size, ...n }, viewport: { ...e.viewport, ...s }, setEvents: e => t.set(t => ({ ...t, events: { ...t.events, ...e } })) } }), d = h.useMemo(() => { let e = v((e, t) => ({ ...s, set: e, get: t })), t = t => e.setState(e => c.current(t, e)); return t(a.getState()), a.subscribe(t), e }, [a, i]); return (0, _.jsx)(_.Fragment, { children: eT.createPortal((0, _.jsx)(J.Provider, { value: d, children: t }), d, null) }) } function eD(e, t) { let i = { callback: e }; return t.add(i), () => void t.delete(i) } let eO = new Set, ek = new Set, eF = new Set, eU = e => eD(e, eO), eN = e => eD(e, ek), eB = e => eD(e, eF); function ez(e, t) { if (e.size) for (let { callback: i } of e.values()) i(t) } function eG(e, t) { switch (e) { case "before": return ez(eO, t); case "after": return ez(ek, t); case "tail": return ez(eF, t) } } function eH(e, t, i) { let s = t.clock.getDelta(); "never" === t.frameloop && "number" == typeof e && (s = e - t.clock.elapsedTime, t.clock.oldTime = t.clock.elapsedTime, t.clock.elapsedTime = e), r = t.internal.subscribers; for (let e = 0; e < r.length; e++)(n = r[e]).ref.current(n.store.getState(), s, i); return !t.internal.priority && t.gl.render && t.gl.render(t.scene, t.camera), t.internal.frames = Math.max(0, t.internal.frames - 1), "always" === t.frameloop ? 1 : t.internal.frames } let eV = !1, eW = !1; function ej(e) { for (let i of (a = requestAnimationFrame(ej), eV = !0, s = 0, eG("before", e), eW = !0, ew.values())) { var t; (o = i.store.getState()).internal.active && ("always" === o.frameloop || o.internal.frames > 0) && !(null != (t = o.gl.xr) && t.isPresenting) && (s += eH(e, o)) } if (eW = !1, eG("after", e), 0 === s) return eG("tail", e), eV = !1, cancelAnimationFrame(a) } function eY(e, t = 1) { var i; if (!e) return ew.forEach(e => eY(e.store.getState(), t)); null != (i = e.gl.xr) && i.isPresenting || !e.internal.active || "never" === e.frameloop || (t > 1 ? e.internal.frames = Math.min(60, e.internal.frames + t) : eW ? e.internal.frames = 2 : e.internal.frames = 1, eV || (eV = !0, requestAnimationFrame(ej))) } function eX(e, t = !0, i, r) { if (t && eG("before", e), i) eH(e, i, r); else for (let t of ew.values()) eH(e, t.store.getState()); t && eG("after", e) } let eK = { onClick: ["click", !1], onContextMenu: ["contextmenu", !1], onDoubleClick: ["dblclick", !1], onWheel: ["wheel", !0], onPointerDown: ["pointerdown", !0], onPointerUp: ["pointerup", !0], onPointerLeave: ["pointerleave", !0], onPointerMove: ["pointermove", !0], onPointerCancel: ["pointercancel", !0], onLostPointerCapture: ["lostpointercapture", !0] }; function eq(e) { let { handlePointer: t } = function (e) { function t(e) { return e.filter(e => ["Move", "Over", "Enter", "Out", "Leave"].some(t => { var i; return null == (i = e.__r3f) ? void 0 : i.handlers["onPointer" + t] })) } function i(t) { let { internal: i } = e.getState(); for (let e of i.hovered.values()) if (!t.length || !t.find(t => t.object === e.object && t.index === e.index && t.instanceId === e.instanceId)) { let r = e.eventObject.__r3f; if (i.hovered.delete(Q(e)), null != r && r.eventCount) { let i = r.handlers, n = { ...e, intersections: t }; null == i.onPointerOut || i.onPointerOut(n), null == i.onPointerLeave || i.onPointerLeave(n) } } } function r(e, t) { for (let i = 0; i < t.length; i++) { let r = t[i].__r3f; null == r || null == r.handlers.onPointerMissed || r.handlers.onPointerMissed(e) } } return { handlePointer: function (n) { switch (n) { case "onPointerLeave": case "onPointerCancel": return () => i([]); case "onLostPointerCapture": return t => { let { internal: r } = e.getState(); "pointerId" in t && r.capturedMap.has(t.pointerId) && requestAnimationFrame(() => { r.capturedMap.has(t.pointerId) && (r.capturedMap.delete(t.pointerId), i([])) }) } }return function (s) { let { onPointerMissed: a, internal: o } = e.getState(); o.lastEvent.current = s; let u = "onPointerMove" === n, h = "onClick" === n || "onContextMenu" === n || "onDoubleClick" === n, c = function (t, i) { let r = e.getState(), n = new Set, s = [], a = i ? i(r.internal.interaction) : r.internal.interaction; for (let e = 0; e < a.length; e++) { let t = O(a[e]); t && (t.raycaster.camera = void 0) } r.previousRoot || null == r.events.compute || r.events.compute(t, r); let o = a.flatMap(function (e) { let i = O(e); if (!i || !i.events.enabled || null === i.raycaster.camera) return []; if (void 0 === i.raycaster.camera) { var r; null == i.events.compute || i.events.compute(t, i, null == (r = i.previousRoot) ? void 0 : r.getState()), void 0 === i.raycaster.camera && (i.raycaster.camera = null) } return i.raycaster.camera ? i.raycaster.intersectObject(e, !0) : [] }).sort((e, t) => { let i = O(e.object), r = O(t.object); return i && r && r.events.priority - i.events.priority || e.distance - t.distance }).filter(e => { let t = Q(e); return !n.has(t) && (n.add(t), !0) }); for (let e of (r.events.filter && (o = r.events.filter(o, r)), o)) { let t = e.object; for (; t;) { var l; null != (l = t.__r3f) && l.eventCount && s.push({ ...e, eventObject: t }), t = t.parent } } if ("pointerId" in t && r.internal.capturedMap.has(t.pointerId)) for (let e of r.internal.capturedMap.get(t.pointerId).values()) n.has(Q(e.intersection)) || s.push(e.intersection); return s }(s, u ? t : void 0), d = h ? function (t) { let { internal: i } = e.getState(), r = t.offsetX - i.initialClick[0], n = t.offsetY - i.initialClick[1]; return Math.round(Math.sqrt(r * r + n * n)) }(s) : 0; "onPointerDown" === n && (o.initialClick = [s.offsetX, s.offsetY], o.initialHits = c.map(e => e.eventObject)), h && !c.length && d <= 2 && (r(s, o.interaction), a && a(s)), u && i(c), function (e, t, r, n) { if (e.length) { let s = { stopped: !1 }; for (let a of e) { let o = O(a.object); if (o || a.object.traverseAncestors(e => { let t = O(e); if (t) return o = t, !1 }), o) { let { raycaster: u, pointer: h, camera: c, internal: d } = o, f = new l.Pq0(h.x, h.y, 0).unproject(c), p = e => { var t, i; return null != (t = null == (i = d.capturedMap.get(e)) ? void 0 : i.has(a.eventObject)) && t }, m = e => { let i = { intersection: a, target: t.target }; d.capturedMap.has(e) ? d.capturedMap.get(e).set(a.eventObject, i) : d.capturedMap.set(e, new Map([[a.eventObject, i]])), t.target.setPointerCapture(e) }, g = e => { let t = d.capturedMap.get(e); t && Z(d.capturedMap, a.eventObject, t, e) }, v = {}; for (let e in t) { let i = t[e]; "function" != typeof i && (v[e] = i) } let y = { ...a, ...v, pointer: h, intersections: e, stopped: s.stopped, delta: r, unprojectedPoint: f, ray: u.ray, camera: c, stopPropagation() { let r = "pointerId" in t && d.capturedMap.get(t.pointerId); (!r || r.has(a.eventObject)) && (y.stopped = s.stopped = !0, d.hovered.size && Array.from(d.hovered.values()).find(e => e.eventObject === a.eventObject) && i([...e.slice(0, e.indexOf(a)), a])) }, target: { hasPointerCapture: p, setPointerCapture: m, releasePointerCapture: g }, currentTarget: { hasPointerCapture: p, setPointerCapture: m, releasePointerCapture: g }, nativeEvent: t }; if (n(y), !0 === s.stopped) break } } } }(c, s, d, function (e) { let t = e.eventObject, i = t.__r3f; if (!(null != i && i.eventCount)) return; let a = i.handlers; if (u) { if (a.onPointerOver || a.onPointerEnter || a.onPointerOut || a.onPointerLeave) { let t = Q(e), i = o.hovered.get(t); i ? i.stopped && e.stopPropagation() : (o.hovered.set(t, e), null == a.onPointerOver || a.onPointerOver(e), null == a.onPointerEnter || a.onPointerEnter(e)) } null == a.onPointerMove || a.onPointerMove(e) } else { let i = a[n]; i ? (!h || o.initialHits.includes(t)) && (r(s, o.interaction.filter(e => !o.initialHits.includes(e))), i(e)) : h && o.initialHits.includes(t) && r(s, o.interaction.filter(e => !o.initialHits.includes(e))) } }) } } } }(e); return { priority: 1, enabled: !0, compute(e, t, i) { t.pointer.set(e.offsetX / t.size.width * 2 - 1, -(2 * (e.offsetY / t.size.height)) + 1), t.raycaster.setFromCamera(t.pointer, t.camera) }, connected: void 0, handlers: Object.keys(eK).reduce((e, i) => ({ ...e, [i]: t(i) }), {}), update: () => { var t; let { events: i, internal: r } = e.getState(); null != (t = r.lastEvent) && t.current && i.handlers && i.handlers.onPointerMove(r.lastEvent.current) }, connect: t => { let { set: i, events: r } = e.getState(); if (null == r.disconnect || r.disconnect(), i(e => ({ events: { ...e.events, connected: t } })), r.handlers) for (let e in r.handlers) { let i = r.handlers[e], [n, s] = eK[e]; t.addEventListener(n, i, { passive: s }) } }, disconnect: () => { let { set: t, events: i } = e.getState(); if (i.connected) { if (i.handlers) for (let e in i.handlers) { let t = i.handlers[e], [r] = eK[e]; i.connected.removeEventListener(r, t) } t(e => ({ events: { ...e.events, connected: void 0 } })) } } } } }, 2428: (e, t, i) => { "use strict"; i.d(t, { Hl: () => d }); var r = i(2111), n = i(6540), s = i(9437); function a(e, t) { let i; return (...r) => { window.clearTimeout(i), i = window.setTimeout(() => e(...r), t) } } let o = ["x", "y", "top", "bottom", "left", "right", "width", "height"], l = (e, t) => o.every(i => e[i] === t[i]); var u = i(9318), h = i(4848); function c({ ref: e, children: t, fallback: i, resize: o, style: u, gl: c, events: d = r.f, eventSource: f, eventPrefix: p, shadows: m, linear: g, flat: v, legacy: y, orthographic: x, frameloop: S, dpr: A, performance: _, raycaster: E, camera: b, scene: T, onPointerMissed: w, onCreated: M, ...R }) { n.useMemo(() => (0, r.e)(s), []); let C = (0, r.u)(), [I, L] = function ({ debounce: e, scroll: t, polyfill: i, offsetSize: r } = { debounce: 0, scroll: !1, offsetSize: !1 }) { var s; let o = i || ("undefined" == typeof window ? class { } : window.ResizeObserver); if (!o) throw Error("This browser does not support ResizeObserver out of the box. See: https://github.com/react-spring/react-use-measure/#resize-observer-polyfills"); let [u, h] = (0, n.useState)({ left: 0, top: 0, width: 0, height: 0, bottom: 0, right: 0, x: 0, y: 0 }), c = (0, n.useRef)({ element: null, scrollContainers: null, resizeObserver: null, lastBounds: u, orientationHandler: null }), d = e ? "number" == typeof e ? e : e.scroll : null, f = e ? "number" == typeof e ? e : e.resize : null, p = (0, n.useRef)(!1); (0, n.useEffect)(() => (p.current = !0, () => void (p.current = !1))); let [m, g, v] = (0, n.useMemo)(() => { let e = () => { if (!c.current.element) return; let { left: e, top: t, width: i, height: n, bottom: s, right: a, x: o, y: u } = c.current.element.getBoundingClientRect(), d = { left: e, top: t, width: i, height: n, bottom: s, right: a, x: o, y: u }; c.current.element instanceof HTMLElement && r && (d.height = c.current.element.offsetHeight, d.width = c.current.element.offsetWidth), Object.freeze(d), p.current && !l(c.current.lastBounds, d) && h(c.current.lastBounds = d) }; return [e, f ? a(e, f) : e, d ? a(e, d) : e] }, [h, r, d, f]); function y() { c.current.scrollContainers && (c.current.scrollContainers.forEach(e => e.removeEventListener("scroll", v, !0)), c.current.scrollContainers = null), c.current.resizeObserver && (c.current.resizeObserver.disconnect(), c.current.resizeObserver = null), c.current.orientationHandler && ("orientation" in screen && "removeEventListener" in screen.orientation ? screen.orientation.removeEventListener("change", c.current.orientationHandler) : "onorientationchange" in window && window.removeEventListener("orientationchange", c.current.orientationHandler)) } function x() { c.current.element && (c.current.resizeObserver = new o(v), c.current.resizeObserver.observe(c.current.element), t && c.current.scrollContainers && c.current.scrollContainers.forEach(e => e.addEventListener("scroll", v, { capture: !0, passive: !0 })), c.current.orientationHandler = () => { v() }, "orientation" in screen && "addEventListener" in screen.orientation ? screen.orientation.addEventListener("change", c.current.orientationHandler) : "onorientationchange" in window && window.addEventListener("orientationchange", c.current.orientationHandler)) } return s = !!t, (0, n.useEffect)(() => { if (s) return window.addEventListener("scroll", v, { capture: !0, passive: !0 }), () => void window.removeEventListener("scroll", v, !0) }, [v, s]), (0, n.useEffect)(() => (window.addEventListener("resize", g), () => void window.removeEventListener("resize", g)), [g]), (0, n.useEffect)(() => { y(), x() }, [t, v, g]), (0, n.useEffect)(() => y, []), [e => { e && e !== c.current.element && (y(), c.current.element = e, c.current.scrollContainers = function e(t) { let i = []; if (!t || t === document.body) return i; let { overflow: r, overflowX: n, overflowY: s } = window.getComputedStyle(t); return [r, n, s].some(e => "auto" === e || "scroll" === e) && i.push(t), [...i, ...e(t.parentElement)] }(e), x()) }, u, m] }({ scroll: !0, debounce: { scroll: 50, resize: 0 }, ...o }), P = n.useRef(null), D = n.useRef(null); n.useImperativeHandle(e, () => P.current); let O = (0, r.a)(w), [k, F] = n.useState(!1), [U, N] = n.useState(!1); if (k) throw k; if (U) throw U; let B = n.useRef(null); (0, r.b)(() => { let e = P.current; L.width > 0 && L.height > 0 && e && (B.current || (B.current = (0, r.c)(e)), async function () { await B.current.configure({ gl: c, scene: T, events: d, shadows: m, linear: g, flat: v, legacy: y, orthographic: x, frameloop: S, dpr: A, performance: _, raycaster: E, camera: b, size: L, onPointerMissed: (...e) => null == O.current ? void 0 : O.current(...e), onCreated: e => { null == e.events.connect || e.events.connect(f ? (0, r.i)(f) ? f.current : f : D.current), p && e.setEvents({ compute: (e, t) => { let i = e[p + "X"], r = e[p + "Y"]; t.pointer.set(i / t.size.width * 2 - 1, -(2 * (r / t.size.height)) + 1), t.raycaster.setFromCamera(t.pointer, t.camera) } }), null == M || M(e) } }), B.current.render((0, h.jsx)(C, { children: (0, h.jsx)(r.E, { set: N, children: (0, h.jsx)(n.Suspense, { fallback: (0, h.jsx)(r.B, { set: F }), children: null != t ? t : null }) }) })) }()) }), n.useEffect(() => { let e = P.current; if (e) return () => (0, r.d)(e) }, []); let z = f ? "none" : "auto"; return (0, h.jsx)("div", { ref: D, style: { position: "relative", width: "100%", height: "100%", overflow: "hidden", pointerEvents: z, ...u }, ...R, children: (0, h.jsx)("div", { ref: I, style: { width: "100%", height: "100%" }, children: (0, h.jsx)("canvas", { ref: P, style: { display: "block" }, children: i }) }) }) } function d(e) { return (0, h.jsx)(u.Af, { children: (0, h.jsx)(c, { ...e }) }) } i(772), i(4845), i(9982) }, 4196: (e, t, i) => { var r; !function () { "use strict"; var n = function () { this.init() }; n.prototype = { init: function () { var e = this || s; return e._counter = 1e3, e._html5AudioPool = [], e.html5PoolSize = 10, e._codecs = {}, e._howls = [], e._muted = !1, e._volume = 1, e._canPlayEvent = "canplaythrough", e._navigator = "undefined" != typeof window && window.navigator ? window.navigator : null, e.masterGain = null, e.noAudio = !1, e.usingWebAudio = !0, e.autoSuspend = !0, e.ctx = null, e.autoUnlock = !0, e._setup(), e }, volume: function (e) { var t = this || s; if (e = parseFloat(e), t.ctx || f(), void 0 !== e && e >= 0 && e <= 1) { if (t._volume = e, t._muted) return t; t.usingWebAudio && t.masterGain.gain.setValueAtTime(e, s.ctx.currentTime); for (var i = 0; i < t._howls.length; i++)if (!t._howls[i]._webAudio) for (var r = t._howls[i]._getSoundIds(), n = 0; n < r.length; n++) { var a = t._howls[i]._soundById(r[n]); a && a._node && (a._node.volume = a._volume * e) } return t } return t._volume }, mute: function (e) { var t = this || s; t.ctx || f(), t._muted = e, t.usingWebAudio && t.masterGain.gain.setValueAtTime(e ? 0 : t._volume, s.ctx.currentTime); for (var i = 0; i < t._howls.length; i++)if (!t._howls[i]._webAudio) for (var r = t._howls[i]._getSoundIds(), n = 0; n < r.length; n++) { var a = t._howls[i]._soundById(r[n]); a && a._node && (a._node.muted = !!e || a._muted) } return t }, stop: function () { for (var e = this || s, t = 0; t < e._howls.length; t++)e._howls[t].stop(); return e }, unload: function () { for (var e = this || s, t = e._howls.length - 1; t >= 0; t--)e._howls[t].unload(); return e.usingWebAudio && e.ctx && void 0 !== e.ctx.close && (e.ctx.close(), e.ctx = null, f()), e }, codecs: function (e) { return (this || s)._codecs[e.replace(/^x-/, "")] }, _setup: function () { var e = this || s; if (e.state = e.ctx && e.ctx.state || "suspended", e._autoSuspend(), !e.usingWebAudio) { if ("undefined" != typeof Audio) try { var t = new Audio; void 0 === t.oncanplaythrough && (e._canPlayEvent = "canplay") } catch (t) { e.noAudio = !0 } else e.noAudio = !0 } try { var t = new Audio; t.muted && (e.noAudio = !0) } catch (e) { } return e.noAudio || e._setupCodecs(), e }, _setupCodecs: function () { var e = this || s, t = null; try { t = "undefined" != typeof Audio ? new Audio : null } catch (t) { return e } if (!t || "function" != typeof t.canPlayType) return e; var i = t.canPlayType("audio/mpeg;").replace(/^no$/, ""), r = e._navigator ? e._navigator.userAgent : "", n = r.match(/OPR\/(\d+)/g), a = n && 33 > parseInt(n[0].split("/")[1], 10), o = -1 !== r.indexOf("Safari") && -1 === r.indexOf("Chrome"), l = r.match(/Version\/(.*?) /), u = o && l && 15 > parseInt(l[1], 10); return e._codecs = { mp3: !!(!a && (i || t.canPlayType("audio/mp3;").replace(/^no$/, ""))), mpeg: !!i, opus: !!t.canPlayType('audio/ogg; codecs="opus"').replace(/^no$/, ""), ogg: !!t.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/, ""), oga: !!t.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/, ""), wav: !!(t.canPlayType('audio/wav; codecs="1"') || t.canPlayType("audio/wav")).replace(/^no$/, ""), aac: !!t.canPlayType("audio/aac;").replace(/^no$/, ""), caf: !!t.canPlayType("audio/x-caf;").replace(/^no$/, ""), m4a: !!(t.canPlayType("audio/x-m4a;") || t.canPlayType("audio/m4a;") || t.canPlayType("audio/aac;")).replace(/^no$/, ""), m4b: !!(t.canPlayType("audio/x-m4b;") || t.canPlayType("audio/m4b;") || t.canPlayType("audio/aac;")).replace(/^no$/, ""), mp4: !!(t.canPlayType("audio/x-mp4;") || t.canPlayType("audio/mp4;") || t.canPlayType("audio/aac;")).replace(/^no$/, ""), weba: !!(!u && t.canPlayType('audio/webm; codecs="vorbis"').replace(/^no$/, "")), webm: !!(!u && t.canPlayType('audio/webm; codecs="vorbis"').replace(/^no$/, "")), dolby: !!t.canPlayType('audio/mp4; codecs="ec-3"').replace(/^no$/, ""), flac: !!(t.canPlayType("audio/x-flac;") || t.canPlayType("audio/flac;")).replace(/^no$/, "") }, e }, _unlockAudio: function () { var e = this || s; if (!e._audioUnlocked && e.ctx) { e._audioUnlocked = !1, e.autoUnlock = !1, e._mobileUnloaded || 44100 === e.ctx.sampleRate || (e._mobileUnloaded = !0, e.unload()), e._scratchBuffer = e.ctx.createBuffer(1, 1, 22050); var t = function (i) { for (; e._html5AudioPool.length < e.html5PoolSize;)try { var r = new Audio; r._unlocked = !0, e._releaseHtml5Audio(r) } catch (t) { e.noAudio = !0; break } for (var n = 0; n < e._howls.length; n++)if (!e._howls[n]._webAudio) for (var s = e._howls[n]._getSoundIds(), a = 0; a < s.length; a++) { var o = e._howls[n]._soundById(s[a]); o && o._node && !o._node._unlocked && (o._node._unlocked = !0, o._node.load()) } e._autoResume(); var l = e.ctx.createBufferSource(); l.buffer = e._scratchBuffer, l.connect(e.ctx.destination), void 0 === l.start ? l.noteOn(0) : l.start(0), "function" == typeof e.ctx.resume && e.ctx.resume(), l.onended = function () { l.disconnect(0), e._audioUnlocked = !0, document.removeEventListener("touchstart", t, !0), document.removeEventListener("touchend", t, !0), document.removeEventListener("click", t, !0), document.removeEventListener("keydown", t, !0); for (var i = 0; i < e._howls.length; i++)e._howls[i]._emit("unlock") } }; return document.addEventListener("touchstart", t, !0), document.addEventListener("touchend", t, !0), document.addEventListener("click", t, !0), document.addEventListener("keydown", t, !0), e } }, _obtainHtml5Audio: function () { var e = this || s; if (e._html5AudioPool.length) return e._html5AudioPool.pop(); var t = new Audio().play(); return t && "undefined" != typeof Promise && (t instanceof Promise || "function" == typeof t.then) && t.catch(function () { console.warn("HTML5 Audio pool exhausted, returning potentially locked audio object.") }), new Audio }, _releaseHtml5Audio: function (e) { var t = this || s; return e._unlocked && t._html5AudioPool.push(e), t }, _autoSuspend: function () { var e = this; if (e.autoSuspend && e.ctx && void 0 !== e.ctx.suspend && s.usingWebAudio) { for (var t = 0; t < e._howls.length; t++)if (e._howls[t]._webAudio) { for (var i = 0; i < e._howls[t]._sounds.length; i++)if (!e._howls[t]._sounds[i]._paused) return e } return e._suspendTimer && clearTimeout(e._suspendTimer), e._suspendTimer = setTimeout(function () { if (e.autoSuspend) { e._suspendTimer = null, e.state = "suspending"; var t = function () { e.state = "suspended", e._resumeAfterSuspend && (delete e._resumeAfterSuspend, e._autoResume()) }; e.ctx.suspend().then(t, t) } }, 3e4), e } }, _autoResume: function () { var e = this; if (e.ctx && void 0 !== e.ctx.resume && s.usingWebAudio) return "running" === e.state && "interrupted" !== e.ctx.state && e._suspendTimer ? (clearTimeout(e._suspendTimer), e._suspendTimer = null) : "suspended" === e.state || "running" === e.state && "interrupted" === e.ctx.state ? (e.ctx.resume().then(function () { e.state = "running"; for (var t = 0; t < e._howls.length; t++)e._howls[t]._emit("resume") }), e._suspendTimer && (clearTimeout(e._suspendTimer), e._suspendTimer = null)) : "suspending" === e.state && (e._resumeAfterSuspend = !0), e } }; var s = new n, a = function (e) { if (!e.src || 0 === e.src.length) { console.error("An array of source files must be passed with any new Howl."); return } this.init(e) }; a.prototype = { init: function (e) { var t = this; return s.ctx || f(), t._autoplay = e.autoplay || !1, t._format = "string" != typeof e.format ? e.format : [e.format], t._html5 = e.html5 || !1, t._muted = e.mute || !1, t._loop = e.loop || !1, t._pool = e.pool || 5, t._preload = "boolean" != typeof e.preload && "metadata" !== e.preload || e.preload, t._rate = e.rate || 1, t._sprite = e.sprite || {}, t._src = "string" != typeof e.src ? e.src : [e.src], t._volume = void 0 !== e.volume ? e.volume : 1, t._xhr = { method: e.xhr && e.xhr.method ? e.xhr.method : "GET", headers: e.xhr && e.xhr.headers ? e.xhr.headers : null, withCredentials: !!e.xhr && !!e.xhr.withCredentials && e.xhr.withCredentials }, t._duration = 0, t._state = "unloaded", t._sounds = [], t._endTimers = {}, t._queue = [], t._playLock = !1, t._onend = e.onend ? [{ fn: e.onend }] : [], t._onfade = e.onfade ? [{ fn: e.onfade }] : [], t._onload = e.onload ? [{ fn: e.onload }] : [], t._onloaderror = e.onloaderror ? [{ fn: e.onloaderror }] : [], t._onplayerror = e.onplayerror ? [{ fn: e.onplayerror }] : [], t._onpause = e.onpause ? [{ fn: e.onpause }] : [], t._onplay = e.onplay ? [{ fn: e.onplay }] : [], t._onstop = e.onstop ? [{ fn: e.onstop }] : [], t._onmute = e.onmute ? [{ fn: e.onmute }] : [], t._onvolume = e.onvolume ? [{ fn: e.onvolume }] : [], t._onrate = e.onrate ? [{ fn: e.onrate }] : [], t._onseek = e.onseek ? [{ fn: e.onseek }] : [], t._onunlock = e.onunlock ? [{ fn: e.onunlock }] : [], t._onresume = [], t._webAudio = s.usingWebAudio && !t._html5, void 0 !== s.ctx && s.ctx && s.autoUnlock && s._unlockAudio(), s._howls.push(t), t._autoplay && t._queue.push({ event: "play", action: function () { t.play() } }), t._preload && "none" !== t._preload && t.load(), t }, load: function () { var e, t, i = null; if (s.noAudio) { this._emit("loaderror", null, "No audio support."); return } "string" == typeof this._src && (this._src = [this._src]); for (var r = 0; r < this._src.length; r++) { if (this._format && this._format[r]) e = this._format[r]; else { if ("string" != typeof (t = this._src[r])) { this._emit("loaderror", null, "Non-string found in selected audio sources - ignoring."); continue } (e = /^data:audio\/([^;,]+);/i.exec(t)) || (e = /\.([^.]+)$/.exec(t.split("?", 1)[0])), e && (e = e[1].toLowerCase()) } if (e || console.warn('No file extension was found. Consider using the "format" property or specify an extension.'), e && s.codecs(e)) { i = this._src[r]; break } } if (!i) { this._emit("loaderror", null, "No codec support for selected audio sources."); return } return this._src = i, this._state = "loading", "https:" === window.location.protocol && "http:" === i.slice(0, 5) && (this._html5 = !0, this._webAudio = !1), new o(this), this._webAudio && u(this), this }, play: function (e, t) { var i = this, r = null; if ("number" == typeof e) r = e, e = null; else if ("string" == typeof e && "loaded" === i._state && !i._sprite[e]) return null; else if (void 0 === e && (e = "__default", !i._playLock)) { for (var n = 0, a = 0; a < i._sounds.length; a++)i._sounds[a]._paused && !i._sounds[a]._ended && (n++, r = i._sounds[a]._id); 1 === n ? e = null : r = null } var o = r ? i._soundById(r) : i._inactiveSound(); if (!o) return null; if (r && !e && (e = o._sprite || "__default"), "loaded" !== i._state) { o._sprite = e, o._ended = !1; var l = o._id; return i._queue.push({ event: "play", action: function () { i.play(l) } }), l } if (r && !o._paused) return t || i._loadQueue("play"), o._id; i._webAudio && s._autoResume(); var u = Math.max(0, o._seek > 0 ? o._seek : i._sprite[e][0] / 1e3), h = Math.max(0, (i._sprite[e][0] + i._sprite[e][1]) / 1e3 - u), c = 1e3 * h / Math.abs(o._rate), d = i._sprite[e][0] / 1e3, f = (i._sprite[e][0] + i._sprite[e][1]) / 1e3; o._sprite = e, o._ended = !1; var p = function () { o._paused = !1, o._seek = u, o._start = d, o._stop = f, o._loop = !!(o._loop || i._sprite[e][2]) }; if (u >= f) { i._ended(o); return } var m = o._node; if (i._webAudio) { var g = function () { i._playLock = !1, p(), i._refreshBuffer(o); var e = o._muted || i._muted ? 0 : o._volume; m.gain.setValueAtTime(e, s.ctx.currentTime), o._playStart = s.ctx.currentTime, void 0 === m.bufferSource.start ? o._loop ? m.bufferSource.noteGrainOn(0, u, 86400) : m.bufferSource.noteGrainOn(0, u, h) : o._loop ? m.bufferSource.start(0, u, 86400) : m.bufferSource.start(0, u, h), c !== 1 / 0 && (i._endTimers[o._id] = setTimeout(i._ended.bind(i, o), c)), t || setTimeout(function () { i._emit("play", o._id), i._loadQueue() }, 0) }; "running" === s.state && "interrupted" !== s.ctx.state ? g() : (i._playLock = !0, i.once("resume", g), i._clearTimer(o._id)) } else { var v = function () { m.currentTime = u, m.muted = o._muted || i._muted || s._muted || m.muted, m.volume = o._volume * s.volume(), m.playbackRate = o._rate; try { var r = m.play(); if (r && "undefined" != typeof Promise && (r instanceof Promise || "function" == typeof r.then) ? (i._playLock = !0, p(), r.then(function () { i._playLock = !1, m._unlocked = !0, t ? i._loadQueue() : i._emit("play", o._id) }).catch(function () { i._playLock = !1, i._emit("playerror", o._id, "Playback was unable to start. This is most commonly an issue on mobile devices and Chrome where playback was not within a user interaction."), o._ended = !0, o._paused = !0 })) : t || (i._playLock = !1, p(), i._emit("play", o._id)), m.playbackRate = o._rate, m.paused) { i._emit("playerror", o._id, "Playback was unable to start. This is most commonly an issue on mobile devices and Chrome where playback was not within a user interaction."); return } "__default" !== e || o._loop ? i._endTimers[o._id] = setTimeout(i._ended.bind(i, o), c) : (i._endTimers[o._id] = function () { i._ended(o), m.removeEventListener("ended", i._endTimers[o._id], !1) }, m.addEventListener("ended", i._endTimers[o._id], !1)) } catch (e) { i._emit("playerror", o._id, e) } }; "data:audio/wav;base64,UklGRigAAABXQVZFZm10IBIAAAABAAEARKwAAIhYAQACABAAAABkYXRhAgAAAAEA" === m.src && (m.src = i._src, m.load()); var y = window && window.ejecta || !m.readyState && s._navigator.isCocoonJS; if (m.readyState >= 3 || y) v(); else { i._playLock = !0, i._state = "loading"; var x = function () { i._state = "loaded", v(), m.removeEventListener(s._canPlayEvent, x, !1) }; m.addEventListener(s._canPlayEvent, x, !1), i._clearTimer(o._id) } } return o._id }, pause: function (e) { var t = this; if ("loaded" !== t._state || t._playLock) return t._queue.push({ event: "pause", action: function () { t.pause(e) } }), t; for (var i = t._getSoundIds(e), r = 0; r < i.length; r++) { t._clearTimer(i[r]); var n = t._soundById(i[r]); if (n && !n._paused && (n._seek = t.seek(i[r]), n._rateSeek = 0, n._paused = !0, t._stopFade(i[r]), n._node)) { if (t._webAudio) { if (!n._node.bufferSource) continue; void 0 === n._node.bufferSource.stop ? n._node.bufferSource.noteOff(0) : n._node.bufferSource.stop(0), t._cleanBuffer(n._node) } else isNaN(n._node.duration) && n._node.duration !== 1 / 0 || n._node.pause() } arguments[1] || t._emit("pause", n ? n._id : null) } return t }, stop: function (e, t) { var i = this; if ("loaded" !== i._state || i._playLock) return i._queue.push({ event: "stop", action: function () { i.stop(e) } }), i; for (var r = i._getSoundIds(e), n = 0; n < r.length; n++) { i._clearTimer(r[n]); var s = i._soundById(r[n]); s && (s._seek = s._start || 0, s._rateSeek = 0, s._paused = !0, s._ended = !0, i._stopFade(r[n]), s._node && (i._webAudio ? s._node.bufferSource && (void 0 === s._node.bufferSource.stop ? s._node.bufferSource.noteOff(0) : s._node.bufferSource.stop(0), i._cleanBuffer(s._node)) : isNaN(s._node.duration) && s._node.duration !== 1 / 0 || (s._node.currentTime = s._start || 0, s._node.pause(), s._node.duration === 1 / 0 && i._clearSound(s._node))), t || i._emit("stop", s._id)) } return i }, mute: function (e, t) { var i = this; if ("loaded" !== i._state || i._playLock) return i._queue.push({ event: "mute", action: function () { i.mute(e, t) } }), i; if (void 0 === t) { if ("boolean" != typeof e) return i._muted; i._muted = e } for (var r = i._getSoundIds(t), n = 0; n < r.length; n++) { var a = i._soundById(r[n]); a && (a._muted = e, a._interval && i._stopFade(a._id), i._webAudio && a._node ? a._node.gain.setValueAtTime(e ? 0 : a._volume, s.ctx.currentTime) : a._node && (a._node.muted = !!s._muted || e), i._emit("mute", a._id)) } return i }, volume: function () { var e, t, i, r = this, n = arguments; if (0 === n.length) return r._volume; if (1 === n.length || 2 === n.length && void 0 === n[1] ? r._getSoundIds().indexOf(n[0]) >= 0 ? t = parseInt(n[0], 10) : e = parseFloat(n[0]) : n.length >= 2 && (e = parseFloat(n[0]), t = parseInt(n[1], 10)), void 0 === e || !(e >= 0) || !(e <= 1)) return (i = t ? r._soundById(t) : r._sounds[0]) ? i._volume : 0; if ("loaded" !== r._state || r._playLock) return r._queue.push({ event: "volume", action: function () { r.volume.apply(r, n) } }), r; void 0 === t && (r._volume = e), t = r._getSoundIds(t); for (var a = 0; a < t.length; a++)(i = r._soundById(t[a])) && (i._volume = e, n[2] || r._stopFade(t[a]), r._webAudio && i._node && !i._muted ? i._node.gain.setValueAtTime(e, s.ctx.currentTime) : i._node && !i._muted && (i._node.volume = e * s.volume()), r._emit("volume", i._id)); return r }, fade: function (e, t, i, r) { var n = this; if ("loaded" !== n._state || n._playLock) return n._queue.push({ event: "fade", action: function () { n.fade(e, t, i, r) } }), n; e = Math.min(Math.max(0, parseFloat(e)), 1), t = Math.min(Math.max(0, parseFloat(t)), 1), i = parseFloat(i), n.volume(e, r); for (var a = n._getSoundIds(r), o = 0; o < a.length; o++) { var l = n._soundById(a[o]); if (l) { if (r || n._stopFade(a[o]), n._webAudio && !l._muted) { var u = s.ctx.currentTime, h = u + i / 1e3; l._volume = e, l._node.gain.setValueAtTime(e, u), l._node.gain.linearRampToValueAtTime(t, h) } n._startFadeInterval(l, e, t, i, a[o], void 0 === r) } } return n }, _startFadeInterval: function (e, t, i, r, n, s) { var a = this, o = t, l = i - t, u = Math.abs(l / .01), h = Math.max(4, u > 0 ? r / u : r), c = Date.now(); e._fadeTo = i, e._interval = setInterval(function () { var n = (Date.now() - c) / r; c = Date.now(), o += l * n, o = Math.round(100 * o) / 100, o = l < 0 ? Math.max(i, o) : Math.min(i, o), a._webAudio ? e._volume = o : a.volume(o, e._id, !0), s && (a._volume = o), (i < t && o <= i || i > t && o >= i) && (clearInterval(e._interval), e._interval = null, e._fadeTo = null, a.volume(i, e._id), a._emit("fade", e._id)) }, h) }, _stopFade: function (e) { var t = this._soundById(e); return t && t._interval && (this._webAudio && t._node.gain.cancelScheduledValues(s.ctx.currentTime), clearInterval(t._interval), t._interval = null, this.volume(t._fadeTo, e), t._fadeTo = null, this._emit("fade", e)), this }, loop: function () { var e, t, i, r = arguments; if (0 === r.length) return this._loop; if (1 === r.length) { if ("boolean" != typeof r[0]) return !!(i = this._soundById(parseInt(r[0], 10))) && i._loop; e = r[0], this._loop = e } else 2 === r.length && (e = r[0], t = parseInt(r[1], 10)); for (var n = this._getSoundIds(t), s = 0; s < n.length; s++)(i = this._soundById(n[s])) && (i._loop = e, this._webAudio && i._node && i._node.bufferSource && (i._node.bufferSource.loop = e, e && (i._node.bufferSource.loopStart = i._start || 0, i._node.bufferSource.loopEnd = i._stop, this.playing(n[s]) && (this.pause(n[s], !0), this.play(n[s], !0))))); return this }, rate: function () { var e, t, i, r = this, n = arguments; if (0 === n.length ? t = r._sounds[0]._id : 1 === n.length ? r._getSoundIds().indexOf(n[0]) >= 0 ? t = parseInt(n[0], 10) : e = parseFloat(n[0]) : 2 === n.length && (e = parseFloat(n[0]), t = parseInt(n[1], 10)), "number" != typeof e) return (i = r._soundById(t)) ? i._rate : r._rate; if ("loaded" !== r._state || r._playLock) return r._queue.push({ event: "rate", action: function () { r.rate.apply(r, n) } }), r; void 0 === t && (r._rate = e), t = r._getSoundIds(t); for (var a = 0; a < t.length; a++)if (i = r._soundById(t[a])) { r.playing(t[a]) && (i._rateSeek = r.seek(t[a]), i._playStart = r._webAudio ? s.ctx.currentTime : i._playStart), i._rate = e, r._webAudio && i._node && i._node.bufferSource ? i._node.bufferSource.playbackRate.setValueAtTime(e, s.ctx.currentTime) : i._node && (i._node.playbackRate = e); var o = r.seek(t[a]), l = 1e3 * ((r._sprite[i._sprite][0] + r._sprite[i._sprite][1]) / 1e3 - o) / Math.abs(i._rate); (r._endTimers[t[a]] || !i._paused) && (r._clearTimer(t[a]), r._endTimers[t[a]] = setTimeout(r._ended.bind(r, i), l)), r._emit("rate", i._id) } return r }, seek: function () { var e, t, i = this, r = arguments; if (0 === r.length ? i._sounds.length && (t = i._sounds[0]._id) : 1 === r.length ? i._getSoundIds().indexOf(r[0]) >= 0 ? t = parseInt(r[0], 10) : i._sounds.length && (t = i._sounds[0]._id, e = parseFloat(r[0])) : 2 === r.length && (e = parseFloat(r[0]), t = parseInt(r[1], 10)), void 0 === t) return 0; if ("number" == typeof e && ("loaded" !== i._state || i._playLock)) return i._queue.push({ event: "seek", action: function () { i.seek.apply(i, r) } }), i; var n = i._soundById(t); if (n) { if ("number" == typeof e && e >= 0) { var a = i.playing(t); a && i.pause(t, !0), n._seek = e, n._ended = !1, i._clearTimer(t), i._webAudio || !n._node || isNaN(n._node.duration) || (n._node.currentTime = e); var o = function () { a && i.play(t, !0), i._emit("seek", t) }; if (a && !i._webAudio) { var l = function () { i._playLock ? setTimeout(l, 0) : o() }; setTimeout(l, 0) } else o() } else { if (!i._webAudio) return n._node.currentTime; var u = i.playing(t) ? s.ctx.currentTime - n._playStart : 0, h = n._rateSeek ? n._rateSeek - n._seek : 0; return n._seek + (h + u * Math.abs(n._rate)) } } return i }, playing: function (e) { if ("number" == typeof e) { var t = this._soundById(e); return !!t && !t._paused } for (var i = 0; i < this._sounds.length; i++)if (!this._sounds[i]._paused) return !0; return !1 }, duration: function (e) { var t = this._duration, i = this._soundById(e); return i && (t = this._sprite[i._sprite][1] / 1e3), t }, state: function () { return this._state }, unload: function () { for (var e = this, t = e._sounds, i = 0; i < t.length; i++)t[i]._paused || e.stop(t[i]._id), e._webAudio || (e._clearSound(t[i]._node), t[i]._node.removeEventListener("error", t[i]._errorFn, !1), t[i]._node.removeEventListener(s._canPlayEvent, t[i]._loadFn, !1), t[i]._node.removeEventListener("ended", t[i]._endFn, !1), s._releaseHtml5Audio(t[i]._node)), delete t[i]._node, e._clearTimer(t[i]._id); var r = s._howls.indexOf(e); r >= 0 && s._howls.splice(r, 1); var n = !0; for (i = 0; i < s._howls.length; i++)if (s._howls[i]._src === e._src || e._src.indexOf(s._howls[i]._src) >= 0) { n = !1; break } return l && n && delete l[e._src], s.noAudio = !1, e._state = "unloaded", e._sounds = [], e = null, null }, on: function (e, t, i, r) { var n = this["_on" + e]; return "function" == typeof t && n.push(r ? { id: i, fn: t, once: r } : { id: i, fn: t }), this }, off: function (e, t, i) { var r = this["_on" + e], n = 0; if ("number" == typeof t && (i = t, t = null), t || i) for (n = 0; n < r.length; n++) { var s = i === r[n].id; if (t === r[n].fn && s || !t && s) { r.splice(n, 1); break } } else if (e) this["_on" + e] = []; else { var a = Object.keys(this); for (n = 0; n < a.length; n++)0 === a[n].indexOf("_on") && Array.isArray(this[a[n]]) && (this[a[n]] = []) } return this }, once: function (e, t, i) { return this.on(e, t, i, 1), this }, _emit: function (e, t, i) { for (var r = this["_on" + e], n = r.length - 1; n >= 0; n--)(!r[n].id || r[n].id === t || "load" === e) && (setTimeout((function (e) { e.call(this, t, i) }).bind(this, r[n].fn), 0), r[n].once && this.off(e, r[n].fn, r[n].id)); return this._loadQueue(e), this }, _loadQueue: function (e) { if (this._queue.length > 0) { var t = this._queue[0]; t.event === e && (this._queue.shift(), this._loadQueue()), e || t.action() } return this }, _ended: function (e) { var t = e._sprite; if (!this._webAudio && e._node && !e._node.paused && !e._node.ended && e._node.currentTime < e._stop) return setTimeout(this._ended.bind(this, e), 100), this; var i = !!(e._loop || this._sprite[t][2]); if (this._emit("end", e._id), !this._webAudio && i && this.stop(e._id, !0).play(e._id), this._webAudio && i) { this._emit("play", e._id), e._seek = e._start || 0, e._rateSeek = 0, e._playStart = s.ctx.currentTime; var r = (e._stop - e._start) * 1e3 / Math.abs(e._rate); this._endTimers[e._id] = setTimeout(this._ended.bind(this, e), r) } return this._webAudio && !i && (e._paused = !0, e._ended = !0, e._seek = e._start || 0, e._rateSeek = 0, this._clearTimer(e._id), this._cleanBuffer(e._node), s._autoSuspend()), this._webAudio || i || this.stop(e._id, !0), this }, _clearTimer: function (e) { if (this._endTimers[e]) { if ("function" != typeof this._endTimers[e]) clearTimeout(this._endTimers[e]); else { var t = this._soundById(e); t && t._node && t._node.removeEventListener("ended", this._endTimers[e], !1) } delete this._endTimers[e] } return this }, _soundById: function (e) { for (var t = 0; t < this._sounds.length; t++)if (e === this._sounds[t]._id) return this._sounds[t]; return null }, _inactiveSound: function () { this._drain(); for (var e = 0; e < this._sounds.length; e++)if (this._sounds[e]._ended) return this._sounds[e].reset(); return new o(this) }, _drain: function () { var e = this._pool, t = 0, i = 0; if (!(this._sounds.length < e)) { for (i = 0; i < this._sounds.length; i++)this._sounds[i]._ended && t++; for (i = this._sounds.length - 1; i >= 0; i--) { if (t <= e) return; this._sounds[i]._ended && (this._webAudio && this._sounds[i]._node && this._sounds[i]._node.disconnect(0), this._sounds.splice(i, 1), t--) } } }, _getSoundIds: function (e) { if (void 0 !== e) return [e]; for (var t = [], i = 0; i < this._sounds.length; i++)t.push(this._sounds[i]._id); return t }, _refreshBuffer: function (e) { return e._node.bufferSource = s.ctx.createBufferSource(), e._node.bufferSource.buffer = l[this._src], e._panner ? e._node.bufferSource.connect(e._panner) : e._node.bufferSource.connect(e._node), e._node.bufferSource.loop = e._loop, e._loop && (e._node.bufferSource.loopStart = e._start || 0, e._node.bufferSource.loopEnd = e._stop || 0), e._node.bufferSource.playbackRate.setValueAtTime(e._rate, s.ctx.currentTime), this }, _cleanBuffer: function (e) { var t = s._navigator && s._navigator.vendor.indexOf("Apple") >= 0; if (!e.bufferSource) return this; if (s._scratchBuffer && e.bufferSource && (e.bufferSource.onended = null, e.bufferSource.disconnect(0), t)) try { e.bufferSource.buffer = s._scratchBuffer } catch (e) { } return e.bufferSource = null, this }, _clearSound: function (e) { /MSIE |Trident\//.test(s._navigator && s._navigator.userAgent) || (e.src = "data:audio/wav;base64,UklGRigAAABXQVZFZm10IBIAAAABAAEARKwAAIhYAQACABAAAABkYXRhAgAAAAEA") } }; var o = function (e) { this._parent = e, this.init() }; o.prototype = { init: function () { var e = this._parent; return this._muted = e._muted, this._loop = e._loop, this._volume = e._volume, this._rate = e._rate, this._seek = 0, this._paused = !0, this._ended = !0, this._sprite = "__default", this._id = ++s._counter, e._sounds.push(this), this.create(), this }, create: function () { var e = this._parent, t = s._muted || this._muted || this._parent._muted ? 0 : this._volume; return e._webAudio ? (this._node = void 0 === s.ctx.createGain ? s.ctx.createGainNode() : s.ctx.createGain(), this._node.gain.setValueAtTime(t, s.ctx.currentTime), this._node.paused = !0, this._node.connect(s.masterGain)) : s.noAudio || (this._node = s._obtainHtml5Audio(), this._errorFn = this._errorListener.bind(this), this._node.addEventListener("error", this._errorFn, !1), this._loadFn = this._loadListener.bind(this), this._node.addEventListener(s._canPlayEvent, this._loadFn, !1), this._endFn = this._endListener.bind(this), this._node.addEventListener("ended", this._endFn, !1), this._node.src = e._src, this._node.preload = !0 === e._preload ? "auto" : e._preload, this._node.volume = t * s.volume(), this._node.load()), this }, reset: function () { var e = this._parent; return this._muted = e._muted, this._loop = e._loop, this._volume = e._volume, this._rate = e._rate, this._seek = 0, this._rateSeek = 0, this._paused = !0, this._ended = !0, this._sprite = "__default", this._id = ++s._counter, this }, _errorListener: function () { this._parent._emit("loaderror", this._id, this._node.error ? this._node.error.code : 0), this._node.removeEventListener("error", this._errorFn, !1) }, _loadListener: function () { var e = this._parent; e._duration = Math.ceil(10 * this._node.duration) / 10, 0 === Object.keys(e._sprite).length && (e._sprite = { __default: [0, 1e3 * e._duration] }), "loaded" !== e._state && (e._state = "loaded", e._emit("load"), e._loadQueue()), this._node.removeEventListener(s._canPlayEvent, this._loadFn, !1) }, _endListener: function () { var e = this._parent; e._duration === 1 / 0 && (e._duration = Math.ceil(10 * this._node.duration) / 10, e._sprite.__default[1] === 1 / 0 && (e._sprite.__default[1] = 1e3 * e._duration), e._ended(this)), this._node.removeEventListener("ended", this._endFn, !1) } }; var l = {}, u = function (e) { var t = e._src; if (l[t]) { e._duration = l[t].duration, d(e); return } if (/^data:[^;]+;base64,/.test(t)) { for (var i = atob(t.split(",")[1]), r = new Uint8Array(i.length), n = 0; n < i.length; ++n)r[n] = i.charCodeAt(n); c(r.buffer, e) } else { var s = new XMLHttpRequest; s.open(e._xhr.method, t, !0), s.withCredentials = e._xhr.withCredentials, s.responseType = "arraybuffer", e._xhr.headers && Object.keys(e._xhr.headers).forEach(function (t) { s.setRequestHeader(t, e._xhr.headers[t]) }), s.onload = function () { var t = (s.status + "")[0]; if ("0" !== t && "2" !== t && "3" !== t) { e._emit("loaderror", null, "Failed loading audio file with status: " + s.status + "."); return } c(s.response, e) }, s.onerror = function () { e._webAudio && (e._html5 = !0, e._webAudio = !1, e._sounds = [], delete l[t], e.load()) }, h(s) } }, h = function (e) { try { e.send() } catch (t) { e.onerror() } }, c = function (e, t) { var i = function () { t._emit("loaderror", null, "Decoding audio data failed.") }, r = function (e) { e && t._sounds.length > 0 ? (l[t._src] = e, d(t, e)) : i() }; "undefined" != typeof Promise && 1 === s.ctx.decodeAudioData.length ? s.ctx.decodeAudioData(e).then(r).catch(i) : s.ctx.decodeAudioData(e, r, i) }, d = function (e, t) { t && !e._duration && (e._duration = t.duration), 0 === Object.keys(e._sprite).length && (e._sprite = { __default: [0, 1e3 * e._duration] }), "loaded" !== e._state && (e._state = "loaded", e._emit("load"), e._loadQueue()) }, f = function () { if (s.usingWebAudio) { try { "undefined" != typeof AudioContext ? s.ctx = new AudioContext : "undefined" != typeof webkitAudioContext ? s.ctx = new webkitAudioContext : s.usingWebAudio = !1 } catch (e) { s.usingWebAudio = !1 } s.ctx || (s.usingWebAudio = !1); var e = /iP(hone|od|ad)/.test(s._navigator && s._navigator.platform), t = s._navigator && s._navigator.appVersion.match(/OS (\d+)_(\d+)_?(\d+)?/), i = t ? parseInt(t[1], 10) : null; if (e && i && i < 9) { var r = /safari/.test(s._navigator && s._navigator.userAgent.toLowerCase()); s._navigator && !r && (s.usingWebAudio = !1) } s.usingWebAudio && (s.masterGain = void 0 === s.ctx.createGain ? s.ctx.createGainNode() : s.ctx.createGain(), s.masterGain.gain.setValueAtTime(s._muted ? 0 : s._volume, s.ctx.currentTime), s.masterGain.connect(s.ctx.destination)), s._setup() } }; void 0 !== (r = (function () { return { Howler: s, Howl: a } }).apply(t, [])) && (e.exports = r), t.Howler = s, t.Howl = a, void 0 !== i.g ? (i.g.HowlerGlobal = n, i.g.Howler = s, i.g.Howl = a, i.g.Sound = o) : "undefined" != typeof window && (window.HowlerGlobal = n, window.Howler = s, window.Howl = a, window.Sound = o) }(), function () { "use strict"; HowlerGlobal.prototype._pos = [0, 0, 0], HowlerGlobal.prototype._orientation = [0, 0, -1, 0, 1, 0], HowlerGlobal.prototype.stereo = function (e) { if (!this.ctx || !this.ctx.listener) return this; for (var t = this._howls.length - 1; t >= 0; t--)this._howls[t].stereo(e); return this }, HowlerGlobal.prototype.pos = function (e, t, i) { return this.ctx && this.ctx.listener ? (t = "number" != typeof t ? this._pos[1] : t, i = "number" != typeof i ? this._pos[2] : i, "number" != typeof e) ? this._pos : (this._pos = [e, t, i], void 0 !== this.ctx.listener.positionX ? (this.ctx.listener.positionX.setTargetAtTime(this._pos[0], Howler.ctx.currentTime, .1), this.ctx.listener.positionY.setTargetAtTime(this._pos[1], Howler.ctx.currentTime, .1), this.ctx.listener.positionZ.setTargetAtTime(this._pos[2], Howler.ctx.currentTime, .1)) : this.ctx.listener.setPosition(this._pos[0], this._pos[1], this._pos[2]), this) : this }, HowlerGlobal.prototype.orientation = function (e, t, i, r, n, s) { if (!this.ctx || !this.ctx.listener) return this; var a = this._orientation; return (t = "number" != typeof t ? a[1] : t, i = "number" != typeof i ? a[2] : i, r = "number" != typeof r ? a[3] : r, n = "number" != typeof n ? a[4] : n, s = "number" != typeof s ? a[5] : s, "number" != typeof e) ? a : (this._orientation = [e, t, i, r, n, s], void 0 !== this.ctx.listener.forwardX ? (this.ctx.listener.forwardX.setTargetAtTime(e, Howler.ctx.currentTime, .1), this.ctx.listener.forwardY.setTargetAtTime(t, Howler.ctx.currentTime, .1), this.ctx.listener.forwardZ.setTargetAtTime(i, Howler.ctx.currentTime, .1), this.ctx.listener.upX.setTargetAtTime(r, Howler.ctx.currentTime, .1), this.ctx.listener.upY.setTargetAtTime(n, Howler.ctx.currentTime, .1), this.ctx.listener.upZ.setTargetAtTime(s, Howler.ctx.currentTime, .1)) : this.ctx.listener.setOrientation(e, t, i, r, n, s), this) }, Howl.prototype.init = (e = Howl.prototype.init, function (t) { return this._orientation = t.orientation || [1, 0, 0], this._stereo = t.stereo || null, this._pos = t.pos || null, this._pannerAttr = { coneInnerAngle: void 0 !== t.coneInnerAngle ? t.coneInnerAngle : 360, coneOuterAngle: void 0 !== t.coneOuterAngle ? t.coneOuterAngle : 360, coneOuterGain: void 0 !== t.coneOuterGain ? t.coneOuterGain : 0, distanceModel: void 0 !== t.distanceModel ? t.distanceModel : "inverse", maxDistance: void 0 !== t.maxDistance ? t.maxDistance : 1e4, panningModel: void 0 !== t.panningModel ? t.panningModel : "HRTF", refDistance: void 0 !== t.refDistance ? t.refDistance : 1, rolloffFactor: void 0 !== t.rolloffFactor ? t.rolloffFactor : 1 }, this._onstereo = t.onstereo ? [{ fn: t.onstereo }] : [], this._onpos = t.onpos ? [{ fn: t.onpos }] : [], this._onorientation = t.onorientation ? [{ fn: t.onorientation }] : [], e.call(this, t) }), Howl.prototype.stereo = function (e, t) { var i = this; if (!i._webAudio) return i; if ("loaded" !== i._state) return i._queue.push({ event: "stereo", action: function () { i.stereo(e, t) } }), i; var n = void 0 === Howler.ctx.createStereoPanner ? "spatial" : "stereo"; if (void 0 === t) { if ("number" != typeof e) return i._stereo; i._stereo = e, i._pos = [e, 0, 0] } for (var s = i._getSoundIds(t), a = 0; a < s.length; a++) { var o = i._soundById(s[a]); if (o) { if ("number" != typeof e) return o._stereo; o._stereo = e, o._pos = [e, 0, 0], o._node && (o._pannerAttr.panningModel = "equalpower", o._panner && o._panner.pan || r(o, n), "spatial" === n ? void 0 !== o._panner.positionX ? (o._panner.positionX.setValueAtTime(e, Howler.ctx.currentTime), o._panner.positionY.setValueAtTime(0, Howler.ctx.currentTime), o._panner.positionZ.setValueAtTime(0, Howler.ctx.currentTime)) : o._panner.setPosition(e, 0, 0) : o._panner.pan.setValueAtTime(e, Howler.ctx.currentTime)), i._emit("stereo", o._id) } } return i }, Howl.prototype.pos = function (e, t, i, n) { var s = this; if (!s._webAudio) return s; if ("loaded" !== s._state) return s._queue.push({ event: "pos", action: function () { s.pos(e, t, i, n) } }), s; if (t = "number" != typeof t ? 0 : t, i = "number" != typeof i ? -.5 : i, void 0 === n) { if ("number" != typeof e) return s._pos; s._pos = [e, t, i] } for (var a = s._getSoundIds(n), o = 0; o < a.length; o++) { var l = s._soundById(a[o]); if (l) { if ("number" != typeof e) return l._pos; l._pos = [e, t, i], l._node && ((!l._panner || l._panner.pan) && r(l, "spatial"), void 0 !== l._panner.positionX ? (l._panner.positionX.setValueAtTime(e, Howler.ctx.currentTime), l._panner.positionY.setValueAtTime(t, Howler.ctx.currentTime), l._panner.positionZ.setValueAtTime(i, Howler.ctx.currentTime)) : l._panner.setPosition(e, t, i)), s._emit("pos", l._id) } } return s }, Howl.prototype.orientation = function (e, t, i, n) { var s = this; if (!s._webAudio) return s; if ("loaded" !== s._state) return s._queue.push({ event: "orientation", action: function () { s.orientation(e, t, i, n) } }), s; if (t = "number" != typeof t ? s._orientation[1] : t, i = "number" != typeof i ? s._orientation[2] : i, void 0 === n) { if ("number" != typeof e) return s._orientation; s._orientation = [e, t, i] } for (var a = s._getSoundIds(n), o = 0; o < a.length; o++) { var l = s._soundById(a[o]); if (l) { if ("number" != typeof e) return l._orientation; l._orientation = [e, t, i], l._node && (l._panner || (l._pos || (l._pos = s._pos || [0, 0, -.5]), r(l, "spatial")), void 0 !== l._panner.orientationX ? (l._panner.orientationX.setValueAtTime(e, Howler.ctx.currentTime), l._panner.orientationY.setValueAtTime(t, Howler.ctx.currentTime), l._panner.orientationZ.setValueAtTime(i, Howler.ctx.currentTime)) : l._panner.setOrientation(e, t, i)), s._emit("orientation", l._id) } } return s }, Howl.prototype.pannerAttr = function () { var e, t, i, n = arguments; if (!this._webAudio) return this; if (0 === n.length) return this._pannerAttr; if (1 === n.length) { if ("object" != typeof n[0]) return (i = this._soundById(parseInt(n[0], 10))) ? i._pannerAttr : this._pannerAttr; e = n[0], void 0 === t && (e.pannerAttr || (e.pannerAttr = { coneInnerAngle: e.coneInnerAngle, coneOuterAngle: e.coneOuterAngle, coneOuterGain: e.coneOuterGain, distanceModel: e.distanceModel, maxDistance: e.maxDistance, refDistance: e.refDistance, rolloffFactor: e.rolloffFactor, panningModel: e.panningModel }), this._pannerAttr = { coneInnerAngle: void 0 !== e.pannerAttr.coneInnerAngle ? e.pannerAttr.coneInnerAngle : this._coneInnerAngle, coneOuterAngle: void 0 !== e.pannerAttr.coneOuterAngle ? e.pannerAttr.coneOuterAngle : this._coneOuterAngle, coneOuterGain: void 0 !== e.pannerAttr.coneOuterGain ? e.pannerAttr.coneOuterGain : this._coneOuterGain, distanceModel: void 0 !== e.pannerAttr.distanceModel ? e.pannerAttr.distanceModel : this._distanceModel, maxDistance: void 0 !== e.pannerAttr.maxDistance ? e.pannerAttr.maxDistance : this._maxDistance, refDistance: void 0 !== e.pannerAttr.refDistance ? e.pannerAttr.refDistance : this._refDistance, rolloffFactor: void 0 !== e.pannerAttr.rolloffFactor ? e.pannerAttr.rolloffFactor : this._rolloffFactor, panningModel: void 0 !== e.pannerAttr.panningModel ? e.pannerAttr.panningModel : this._panningModel }) } else 2 === n.length && (e = n[0], t = parseInt(n[1], 10)); for (var s = this._getSoundIds(t), a = 0; a < s.length; a++)if (i = this._soundById(s[a])) { var o = i._pannerAttr; o = { coneInnerAngle: void 0 !== e.coneInnerAngle ? e.coneInnerAngle : o.coneInnerAngle, coneOuterAngle: void 0 !== e.coneOuterAngle ? e.coneOuterAngle : o.coneOuterAngle, coneOuterGain: void 0 !== e.coneOuterGain ? e.coneOuterGain : o.coneOuterGain, distanceModel: void 0 !== e.distanceModel ? e.distanceModel : o.distanceModel, maxDistance: void 0 !== e.maxDistance ? e.maxDistance : o.maxDistance, refDistance: void 0 !== e.refDistance ? e.refDistance : o.refDistance, rolloffFactor: void 0 !== e.rolloffFactor ? e.rolloffFactor : o.rolloffFactor, panningModel: void 0 !== e.panningModel ? e.panningModel : o.panningModel }; var l = i._panner; l || (i._pos || (i._pos = this._pos || [0, 0, -.5]), r(i, "spatial"), l = i._panner), l.coneInnerAngle = o.coneInnerAngle, l.coneOuterAngle = o.coneOuterAngle, l.coneOuterGain = o.coneOuterGain, l.distanceModel = o.distanceModel, l.maxDistance = o.maxDistance, l.refDistance = o.refDistance, l.rolloffFactor = o.rolloffFactor, l.panningModel = o.panningModel } return this }, Sound.prototype.init = (t = Sound.prototype.init, function () { var e = this._parent; this._orientation = e._orientation, this._stereo = e._stereo, this._pos = e._pos, this._pannerAttr = e._pannerAttr, t.call(this), this._stereo ? e.stereo(this._stereo) : this._pos && e.pos(this._pos[0], this._pos[1], this._pos[2], this._id) }), Sound.prototype.reset = (i = Sound.prototype.reset, function () { var e = this._parent; return this._orientation = e._orientation, this._stereo = e._stereo, this._pos = e._pos, this._pannerAttr = e._pannerAttr, this._stereo ? e.stereo(this._stereo) : this._pos ? e.pos(this._pos[0], this._pos[1], this._pos[2], this._id) : this._panner && (this._panner.disconnect(0), this._panner = void 0, e._refreshBuffer(this)), i.call(this) }); var e, t, i, r = function (e, t) { "spatial" === (t = t || "spatial") ? (e._panner = Howler.ctx.createPanner(), e._panner.coneInnerAngle = e._pannerAttr.coneInnerAngle, e._panner.coneOuterAngle = e._pannerAttr.coneOuterAngle, e._panner.coneOuterGain = e._pannerAttr.coneOuterGain, e._panner.distanceModel = e._pannerAttr.distanceModel, e._panner.maxDistance = e._pannerAttr.maxDistance, e._panner.refDistance = e._pannerAttr.refDistance, e._panner.rolloffFactor = e._pannerAttr.rolloffFactor, e._panner.panningModel = e._pannerAttr.panningModel, void 0 !== e._panner.positionX ? (e._panner.positionX.setValueAtTime(e._pos[0], Howler.ctx.currentTime), e._panner.positionY.setValueAtTime(e._pos[1], Howler.ctx.currentTime), e._panner.positionZ.setValueAtTime(e._pos[2], Howler.ctx.currentTime)) : e._panner.setPosition(e._pos[0], e._pos[1], e._pos[2]), void 0 !== e._panner.orientationX ? (e._panner.orientationX.setValueAtTime(e._orientation[0], Howler.ctx.currentTime), e._panner.orientationY.setValueAtTime(e._orientation[1], Howler.ctx.currentTime), e._panner.orientationZ.setValueAtTime(e._orientation[2], Howler.ctx.currentTime)) : e._panner.setOrientation(e._orientation[0], e._orientation[1], e._orientation[2])) : (e._panner = Howler.ctx.createStereoPanner(), e._panner.pan.setValueAtTime(e._stereo, Howler.ctx.currentTime)), e._panner.connect(e._node), e._paused || e._parent.pause(e._id, !0).play(e._id, !0) } }() }, 8424: (e, t, i) => { (window.__NEXT_P = window.__NEXT_P || []).push(["/_app", function () { return i(411) }]) }, 5157: (e, t, i) => { "use strict"; function r(e, t, i, r) { return !1 } Object.defineProperty(t, "__esModule", { value: !0 }), Object.defineProperty(t, "getDomainLocale", { enumerable: !0, get: function () { return r } }), i(2063), ("function" == typeof t.default || "object" == typeof t.default && null !== t.default) && void 0 === t.default.__esModule && (Object.defineProperty(t.default, "__esModule", { value: !0 }), Object.assign(t.default, t), e.exports = t.default) }, 6526: (e, t, i) => { "use strict"; Object.defineProperty(t, "__esModule", { value: !0 }), Object.defineProperty(t, "Image", { enumerable: !0, get: function () { return S } }); let r = i(7677), n = i(544), s = i(4848), a = n._(i(6540)), o = r._(i(961)), l = r._(i(6085)), u = i(7282), h = i(2105), c = i(9641); i(7679); let d = i(7644), f = r._(i(5472)), p = i(1903), m = { deviceSizes: [640, 750, 828, 1080, 1200, 1920, 2048, 3840], imageSizes: [16, 32, 48, 64, 96, 128, 256, 384], path: "/_next/image/", loader: "default", dangerouslyAllowSVG: !1, unoptimized: !0 }; function g(e, t, i, r, n, s, a) { let o = null == e ? void 0 : e.src; e && e["data-loaded-src"] !== o && (e["data-loaded-src"] = o, ("decode" in e ? e.decode() : Promise.resolve()).catch(() => { }).then(() => { if (e.parentElement && e.isConnected) { if ("empty" !== t && n(!0), null == i ? void 0 : i.current) { let t = new Event("load"); Object.defineProperty(t, "target", { writable: !1, value: e }); let r = !1, n = !1; i.current({ ...t, nativeEvent: t, currentTarget: e, target: e, isDefaultPrevented: () => r, isPropagationStopped: () => n, persist: () => { }, preventDefault: () => { r = !0, t.preventDefault() }, stopPropagation: () => { n = !0, t.stopPropagation() } }) } (null == r ? void 0 : r.current) && r.current(e) } })) } function v(e) { return a.use ? { fetchPriority: e } : { fetchpriority: e } } let y = (0, a.forwardRef)((e, t) => { let { src: i, srcSet: r, sizes: n, height: o, width: l, decoding: u, className: h, style: c, fetchPriority: d, placeholder: f, loading: m, unoptimized: y, fill: x, onLoadRef: S, onLoadingCompleteRef: A, setBlurComplete: _, setShowAltText: E, sizesInput: b, onLoad: T, onError: w, ...M } = e, R = (0, a.useCallback)(e => { e && (w && (e.src = e.src), e.complete && g(e, f, S, A, _, y, b)) }, [i, f, S, A, _, w, y, b]), C = (0, p.useMergedRef)(t, R); return (0, s.jsx)("img", { ...M, ...v(d), loading: m, width: l, height: o, decoding: u, "data-nimg": x ? "fill" : "1", className: h, style: c, sizes: n, srcSet: r, src: i, ref: C, onLoad: e => { g(e.currentTarget, f, S, A, _, y, b) }, onError: e => { E(!0), "empty" !== f && _(!0), w && w(e) } }) }); function x(e) { let { isAppRouter: t, imgAttributes: i } = e, r = { as: "image", imageSrcSet: i.srcSet, imageSizes: i.sizes, crossOrigin: i.crossOrigin, referrerPolicy: i.referrerPolicy, ...v(i.fetchPriority) }; return t && o.default.preload ? (o.default.preload(i.src, r), null) : (0, s.jsx)(l.default, { children: (0, s.jsx)("link", { rel: "preload", href: i.srcSet ? void 0 : i.src, ...r }, "__nimg-" + i.src + i.srcSet + i.sizes) }) } let S = (0, a.forwardRef)((e, t) => { let i = (0, a.useContext)(d.RouterContext), r = (0, a.useContext)(c.ImageConfigContext), n = (0, a.useMemo)(() => { var e; let t = m || r || h.imageConfigDefault, i = [...t.deviceSizes, ...t.imageSizes].sort((e, t) => e - t), n = t.deviceSizes.sort((e, t) => e - t), s = null == (e = t.qualities) ? void 0 : e.sort((e, t) => e - t); return { ...t, allSizes: i, deviceSizes: n, qualities: s } }, [r]), { onLoad: o, onLoadingComplete: l } = e, p = (0, a.useRef)(o); (0, a.useEffect)(() => { p.current = o }, [o]); let g = (0, a.useRef)(l); (0, a.useEffect)(() => { g.current = l }, [l]); let [v, S] = (0, a.useState)(!1), [A, _] = (0, a.useState)(!1), { props: E, meta: b } = (0, u.getImgProps)(e, { defaultLoader: f.default, imgConf: n, blurComplete: v, showAltText: A }); return (0, s.jsxs)(s.Fragment, { children: [(0, s.jsx)(y, { ...E, unoptimized: b.unoptimized, placeholder: b.placeholder, fill: b.fill, onLoadRef: p, onLoadingCompleteRef: g, setBlurComplete: S, setShowAltText: _, sizesInput: e.sizes, ref: t }), b.priority ? (0, s.jsx)(x, { isAppRouter: !i, imgAttributes: E }) : null] }) }); ("function" == typeof t.default || "object" == typeof t.default && null !== t.default) && void 0 === t.default.__esModule && (Object.defineProperty(t.default, "__esModule", { value: !0 }), Object.assign(t.default, t), e.exports = t.default) }, 6397: (e, t, i) => { "use strict"; Object.defineProperty(t, "__esModule", { value: !0 }), Object.defineProperty(t, "default", { enumerable: !0, get: function () { return x } }); let r = i(7677), n = i(4848), s = r._(i(6540)), a = i(6847), o = i(7785), l = i(2772), u = i(1278), h = i(6185), c = i(7644), d = i(6334), f = i(5157), p = i(296), m = i(1903), g = new Set; function v(e, t, i, r) { if ((0, o.isLocalURL)(t)) { if (!r.bypassPrefetchedCheck) { let n = t + "%" + i + "%" + (void 0 !== r.locale ? r.locale : "locale" in e ? e.locale : void 0); if (g.has(n)) return; g.add(n) } e.prefetch(t, i, r).catch(e => { }) } } function y(e) { return "string" == typeof e ? e : (0, l.formatUrl)(e) } let x = s.default.forwardRef(function (e, t) { let i, r; let { href: l, as: g, children: x, prefetch: S = null, passHref: A, replace: _, shallow: E, scroll: b, locale: T, onClick: w, onMouseEnter: M, onTouchStart: R, legacyBehavior: C = !1, ...I } = e; i = x, C && ("string" == typeof i || "number" == typeof i) && (i = (0, n.jsx)("a", { children: i })); let L = s.default.useContext(c.RouterContext), P = !1 !== S, { href: D, as: O } = s.default.useMemo(() => { if (!L) { let e = y(l); return { href: e, as: g ? y(g) : e } } let [e, t] = (0, a.resolveHref)(L, l, !0); return { href: e, as: g ? (0, a.resolveHref)(L, g) : t || e } }, [L, l, g]), k = s.default.useRef(D), F = s.default.useRef(O); C && (r = s.default.Children.only(i)); let U = C ? r && "object" == typeof r && r.ref : t, [N, B, z] = (0, d.useIntersection)({ rootMargin: "200px" }), G = s.default.useCallback(e => { (F.current !== O || k.current !== D) && (z(), F.current = O, k.current = D), N(e) }, [O, D, z, N]), H = (0, m.useMergedRef)(G, U); s.default.useEffect(() => { L && B && P && v(L, D, O, { locale: T }) }, [O, D, B, T, P, null == L ? void 0 : L.locale, L]); let V = { ref: H, onClick(e) { C || "function" != typeof w || w(e), C && r.props && "function" == typeof r.props.onClick && r.props.onClick(e), L && !e.defaultPrevented && function (e, t, i, r, n, s, a, l) { let { nodeName: u } = e.currentTarget; "A" === u.toUpperCase() && (function (e) { let t = e.currentTarget.getAttribute("target"); return t && "_self" !== t || e.metaKey || e.ctrlKey || e.shiftKey || e.altKey || e.nativeEvent && 2 === e.nativeEvent.which }(e) || !(0, o.isLocalURL)(i)) || (e.preventDefault(), (() => { let e = null == a || a; "beforePopState" in t ? t[n ? "replace" : "push"](i, r, { shallow: s, locale: l, scroll: e }) : t[n ? "replace" : "push"](r || i, { scroll: e }) })()) }(e, L, D, O, _, E, b, T) }, onMouseEnter(e) { C || "function" != typeof M || M(e), C && r.props && "function" == typeof r.props.onMouseEnter && r.props.onMouseEnter(e), L && v(L, D, O, { locale: T, priority: !0, bypassPrefetchedCheck: !0 }) }, onTouchStart: function (e) { C || "function" != typeof R || R(e), C && r.props && "function" == typeof r.props.onTouchStart && r.props.onTouchStart(e), L && v(L, D, O, { locale: T, priority: !0, bypassPrefetchedCheck: !0 }) } }; if ((0, u.isAbsoluteUrl)(O)) V.href = O; else if (!C || A || "a" === r.type && !("href" in r.props)) { let e = void 0 !== T ? T : null == L ? void 0 : L.locale, t = (null == L ? void 0 : L.isLocaleDomain) && (0, f.getDomainLocale)(O, e, null == L ? void 0 : L.locales, null == L ? void 0 : L.domainLocales); V.href = t || (0, p.addBasePath)((0, h.addLocale)(O, e, null == L ? void 0 : L.defaultLocale)) } return C ? s.default.cloneElement(r, V) : (0, n.jsx)("a", { ...I, ...V, children: i }) }); ("function" == typeof t.default || "object" == typeof t.default && null !== t.default) && void 0 === t.default.__esModule && (Object.defineProperty(t.default, "__esModule", { value: !0 }), Object.assign(t.default, t), e.exports = t.default) }, 6334: (e, t, i) => { "use strict"; Object.defineProperty(t, "__esModule", { value: !0 }), Object.defineProperty(t, "useIntersection", { enumerable: !0, get: function () { return l } }); let r = i(6540), n = i(4959), s = "function" == typeof IntersectionObserver, a = new Map, o = []; function l(e) { let { rootRef: t, rootMargin: i, disabled: l } = e, u = l || !s, [h, c] = (0, r.useState)(!1), d = (0, r.useRef)(null), f = (0, r.useCallback)(e => { d.current = e }, []); return (0, r.useEffect)(() => { if (s) { if (u || h) return; let e = d.current; if (e && e.tagName) return function (e, t, i) { let { id: r, observer: n, elements: s } = function (e) { let t; let i = { root: e.root || null, margin: e.rootMargin || "" }, r = o.find(e => e.root === i.root && e.margin === i.margin); if (r && (t = a.get(r))) return t; let n = new Map; return t = { id: i, observer: new IntersectionObserver(e => { e.forEach(e => { let t = n.get(e.target), i = e.isIntersecting || e.intersectionRatio > 0; t && i && t(i) }) }, e), elements: n }, o.push(i), a.set(i, t), t }(i); return s.set(e, t), n.observe(e), function () { if (s.delete(e), n.unobserve(e), 0 === s.size) { n.disconnect(), a.delete(r); let e = o.findIndex(e => e.root === r.root && e.margin === r.margin); e > -1 && o.splice(e, 1) } } }(e, e => e && c(e), { root: null == t ? void 0 : t.current, rootMargin: i }) } else if (!h) { let e = (0, n.requestIdleCallback)(() => c(!0)); return () => (0, n.cancelIdleCallback)(e) } }, [u, i, t, h, d.current]), [f, h, (0, r.useCallback)(() => { c(!1) }, [])] } ("function" == typeof t.default || "object" == typeof t.default && null !== t.default) && void 0 === t.default.__esModule && (Object.defineProperty(t.default, "__esModule", { value: !0 }), Object.assign(t.default, t), e.exports = t.default) }, 1903: (e, t, i) => { "use strict"; Object.defineProperty(t, "__esModule", { value: !0 }), Object.defineProperty(t, "useMergedRef", { enumerable: !0, get: function () { return n } }); let r = i(6540); function n(e, t) { let i = (0, r.useRef)(() => { }), n = (0, r.useRef)(() => { }); return (0, r.useMemo)(() => e && t ? r => { null === r ? (i.current(), n.current()) : (i.current = s(e, r), n.current = s(t, r)) } : e || t, [e, t]) } function s(e, t) { if ("function" != typeof e) return e.current = t, () => { e.current = null }; { let i = e(t); return "function" == typeof i ? i : () => e(null) } } ("function" == typeof t.default || "object" == typeof t.default && null !== t.default) && void 0 === t.default.__esModule && (Object.defineProperty(t.default, "__esModule", { value: !0 }), Object.assign(t.default, t), e.exports = t.default) }, 5946: (e, t, i) => { "use strict"; Object.defineProperty(t, "__esModule", { value: !0 }), function (e, t) { for (var i in t) Object.defineProperty(e, i, { enumerable: !0, get: t[i] }) }(t, { default: function () { return o }, noSSR: function () { return a } }); let r = i(7677); i(4848), i(6540); let n = r._(i(5645)); function s(e) { return { default: (null == e ? void 0 : e.default) || e } } function a(e, t) { return delete t.webpack, delete t.modules, e(t) } function o(e, t) { let i = n.default, r = { loading: e => { let { error: t, isLoading: i, pastDelay: r } = e; return null } }; e instanceof Promise ? r.loader = () => e : "function" == typeof e ? r.loader = e : "object" == typeof e && (r = { ...r, ...e }); let o = (r = { ...r, ...t }).loader; return (r.loadableGenerated && (r = { ...r, ...r.loadableGenerated }, delete r.loadableGenerated), "boolean" != typeof r.ssr || r.ssr) ? i({ ...r, loader: () => null != o ? o().then(s) : Promise.resolve(s(() => null)) }) : (delete r.webpack, delete r.modules, a(i, r)) } ("function" == typeof t.default || "object" == typeof t.default && null !== t.default) && void 0 === t.default.__esModule && (Object.defineProperty(t.default, "__esModule", { value: !0 }), Object.assign(t.default, t), e.exports = t.default) }, 7282: (e, t, i) => { "use strict"; Object.defineProperty(t, "__esModule", { value: !0 }), Object.defineProperty(t, "getImgProps", { enumerable: !0, get: function () { return o } }), i(7679); let r = i(9197), n = i(2105); function s(e) { return void 0 !== e.default } function a(e) { return void 0 === e ? e : "number" == typeof e ? Number.isFinite(e) ? e : NaN : "string" == typeof e && /^[0-9]+$/.test(e) ? parseInt(e, 10) : NaN } function o(e, t) { var i, o; let l, u, h, { src: c, sizes: d, unoptimized: f = !1, priority: p = !1, loading: m, className: g, quality: v, width: y, height: x, fill: S = !1, style: A, overrideSrc: _, onLoad: E, onLoadingComplete: b, placeholder: T = "empty", blurDataURL: w, fetchPriority: M, decoding: R = "async", layout: C, objectFit: I, objectPosition: L, lazyBoundary: P, lazyRoot: D, ...O } = e, { imgConf: k, showAltText: F, blurComplete: U, defaultLoader: N } = t, B = k || n.imageConfigDefault; if ("allSizes" in B) l = B; else { let e = [...B.deviceSizes, ...B.imageSizes].sort((e, t) => e - t), t = B.deviceSizes.sort((e, t) => e - t), r = null == (i = B.qualities) ? void 0 : i.sort((e, t) => e - t); l = { ...B, allSizes: e, deviceSizes: t, qualities: r } } if (void 0 === N) throw Error("images.loaderFile detected but the file is missing default export.\nRead more: https://nextjs.org/docs/messages/invalid-images-config"); let z = O.loader || N; delete O.loader, delete O.srcSet; let G = "__next_img_default" in z; if (G) { if ("custom" === l.loader) throw Error('Image with src "' + c + '" is missing "loader" prop.\nRead more: https://nextjs.org/docs/messages/next-image-missing-loader') } else { let e = z; z = t => { let { config: i, ...r } = t; return e(r) } } if (C) { "fill" === C && (S = !0); let e = { intrinsic: { maxWidth: "100%", height: "auto" }, responsive: { width: "100%", height: "auto" } }[C]; e && (A = { ...A, ...e }); let t = { responsive: "100vw", fill: "100vw" }[C]; t && !d && (d = t) } let H = "", V = a(y), W = a(x); if ((o = c) && "object" == typeof o && (s(o) || void 0 !== o.src)) { let e = s(c) ? c.default : c; if (!e.src) throw Error("An object should only be passed to the image component src parameter if it comes from a static image import. It must include src. Received " + JSON.stringify(e)); if (!e.height || !e.width) throw Error("An object should only be passed to the image component src parameter if it comes from a static image import. It must include height and width. Received " + JSON.stringify(e)); if (u = e.blurWidth, h = e.blurHeight, w = w || e.blurDataURL, H = e.src, !S) { if (V || W) { if (V && !W) { let t = V / e.width; W = Math.round(e.height * t) } else if (!V && W) { let t = W / e.height; V = Math.round(e.width * t) } } else V = e.width, W = e.height } } let j = !p && ("lazy" === m || void 0 === m); (!(c = "string" == typeof c ? c : H) || c.startsWith("data:") || c.startsWith("blob:")) && (f = !0, j = !1), l.unoptimized && (f = !0), G && !l.dangerouslyAllowSVG && c.split("?", 1)[0].endsWith(".svg") && (f = !0); let Y = a(v), X = Object.assign(S ? { position: "absolute", height: "100%", width: "100%", left: 0, top: 0, right: 0, bottom: 0, objectFit: I, objectPosition: L } : {}, F ? {} : { color: "transparent" }, A), K = U || "empty" === T ? null : "blur" === T ? 'url("data:image/svg+xml;charset=utf-8,' + (0, r.getImageBlurSvg)({ widthInt: V, heightInt: W, blurWidth: u, blurHeight: h, blurDataURL: w || "", objectFit: X.objectFit }) + '")' : 'url("' + T + '")', q = K ? { backgroundSize: X.objectFit || "cover", backgroundPosition: X.objectPosition || "50% 50%", backgroundRepeat: "no-repeat", backgroundImage: K } : {}, Q = function (e) { let { config: t, src: i, unoptimized: r, width: n, quality: s, sizes: a, loader: o } = e; if (r) return { src: i, srcSet: void 0, sizes: void 0 }; let { widths: l, kind: u } = function (e, t, i) { let { deviceSizes: r, allSizes: n } = e; if (i) { let e = /(^|\s)(1?\d?\d)vw/g, t = []; for (let r; r = e.exec(i); r)t.push(parseInt(r[2])); if (t.length) { let e = .01 * Math.min(...t); return { widths: n.filter(t => t >= r[0] * e), kind: "w" } } return { widths: n, kind: "w" } } return "number" != typeof t ? { widths: r, kind: "w" } : { widths: [...new Set([t, 2 * t].map(e => n.find(t => t >= e) || n[n.length - 1]))], kind: "x" } }(t, n, a), h = l.length - 1; return { sizes: a || "w" !== u ? a : "100vw", srcSet: l.map((e, r) => o({ config: t, src: i, quality: s, width: e }) + " " + ("w" === u ? e : r + 1) + u).join(", "), src: o({ config: t, src: i, quality: s, width: l[h] }) } }({ config: l, src: c, unoptimized: f, width: V, quality: Y, sizes: d, loader: z }); return { props: { ...O, loading: j ? "lazy" : m, fetchPriority: M, width: V, height: W, decoding: R, className: g, style: { ...X, ...q }, sizes: Q.sizes, srcSet: Q.srcSet, src: _ || Q.src }, meta: { unoptimized: f, priority: p, placeholder: T, fill: S } } } }, 9197: (e, t) => { "use strict"; function i(e) { let { widthInt: t, heightInt: i, blurWidth: r, blurHeight: n, blurDataURL: s, objectFit: a } = e, o = r ? 40 * r : t, l = n ? 40 * n : i, u = o && l ? "viewBox='0 0 " + o + " " + l + "'" : ""; return "%3Csvg xmlns='http://www.w3.org/2000/svg' " + u + "%3E%3Cfilter id='b' color-interpolation-filters='sRGB'%3E%3CfeGaussianBlur stdDeviation='20'/%3E%3CfeColorMatrix values='1 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 100 -1' result='s'/%3E%3CfeFlood x='0' y='0' width='100%25' height='100%25'/%3E%3CfeComposite operator='out' in='s'/%3E%3CfeComposite in2='SourceGraphic'/%3E%3CfeGaussianBlur stdDeviation='20'/%3E%3C/filter%3E%3Cimage width='100%25' height='100%25' x='0' y='0' preserveAspectRatio='" + (u ? "none" : "contain" === a ? "xMidYMid" : "cover" === a ? "xMidYMid slice" : "none") + "' style='filter: url(%23b);' href='" + s + "'/%3E%3C/svg%3E" } Object.defineProperty(t, "__esModule", { value: !0 }), Object.defineProperty(t, "getImageBlurSvg", { enumerable: !0, get: function () { return i } }) }, 2364: (e, t, i) => { "use strict"; Object.defineProperty(t, "__esModule", { value: !0 }), function (e, t) { for (var i in t) Object.defineProperty(e, i, { enumerable: !0, get: t[i] }) }(t, { default: function () { return l }, getImageProps: function () { return o } }); let r = i(7677), n = i(7282), s = i(6526), a = r._(i(5472)); function o(e) { let { props: t } = (0, n.getImgProps)(e, { defaultLoader: a.default, imgConf: { deviceSizes: [640, 750, 828, 1080, 1200, 1920, 2048, 3840], imageSizes: [16, 32, 48, 64, 96, 128, 256, 384], path: "/_next/image/", loader: "default", dangerouslyAllowSVG: !1, unoptimized: !0 } }); for (let [e, i] of Object.entries(t)) void 0 === i && delete t[e]; return { props: t } } let l = s.Image }, 5472: (e, t) => { "use strict"; function i(e) { var t; let { config: i, src: r, width: n, quality: s } = e, a = s || (null == (t = i.qualities) ? void 0 : t.reduce((e, t) => Math.abs(t - 75) < Math.abs(e - 75) ? t : e)) || 75; return i.path + "?url=" + encodeURIComponent(r) + "&w=" + n + "&q=" + a + (r.startsWith("/_next/static/media/"), "") } Object.defineProperty(t, "__esModule", { value: !0 }), Object.defineProperty(t, "default", { enumerable: !0, get: function () { return r } }), i.__next_img_default = !0; let r = i }, 4319: (e, t, i) => { "use strict"; Object.defineProperty(t, "__esModule", { value: !0 }), Object.defineProperty(t, "LoadableContext", { enumerable: !0, get: function () { return r } }); let r = i(7677)._(i(6540)).default.createContext(null) }, 5645: (e, t, i) => { "use strict"; Object.defineProperty(t, "__esModule", { value: !0 }), Object.defineProperty(t, "default", { enumerable: !0, get: function () { return d } }); let r = i(7677)._(i(6540)), n = i(4319), s = [], a = [], o = !1; function l(e) { let t = e(), i = { loading: !0, loaded: null, error: null }; return i.promise = t.then(e => (i.loading = !1, i.loaded = e, e)).catch(e => { throw i.loading = !1, i.error = e, e }), i } class u { promise() { return this._res.promise } retry() { this._clearTimeouts(), this._res = this._loadFn(this._opts.loader), this._state = { pastDelay: !1, timedOut: !1 }; let { _res: e, _opts: t } = this; e.loading && ("number" == typeof t.delay && (0 === t.delay ? this._state.pastDelay = !0 : this._delay = setTimeout(() => { this._update({ pastDelay: !0 }) }, t.delay)), "number" == typeof t.timeout && (this._timeout = setTimeout(() => { this._update({ timedOut: !0 }) }, t.timeout))), this._res.promise.then(() => { this._update({}), this._clearTimeouts() }).catch(e => { this._update({}), this._clearTimeouts() }), this._update({}) } _update(e) { this._state = { ...this._state, error: this._res.error, loaded: this._res.loaded, loading: this._res.loading, ...e }, this._callbacks.forEach(e => e()) } _clearTimeouts() { clearTimeout(this._delay), clearTimeout(this._timeout) } getCurrentValue() { return this._state } subscribe(e) { return this._callbacks.add(e), () => { this._callbacks.delete(e) } } constructor(e, t) { this._loadFn = e, this._opts = t, this._callbacks = new Set, this._delay = null, this._timeout = null, this.retry() } } function h(e) { return function (e, t) { let i = Object.assign({ loader: null, loading: null, delay: 200, timeout: null, webpack: null, modules: null }, t), s = null; function l() { if (!s) { let t = new u(e, i); s = { getCurrentValue: t.getCurrentValue.bind(t), subscribe: t.subscribe.bind(t), retry: t.retry.bind(t), promise: t.promise.bind(t) } } return s.promise() } if (!o) { let e = i.webpack ? i.webpack() : i.modules; e && a.push(t => { for (let i of e) if (t.includes(i)) return l() }) } function h(e, t) { !function () { l(); let e = r.default.useContext(n.LoadableContext); e && Array.isArray(i.modules) && i.modules.forEach(t => { e(t) }) }(); let a = r.default.useSyncExternalStore(s.subscribe, s.getCurrentValue, s.getCurrentValue); return r.default.useImperativeHandle(t, () => ({ retry: s.retry }), []), r.default.useMemo(() => { var t; return a.loading || a.error ? r.default.createElement(i.loading, { isLoading: a.loading, pastDelay: a.pastDelay, timedOut: a.timedOut, error: a.error, retry: s.retry }) : a.loaded ? r.default.createElement((t = a.loaded) && t.default ? t.default : t, e) : null }, [e, a]) } return h.preload = () => l(), h.displayName = "LoadableComponent", r.default.forwardRef(h) }(l, e) } function c(e, t) { let i = []; for (; e.length;) { let r = e.pop(); i.push(r(t)) } return Promise.all(i).then(() => { if (e.length) return c(e, t) }) } h.preloadAll = () => new Promise((e, t) => { c(s).then(e, t) }), h.preloadReady = e => (void 0 === e && (e = []), new Promise(t => { let i = () => (o = !0, t()); c(a, e).then(i, i) })), window.__NEXT_PRELOADREADY = h.preloadReady; let d = h }, 4299: (e, t, i) => { "use strict"; i.d(t, { AU: () => s, Bd: () => a, lQ: () => r, on: () => n }); var r = function () { }; function n(e) { for (var t = [], i = 1; i < arguments.length; i++)t[i - 1] = arguments[i]; e && e.addEventListener && e.addEventListener.apply(e, t) } function s(e) { for (var t = [], i = 1; i < arguments.length; i++)t[i - 1] = arguments[i]; e && e.removeEventListener && e.removeEventListener.apply(e, t) } var a = !0 }, 9613: (e, t, i) => { "use strict"; i.d(t, { A: () => s }); var r = i(6540), n = i(4299); let s = function (e, t) { var i = (0, r.useState)(void 0 !== t ? t : !!n.Bd && window.matchMedia(e).matches), s = i[0], a = i[1]; return (0, r.useEffect)(function () { var t = !0, i = window.matchMedia(e), r = function () { t && a(!!i.matches) }; return i.addEventListener("change", r), a(i.matches), function () { t = !1, i.removeEventListener("change", r) } }, [e]), s } }, 3871: (e, t, i) => { "use strict"; i.d(t, { wb: () => l, R2: () => u, V4: () => h }); var r = i(4196), n = i(6540); let s = ["auxclick", "click", "contextmenu", "dblclick", "keydown", "keyup", "mousedown", "mouseup", "touchend"]; class a { #e = !1; #t = "blocked"; #i = ""; constructor() { this.#i = this.#r(), s.forEach(e => { window.addEventListener(e, this.#n.bind(this), { capture: !0, passive: !0 }) }) } #n() { "allowed" === this.#t || this.#e || this.#s() } #r() { let e = new ArrayBuffer(10), t = new DataView(e); t.setUint32(0, 48e3, !0), t.setUint32(4, 48e3, !0), t.setUint16(8, 1, !0); let i = window.btoa(String.fromCharCode(...new Uint8Array(e))).slice(0, 13); return `data:audio/wav;base64,UklGRisAAABXQVZFZm10IBAAAAABAAEA${i}AgAZGF0YQcAAACAgICAgICAAAA=` } #s() { this.#e = !0; let e = document.createElement("audio"); e.setAttribute("x-webkit-airplay", "deny"), e.preload = "auto", e.loop = !0, e.src = this.#i, e.load(), e.play().then(() => { this.#t = "allowed" }, () => { this.#t = "blocked", e.src = "about:blank", e.load(), e = null, this.#e = !1 }) } destroy() { s.forEach(e => { window.removeEventListener(e, this.#n.bind(this), { capture: !0, passive: !0 }) }) } get allowed() { return "allowed" === this.#t } } let o = { INTRO_START: "/audio/intro/start", INTRO_LOOP: "/audio/intro/loop", AMBIENCE_INTRO: "/audio/ambience_intro", AMBIENCE: "/audio/ambience", SWORD_INTRO: "/audio/sword/sword_intro", SWORD_LOOP: "/audio/sword/sword_loop", SWORD_HANDLE: "/audio/sword/hover_shaft", SWORD_HOVER_1: "/audio/sword/hover_1", SWORD_HOVER_2: "/audio/sword/hover_2", SWORD_HOVER_3: "/audio/sword/hover_3", FIRE: "/audio/fire", NEWSLETTER: "/audio/newsletter", TRAILER: "/audio/trailer" }, l = .4, u = {}, h = () => (c(), (0, n.useEffect)(() => { let e; return (navigator.userAgent.includes("iPhone") || navigator.userAgent.includes("iPad")) && (e = new a), () => { e?.destroy() } }, []), (0, n.useEffect)(() => { Object.entries(o).forEach(([e, t]) => { u[e] = new r.Howl({ src: [`${t}.webm`, `${t}.mp3`], format: ["webm", "mp3"], preload: !0 }) }); let e = r.Howler.ctx; function t() { e.state } return e.addEventListener("statechange", t), r.Howler.volume(0), () => { e.removeEventListener("statechange", t), r.Howler.unload() } }, [])), c = () => (0, n.useEffect)(() => { let e = () => { r.Howler.mute(!0) }, t = d(), i = () => { r.Howler.mute(document[t.hidden]) }; return window.addEventListener("pagehide", e), document.addEventListener(t.visibilityChange, i), () => { document.removeEventListener(t.visibilityChange, i), window.removeEventListener("pagehide", e) } }, []), d = () => void 0 !== document.hidden ? { hidden: "hidden", visibilityChange: "visibilitychange" } : void 0 !== document.msHidden ? { hidden: "msHidden", visibilityChange: "msvisibilitychange" } : void 0 !== document.webkitHidden ? { hidden: "webkitHidden", visibilityChange: "webkitvisibilitychange" } : { hidden: "hidden", visibilityChange: "visibilitychange" } }, 300: (e, t, i) => { "use strict"; i.d(t, { A: () => a }); var r = i(4848), n = i(4164), s = i(8848); function a(e) { let { className: t, children: i, href: a, noDefaultClass: o, type: l, ...u } = e, h = o ? t : (0, n.A)(a ? "link" : "button", t); return a ? (0, r.jsx)(s.N, { href: a, target: a?.includes("http") ? "_blank" : void 0, rel: a?.includes("http") ? "noopener noreferrer" : void 0, className: h, noTransition: a?.includes("http"), ...u, children: i }) : (0, r.jsx)("button", { type: l, ...u, className: h, children: i }) } }, 3900: (e, t, i) => {
    "use strict"; let r, n; i.d(t, { L: () => D, w: () => P }); var s = i(4848), a = i(3871), o = i(3502), l = i(6540), u = i(1323), h = i(4684), c = i(1538), d = i(9183), f = i(5338), p = i(4922), m = i(2111); let g = new p.Pq0, v = new p.Pq0, y = new p.Pq0, x = new p.I9Y; function S(e, t, i) { let r = g.setFromMatrixPosition(e.matrixWorld); r.project(t); let n = i.width / 2, s = i.height / 2; return [r.x * n + n, -(r.y * s) + s] } let A = e => 1e-10 > Math.abs(e) ? 0 : e; function _(e, t, i = "") { let r = "matrix3d("; for (let i = 0; 16 !== i; i++)r += A(t[i] * e.elements[i]) + (15 !== i ? "," : ")"); return i + r } let E = (r = [1, -1, 1, 1, 1, -1, 1, 1, 1, -1, 1, 1, 1, -1, 1, 1], e => _(e, r)), b = (n = e => [1 / e, 1 / e, 1 / e, 1, -1 / e, -1 / e, -1 / e, -1, 1 / e, 1 / e, 1 / e, 1, 1, 1, 1, 1], (e, t) => _(e, n(t), "translate(-50%,-50%)")), T = l.forwardRef(({ children: e, eps: t = .001, style: i, className: r, prepend: n, center: s, fullscreen: a, portal: o, distanceFactor: u, sprite: h = !1, transform: c = !1, occlude: _, onOcclude: T, castShadow: w, receiveShadow: M, material: R, geometry: C, zIndexRange: I = [0x1000037, 0], calculatePosition: L = S, as: P = "div", wrapperClass: D, pointerEvents: O = "auto", ...k }, F) => {
      let { gl: U, camera: N, scene: B, size: z, raycaster: G, events: H, viewport: V } = (0, m.A)(), [W] = l.useState(() => document.createElement(P)), j = l.useRef(null), Y = l.useRef(null), X = l.useRef(0), K = l.useRef([0, 0]), q = l.useRef(null), Q = l.useRef(null), Z = (null == o ? void 0 : o.current) || H.connected || U.domElement.parentNode, $ = l.useRef(null), J = l.useRef(!1), ee = l.useMemo(() => _ && "blending" !== _ || Array.isArray(_) && _.length && function (e) { return e && "object" == typeof e && "current" in e }(_[0]), [_]); l.useLayoutEffect(() => { let e = U.domElement; _ && "blending" === _ ? (e.style.zIndex = `${Math.floor(I[0] / 2)}`, e.style.position = "absolute", e.style.pointerEvents = "none") : (e.style.zIndex = null, e.style.position = null, e.style.pointerEvents = null) }, [_]), l.useLayoutEffect(() => { if (Y.current) { let e = j.current = f.createRoot(W); if (B.updateMatrixWorld(), c) W.style.cssText = "position:absolute;top:0;left:0;pointer-events:none;overflow:hidden;"; else { let e = L(Y.current, N, z); W.style.cssText = `position:absolute;top:0;left:0;transform:translate3d(${e[0]}px,${e[1]}px,0);transform-origin:0 0;` } return Z && (n ? Z.prepend(W) : Z.appendChild(W)), () => { Z && Z.removeChild(W), e.unmount() } } }, [Z, c]), l.useLayoutEffect(() => { D && (W.className = D) }, [D]); let et = l.useMemo(() => c ? { position: "absolute", top: 0, left: 0, width: z.width, height: z.height, transformStyle: "preserve-3d", pointerEvents: "none" } : { position: "absolute", transform: s ? "translate3d(-50%,-50%,0)" : "none", ...a && { top: -z.height / 2, left: -z.width / 2, width: z.width, height: z.height }, ...i }, [i, s, a, z, c]), ei = l.useMemo(() => ({ position: "absolute", pointerEvents: O }), [O]); l.useLayoutEffect(() => { var t, n; J.current = !1, c ? null == (t = j.current) || t.render(l.createElement("div", { ref: q, style: et }, l.createElement("div", { ref: Q, style: ei }, l.createElement("div", { ref: F, className: r, style: i, children: e })))) : null == (n = j.current) || n.render(l.createElement("div", { ref: F, style: et, className: r, children: e })) }); let er = l.useRef(!0); (0, m.C)(e => { if (Y.current) { N.updateMatrixWorld(), Y.current.updateWorldMatrix(!0, !1); let e = c ? K.current : L(Y.current, N, z); if (c || Math.abs(X.current - N.zoom) > t || Math.abs(K.current[0] - e[0]) > t || Math.abs(K.current[1] - e[1]) > t) { let t = function (e, t) { let i = g.setFromMatrixPosition(e.matrixWorld), r = v.setFromMatrixPosition(t.matrixWorld), n = i.sub(r), s = t.getWorldDirection(y); return n.angleTo(s) > Math.PI / 2 }(Y.current, N), i = !1; ee && (Array.isArray(_) ? i = _.map(e => e.current) : "blending" !== _ && (i = [B])); let r = er.current; if (i) { let e = function (e, t, i, r) { let n = g.setFromMatrixPosition(e.matrixWorld), s = n.clone(); s.project(t), x.set(s.x, s.y), i.setFromCamera(x, t); let a = i.intersectObjects(r, !0); if (a.length) { let e = a[0].distance; return n.distanceTo(i.ray.origin) < e } return !0 }(Y.current, N, G, i); er.current = e && !t } else er.current = !t; r !== er.current && (T ? T(!er.current) : W.style.display = er.current ? "block" : "none"); let n = Math.floor(I[0] / 2), s = _ ? ee ? [I[0], n] : [n - 1, 0] : I; if (W.style.zIndex = `${function (e, t, i) { if (t instanceof p.ubm || t instanceof p.qUd) { let r = g.setFromMatrixPosition(e.matrixWorld), n = v.setFromMatrixPosition(t.matrixWorld), s = r.distanceTo(n), a = (i[1] - i[0]) / (t.far - t.near), o = i[1] - a * t.far; return Math.round(a * s + o) } }(Y.current, N, s)}`, c) { let [e, t] = [z.width / 2, z.height / 2], i = N.projectionMatrix.elements[5] * t, { isOrthographicCamera: r, top: n, left: s, bottom: a, right: o } = N, l = E(N.matrixWorldInverse), c = r ? `scale(${i})translate(${A(-(o + s) / 2)}px,${A((n + a) / 2)}px)` : `translateZ(${i}px)`, d = Y.current.matrixWorld; h && ((d = N.matrixWorldInverse.clone().transpose().copyPosition(d).scale(Y.current.scale)).elements[3] = d.elements[7] = d.elements[11] = 0, d.elements[15] = 1), W.style.width = z.width + "px", W.style.height = z.height + "px", W.style.perspective = r ? "" : `${i}px`, q.current && Q.current && (q.current.style.transform = `${c}${l}translate(${e}px,${t}px)`, Q.current.style.transform = b(d, 1 / ((u || 10) / 400))) } else { let t = void 0 === u ? 1 : function (e, t) { if (t instanceof p.qUd) return t.zoom; if (!(t instanceof p.ubm)) return 1; { let i = g.setFromMatrixPosition(e.matrixWorld), r = v.setFromMatrixPosition(t.matrixWorld); return 1 / (2 * Math.tan(t.fov * Math.PI / 180 / 2) * i.distanceTo(r)) } }(Y.current, N) * u; W.style.transform = `translate3d(${e[0]}px,${e[1]}px,0) scale(${t})` } K.current = e, X.current = N.zoom } } if (!ee && $.current && !J.current) { if (c) { if (q.current) { let e = q.current.children[0]; if (null != e && e.clientWidth && null != e && e.clientHeight) { let { isOrthographicCamera: t } = N; if (t || C) k.scale && (Array.isArray(k.scale) ? k.scale instanceof p.Pq0 ? $.current.scale.copy(k.scale.clone().divideScalar(1)) : $.current.scale.set(1 / k.scale[0], 1 / k.scale[1], 1 / k.scale[2]) : $.current.scale.setScalar(1 / k.scale)); else { let t = (u || 10) / 400, i = e.clientWidth * t, r = e.clientHeight * t; $.current.scale.set(i, r, 1) } J.current = !0 } } } else { let t = W.children[0]; if (null != t && t.clientWidth && null != t && t.clientHeight) { let e = 1 / V.factor, i = t.clientWidth * e, r = t.clientHeight * e; $.current.scale.set(i, r, 1), J.current = !0 } $.current.lookAt(e.camera.position) } } }); let en = l.useMemo(() => ({
        vertexShader: c ? void 0 : `
          /*
            This shader is from the THREE's SpriteMaterial.
            We need to turn the backing plane into a Sprite
            (make it always face the camera) if "transfrom"
            is false.
          */
          #include <common>

          void main() {
            vec2 center = vec2(0., 1.);
            float rotation = 0.0;

            // This is somewhat arbitrary, but it seems to work well
            // Need to figure out how to derive this dynamically if it even matters
            float size = 0.03;

            vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
            vec2 scale;
            scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
            scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );

            bool isPerspective = isPerspectiveMatrix( projectionMatrix );
            if ( isPerspective ) scale *= - mvPosition.z;

            vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale * size;
            vec2 rotatedPosition;
            rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
            rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
            mvPosition.xy += rotatedPosition;

            gl_Position = projectionMatrix * mvPosition;
          }
      `, fragmentShader: `
        void main() {
          gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);
        }
      `}), [c]); return l.createElement("group", (0, d.A)({}, k, { ref: Y }), _ && !ee && l.createElement("mesh", { castShadow: w, receiveShadow: M, ref: $ }, C || l.createElement("planeGeometry", null), R || l.createElement("shaderMaterial", { side: p.$EB, vertexShader: en.vertexShader, fragmentShader: en.fragmentShader })))
    }); var w = i(4841), M = i.n(w), R = i(6715), C = i(6520), I = i(151), L = i(2753); let P = (0, u.v)(() => ({ progress: 0, isHovering: !1, current: "snow" })); function D() { let e = (0, l.useRef)(0), t = (0, l.useRef)(null), i = (0, l.useRef)(null), r = (0, R.useRouter)(), n = (0, I.t)(); (0, l.useEffect)(() => { let e = a.R2.FIRE; e.volume(0), e.loop(!0), e.play(), i.current = e }); let u = () => { requestAnimationFrame(() => { L.o.getState().preloaderAnimationDone && (i.current?.fade(i.current.volume(), .35, 2e3), P.setState({ isHovering: !0 }), t.current && t.current.stop(), t.current = (0, o.i)(e.current, 1, { duration: 6, delay: .2, ease: h.WD, onUpdate: t => { e.current = t, P.setState({ progress: t }) }, onComplete: () => { P.setState({ current: "fire" }) } })) }) }, d = () => { requestAnimationFrame(() => { c.o.getState().hasStarted || (i.current?.fade(i.current.volume(), 0, 2e3), P.setState({ isHovering: !1 }), t.current && t.current.stop(), t.current = (0, o.i)(e.current, 0, { duration: 1, ease: h.WD, onUpdate: t => { e.current = t, P.setState({ progress: t }) }, onComplete: () => { P.setState({ current: "snow" }) } })) }) }, f = n?.fullSiteSwitch ? { onClick: e => { e.target.setAttribute("disabled", "true"), c.o.setState(e => (e.hasStarted = !0, { ...e })), r.push(C.a.STORY).then(() => { c.o.getState().transition() }) }, "data-cursor-hover-state": "orange" } : {}; return (0, s.jsx)("group", { position: [0, -.6, 0], children: (0, s.jsx)(T, { center: !0, children: (0, s.jsx)("button", { className: M().circleGlyphTouchPoint, onPointerOver: u, onPointerLeave: d, onPointerDown: u, onPointerUp: d, ...f, children: (0, s.jsx)("span", { className: "visually-hidden", children: "Enter the story" }) }) }) }) }
  }, 637: (e, t, i) => { "use strict"; i.d(t, { A: () => h }); var r = i(4848), n = i(6540), s = i(9965), a = i.n(s), o = i(1323), l = i(3580); let u = (0, o.v)(e => ({ observer: l.B && new IntersectionObserver(e => { e.forEach(e => { e.isIntersecting ? (e.target.setAttribute("content-visibility", "visible"), e.target.setAttribute("visibility", "visible")) : (e.target.setAttribute("content-visibility", "hidden"), e.target.setAttribute("visibility", "hidden")) }) }) })), h = (0, n.forwardRef)(function (e, t) { let { className: i, src: s, alt: o, height: h, width: c, priority: d, style: f, blurUpThumb: p, focalPoint: m, onReady: g, ...v } = e, y = (0, n.useRef)(null), x = t || y; return (0, n.useEffect)(() => { if (!l.B) return; let e = x.current; if (!e) return; let { observer: t } = u.getState(); return t.observe(e), d && (e.setAttribute("content-visibility", "visible"), e.setAttribute("visibility", "visible")), () => { t && t.unobserve(e) } }, [d]), (0, r.jsx)(r.Fragment, { children: (0, r.jsx)(a(), { ref: x, priority: d, src: s, alt: o || "", width: c, height: h, className: i, decoding: "async", placeholder: p ? "blur" : void 0, blurDataURL: p, quality: 96, sizes: " ", style: { ...f, opacity: g ? 0 : void 0 }, ...v, onLoad: e => { g && g(e.target) } }) }) }) }, 8848: (e, t, i) => { "use strict"; i.d(t, { N: () => l }); var r = i(4848), n = i(1106), s = i.n(n), a = i(4770), o = i(6715); function l(e) { let { noTransition: t, children: i, onClick: n, ...l } = e, u = (0, o.useRouter)(); return (0, r.jsx)(s(), { onClick: i => { if (i.ctrlKey || i.metaKey) { i.preventDefault(), window.open(l.href, "_blank"); return } let r = u.pathname === e.href; t || r || e.href.startsWith("#") || (i.preventDefault(), a.w.setState({ triggerTransition: e.href })), n && n(i) }, target: e.href.includes("http") ? "_blank" : void 0, ...l, children: i }) } }, 7938: (e, t, i) => { "use strict"; i.d(t, { AA: () => c, Br: () => u, QP: () => d, Wo: () => l, e2: () => f, kC: () => p, vi: () => h }); var r = i(8343), n = i(637), s = i(8848), a = i(4684), o = i(300); let l = r.P.create(n.A), u = r.P.create(s.N), h = r.P.create(o.A), c = { hidden: { opacity: 0, scale: .8, y: 10, filter: "blur(4px)" }, visible: { opacity: 1, scale: 1, y: 0, filter: "blur(0px)", transition: { duration: 2.6, delay: .4, ease: a.lu, staggerChildren: .2, delayChildren: .15 } }, exit: { opacity: 0, scale: 1.2, y: -10, filter: "blur(4px)", transition: { duration: 2.6, ease: a.lu, staggerChildren: .2 } } }, d = { hidden: { opacity: 0, y: 20, filter: "blur(4px)" }, visible: { opacity: 1, y: 0, filter: "blur(0px)", transition: { duration: 2.6, delay: .4, ease: a.lu, staggerChildren: .2, delayChildren: .15 } }, exit: { opacity: 0, y: -20, filter: "blur(4px)", transition: { duration: 2.6, ease: a.lu, staggerChildren: .2 } } }, f = { hidden: e => ({ opacity: 0, scale: .9, y: 20, x: "left" === e ? 10 : -10, filter: "blur(4px)", transformOrigin: "left" === e ? "right" : "left" }), visible: e => ({ opacity: 1, scale: 1, y: 0, x: 0, transformOrigin: "left" === e ? "right" : "left", filter: "blur(0px)", transition: { duration: 2.6, delay: .4, ease: a.lu, staggerChildren: .2, delayChildren: .15 } }), exit: e => ({ opacity: 0, scale: 1.1, y: -20, x: "left" === e ? -10 : 10, transformOrigin: "left" === e ? "right" : "left", filter: "blur(4px)", transition: { duration: 2.6, ease: a.lu, staggerChildren: .2 } }) }, p = { initial: "hidden", animate: "visible", exit: "exit", variants: { hidden: { opacity: 0, pointerEvents: "none" }, visible: { opacity: 1, pointerEvents: "all", transition: { delay: .5, duration: .6, ease: a.lu } }, exit: { opacity: 0, pointerEvents: "none", transition: { duration: .6, delay: .5, ease: a.lu } } }, transition: { duration: .6, ease: a.lu } } }, 1194: (e, t, i) => { "use strict"; i.d(t, { V: () => m }); var r = i(4848), n = i(1538), s = i(3502), a = i(4922), o = i(9931), l = i(8823); let u = new a.Q1f("#ffead6"), h = new a.Q1f("#d6904b"); class c { constructor(e) { let t = new a.Gu$(2, 64, 64); this.geometry = { instance: t, count: 1200 }, this.uniforms = { uParticlesTexture: new a.nc$(null), uColor: new a.nc$(u.lerpHSL(h, Math.random())), uTime: new a.nc$(0), uProgress: new a.nc$(0) }; let i = new a.BKk({ vertexShader: "precision mediump float;\n#define GLSLIFY 1\n\nattribute vec3 aColor;\nattribute vec2 aParticlesUv;\nattribute float aSize;\nattribute float aSpeed;\nattribute float aDelay;\n\nuniform sampler2D uParticlesTexture;\n\nvarying vec4 vParticle;\nvarying vec2 vUv;\nvarying vec3 vColor;\nvarying float vDelay;\n\nvoid main() {\n    vec4 particle = texture(uParticlesTexture, aParticlesUv);\n    particle.xyz *= aSpeed;\n\n    vec4 mp = modelMatrix * vec4(particle.xyz, 1.0);\n    vec4 vp = viewMatrix * mp;\n\n    gl_Position = projectionMatrix * vp;\n    gl_PointSize = aSize;\n    gl_PointSize *= (1.0 / -vp.z);\n    vParticle = particle;\n    vUv = aParticlesUv;\n    vColor = aColor;\n    vDelay = aDelay;\n}\n", fragmentShader: "precision mediump float;\n#define GLSLIFY 1\n\nuniform float uProgress;\nuniform float uTime;\nvarying vec3 vColor;\n\nvarying vec4 vParticle;\nvarying vec2 vUv;\nvarying float vDelay;\n\nmat2 rotate2d(float _angle) {\n    return mat2(cos(_angle), -sin(_angle), sin(_angle), cos(_angle));\n}\n\nvec2 fade(vec2 t) {\n    return t * t * t * (t * (t * 6.0 - 15.0) + 10.0);\n}\nvec4 permute(vec4 x) {\n    return mod(((x * 34.0) + 1.0) * x, 289.0);\n}\n\nfloat cnoise(vec2 P) {\n    vec4 Pi = floor(P.xyxy) + vec4(0.0, 0.0, 1.0, 1.0);\n    vec4 Pf = fract(P.xyxy) - vec4(0.0, 0.0, 1.0, 1.0);\n    Pi = mod(Pi, 289.0); // To avoid truncation effects in permutation\n    vec4 ix = Pi.xzxz;\n    vec4 iy = Pi.yyww;\n    vec4 fx = Pf.xzxz;\n    vec4 fy = Pf.yyww;\n    vec4 i = permute(permute(ix) + iy);\n    vec4 gx = 2.0 * fract(i * 0.0243902439) - 1.0; // 1/41 = 0.024...\n    vec4 gy = abs(gx) - 0.5;\n    vec4 tx = floor(gx + 0.5);\n    gx = gx - tx;\n    vec2 g00 = vec2(gx.x, gy.x);\n    vec2 g10 = vec2(gx.y, gy.y);\n    vec2 g01 = vec2(gx.z, gy.z);\n    vec2 g11 = vec2(gx.w, gy.w);\n    vec4 norm = 1.79284291400159 - 0.85373472095314 *\n        vec4(dot(g00, g00), dot(g01, g01), dot(g10, g10), dot(g11, g11));\n    g00 *= norm.x;\n    g01 *= norm.y;\n    g10 *= norm.z;\n    g11 *= norm.w;\n    float n00 = dot(g00, vec2(fx.x, fy.x));\n    float n10 = dot(g10, vec2(fx.y, fy.y));\n    float n01 = dot(g01, vec2(fx.z, fy.z));\n    float n11 = dot(g11, vec2(fx.w, fy.w));\n    vec2 fade_xy = fade(Pf.xy);\n    vec2 n_x = mix(vec2(n00, n01), vec2(n10, n11), fade_xy.x);\n    float n_xy = mix(n_x.x, n_x.y, fade_xy.y);\n    return 2.3 * n_xy;\n}\n\nvoid main() {\n    vec2 uv = gl_PointCoord;\n\n    // Noise\n    vec2 nv = uv + uTime * 0.75;\n    float n = cnoise(nv * 6.) * 0.5 + 0.5;\n\n    uv += n * 0.05;\n\n    float distanceToCenter = length(uv - 0.5);\n    float smoothDistanceToCenter = smoothstep(0.0, .4, distanceToCenter);\n    smoothDistanceToCenter = (0.15 + n * 0.03) / smoothDistanceToCenter;\n\n    float whiteCircle = step(length(uv - 0.5), 0.04 + (n * 0.06));\n\n    float mask = 1.0 - smoothstep(0.0, 0.5, distanceToCenter);\n\n    float alphaIn = smoothstep(0.0, 0.05, uProgress);\n    // float brightness = clamp(smoothDistanceToCenter * 0.5, 0.0, 1.0);\n\n    vec4 whiteCircleColor = vec4(vec3(whiteCircle), 0.0);\n    vec4 glowColor = vec4(vColor, smoothDistanceToCenter);\n\n    gl_FragColor = (whiteCircleColor + glowColor);\n    gl_FragColor.a *= mask;\n    gl_FragColor.a *= alphaIn;\n\n    // gl_FragColor = vec4(vec3(n), 1.0);\n\n    // if (glowColor.r <= 0.001) {\n    //     discard;\n    // }\n}\n", uniforms: this.uniforms, transparent: !0, blending: a.EZo, depthWrite: !1 }), r = Math.ceil(Math.sqrt(this.geometry.count)), c = new o.d(r, r, e), d = c.createTexture(), f = c.createTexture(); for (let e = 0; e < this.geometry.count; e++) { let t = 3 * e, i = 4 * e; this.geometry.instance.attributes.position.array[t + 0], this.geometry.instance.attributes.position.array[t + 1], this.geometry.instance.attributes.position.array[t + 2]; let r = (0, l.fs)(.08), n = (0, l.fs)(2.5); d.image.data[i + 0] = r, d.image.data[i + 1] = n, d.image.data[i + 2] = 0, d.image.data[i + 3] = 0; let s = 0 - .035 * Math.floor(e / 1.5); f.image.data[i + 0] = s, f.image.data[i + 1] = 0, f.image.data[i + 2] = (0, l.YR)(1, 5), f.image.data[i + 3] = Math.random() } let p = new Float32Array(2 * this.geometry.count), m = new Float32Array(this.geometry.count), g = new Float32Array(this.geometry.count), v = new Float32Array(3 * this.geometry.count), y = new Float32Array(this.geometry.count); for (let e = 0; e < r; e++)for (let t = 0; t < r; t++) { let i = 2 * (e * r + t), n = (t + .5) / r, s = (e + .5) / r; p[i + 0] = n, p[i + 1] = s } for (let e = 0; e < this.geometry.count; e++) { let t = 3 * e, i = 200 + 200 * Math.pow(Math.random(), .7); m[e] = i * Math.min(2, window.devicePixelRatio), g[e] = (0, l.YR)(.75, 2); let r = new a.Q1f().lerpColors(u, h, Math.random()); v[t + 0] = r.r, v[t + 1] = r.g, v[t + 2] = r.b, y[e] = (0, l.YR)(0, .1) } let x = new a.LoY; x.setDrawRange(0, this.geometry.count), x.setAttribute("aParticlesUv", new a.THS(p, 2)), x.setAttribute("aColor", new a.qtW(v, 3)), x.setAttribute("aSize", new a.qtW(m, 1)), x.setAttribute("aSpeed", new a.qtW(g, 1)), x.setAttribute("aDelay", new a.qtW(y, 1)), this.points = new a.ONl(x, i), this.points.position.z = -1, this.points.position.y = -.5, this.points.frustumCulled = !1; let S = c.addVariable("uParticles", "precision mediump float;\n#define GLSLIFY 1\n\nvec4 permute(vec4 x) {\n    return mod(((x * 34.0) + 1.0) * x, 289.0);\n}\nvec4 taylorInvSqrt(vec4 r) {\n    return 1.79284291400159 - 0.85373472095314 * r;\n}\nvec3 fade(vec3 t) {\n    return t * t * t * (t * (t * 6.0 - 15.0) + 10.0);\n}\n\nfloat cnoise(vec3 P) {\n    vec3 Pi0 = floor(P); // Integer part for indexing\n    vec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1\n    Pi0 = mod(Pi0, 289.0);\n    Pi1 = mod(Pi1, 289.0);\n    vec3 Pf0 = fract(P); // Fractional part for interpolation\n    vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\n    vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n    vec4 iy = vec4(Pi0.yy, Pi1.yy);\n    vec4 iz0 = Pi0.zzzz;\n    vec4 iz1 = Pi1.zzzz;\n\n    vec4 ixy = permute(permute(ix) + iy);\n    vec4 ixy0 = permute(ixy + iz0);\n    vec4 ixy1 = permute(ixy + iz1);\n\n    vec4 gx0 = ixy0 / 7.0;\n    vec4 gy0 = fract(floor(gx0) / 7.0) - 0.5;\n    gx0 = fract(gx0);\n    vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n    vec4 sz0 = step(gz0, vec4(0.0));\n    gx0 -= sz0 * (step(0.0, gx0) - 0.5);\n    gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n\n    vec4 gx1 = ixy1 / 7.0;\n    vec4 gy1 = fract(floor(gx1) / 7.0) - 0.5;\n    gx1 = fract(gx1);\n    vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n    vec4 sz1 = step(gz1, vec4(0.0));\n    gx1 -= sz1 * (step(0.0, gx1) - 0.5);\n    gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n\n    vec3 g000 = vec3(gx0.x, gy0.x, gz0.x);\n    vec3 g100 = vec3(gx0.y, gy0.y, gz0.y);\n    vec3 g010 = vec3(gx0.z, gy0.z, gz0.z);\n    vec3 g110 = vec3(gx0.w, gy0.w, gz0.w);\n    vec3 g001 = vec3(gx1.x, gy1.x, gz1.x);\n    vec3 g101 = vec3(gx1.y, gy1.y, gz1.y);\n    vec3 g011 = vec3(gx1.z, gy1.z, gz1.z);\n    vec3 g111 = vec3(gx1.w, gy1.w, gz1.w);\n\n    vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n    g000 *= norm0.x;\n    g010 *= norm0.y;\n    g100 *= norm0.z;\n    g110 *= norm0.w;\n    vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n    g001 *= norm1.x;\n    g011 *= norm1.y;\n    g101 *= norm1.z;\n    g111 *= norm1.w;\n\n    float n000 = dot(g000, Pf0);\n    float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n    float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n    float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n    float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n    float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n    float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n    float n111 = dot(g111, Pf1);\n\n    vec3 fade_xyz = fade(Pf0);\n    vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\n    vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n    float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x);\n    return 2.2 * n_xyz;\n}\n\nfloat hash(float x) {\n    return fract(sin(x) * 43758.5453);\n}\n\nuniform float uTime;\nuniform float uDeltaTime;\nuniform float uProgress;\nuniform sampler2D uBasePosition;\n\nuniform bool uAnimate;\n\nvoid main() {\n    // Sample UVs\n    vec2 uv = gl_FragCoord.xy / resolution.xy;\n    vec4 particle = texture2D(uParticles, uv);\n    vec4 basePosition = texture2D(uBasePosition, uv);\n    vec4 velocity = texture2D(uVelocity, uv);\n\n    // Get angle direction\n    float xDir = 1.0 - (step(0.5, velocity.a) * 2.0);\n\n    float amp = 2.4;\n    float freq = 2.2;\n\n    // gl_FragColor = particle;\n\n    // // Animation\n    if(uAnimate) {\n        float x = amp * sin(xDir * (particle.a) * freq);\n        float y = uDeltaTime;\n\n        float nx = x * uProgress;\n        particle.x = basePosition.x + nx;\n\n        particle.y += velocity.y * 0.3 * uProgress;\n\n        // Delay the Z so they look like they come from behind the sword a lot better.\n        float zProgress = smoothstep(0.25, 1.0, uProgress);\n\n        float vx = max(velocity.x, 0.0);\n\n        particle.z += uDeltaTime * vx * 1.4 * zProgress;\n        particle.a += uDeltaTime * vx * uProgress;\n    }\n\n    gl_FragColor = particle;\n}\n", d), A = c.addVariable("uVelocity", "precision mediump float;\n#define GLSLIFY 1\n\n//	Classic Perlin 3D Noise\n//	by Stefan Gustavson (https://github.com/stegu/webgl-noise)\n//\nvec4 permute(vec4 x) {\n  return mod(((x * 34.0) + 1.0) * x, 289.0);\n}\nvec4 taylorInvSqrt(vec4 r) {\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\nvec4 fade(vec4 t) {\n  return t * t * t * (t * (t * 6.0 - 15.0) + 10.0);\n}\n\nfloat cnoise(vec4 P) {\n  vec4 Pi0 = floor(P); // Integer part for indexing\n  vec4 Pi1 = Pi0 + 1.0; // Integer part + 1\n  Pi0 = mod(Pi0, 289.0);\n  Pi1 = mod(Pi1, 289.0);\n  vec4 Pf0 = fract(P); // Fractional part for interpolation\n  vec4 Pf1 = Pf0 - 1.0; // Fractional part - 1.0\n  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n  vec4 iy = vec4(Pi0.yy, Pi1.yy);\n  vec4 iz0 = vec4(Pi0.zzzz);\n  vec4 iz1 = vec4(Pi1.zzzz);\n  vec4 iw0 = vec4(Pi0.wwww);\n  vec4 iw1 = vec4(Pi1.wwww);\n\n  vec4 ixy = permute(permute(ix) + iy);\n  vec4 ixy0 = permute(ixy + iz0);\n  vec4 ixy1 = permute(ixy + iz1);\n  vec4 ixy00 = permute(ixy0 + iw0);\n  vec4 ixy01 = permute(ixy0 + iw1);\n  vec4 ixy10 = permute(ixy1 + iw0);\n  vec4 ixy11 = permute(ixy1 + iw1);\n\n  vec4 gx00 = ixy00 / 7.0;\n  vec4 gy00 = floor(gx00) / 7.0;\n  vec4 gz00 = floor(gy00) / 6.0;\n  gx00 = fract(gx00) - 0.5;\n  gy00 = fract(gy00) - 0.5;\n  gz00 = fract(gz00) - 0.5;\n  vec4 gw00 = vec4(0.75) - abs(gx00) - abs(gy00) - abs(gz00);\n  vec4 sw00 = step(gw00, vec4(0.0));\n  gx00 -= sw00 * (step(0.0, gx00) - 0.5);\n  gy00 -= sw00 * (step(0.0, gy00) - 0.5);\n\n  vec4 gx01 = ixy01 / 7.0;\n  vec4 gy01 = floor(gx01) / 7.0;\n  vec4 gz01 = floor(gy01) / 6.0;\n  gx01 = fract(gx01) - 0.5;\n  gy01 = fract(gy01) - 0.5;\n  gz01 = fract(gz01) - 0.5;\n  vec4 gw01 = vec4(0.75) - abs(gx01) - abs(gy01) - abs(gz01);\n  vec4 sw01 = step(gw01, vec4(0.0));\n  gx01 -= sw01 * (step(0.0, gx01) - 0.5);\n  gy01 -= sw01 * (step(0.0, gy01) - 0.5);\n\n  vec4 gx10 = ixy10 / 7.0;\n  vec4 gy10 = floor(gx10) / 7.0;\n  vec4 gz10 = floor(gy10) / 6.0;\n  gx10 = fract(gx10) - 0.5;\n  gy10 = fract(gy10) - 0.5;\n  gz10 = fract(gz10) - 0.5;\n  vec4 gw10 = vec4(0.75) - abs(gx10) - abs(gy10) - abs(gz10);\n  vec4 sw10 = step(gw10, vec4(0.0));\n  gx10 -= sw10 * (step(0.0, gx10) - 0.5);\n  gy10 -= sw10 * (step(0.0, gy10) - 0.5);\n\n  vec4 gx11 = ixy11 / 7.0;\n  vec4 gy11 = floor(gx11) / 7.0;\n  vec4 gz11 = floor(gy11) / 6.0;\n  gx11 = fract(gx11) - 0.5;\n  gy11 = fract(gy11) - 0.5;\n  gz11 = fract(gz11) - 0.5;\n  vec4 gw11 = vec4(0.75) - abs(gx11) - abs(gy11) - abs(gz11);\n  vec4 sw11 = step(gw11, vec4(0.0));\n  gx11 -= sw11 * (step(0.0, gx11) - 0.5);\n  gy11 -= sw11 * (step(0.0, gy11) - 0.5);\n\n  vec4 g0000 = vec4(gx00.x, gy00.x, gz00.x, gw00.x);\n  vec4 g1000 = vec4(gx00.y, gy00.y, gz00.y, gw00.y);\n  vec4 g0100 = vec4(gx00.z, gy00.z, gz00.z, gw00.z);\n  vec4 g1100 = vec4(gx00.w, gy00.w, gz00.w, gw00.w);\n  vec4 g0010 = vec4(gx10.x, gy10.x, gz10.x, gw10.x);\n  vec4 g1010 = vec4(gx10.y, gy10.y, gz10.y, gw10.y);\n  vec4 g0110 = vec4(gx10.z, gy10.z, gz10.z, gw10.z);\n  vec4 g1110 = vec4(gx10.w, gy10.w, gz10.w, gw10.w);\n  vec4 g0001 = vec4(gx01.x, gy01.x, gz01.x, gw01.x);\n  vec4 g1001 = vec4(gx01.y, gy01.y, gz01.y, gw01.y);\n  vec4 g0101 = vec4(gx01.z, gy01.z, gz01.z, gw01.z);\n  vec4 g1101 = vec4(gx01.w, gy01.w, gz01.w, gw01.w);\n  vec4 g0011 = vec4(gx11.x, gy11.x, gz11.x, gw11.x);\n  vec4 g1011 = vec4(gx11.y, gy11.y, gz11.y, gw11.y);\n  vec4 g0111 = vec4(gx11.z, gy11.z, gz11.z, gw11.z);\n  vec4 g1111 = vec4(gx11.w, gy11.w, gz11.w, gw11.w);\n\n  vec4 norm00 = taylorInvSqrt(vec4(dot(g0000, g0000), dot(g0100, g0100), dot(g1000, g1000), dot(g1100, g1100)));\n  g0000 *= norm00.x;\n  g0100 *= norm00.y;\n  g1000 *= norm00.z;\n  g1100 *= norm00.w;\n\n  vec4 norm01 = taylorInvSqrt(vec4(dot(g0001, g0001), dot(g0101, g0101), dot(g1001, g1001), dot(g1101, g1101)));\n  g0001 *= norm01.x;\n  g0101 *= norm01.y;\n  g1001 *= norm01.z;\n  g1101 *= norm01.w;\n\n  vec4 norm10 = taylorInvSqrt(vec4(dot(g0010, g0010), dot(g0110, g0110), dot(g1010, g1010), dot(g1110, g1110)));\n  g0010 *= norm10.x;\n  g0110 *= norm10.y;\n  g1010 *= norm10.z;\n  g1110 *= norm10.w;\n\n  vec4 norm11 = taylorInvSqrt(vec4(dot(g0011, g0011), dot(g0111, g0111), dot(g1011, g1011), dot(g1111, g1111)));\n  g0011 *= norm11.x;\n  g0111 *= norm11.y;\n  g1011 *= norm11.z;\n  g1111 *= norm11.w;\n\n  float n0000 = dot(g0000, Pf0);\n  float n1000 = dot(g1000, vec4(Pf1.x, Pf0.yzw));\n  float n0100 = dot(g0100, vec4(Pf0.x, Pf1.y, Pf0.zw));\n  float n1100 = dot(g1100, vec4(Pf1.xy, Pf0.zw));\n  float n0010 = dot(g0010, vec4(Pf0.xy, Pf1.z, Pf0.w));\n  float n1010 = dot(g1010, vec4(Pf1.x, Pf0.y, Pf1.z, Pf0.w));\n  float n0110 = dot(g0110, vec4(Pf0.x, Pf1.yz, Pf0.w));\n  float n1110 = dot(g1110, vec4(Pf1.xyz, Pf0.w));\n  float n0001 = dot(g0001, vec4(Pf0.xyz, Pf1.w));\n  float n1001 = dot(g1001, vec4(Pf1.x, Pf0.yz, Pf1.w));\n  float n0101 = dot(g0101, vec4(Pf0.x, Pf1.y, Pf0.z, Pf1.w));\n  float n1101 = dot(g1101, vec4(Pf1.xy, Pf0.z, Pf1.w));\n  float n0011 = dot(g0011, vec4(Pf0.xy, Pf1.zw));\n  float n1011 = dot(g1011, vec4(Pf1.x, Pf0.y, Pf1.zw));\n  float n0111 = dot(g0111, vec4(Pf0.x, Pf1.yzw));\n  float n1111 = dot(g1111, Pf1);\n\n  vec4 fade_xyzw = fade(Pf0);\n  vec4 n_0w = mix(vec4(n0000, n1000, n0100, n1100), vec4(n0001, n1001, n0101, n1101), fade_xyzw.w);\n  vec4 n_1w = mix(vec4(n0010, n1010, n0110, n1110), vec4(n0011, n1011, n0111, n1111), fade_xyzw.w);\n  vec4 n_zw = mix(n_0w, n_1w, fade_xyzw.z);\n  vec2 n_yzw = mix(n_zw.xy, n_zw.zw, fade_xyzw.y);\n  float n_xyzw = mix(n_yzw.x, n_yzw.y, fade_xyzw.x);\n  return 2.2 * n_xyzw;\n}\n\nuniform float uTime;\nuniform float uProgress;\nuniform bool uAnimate;\n\n// DON'T UPDATE VELOCITY A/W\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / resolution.xy;\n  vec4 particle = texture2D(uParticles, uv);\n  vec4 velocity = texture2D(uVelocity, uv);\n\n  vec3 noise = vec3(cnoise(vec4(particle.xyz + 0.0, uTime)), cnoise(vec4(particle.xyz + 1.0, uTime)), cnoise(vec4(particle.xyz + 2.0, uTime)));\n\n  if(uAnimate) {\n    velocity.y = noise.y * uProgress;\n    // velocity.x += noise.x * 0.1 * uProgress;\n    velocity.x += 0.02 * velocity.z;\n\n  }\n\n  gl_FragColor = velocity;\n}", f); this.variable = S, this.velocityVariable = A, c.setVariableDependencies(S, [A, S]), c.setVariableDependencies(A, [A, S]), this.variable.material.uniforms.uTime = new a.nc$(0), this.variable.material.uniforms.uDeltaTime = new a.nc$(0), this.variable.material.uniforms.uProgress = new a.nc$(0), this.variable.material.uniforms.uAnimate = new a.nc$(!1), this.variable.material.uniforms.uBasePosition = new a.nc$(d), this.velocityVariable.material.uniforms.uTime = new a.nc$(0), this.velocityVariable.material.uniforms.uAnimate = new a.nc$(!1), this.velocityVariable.material.uniforms.uProgress = new a.nc$(0), c.init(), this.gpuRenderer = c, this.unsub = n.o.subscribe(({ inTransition: e, isStory: t }) => { e && !t && (this.variable.material.uniforms.uAnimate.value = e, this.velocityVariable.material.uniforms.uAnimate.value = e, this.animation = (0, s.i)(0, 1, { onUpdate: e => { this.variable.material.uniforms.uProgress.value = e, this.velocityVariable.material.uniforms.uProgress.value = e, this.uniforms.uProgress.value = e }, ease: "easeIn", duration: 2 })) }) } update(e, t) { this.variable.material.uniforms.uDeltaTime.value = t, this.variable.material.uniforms.uTime.value = e, this.velocityVariable.material.uniforms.uTime.value = e, this.gpuRenderer.compute(), this.uniforms.uParticlesTexture.value = this.gpuRenderer.getCurrentRenderTarget(this.variable).texture, this.uniforms.uTime.value = e } dispose() { this.points.geometry.dispose(), this.points.material.dispose(), this.gpuRenderer.dispose(), this.unsub && this.unsub(), this.animation && this.animation.cancel() } } var d = i(9978), f = i(2111), p = i(6540); function m(e) { let { store: t } = (0, d.F)(), i = (0, p.useRef)(new c(t?.getState().gl)), n = (0, p.useRef)(null); return (0, f.C)(({ clock: e }, t) => { i.current && (i.current.update(e.getElapsedTime(), t), n.current && i.current.uniforms.uParticlesTexture.value && (n.current.map = i.current.uniforms.uParticlesTexture.value, n.current.needsUpdate = !0)) }), (0, p.useEffect)(() => () => { let e = i.current; e && e.dispose() }, []), (0, r.jsx)(r.Fragment, { children: (0, r.jsx)("group", { rotation: [-.1, 0, -.25], children: (0, r.jsx)("primitive", { renderOrder: -1, object: i.current.points }) }) }) } }, 2753: (e, t, i) => { "use strict"; i.d(t, { o: () => s }); var r = i(1323), n = i(7134); let s = (0, r.v)((0, n.eh)(() => ({ canLoadSwordScene: !1, percentage: 0, glyphsPreloaderDone: !1, preloaderAnimationDone: !1, introAnimationFunc: [() => { }] }))) }, 4978: (e, t, i) => { "use strict"; i.d(t, { OB: () => v, jS: () => p, jq: () => g, wj: () => m }); var r = i(4848), n = i(6540), s = i(2833), a = i.n(s), o = i(4164), l = i(4066), u = i(104), h = i(1323), c = i(5769), d = i(3668), f = i(7039); let p = (0, h.v)(() => 0), m = (0, h.v)(() => !0), g = (0, h.v)(() => !1); function v({ children: e }) { let t = (0, n.useRef)(null), i = n.Children.count(e); return (0, n.useEffect)(() => { let e = () => { g.setState(!1) }, t = () => { g.setState(!0) }, r = matchMedia(d.$.laptop.max).matches, n = () => { r = matchMedia(d.$.laptop.max).matches }; window.addEventListener("resize", n), window.addEventListener("touchend", e), window.addEventListener("touchstart", t), document.body.style.setProperty("overflow-y", "hidden"); let s = 0, a = new l.A({ overscroll: !1, virtualScroll: e => { if (f.s.getState().Lenis?.isStopped || c.H.getState() || !m.getState()) return !1; let t = g.getState(), n = r ? 50 : 400; return s > n && !t && (p.setState(e => Math.min(e + 1, i - 1)), s = 0), s < -n && !t && (p.setState(e => Math.max(e - 1, 0)), s = 0), r ? t ? s += e.deltaY : s = 0 : s += e.deltaY, !1 } }), o = e => { a.raf(e.timestamp) }; return u.Gt.update(o, !0), () => { document.body.style.removeProperty("overflow-y"), (0, u.WG)(o), window.removeEventListener("touchend", e), window.removeEventListener("touchstart", t), window.removeEventListener("resize", n), a.destroy() } }, [i]), (0, r.jsx)("article", { className: (0, o.A)(a().StickyScrollContainer), ref: t, children: e }) } }, 8890: (e, t, i) => { "use strict"; i.d(t, { a: () => r, t: () => n }); let r = (0, i(6540).createContext)(null); function n() { return function (e) { let t = new Map, i = e; return Object.freeze({ get current() { return i }, setState(e) { i = e, t.forEach(t => { t(e) }) }, subscribe: e => (t.set(e, e), () => { t.delete(e) }) }) }({ sync: !1 }) } }, 5769: (e, t, i) => { "use strict"; i.d(t, { q: () => S, H: () => x }); var r = i(4848), n = i(6385), s = i.n(n), a = i(4164), o = i(6297), l = i(8343), u = i(6540), h = i(4978), c = i(1323), d = i(7938), f = i(1290), p = i(8890), m = i(4066), g = i(8823); let v = (0, u.memo)(function ({ index: e, children: t }) { let i = (0, u.useRef)(null); return (0, u.useEffect)(() => { let t; if (!i.current) return; let r = 0, n = 0, s = !1, a = i.current.parentElement, o = a.parentElement, l = () => { (t = new m.A({ wrapper: o, content: a, syncTouch: !0 })).on("virtual-scroll", e => { if (!i.current) return; if (!s) return !1; let t = e.deltaY > 0 ? "down" : "up"; r -= e.deltaY, r = (0, g.qE)(r, -n, 0), i.current.style.setProperty("transform", `translateY(${r}px)`), "up" === t && r >= -20 || r <= -n + 20 || x.setState(!0) }) }, u = () => { if (!i.current) return; let e = a.getBoundingClientRect(), o = i.current.getBoundingClientRect(), u = window.getComputedStyle(a), h = parseInt(u.getPropertyValue("padding-top")), c = parseInt(u.getPropertyValue("padding-bottom")); o.height > e.height ? (n = o.height - (e.height - (h + c)), s = !0, t || l()) : (s = !1, i.current.style.removeProperty("transform"), r = 0) }, c = new ResizeObserver(u); u(), c.observe(i.current); let d = h.jS.subscribe(t => { i.current && t === e && (i.current.style.removeProperty("transform"), r = 0, u()) }); return () => { d(), c.disconnect(), t && t.destroy() } }, [e]), (0, r.jsx)("div", { ref: i, className: (0, a.A)(s().ContentContainer, "grid"), children: t }) }); var y = i(3668); let x = (0, c.v)(() => !1); function S(e) { let { backgroundImage: t, showRowsOnMobile: i, children: n, index: c } = e, m = (0, u.useRef)(null), g = (0, u.useRef)(null), S = (0, u.useRef)((0, p.t)()), [A, _] = (0, u.useState)(0 === c ? "visible" : "hidden"); return (0, u.useEffect)(() => { let e = matchMedia(y.$.laptop.max), t = h.jS.subscribe((t, i) => { t === c ? (e.matches || f.h.setState({ closed: !0 }), _("visible"), S.current.setState({ sync: !0 })) : i === c ? (f.h.setState({ closed: !1 }), S.current.setState({ sync: !1 }), _("exit")) : (f.h.setState({ closed: !1 }), S.current.setState({ sync: !1 }), _("hidden")) }); return e.addEventListener("change", function (e) { h.jS.getState() === c && f.h.setState({ closed: !e.matches }) }), () => { t() } }, [c]), "visible" === A && 0 !== c && (h.wj.setState(!1), g.current && (g.current.scrollTop = 0)), (0, u.useEffect)(() => { if (!m.current) return; let e = h.jq.subscribe(e => { e || requestAnimationFrame(() => { x.setState(!1) }) }); return () => { e() } }, [c]), (0, r.jsx)(p.a.Provider, { value: S.current, children: (0, r.jsx)("div", { className: (0, a.A)(s().wrapper), ref: m, children: (0, r.jsx)(o.N, { onExitComplete: () => { h.wj.setState(!0) }, children: (0, r.jsx)(l.P.div, { ...d.kC, initial: "hidden", animate: A, className: (0, a.A)(s()["content-wrapper"], "grid"), children: (0, r.jsx)("div", { className: (0, a.A)(s().content, i && s()["mobile-rows"], "grid"), ref: g, children: (0, r.jsx)(v, { index: c, children: n }) }) }) }) }) }) } }, 411: (e, t, i) => {
    "use strict"; i.r(t), i.d(t, { default: () => ie }); var r = i(4848), n = i(4704), s = i.n(n); function a(e) { return (0, r.jsx)(r.Fragment, { children: (0, r.jsx)("main", { className: s().main, children: e.children }) }) } var o = i(3871), l = i(2111), u = i(4922); class h extends u._4j {
      constructor(e, t) {
        super(), this.originalDispose = u._4j.prototype.dispose, this.mesh = e, this.offset = t ?? new u.I9Y(.5, .5), this.uniforms = { uPlaneSizes: new u.nc$(new u.I9Y(1, 1)), uImagePosition: new u.nc$(this.offset) }, this.uniforms.uImagePosition.value = this.offset, this.onBeforeCompile = e => {
          e.uniforms = { ...e.uniforms, ...this.uniforms }, e.vertexShader = `
        uniform vec2 uPlaneSizes;
        uniform vec2 uImagePosition;
        varying vec2 vUv;
        ${e.vertexShader}
      `.replace("#include <begin_vertex>", `
          #include <begin_vertex>
          // Calculate scaled and offset UVs
          vec2 scaledUV = uImagePosition + (uv - uImagePosition) / uPlaneSizes;
          vUv = scaledUV;
        `).replace("#include <fog_vertex>", `
          #include <fog_vertex>

          vMapUv = scaledUV;

          #ifdef USE_ALPHAMAP
            vAlphaMapUv = scaledUV;
          #endif

          #ifdef USE_NORMALMAP
            vNormalMapUv = scaledUV;
          #endif
        `)
        }, window.addEventListener("resize", this.onResize.bind(this))
      } fit() { let e, t; if (!this.mesh.current) { requestAnimationFrame(() => { this.fit() }); return } if (!this.mesh || !this.map) return; let i = this.map.image.width / this.map.image.height, r = this.mesh.current.scale.x / this.mesh.current.scale.y; i > r ? (e = i / r, t = 1) : i < r ? (e = 1, t = r / i) : (e = 1, t = 1), this.uniforms.uPlaneSizes.value.set(e, t) } setMesh() { this.fit() } dispose() { this.originalDispose.call(this), window.removeEventListener("resize", this.onResize.bind(this)) } onResize() { this.fit() }
    } (0, l.e)({ CoverMaterial: h }); class c extends u.V9B {
      constructor(e) {
        super(), this.mesh = null, this.originalDispose = u._4j.prototype.dispose, this.offset = e ?? new u.I9Y(.5, .5), this.uniforms = { uPlaneSizes: new u.nc$(new u.I9Y(1, 1)), uImagePosition: new u.nc$(this.offset) }, this.uniforms.uImagePosition.value = this.offset, this.onBeforeCompile = e => {
          e.uniforms = { ...e.uniforms, ...this.uniforms }, e.vertexShader = `
        uniform vec2 uPlaneSizes;
        uniform vec2 uImagePosition;
        varying vec2 vUv;
        ${e.vertexShader}
      `.replace("#include <begin_vertex>", `
          #include <begin_vertex>
          // Calculate scaled and offset UVs
          vec2 scaledUV = uImagePosition + (uv - uImagePosition) / uPlaneSizes;
          vUv = scaledUV;
        `).replace("#include <fog_vertex>", `
          #include <fog_vertex>

          vMapUv = scaledUV;

          #ifdef USE_ALPHAMAP
            vAlphaMapUv = scaledUV;
          #endif
        `)
        }, window.addEventListener("resize", this.onResize.bind(this))
      } fit() { let e, t; if (!this.mesh || !this.map) return; let i = this.map.image.width / this.map.image.height, r = this.mesh.scale.x / this.mesh.scale.y; i > r ? (e = i / r, t = 1) : i < r ? (e = 1, t = r / i) : (e = 1, t = 1), this.uniforms.uPlaneSizes.value.set(e, t) } setMesh(e) { this.mesh = e, this.fit() } dispose() { this.originalDispose.call(this), window.removeEventListener("resize", this.onResize.bind(this)) } onResize() { this.fit() }
    } (0, l.e)({ CoverMaterialBasic: c }); let d = `
//	Classic Perlin 3D Noise
//	by Stefan Gustavson (https://github.com/stegu/webgl-noise)
//
vec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}
vec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}
vec3 fade(vec3 t) {return t*t*t*(t*(t*6.0-15.0)+10.0);}

float cnoise(vec3 P){
  vec3 Pi0 = floor(P); // Integer part for indexing
  vec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1
  Pi0 = mod(Pi0, 289.0);
  Pi1 = mod(Pi1, 289.0);
  vec3 Pf0 = fract(P); // Fractional part for interpolation
  vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0
  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);
  vec4 iy = vec4(Pi0.yy, Pi1.yy);
  vec4 iz0 = Pi0.zzzz;
  vec4 iz1 = Pi1.zzzz;

  vec4 ixy = permute(permute(ix) + iy);
  vec4 ixy0 = permute(ixy + iz0);
  vec4 ixy1 = permute(ixy + iz1);

  vec4 gx0 = ixy0 / 7.0;
  vec4 gy0 = fract(floor(gx0) / 7.0) - 0.5;
  gx0 = fract(gx0);
  vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);
  vec4 sz0 = step(gz0, vec4(0.0));
  gx0 -= sz0 * (step(0.0, gx0) - 0.5);
  gy0 -= sz0 * (step(0.0, gy0) - 0.5);

  vec4 gx1 = ixy1 / 7.0;
  vec4 gy1 = fract(floor(gx1) / 7.0) - 0.5;
  gx1 = fract(gx1);
  vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);
  vec4 sz1 = step(gz1, vec4(0.0));
  gx1 -= sz1 * (step(0.0, gx1) - 0.5);
  gy1 -= sz1 * (step(0.0, gy1) - 0.5);

  vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);
  vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);
  vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);
  vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);
  vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);
  vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);
  vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);
  vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);

  vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));
  g000 *= norm0.x;
  g010 *= norm0.y;
  g100 *= norm0.z;
  g110 *= norm0.w;
  vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));
  g001 *= norm1.x;
  g011 *= norm1.y;
  g101 *= norm1.z;
  g111 *= norm1.w;

  float n000 = dot(g000, Pf0);
  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));
  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));
  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));
  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));
  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));
  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));
  float n111 = dot(g111, Pf1);

  vec3 fade_xyz = fade(Pf0);
  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);
  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);
  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x);
  return 2.2 * n_xyz;
}
`; class f extends u.V9B {
      #a; constructor(e, t, i) {
        super(), this.mesh = null, this.originalDispose = u._4j.prototype.dispose, this.offset = i ?? new u.I9Y(.5, .5), this.#a = 0, this.uniforms = { uPlaneSizes: new u.nc$(new u.I9Y(1, 1)), uImagePosition: new u.nc$(this.offset), uResolution: new u.nc$(new u.I9Y(window.innerWidth, window.innerHeight)), uTextureA: new u.nc$(e), uTextureB: new u.nc$(t), uProgress: new u.nc$(this.#a), uTime: new u.nc$(0) }, this.uniforms.uImagePosition.value = this.offset, this.onBeforeCompile = e => {
          e.uniforms = { ...e.uniforms, ...this.uniforms }, e.vertexShader = `
        uniform vec2 uPlaneSizes;
        uniform vec2 uImagePosition;
        uniform sampler2D uTextureA;
        uniform sampler2D uTextureB;
        varying vec2 vUv;
        ${e.vertexShader}
      `.replace("#include <begin_vertex>", `
          #include <begin_vertex>
          // Calculate scaled and offset UVs
          vec2 scaledUV = uImagePosition + (uv - uImagePosition) / uPlaneSizes;
          vUv = uv;
        `).replace("#include <fog_vertex>", `
        #include <fog_vertex>

        vMapUv = scaledUV;

        #ifdef USE_ALPHAMAP
          vAlphaMapUv = scaledUV;
        #endif
      `), e.fragmentShader = `
      uniform vec2 uPlaneSizes;
      uniform sampler2D uTextureA;
      uniform sampler2D uTextureB;
      uniform vec2 uResolution;
      uniform float uProgress;
      uniform float uTime;
      varying vec2 vUv;
      ${d}
      ${e.fragmentShader}
      `.replace("#include <map_fragment>", `
        #ifdef USE_MAP
          vec4 t1 = texture2D(uTextureA, vMapUv);
          vec4 t2 = texture2D(uTextureB, vMapUv);

          vec2 duv = vUv * 2.0 - 1.0;
          float n = cnoise(vec3(vUv * 10., uTime));
          n *= 0.5;
          n += 0.5;
          // Strength
          n *= 0.4;

          float aspect = uResolution.x / uResolution.y;
          duv.x *= aspect;

          float max_dist = length(vec2(aspect, 1.0));
          float dtc = distance(duv, vec2(0.0, 0.0));

          dtc /= max_dist;

          float startProgress = 0.0;
          float remainder = (1.0 - startProgress) * (uProgress);
          float stepValue = startProgress + remainder;

          dtc = smoothstep(stepValue, stepValue + n + 0.2, dtc);
          dtc = 1.0 - dtc;
          dtc *= uProgress;

          vec4 sampledDiffuseColor = mix(t1, t2, dtc);



          #ifdef DECODE_VIDEO_TEXTURE
            sampledDiffuseColor = sRGBTransferEOTF( sampledDiffuseColor );
          #endif
          diffuseColor *= sampledDiffuseColor;
        #endif
        `)
        }, window.addEventListener("resize", this.onResize.bind(this))
      } fit() { let e, t; if (!this.mesh || !this.map) return; let i = this.map.image.width / this.map.image.height, r = this.mesh.scale.x / this.mesh.scale.y; i > r ? (e = i / r, t = 1) : i < r ? (e = 1, t = r / i) : (e = 1, t = 1), this.uniforms.uPlaneSizes.value.set(e, t) } setMesh(e) { this.mesh = e, this.fit() } get progress() { return this.#a } set progress(e) { this.#a = e, this.uniforms.uProgress.value = e } dispose() { this.originalDispose.call(this), window.removeEventListener("resize", this.onResize.bind(this)) } onResize() { this.fit(), this.uniforms.uResolution.value.set(window.innerWidth, window.innerHeight) }
    } (0, l.e)({ BlendMaterial: f }); var p = i(819), m = i(9978), g = i(6540); function v() { let { store: e } = (0, m.F)(); return (0, g.useEffect)(() => p.D.subscribe(({ enableCanvasFrameloop: t }) => { let { frameloop: i, setFrameloop: r } = e?.getState(); i !== t && r(t) }), []), null } var y = i(2445), x = i(1538), S = i(3502), A = class { constructor() { this.startTime = performance.now(), this.previousTime = 0, this.currentTime = 0, this._delta = 0, this._elapsed = 0, this._fixedDelta = 1e3 / 60, this.timescale = 1, this.useFixedDelta = !1, this._autoReset = !1 } get autoReset() { return this._autoReset } set autoReset(e) { "undefined" != typeof document && void 0 !== document.hidden && (e ? document.addEventListener("visibilitychange", this) : document.removeEventListener("visibilitychange", this), this._autoReset = e) } get delta() { return .001 * this._delta } get fixedDelta() { return .001 * this._fixedDelta } set fixedDelta(e) { this._fixedDelta = 1e3 * e } get elapsed() { return .001 * this._elapsed } update(e) { this.useFixedDelta ? this._delta = this.fixedDelta : (this.previousTime = this.currentTime, this.currentTime = (void 0 !== e ? e : performance.now()) - this.startTime, this._delta = this.currentTime - this.previousTime), this._delta *= this.timescale, this._elapsed += this._delta } reset() { this._delta = 0, this._elapsed = 0, this.currentTime = performance.now() - this.startTime } getDelta() { return this.delta } getElapsed() { return this.elapsed } handleEvent(e) { document.hidden || (this.currentTime = performance.now() - this.startTime) } dispose() { this.autoReset = !1 } }, _ = (() => { let e = new Float32Array([-1, -1, 0, 3, -1, 0, -1, 3, 0]), t = new Float32Array([0, 0, 2, 0, 0, 2]), i = new u.LoY; return i.setAttribute("position", new u.THS(e, 3)), i.setAttribute("uv", new u.THS(t, 2)), i })(), E = class e { static get fullscreenGeometry() { return _ } constructor(e = "Pass", t = new u.Z58, i = new u.i7d) { this.name = e, this.renderer = null, this.scene = t, this.camera = i, this.screen = null, this.rtt = !0, this.needsSwap = !0, this.needsDepthTexture = !1, this.enabled = !0 } get renderToScreen() { return !this.rtt } set renderToScreen(e) { if (this.rtt === e) { let t = this.fullscreenMaterial; null !== t && (t.needsUpdate = !0), this.rtt = !e } } set mainScene(e) { } set mainCamera(e) { } setRenderer(e) { this.renderer = e } isEnabled() { return this.enabled } setEnabled(e) { this.enabled = e } get fullscreenMaterial() { return null !== this.screen ? this.screen.material : null } set fullscreenMaterial(t) { let i = this.screen; null !== i ? i.material = t : ((i = new u.eaF(e.fullscreenGeometry, t)).frustumCulled = !1, null === this.scene && (this.scene = new u.Z58), this.scene.add(i), this.screen = i) } getFullscreenMaterial() { return this.fullscreenMaterial } setFullscreenMaterial(e) { this.fullscreenMaterial = e } getDepthTexture() { return null } setDepthTexture(e, t = u.Rkk) { } render(e, t, i, r, n) { throw Error("Render method not implemented!") } setSize(e, t) { } initialize(e, t, i) { } dispose() { for (let t of Object.keys(this)) { let i = this[t]; (i instanceof u.nWS || i instanceof u.imn || i instanceof u.gPd || i instanceof e) && this[t].dispose() } null !== this.fullscreenMaterial && this.fullscreenMaterial.dispose() } }, b = class extends E { constructor() { super("ClearMaskPass", null, null), this.needsSwap = !1 } render(e, t, i, r, n) { let s = e.state.buffers.stencil; s.setLocked(!1), s.setTest(!1) } }, T = "varying vec2 vUv;void main(){vUv=position.xy*0.5+0.5;gl_Position=vec4(position.xy,1.0,1.0);}", w = class extends u.BKk { constructor() { super({ name: "CopyMaterial", uniforms: { inputBuffer: new u.nc$(null), opacity: new u.nc$(1) }, blending: u.XIg, toneMapped: !1, depthWrite: !1, depthTest: !1, fragmentShader: "#include <common>\n#include <dithering_pars_fragment>\n#ifdef FRAMEBUFFER_PRECISION_HIGH\nuniform mediump sampler2D inputBuffer;\n#else\nuniform lowp sampler2D inputBuffer;\n#endif\nuniform float opacity;varying vec2 vUv;void main(){vec4 texel=texture2D(inputBuffer,vUv);gl_FragColor=opacity*texel;\n#include <colorspace_fragment>\n#include <dithering_fragment>\n}", vertexShader: T }) } set inputBuffer(e) { this.uniforms.inputBuffer.value = e } setInputBuffer(e) { this.uniforms.inputBuffer.value = e } getOpacity(e) { return this.uniforms.opacity.value } setOpacity(e) { this.uniforms.opacity.value = e } }, M = class extends E { constructor(e, t = !0) { super("CopyPass"), this.fullscreenMaterial = new w, this.needsSwap = !1, this.renderTarget = e, void 0 === e && (this.renderTarget = new u.nWS(1, 1, { minFilter: u.k6q, magFilter: u.k6q, stencilBuffer: !1, depthBuffer: !1 }), this.renderTarget.texture.name = "CopyPass.Target"), this.autoResize = t } get resize() { return this.autoResize } set resize(e) { this.autoResize = e } get texture() { return this.renderTarget.texture } getTexture() { return this.renderTarget.texture } setAutoResizeEnabled(e) { this.autoResize = e } render(e, t, i, r, n) { this.fullscreenMaterial.inputBuffer = t.texture, e.setRenderTarget(this.renderToScreen ? null : this.renderTarget), e.render(this.scene, this.camera) } setSize(e, t) { this.autoResize && this.renderTarget.setSize(e, t) } initialize(e, t, i) { void 0 !== i && (this.renderTarget.texture.type = i, i !== u.OUM ? this.fullscreenMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = "1" : null !== e && e.outputColorSpace === u.er$ && (this.renderTarget.texture.colorSpace = u.er$)) } }, R = new u.Q1f, C = class extends E { constructor(e = !0, t = !0, i = !1) { super("ClearPass", null, null), this.needsSwap = !1, this.color = e, this.depth = t, this.stencil = i, this.overrideClearColor = null, this.overrideClearAlpha = -1 } setClearFlags(e, t, i) { this.color = e, this.depth = t, this.stencil = i } getOverrideClearColor() { return this.overrideClearColor } setOverrideClearColor(e) { this.overrideClearColor = e } getOverrideClearAlpha() { return this.overrideClearAlpha } setOverrideClearAlpha(e) { this.overrideClearAlpha = e } render(e, t, i, r, n) { let s = this.overrideClearColor, a = this.overrideClearAlpha, o = e.getClearAlpha(), l = null !== s, u = a >= 0; l ? (e.getClearColor(R), e.setClearColor(s, u ? a : o)) : u && e.setClearAlpha(a), e.setRenderTarget(this.renderToScreen ? null : t), e.clear(this.color, this.depth, this.stencil), l ? e.setClearColor(R, o) : u && e.setClearAlpha(o) } }, I = class extends E { constructor(e, t) { super("MaskPass", e, t), this.needsSwap = !1, this.clearPass = new C(!1, !1, !0), this.inverse = !1 } set mainScene(e) { this.scene = e } set mainCamera(e) { this.camera = e } get inverted() { return this.inverse } set inverted(e) { this.inverse = e } get clear() { return this.clearPass.enabled } set clear(e) { this.clearPass.enabled = e } getClearPass() { return this.clearPass } isInverted() { return this.inverted } setInverted(e) { this.inverted = e } render(e, t, i, r, n) { let s = e.getContext(), a = e.state.buffers, o = this.scene, l = this.camera, u = this.clearPass, h = this.inverted ? 0 : 1; a.color.setMask(!1), a.depth.setMask(!1), a.color.setLocked(!0), a.depth.setLocked(!0), a.stencil.setTest(!0), a.stencil.setOp(s.REPLACE, s.REPLACE, s.REPLACE), a.stencil.setFunc(s.ALWAYS, h, 0xffffffff), a.stencil.setClear(1 - h), a.stencil.setLocked(!0), this.clearPass.enabled && (this.renderToScreen ? u.render(e, null) : (u.render(e, t), u.render(e, i))), this.renderToScreen ? e.setRenderTarget(null) : (e.setRenderTarget(t), e.render(o, l), e.setRenderTarget(i)), e.render(o, l), a.color.setLocked(!1), a.depth.setLocked(!1), a.stencil.setLocked(!1), a.stencil.setFunc(s.EQUAL, 1, 0xffffffff), a.stencil.setOp(s.KEEP, s.KEEP, s.KEEP), a.stencil.setLocked(!0) } }, L = class { constructor(e = null, { depthBuffer: t = !0, stencilBuffer: i = !1, multisampling: r = 0, frameBufferType: n } = {}) { this.renderer = null, this.inputBuffer = this.createBuffer(t, i, n, r), this.outputBuffer = this.inputBuffer.clone(), this.copyPass = new M, this.depthTexture = null, this.passes = [], this.timer = new A, this.autoRenderToScreen = !0, this.setRenderer(e) } get multisampling() { return this.inputBuffer.samples || 0 } set multisampling(e) { let t = this.inputBuffer, i = this.multisampling; i > 0 && e > 0 ? (this.inputBuffer.samples = e, this.outputBuffer.samples = e, this.inputBuffer.dispose(), this.outputBuffer.dispose()) : i !== e && (this.inputBuffer.dispose(), this.outputBuffer.dispose(), this.inputBuffer = this.createBuffer(t.depthBuffer, t.stencilBuffer, t.texture.type, e), this.inputBuffer.depthTexture = this.depthTexture, this.outputBuffer = this.inputBuffer.clone()) } getTimer() { return this.timer } getRenderer() { return this.renderer } setRenderer(e) { if (this.renderer = e, null !== e) { let t = e.getSize(new u.I9Y), i = e.getContext().getContextAttributes().alpha, r = this.inputBuffer.texture.type; for (let n of (r === u.OUM && e.outputColorSpace === u.er$ && (this.inputBuffer.texture.colorSpace = u.er$, this.outputBuffer.texture.colorSpace = u.er$, this.inputBuffer.dispose(), this.outputBuffer.dispose()), e.autoClear = !1, this.setSize(t.width, t.height), this.passes)) n.initialize(e, i, r) } } replaceRenderer(e, t = !0) { let i = this.renderer, r = i.domElement.parentNode; return this.setRenderer(e), t && null !== r && (r.removeChild(i.domElement), r.appendChild(e.domElement)), i } createDepthTexture() { let e = this.depthTexture = new u.VCu; return this.inputBuffer.depthTexture = e, this.inputBuffer.dispose(), this.inputBuffer.stencilBuffer ? (e.format = u.dcC, e.type = u.V3x) : e.type = u.bkx, e } deleteDepthTexture() { if (null !== this.depthTexture) for (let e of (this.depthTexture.dispose(), this.depthTexture = null, this.inputBuffer.depthTexture = null, this.inputBuffer.dispose(), this.passes)) e.setDepthTexture(null) } createBuffer(e, t, i, r) { let n = this.renderer, s = null === n ? new u.I9Y : n.getDrawingBufferSize(new u.I9Y), a = { minFilter: u.k6q, magFilter: u.k6q, stencilBuffer: t, depthBuffer: e, type: i }, o = new u.nWS(s.width, s.height, a); return r > 0 && (o.ignoreDepthForMultisampleCopy = !1, o.samples = r), i === u.OUM && null !== n && n.outputColorSpace === u.er$ && (o.texture.colorSpace = u.er$), o.texture.name = "EffectComposer.Buffer", o.texture.generateMipmaps = !1, o } setMainScene(e) { for (let t of this.passes) t.mainScene = e } setMainCamera(e) { for (let t of this.passes) t.mainCamera = e } addPass(e, t) { let i = this.passes, r = this.renderer, n = r.getDrawingBufferSize(new u.I9Y), s = r.getContext().getContextAttributes().alpha, a = this.inputBuffer.texture.type; if (e.setRenderer(r), e.setSize(n.width, n.height), e.initialize(r, s, a), this.autoRenderToScreen && (i.length > 0 && (i[i.length - 1].renderToScreen = !1), e.renderToScreen && (this.autoRenderToScreen = !1)), void 0 !== t ? i.splice(t, 0, e) : i.push(e), this.autoRenderToScreen && (i[i.length - 1].renderToScreen = !0), e.needsDepthTexture || null !== this.depthTexture) { if (null === this.depthTexture) { let t = this.createDepthTexture(); for (e of i) e.setDepthTexture(t) } else e.setDepthTexture(this.depthTexture) } } removePass(e) { let t = this.passes, i = t.indexOf(e); -1 !== i && t.splice(i, 1).length > 0 && (null === this.depthTexture || t.reduce((e, t) => e || t.needsDepthTexture, !1) || (e.getDepthTexture() === this.depthTexture && e.setDepthTexture(null), this.deleteDepthTexture()), this.autoRenderToScreen && i === t.length && (e.renderToScreen = !1, t.length > 0 && (t[t.length - 1].renderToScreen = !0))) } removeAllPasses() { let e = this.passes; this.deleteDepthTexture(), e.length > 0 && (this.autoRenderToScreen && (e[e.length - 1].renderToScreen = !1), this.passes = []) } render(e) { let t, i, r; let n = this.renderer, s = this.copyPass, a = this.inputBuffer, o = this.outputBuffer, l = !1; for (let u of (void 0 === e && (this.timer.update(), e = this.timer.getDelta()), this.passes)) u.enabled && (u.render(n, a, o, e, l), u.needsSwap && (l && (s.renderToScreen = u.renderToScreen, t = n.getContext(), (i = n.state.buffers.stencil).setFunc(t.NOTEQUAL, 1, 0xffffffff), s.render(n, a, o, e, l), i.setFunc(t.EQUAL, 1, 0xffffffff)), r = a, a = o, o = r), u instanceof I ? l = !0 : u instanceof b && (l = !1)) } setSize(e, t, i) { let r = this.renderer, n = r.getSize(new u.I9Y); (void 0 === e || void 0 === t) && (e = n.width, t = n.height), (n.width !== e || n.height !== t) && r.setSize(e, t, i); let s = r.getDrawingBufferSize(new u.I9Y); for (let e of (this.inputBuffer.setSize(s.width, s.height), this.outputBuffer.setSize(s.width, s.height), this.passes)) e.setSize(s.width, s.height) } reset() { this.dispose(), this.autoRenderToScreen = !0 } dispose() { for (let e of this.passes) e.dispose(); this.passes = [], null !== this.inputBuffer && this.inputBuffer.dispose(), null !== this.outputBuffer && this.outputBuffer.dispose(), this.deleteDepthTexture(), this.copyPass.dispose(), this.timer.dispose(), E.fullscreenGeometry.dispose() } }, P = { NONE: 0, DEPTH: 1, CONVOLUTION: 2 }, D = { FRAGMENT_HEAD: "FRAGMENT_HEAD", FRAGMENT_MAIN_UV: "FRAGMENT_MAIN_UV", FRAGMENT_MAIN_IMAGE: "FRAGMENT_MAIN_IMAGE", VERTEX_HEAD: "VERTEX_HEAD", VERTEX_MAIN_SUPPORT: "VERTEX_MAIN_SUPPORT" }, O = class { constructor() { this.shaderParts = new Map([[D.FRAGMENT_HEAD, null], [D.FRAGMENT_MAIN_UV, null], [D.FRAGMENT_MAIN_IMAGE, null], [D.VERTEX_HEAD, null], [D.VERTEX_MAIN_SUPPORT, null]]), this.defines = new Map, this.uniforms = new Map, this.blendModes = new Map, this.extensions = new Set, this.attributes = P.NONE, this.varyings = new Set, this.uvTransformation = !1, this.readDepth = !1, this.colorSpace = u.Zr2 } }; function k(e) { let t; if (0 === e) t = new Float64Array(0); else if (1 === e) t = new Float64Array([1]); else if (e > 1) { let i = new Float64Array(e), r = new Float64Array(e); for (let n = 1; n <= e; ++n) { for (let e = 0; e < n; ++e)r[e] = 0 === e || e === n - 1 ? 1 : i[e - 1] + i[e]; t = r, r = i, i = t } } return t } var F = !1, U = class { constructor(e = null) { this.originalMaterials = new Map, this.material = null, this.materials = null, this.materialsBackSide = null, this.materialsDoubleSide = null, this.materialsFlatShaded = null, this.materialsFlatShadedBackSide = null, this.materialsFlatShadedDoubleSide = null, this.setMaterial(e), this.meshCount = 0, this.replaceMaterial = e => { if (e.isMesh) { let t; if (e.material.flatShading) switch (e.material.side) { case u.$EB: t = this.materialsFlatShadedDoubleSide; break; case u.hsX: t = this.materialsFlatShadedBackSide; break; default: t = this.materialsFlatShaded } else switch (e.material.side) { case u.$EB: t = this.materialsDoubleSide; break; case u.hsX: t = this.materialsBackSide; break; default: t = this.materials }this.originalMaterials.set(e, e.material), e.isSkinnedMesh ? e.material = t[2] : e.isInstancedMesh ? e.material = t[1] : e.material = t[0], ++this.meshCount } } } cloneMaterial(e) { if (!(e instanceof u.BKk)) return e.clone(); let t = e.uniforms, i = new Map; for (let e in t) { let r = t[e].value; r.isRenderTargetTexture && (t[e].value = null, i.set(e, r)) } let r = e.clone(); for (let e of i) t[e[0]].value = e[1], r.uniforms[e[0]].value = e[1]; return r } setMaterial(e) { if (this.disposeMaterials(), this.material = e, null !== e) { let t = this.materials = [this.cloneMaterial(e), this.cloneMaterial(e), this.cloneMaterial(e)]; for (let i of t) i.uniforms = Object.assign({}, e.uniforms), i.side = u.hB5; t[2].skinning = !0, this.materialsBackSide = t.map(t => { let i = this.cloneMaterial(t); return i.uniforms = Object.assign({}, e.uniforms), i.side = u.hsX, i }), this.materialsDoubleSide = t.map(t => { let i = this.cloneMaterial(t); return i.uniforms = Object.assign({}, e.uniforms), i.side = u.$EB, i }), this.materialsFlatShaded = t.map(t => { let i = this.cloneMaterial(t); return i.uniforms = Object.assign({}, e.uniforms), i.flatShading = !0, i }), this.materialsFlatShadedBackSide = t.map(t => { let i = this.cloneMaterial(t); return i.uniforms = Object.assign({}, e.uniforms), i.flatShading = !0, i.side = u.hsX, i }), this.materialsFlatShadedDoubleSide = t.map(t => { let i = this.cloneMaterial(t); return i.uniforms = Object.assign({}, e.uniforms), i.flatShading = !0, i.side = u.$EB, i }) } } render(e, t, i) { let r = e.shadowMap.enabled; if (e.shadowMap.enabled = !1, F) { let r = this.originalMaterials; for (let n of (this.meshCount = 0, t.traverse(this.replaceMaterial), e.render(t, i), r)) n[0].material = n[1]; this.meshCount !== r.size && r.clear() } else { let r = t.overrideMaterial; t.overrideMaterial = this.material, e.render(t, i), t.overrideMaterial = r } e.shadowMap.enabled = r } disposeMaterials() { if (null !== this.material) for (let e of this.materials.concat(this.materialsBackSide).concat(this.materialsDoubleSide).concat(this.materialsFlatShaded).concat(this.materialsFlatShadedBackSide).concat(this.materialsFlatShadedDoubleSide)) e.dispose() } dispose() { this.originalMaterials.clear(), this.disposeMaterials() } static get workaroundEnabled() { return F } static set workaroundEnabled(e) { F = e } }, N = class extends u.Qev { constructor(e, t = -1, i = -1, r = 1) { super(), this.resizable = e, this.baseSize = new u.I9Y(1, 1), this.preferredSize = new u.I9Y(t, i), this.target = this.preferredSize, this.s = r, this.effectiveSize = new u.I9Y, this.addEventListener("change", () => this.updateEffectiveSize()), this.updateEffectiveSize() } updateEffectiveSize() { let e = this.baseSize, t = this.preferredSize, i = this.effectiveSize, r = this.scale; -1 !== t.width ? i.width = t.width : -1 !== t.height ? i.width = Math.round(t.height * (e.width / Math.max(e.height, 1))) : i.width = Math.round(e.width * r), -1 !== t.height ? i.height = t.height : -1 !== t.width ? i.height = Math.round(t.width / Math.max(e.width / Math.max(e.height, 1), 1)) : i.height = Math.round(e.height * r) } get width() { return this.effectiveSize.width } set width(e) { this.preferredWidth = e } get height() { return this.effectiveSize.height } set height(e) { this.preferredHeight = e } getWidth() { return this.width } getHeight() { return this.height } get scale() { return this.s } set scale(e) { this.s !== e && (this.s = e, this.preferredSize.setScalar(-1), this.dispatchEvent({ type: "change" }), this.resizable.setSize(this.baseSize.width, this.baseSize.height)) } getScale() { return this.scale } setScale(e) { this.scale = e } get baseWidth() { return this.baseSize.width } set baseWidth(e) { this.baseSize.width !== e && (this.baseSize.width = e, this.dispatchEvent({ type: "change" }), this.resizable.setSize(this.baseSize.width, this.baseSize.height)) } getBaseWidth() { return this.baseWidth } setBaseWidth(e) { this.baseWidth = e } get baseHeight() { return this.baseSize.height } set baseHeight(e) { this.baseSize.height !== e && (this.baseSize.height = e, this.dispatchEvent({ type: "change" }), this.resizable.setSize(this.baseSize.width, this.baseSize.height)) } getBaseHeight() { return this.baseHeight } setBaseHeight(e) { this.baseHeight = e } setBaseSize(e, t) { (this.baseSize.width !== e || this.baseSize.height !== t) && (this.baseSize.set(e, t), this.dispatchEvent({ type: "change" }), this.resizable.setSize(this.baseSize.width, this.baseSize.height)) } get preferredWidth() { return this.preferredSize.width } set preferredWidth(e) { this.preferredSize.width !== e && (this.preferredSize.width = e, this.dispatchEvent({ type: "change" }), this.resizable.setSize(this.baseSize.width, this.baseSize.height)) } getPreferredWidth() { return this.preferredWidth } setPreferredWidth(e) { this.preferredWidth = e } get preferredHeight() { return this.preferredSize.height } set preferredHeight(e) { this.preferredSize.height !== e && (this.preferredSize.height = e, this.dispatchEvent({ type: "change" }), this.resizable.setSize(this.baseSize.width, this.baseSize.height)) } getPreferredHeight() { return this.preferredHeight } setPreferredHeight(e) { this.preferredHeight = e } setPreferredSize(e, t) { (this.preferredSize.width !== e || this.preferredSize.height !== t) && (this.preferredSize.set(e, t), this.dispatchEvent({ type: "change" }), this.resizable.setSize(this.baseSize.width, this.baseSize.height)) } copy(e) { this.s = e.scale, this.baseSize.set(e.baseWidth, e.baseHeight), this.preferredSize.set(e.preferredWidth, e.preferredHeight), this.dispatchEvent({ type: "change" }), this.resizable.setSize(this.baseSize.width, this.baseSize.height) } static get AUTO_SIZE() { return -1 } }, B = { ADD: 0, ALPHA: 1, AVERAGE: 2, COLOR: 3, COLOR_BURN: 4, COLOR_DODGE: 5, DARKEN: 6, DIFFERENCE: 7, DIVIDE: 8, DST: 9, EXCLUSION: 10, HARD_LIGHT: 11, HARD_MIX: 12, HUE: 13, INVERT: 14, INVERT_RGB: 15, LIGHTEN: 16, LINEAR_BURN: 17, LINEAR_DODGE: 18, LINEAR_LIGHT: 19, LUMINOSITY: 20, MULTIPLY: 21, NEGATION: 22, NORMAL: 23, OVERLAY: 24, PIN_LIGHT: 25, REFLECT: 26, SATURATION: 27, SCREEN: 28, SOFT_LIGHT: 29, SRC: 30, SUBTRACT: 31, VIVID_LIGHT: 32 }, z = new Map([[B.ADD, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,x+y,opacity);}"], [B.ALPHA, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,y,min(y.a,opacity));}"], [B.AVERAGE, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,(x+y)*0.5,opacity);}"], [B.COLOR, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 xHSL=RGBToHSL(x.rgb);vec3 yHSL=RGBToHSL(y.rgb);vec3 z=HSLToRGB(vec3(yHSL.rg,xHSL.b));return vec4(mix(x.rgb,z,opacity),y.a);}"], [B.COLOR_BURN, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=mix(step(0.0,y)*(1.0-min(vec4(1.0),(1.0-x)/y)),vec4(1.0),step(1.0,x));return mix(x,z,opacity);}"], [B.COLOR_DODGE, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=step(0.0,x)*mix(min(vec4(1.0),x/max(1.0-y,1e-9)),vec4(1.0),step(1.0,y));return mix(x,z,opacity);}"], [B.DARKEN, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,min(x,y),opacity);}"], [B.DIFFERENCE, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,abs(x-y),opacity);}"], [B.DIVIDE, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,x/max(y,1e-12),opacity);}"], [B.DST, null], [B.EXCLUSION, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,(x+y-2.0*x*y),opacity);}"], [B.HARD_LIGHT, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 a=min(x,1.0),b=min(y,1.0);vec4 z=mix(2.0*a*b,1.0-2.0*(1.0-a)*(1.0-b),step(0.5,y));return mix(x,z,opacity);}"], [B.HARD_MIX, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,step(1.0,x+y),opacity);}"], [B.HUE, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 xHSL=RGBToHSL(x.rgb);vec3 yHSL=RGBToHSL(y.rgb);vec3 z=HSLToRGB(vec3(yHSL.r,xHSL.gb));return vec4(mix(x.rgb,z,opacity),y.a);}"], [B.INVERT, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,1.0-y,opacity);}"], [B.INVERT_RGB, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,y*(1.0-x),opacity);}"], [B.LIGHTEN, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,max(x,y),opacity);}"], [B.LINEAR_BURN, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,clamp(y+x-1.0,0.0,1.0),opacity);}"], [B.LINEAR_DODGE, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,min(x+y,1.0),opacity);}"], [B.LINEAR_LIGHT, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,clamp(2.0*y+x-1.0,0.0,1.0),opacity);}"], [B.LUMINOSITY, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 xHSL=RGBToHSL(x.rgb);vec3 yHSL=RGBToHSL(y.rgb);vec3 z=HSLToRGB(vec3(xHSL.rg,yHSL.b));return vec4(mix(x.rgb,z,opacity),y.a);}"], [B.MULTIPLY, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,x*y,opacity);}"], [B.NEGATION, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,1.0-abs(1.0-x-y),opacity);}"], [B.NORMAL, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,y,opacity);}"], [B.OVERLAY, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=mix(2.0*y*x,1.0-2.0*(1.0-y)*(1.0-x),step(0.5,x));return mix(x,z,opacity);}"], [B.PIN_LIGHT, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 y2=2.0*y;vec4 z=mix(mix(y2,x,step(0.5*x,y)),max(vec4(0.0),y2-1.0),step(x,(y2-1.0)));return mix(x,z,opacity);}"], [B.REFLECT, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=mix(min(x*x/max(1.0-y,1e-12),1.0),y,step(1.0,y));return mix(x,z,opacity);}"], [B.SATURATION, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 xHSL=RGBToHSL(x.rgb);vec3 yHSL=RGBToHSL(y.rgb);vec3 z=HSLToRGB(vec3(xHSL.r,yHSL.g,xHSL.b));return vec4(mix(x.rgb,z,opacity),y.a);}"], [B.SCREEN, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,x+y-min(x*y,1.0),opacity);}"], [B.SOFT_LIGHT, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 y2=2.0*y;vec4 w=step(0.5,y);vec4 z=mix(x-(1.0-y2)*x*(1.0-x),mix(x+(y2-1.0)*(sqrt(x)-x),x+(y2-1.0)*x*((16.0*x-12.0)*x+3.0),w*(1.0-step(0.25,x))),w);return mix(x,z,opacity);}"], [B.SRC, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return y;}"], [B.SUBTRACT, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,max(x+y-1.0,0.0),opacity);}"], [B.VIVID_LIGHT, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=mix(max(1.0-min((1.0-x)/(2.0*y),1.0),0.0),min(x/(2.0*(1.0-y)),1.0),step(0.5,y));return mix(x,z,opacity);}"]]), G = class extends u.Qev { constructor(e, t = 1) { super(), this._blendFunction = e, this.opacity = new u.nc$(t) } getOpacity() { return this.opacity.value } setOpacity(e) { this.opacity.value = e } get blendFunction() { return this._blendFunction } set blendFunction(e) { this._blendFunction = e, this.dispatchEvent({ type: "change" }) } getBlendFunction() { return this.blendFunction } setBlendFunction(e) { this.blendFunction = e } getShaderCode() { return z.get(this.blendFunction) } }, H = (u.GOR, class extends u.Qev { constructor(e, t, { attributes: i = P.NONE, blendFunction: r = B.NORMAL, defines: n = new Map, uniforms: s = new Map, extensions: a = null, vertexShader: o = null } = {}) { super(), this.name = e, this.renderer = null, this.attributes = i, this.fragmentShader = t, this.vertexShader = o, this.defines = n, this.uniforms = s, this.extensions = a, this.blendMode = new G(r), this.blendMode.addEventListener("change", e => this.setChanged()), this._inputColorSpace = u.Zr2, this._outputColorSpace = u.jf0 } get inputColorSpace() { return this._inputColorSpace } set inputColorSpace(e) { this._inputColorSpace = e, this.setChanged() } get outputColorSpace() { return this._outputColorSpace } set outputColorSpace(e) { this._outputColorSpace = e, this.setChanged() } set mainScene(e) { } set mainCamera(e) { } getName() { return this.name } setRenderer(e) { this.renderer = e } getDefines() { return this.defines } getUniforms() { return this.uniforms } getExtensions() { return this.extensions } getBlendMode() { return this.blendMode } getAttributes() { return this.attributes } setAttributes(e) { this.attributes = e, this.setChanged() } getFragmentShader() { return this.fragmentShader } setFragmentShader(e) { this.fragmentShader = e, this.setChanged() } getVertexShader() { return this.vertexShader } setVertexShader(e) { this.vertexShader = e, this.setChanged() } setChanged() { this.dispatchEvent({ type: "change" }) } setDepthTexture(e, t = u.Rkk) { } update(e, t, i) { } setSize(e, t) { } initialize(e, t, i) { } dispose() { for (let e of Object.keys(this)) { let t = this[e]; (t instanceof u.nWS || t instanceof u.imn || t instanceof u.gPd || t instanceof E) && this[e].dispose() } } }), V = { MEDIUM: 2 }, W = [new Float32Array([0, 0]), new Float32Array([0, 1, 1]), new Float32Array([0, 1, 1, 2]), new Float32Array([0, 1, 2, 2, 3]), new Float32Array([0, 1, 2, 3, 4, 4, 5]), new Float32Array([0, 1, 2, 3, 4, 5, 7, 8, 9, 10])], j = class extends u.BKk { constructor(e = new u.IUQ) { super({ name: "KawaseBlurMaterial", uniforms: { inputBuffer: new u.nc$(null), texelSize: new u.nc$(new u.IUQ), scale: new u.nc$(1), kernel: new u.nc$(0) }, blending: u.XIg, toneMapped: !1, depthWrite: !1, depthTest: !1, fragmentShader: "#ifdef FRAMEBUFFER_PRECISION_HIGH\nuniform mediump sampler2D inputBuffer;\n#else\nuniform lowp sampler2D inputBuffer;\n#endif\nvarying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;void main(){vec4 sum=texture2D(inputBuffer,vUv0);sum+=texture2D(inputBuffer,vUv1);sum+=texture2D(inputBuffer,vUv2);sum+=texture2D(inputBuffer,vUv3);gl_FragColor=sum*0.25;\n#include <colorspace_fragment>\n}", vertexShader: "uniform vec4 texelSize;uniform float kernel;uniform float scale;varying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;void main(){vec2 uv=position.xy*0.5+0.5;vec2 dUv=(texelSize.xy*vec2(kernel)+texelSize.zw)*scale;vUv0=vec2(uv.x-dUv.x,uv.y+dUv.y);vUv1=vec2(uv.x+dUv.x,uv.y+dUv.y);vUv2=vec2(uv.x+dUv.x,uv.y-dUv.y);vUv3=vec2(uv.x-dUv.x,uv.y-dUv.y);gl_Position=vec4(position.xy,1.0,1.0);}" }), this.setTexelSize(e.x, e.y), this.kernelSize = V.MEDIUM } set inputBuffer(e) { this.uniforms.inputBuffer.value = e } setInputBuffer(e) { this.inputBuffer = e } get kernelSequence() { return W[this.kernelSize] } get scale() { return this.uniforms.scale.value } set scale(e) { this.uniforms.scale.value = e } getScale() { return this.uniforms.scale.value } setScale(e) { this.uniforms.scale.value = e } getKernel() { return null } get kernel() { return this.uniforms.kernel.value } set kernel(e) { this.uniforms.kernel.value = e } setKernel(e) { this.kernel = e } setTexelSize(e, t) { this.uniforms.texelSize.value.set(e, t, .5 * e, .5 * t) } setSize(e, t) { let i = 1 / e, r = 1 / t; this.uniforms.texelSize.value.set(i, r, .5 * i, .5 * r) } }, Y = class extends u.BKk { constructor(e = !1, t = null) { super({ name: "LuminanceMaterial", defines: { THREE_REVISION: u.sPf.replace(/\D+/g, "") }, uniforms: { inputBuffer: new u.nc$(null), threshold: new u.nc$(0), smoothing: new u.nc$(1), range: new u.nc$(null) }, blending: u.XIg, toneMapped: !1, depthWrite: !1, depthTest: !1, fragmentShader: "#include <common>\n#ifdef FRAMEBUFFER_PRECISION_HIGH\nuniform mediump sampler2D inputBuffer;\n#else\nuniform lowp sampler2D inputBuffer;\n#endif\n#ifdef RANGE\nuniform vec2 range;\n#elif defined(THRESHOLD)\nuniform float threshold;uniform float smoothing;\n#endif\nvarying vec2 vUv;void main(){vec4 texel=texture2D(inputBuffer,vUv);float l=luminance(texel.rgb);\n#ifdef RANGE\nfloat low=step(range.x,l);float high=step(l,range.y);l*=low*high;\n#elif defined(THRESHOLD)\nl=smoothstep(threshold,threshold+smoothing,l)*l;\n#endif\n#ifdef COLOR\ngl_FragColor=vec4(texel.rgb*clamp(l,0.0,1.0),l);\n#else\ngl_FragColor=vec4(l);\n#endif\n}", vertexShader: T }), this.colorOutput = e, this.luminanceRange = t } set inputBuffer(e) { this.uniforms.inputBuffer.value = e } setInputBuffer(e) { this.uniforms.inputBuffer.value = e } get threshold() { return this.uniforms.threshold.value } set threshold(e) { this.smoothing > 0 || e > 0 ? this.defines.THRESHOLD = "1" : delete this.defines.THRESHOLD, this.uniforms.threshold.value = e } getThreshold() { return this.threshold } setThreshold(e) { this.threshold = e } get smoothing() { return this.uniforms.smoothing.value } set smoothing(e) { this.threshold > 0 || e > 0 ? this.defines.THRESHOLD = "1" : delete this.defines.THRESHOLD, this.uniforms.smoothing.value = e } getSmoothingFactor() { return this.smoothing } setSmoothingFactor(e) { this.smoothing = e } get useThreshold() { return this.threshold > 0 || this.smoothing > 0 } set useThreshold(e) { } get colorOutput() { return void 0 !== this.defines.COLOR } set colorOutput(e) { e ? this.defines.COLOR = "1" : delete this.defines.COLOR, this.needsUpdate = !0 } isColorOutputEnabled(e) { return this.colorOutput } setColorOutputEnabled(e) { this.colorOutput = e } get useRange() { return null !== this.luminanceRange } set useRange(e) { this.luminanceRange = null } get luminanceRange() { return this.uniforms.range.value } set luminanceRange(e) { null !== e ? this.defines.RANGE = "1" : delete this.defines.RANGE, this.uniforms.range.value = e, this.needsUpdate = !0 } getLuminanceRange() { return this.luminanceRange } setLuminanceRange(e) { this.luminanceRange = e } }, X = class extends E { constructor({ renderTarget: e, luminanceRange: t, colorOutput: i, resolutionScale: r = 1, width: n = N.AUTO_SIZE, height: s = N.AUTO_SIZE, resolutionX: a = n, resolutionY: o = s } = {}) { super("LuminancePass"), this.fullscreenMaterial = new Y(i, t), this.needsSwap = !1, this.renderTarget = e, void 0 === this.renderTarget && (this.renderTarget = new u.nWS(1, 1, { depthBuffer: !1 }), this.renderTarget.texture.name = "LuminancePass.Target"); let l = this.resolution = new N(this, a, o, r); l.addEventListener("change", e => this.setSize(l.baseWidth, l.baseHeight)) } get texture() { return this.renderTarget.texture } getTexture() { return this.renderTarget.texture } getResolution() { return this.resolution } render(e, t, i, r, n) { this.fullscreenMaterial.inputBuffer = t.texture, e.setRenderTarget(this.renderToScreen ? null : this.renderTarget), e.render(this.scene, this.camera) } setSize(e, t) { let i = this.resolution; i.setBaseSize(e, t), this.renderTarget.setSize(i.width, i.height) } initialize(e, t, i) { void 0 !== i && i !== u.OUM && (this.renderTarget.texture.type = i, this.fullscreenMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = "1") } }, K = class extends u.BKk { constructor() { super({ name: "DownsamplingMaterial", uniforms: { inputBuffer: new u.nc$(null), texelSize: new u.nc$(new u.I9Y) }, blending: u.XIg, toneMapped: !1, depthWrite: !1, depthTest: !1, fragmentShader: "#ifdef FRAMEBUFFER_PRECISION_HIGH\nuniform mediump sampler2D inputBuffer;\n#else\nuniform lowp sampler2D inputBuffer;\n#endif\n#define WEIGHT_INNER 0.125\n#define WEIGHT_OUTER 0.0555555\nvarying vec2 vUv;varying vec2 vUv00;varying vec2 vUv01;varying vec2 vUv02;varying vec2 vUv03;varying vec2 vUv04;varying vec2 vUv05;varying vec2 vUv06;varying vec2 vUv07;varying vec2 vUv08;varying vec2 vUv09;varying vec2 vUv10;varying vec2 vUv11;float clampToBorder(const in vec2 uv){return float(uv.s>=0.0&&uv.s<=1.0&&uv.t>=0.0&&uv.t<=1.0);}void main(){vec4 c=vec4(0.0);vec4 w=WEIGHT_INNER*vec4(clampToBorder(vUv00),clampToBorder(vUv01),clampToBorder(vUv02),clampToBorder(vUv03));c+=w.x*texture2D(inputBuffer,vUv00);c+=w.y*texture2D(inputBuffer,vUv01);c+=w.z*texture2D(inputBuffer,vUv02);c+=w.w*texture2D(inputBuffer,vUv03);w=WEIGHT_OUTER*vec4(clampToBorder(vUv04),clampToBorder(vUv05),clampToBorder(vUv06),clampToBorder(vUv07));c+=w.x*texture2D(inputBuffer,vUv04);c+=w.y*texture2D(inputBuffer,vUv05);c+=w.z*texture2D(inputBuffer,vUv06);c+=w.w*texture2D(inputBuffer,vUv07);w=WEIGHT_OUTER*vec4(clampToBorder(vUv08),clampToBorder(vUv09),clampToBorder(vUv10),clampToBorder(vUv11));c+=w.x*texture2D(inputBuffer,vUv08);c+=w.y*texture2D(inputBuffer,vUv09);c+=w.z*texture2D(inputBuffer,vUv10);c+=w.w*texture2D(inputBuffer,vUv11);c+=WEIGHT_OUTER*texture2D(inputBuffer,vUv);gl_FragColor=c;\n#include <colorspace_fragment>\n}", vertexShader: "uniform vec2 texelSize;varying vec2 vUv;varying vec2 vUv00;varying vec2 vUv01;varying vec2 vUv02;varying vec2 vUv03;varying vec2 vUv04;varying vec2 vUv05;varying vec2 vUv06;varying vec2 vUv07;varying vec2 vUv08;varying vec2 vUv09;varying vec2 vUv10;varying vec2 vUv11;void main(){vUv=position.xy*0.5+0.5;vUv00=vUv+texelSize*vec2(-1.0,1.0);vUv01=vUv+texelSize*vec2(1.0,1.0);vUv02=vUv+texelSize*vec2(-1.0,-1.0);vUv03=vUv+texelSize*vec2(1.0,-1.0);vUv04=vUv+texelSize*vec2(-2.0,2.0);vUv05=vUv+texelSize*vec2(0.0,2.0);vUv06=vUv+texelSize*vec2(2.0,2.0);vUv07=vUv+texelSize*vec2(-2.0,0.0);vUv08=vUv+texelSize*vec2(2.0,0.0);vUv09=vUv+texelSize*vec2(-2.0,-2.0);vUv10=vUv+texelSize*vec2(0.0,-2.0);vUv11=vUv+texelSize*vec2(2.0,-2.0);gl_Position=vec4(position.xy,1.0,1.0);}" }) } set inputBuffer(e) { this.uniforms.inputBuffer.value = e } setSize(e, t) { this.uniforms.texelSize.value.set(1 / e, 1 / t) } }, q = class extends u.BKk { constructor() { super({ name: "UpsamplingMaterial", uniforms: { inputBuffer: new u.nc$(null), supportBuffer: new u.nc$(null), texelSize: new u.nc$(new u.I9Y), radius: new u.nc$(.85) }, blending: u.XIg, toneMapped: !1, depthWrite: !1, depthTest: !1, fragmentShader: "#ifdef FRAMEBUFFER_PRECISION_HIGH\nuniform mediump sampler2D inputBuffer;uniform mediump sampler2D supportBuffer;\n#else\nuniform lowp sampler2D inputBuffer;uniform lowp sampler2D supportBuffer;\n#endif\nuniform float radius;varying vec2 vUv;varying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;varying vec2 vUv4;varying vec2 vUv5;varying vec2 vUv6;varying vec2 vUv7;void main(){vec4 c=vec4(0.0);c+=texture2D(inputBuffer,vUv0)*0.0625;c+=texture2D(inputBuffer,vUv1)*0.125;c+=texture2D(inputBuffer,vUv2)*0.0625;c+=texture2D(inputBuffer,vUv3)*0.125;c+=texture2D(inputBuffer,vUv)*0.25;c+=texture2D(inputBuffer,vUv4)*0.125;c+=texture2D(inputBuffer,vUv5)*0.0625;c+=texture2D(inputBuffer,vUv6)*0.125;c+=texture2D(inputBuffer,vUv7)*0.0625;vec4 baseColor=texture2D(supportBuffer,vUv);gl_FragColor=mix(baseColor,c,radius);\n#include <colorspace_fragment>\n}", vertexShader: "uniform vec2 texelSize;varying vec2 vUv;varying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;varying vec2 vUv4;varying vec2 vUv5;varying vec2 vUv6;varying vec2 vUv7;void main(){vUv=position.xy*0.5+0.5;vUv0=vUv+texelSize*vec2(-1.0,1.0);vUv1=vUv+texelSize*vec2(0.0,1.0);vUv2=vUv+texelSize*vec2(1.0,1.0);vUv3=vUv+texelSize*vec2(-1.0,0.0);vUv4=vUv+texelSize*vec2(1.0,0.0);vUv5=vUv+texelSize*vec2(-1.0,-1.0);vUv6=vUv+texelSize*vec2(0.0,-1.0);vUv7=vUv+texelSize*vec2(1.0,-1.0);gl_Position=vec4(position.xy,1.0,1.0);}" }) } set inputBuffer(e) { this.uniforms.inputBuffer.value = e } set supportBuffer(e) { this.uniforms.supportBuffer.value = e } get radius() { return this.uniforms.radius.value } set radius(e) { this.uniforms.radius.value = e } setSize(e, t) { this.uniforms.texelSize.value.set(1 / e, 1 / t) } }, Q = class extends H { constructor({ blendFunction: e = B.SRC, brightness: t = 0, contrast: i = 0 } = {}) { super("BrightnessContrastEffect", "uniform float brightness;uniform float contrast;void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){vec3 color=inputColor.rgb+vec3(brightness-0.5);if(contrast>0.0){color/=vec3(1.0-contrast);}else{color*=vec3(1.0+contrast);}outputColor=vec4(color+vec3(0.5),inputColor.a);}", { blendFunction: e, uniforms: new Map([["brightness", new u.nc$(t)], ["contrast", new u.nc$(i)]]) }), this.inputColorSpace = u.er$ } get brightness() { return this.uniforms.get("brightness").value } set brightness(e) { this.uniforms.get("brightness").value = e } getBrightness() { return this.brightness } setBrightness(e) { this.brightness = e } get contrast() { return this.uniforms.get("contrast").value } set contrast(e) { this.uniforms.get("contrast").value = e } getContrast() { return this.contrast } setContrast(e) { this.contrast = e } }; u.BKk; u.BKk, u.BKk; var Z = class extends E { constructor(e, t = "inputBuffer") { super("ShaderPass"), this.fullscreenMaterial = e, this.input = t } setInput(e) { this.input = e } render(e, t, i, r, n) { let s = this.fullscreenMaterial.uniforms; null !== t && void 0 !== s && void 0 !== s[this.input] && (s[this.input].value = t.texture), e.setRenderTarget(this.renderToScreen ? null : i), e.render(this.scene, this.camera) } initialize(e, t, i) { void 0 !== i && i !== u.OUM && (this.fullscreenMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = "1") } }; u.GYF; var $ = (u.BKk, u.BKk, class extends E { constructor(e, t, i = null) { super("RenderPass", e, t), this.needsSwap = !1, this.clearPass = new C, this.overrideMaterialManager = null === i ? null : new U(i), this.ignoreBackground = !1, this.skipShadowMapUpdate = !1, this.selection = null } set mainScene(e) { this.scene = e } set mainCamera(e) { this.camera = e } get renderToScreen() { return super.renderToScreen } set renderToScreen(e) { super.renderToScreen = e, this.clearPass.renderToScreen = e } get overrideMaterial() { let e = this.overrideMaterialManager; return null !== e ? e.material : null } set overrideMaterial(e) { let t = this.overrideMaterialManager; null !== e ? null !== t ? t.setMaterial(e) : this.overrideMaterialManager = new U(e) : null !== t && (t.dispose(), this.overrideMaterialManager = null) } getOverrideMaterial() { return this.overrideMaterial } setOverrideMaterial(e) { this.overrideMaterial = e } get clear() { return this.clearPass.enabled } set clear(e) { this.clearPass.enabled = e } getSelection() { return this.selection } setSelection(e) { this.selection = e } isBackgroundDisabled() { return this.ignoreBackground } setBackgroundDisabled(e) { this.ignoreBackground = e } isShadowMapDisabled() { return this.skipShadowMapUpdate } setShadowMapDisabled(e) { this.skipShadowMapUpdate = e } getClearPass() { return this.clearPass } render(e, t, i, r, n) { let s = this.scene, a = this.camera, o = this.selection, l = a.layers.mask, u = s.background, h = e.shadowMap.autoUpdate, c = this.renderToScreen ? null : t; null !== o && a.layers.set(o.getLayer()), this.skipShadowMapUpdate && (e.shadowMap.autoUpdate = !1), (this.ignoreBackground || null !== this.clearPass.overrideClearColor) && (s.background = null), this.clearPass.enabled && this.clearPass.render(e, t), e.setRenderTarget(c), null !== this.overrideMaterialManager ? this.overrideMaterialManager.render(e, s, a) : e.render(s, a), a.layers.mask = l, s.background = u, e.shadowMap.autoUpdate = h } }); function J(e, t, i) { let r = document.createElement("canvas"), n = r.getContext("2d"); if (r.width = e, r.height = t, i instanceof Image) n.drawImage(i, 0, 0); else { let r = n.createImageData(e, t); r.data.set(i), n.putImageData(r, 0, 0) } return r } var ee = (u.dYF, { FULL: 0 }), et = { COLOR: 2 }, ei = { DISABLED: 0 }, er = { LOW: 0, MEDIUM: 1, HIGH: 2, ULTRA: 3 }, en = { LINEAR: 0, REINHARD: 1, REINHARD2: 2, REINHARD2_ADAPTIVE: 3, OPTIMIZED_CINEON: 5, CINEON: 5, ACES_FILMIC: 6, AGX: 7, NEUTRAL: 8 }, es = (u.BKk, u.BKk, class extends u.BKk { constructor(e = new u.I9Y, t = et.COLOR) { super({ name: "EdgeDetectionMaterial", defines: { THREE_REVISION: u.sPf.replace(/\D+/g, ""), LOCAL_CONTRAST_ADAPTATION_FACTOR: "2.0", EDGE_THRESHOLD: "0.1", DEPTH_THRESHOLD: "0.01", PREDICATION_MODE: "0", PREDICATION_THRESHOLD: "0.01", PREDICATION_SCALE: "2.0", PREDICATION_STRENGTH: "1.0", DEPTH_PACKING: "0" }, uniforms: { inputBuffer: new u.nc$(null), depthBuffer: new u.nc$(null), predicationBuffer: new u.nc$(null), texelSize: new u.nc$(e) }, blending: u.XIg, toneMapped: !1, depthWrite: !1, depthTest: !1, fragmentShader: "varying vec2 vUv;varying vec2 vUv0;varying vec2 vUv1;\n#if EDGE_DETECTION_MODE != 0\nvarying vec2 vUv2;varying vec2 vUv3;varying vec2 vUv4;varying vec2 vUv5;\n#endif\n#if EDGE_DETECTION_MODE == 1\n#include <common>\n#endif\n#if EDGE_DETECTION_MODE == 0 || PREDICATION_MODE == 1\n#ifdef GL_FRAGMENT_PRECISION_HIGH\nuniform highp sampler2D depthBuffer;\n#else\nuniform mediump sampler2D depthBuffer;\n#endif\nfloat readDepth(const in vec2 uv){\n#if DEPTH_PACKING == 3201\nreturn unpackRGBAToDepth(texture2D(depthBuffer,uv));\n#else\nreturn texture2D(depthBuffer,uv).r;\n#endif\n}vec3 gatherNeighbors(){float p=readDepth(vUv);float pLeft=readDepth(vUv0);float pTop=readDepth(vUv1);return vec3(p,pLeft,pTop);}\n#elif PREDICATION_MODE == 2\nuniform sampler2D predicationBuffer;vec3 gatherNeighbors(){float p=texture2D(predicationBuffer,vUv).r;float pLeft=texture2D(predicationBuffer,vUv0).r;float pTop=texture2D(predicationBuffer,vUv1).r;return vec3(p,pLeft,pTop);}\n#endif\n#if PREDICATION_MODE != 0\nvec2 calculatePredicatedThreshold(){vec3 neighbours=gatherNeighbors();vec2 delta=abs(neighbours.xx-neighbours.yz);vec2 edges=step(PREDICATION_THRESHOLD,delta);return PREDICATION_SCALE*EDGE_THRESHOLD*(1.0-PREDICATION_STRENGTH*edges);}\n#endif\n#if EDGE_DETECTION_MODE != 0\nuniform sampler2D inputBuffer;\n#endif\nvoid main(){\n#if EDGE_DETECTION_MODE == 0\nconst vec2 threshold=vec2(DEPTH_THRESHOLD);\n#elif PREDICATION_MODE != 0\nvec2 threshold=calculatePredicatedThreshold();\n#else\nconst vec2 threshold=vec2(EDGE_THRESHOLD);\n#endif\n#if EDGE_DETECTION_MODE == 0\nvec3 neighbors=gatherNeighbors();vec2 delta=abs(neighbors.xx-vec2(neighbors.y,neighbors.z));vec2 edges=step(threshold,delta);if(dot(edges,vec2(1.0))==0.0){discard;}gl_FragColor=vec4(edges,0.0,1.0);\n#elif EDGE_DETECTION_MODE == 1\nfloat l=luminance(texture2D(inputBuffer,vUv).rgb);float lLeft=luminance(texture2D(inputBuffer,vUv0).rgb);float lTop=luminance(texture2D(inputBuffer,vUv1).rgb);vec4 delta;delta.xy=abs(l-vec2(lLeft,lTop));vec2 edges=step(threshold,delta.xy);if(dot(edges,vec2(1.0))==0.0){discard;}float lRight=luminance(texture2D(inputBuffer,vUv2).rgb);float lBottom=luminance(texture2D(inputBuffer,vUv3).rgb);delta.zw=abs(l-vec2(lRight,lBottom));vec2 maxDelta=max(delta.xy,delta.zw);float lLeftLeft=luminance(texture2D(inputBuffer,vUv4).rgb);float lTopTop=luminance(texture2D(inputBuffer,vUv5).rgb);delta.zw=abs(vec2(lLeft,lTop)-vec2(lLeftLeft,lTopTop));maxDelta=max(maxDelta.xy,delta.zw);float finalDelta=max(maxDelta.x,maxDelta.y);edges.xy*=step(finalDelta,LOCAL_CONTRAST_ADAPTATION_FACTOR*delta.xy);gl_FragColor=vec4(edges,0.0,1.0);\n#elif EDGE_DETECTION_MODE == 2\nvec4 delta;vec3 c=texture2D(inputBuffer,vUv).rgb;vec3 cLeft=texture2D(inputBuffer,vUv0).rgb;vec3 t=abs(c-cLeft);delta.x=max(max(t.r,t.g),t.b);vec3 cTop=texture2D(inputBuffer,vUv1).rgb;t=abs(c-cTop);delta.y=max(max(t.r,t.g),t.b);vec2 edges=step(threshold,delta.xy);if(dot(edges,vec2(1.0))==0.0){discard;}vec3 cRight=texture2D(inputBuffer,vUv2).rgb;t=abs(c-cRight);delta.z=max(max(t.r,t.g),t.b);vec3 cBottom=texture2D(inputBuffer,vUv3).rgb;t=abs(c-cBottom);delta.w=max(max(t.r,t.g),t.b);vec2 maxDelta=max(delta.xy,delta.zw);vec3 cLeftLeft=texture2D(inputBuffer,vUv4).rgb;t=abs(c-cLeftLeft);delta.z=max(max(t.r,t.g),t.b);vec3 cTopTop=texture2D(inputBuffer,vUv5).rgb;t=abs(c-cTopTop);delta.w=max(max(t.r,t.g),t.b);maxDelta=max(maxDelta.xy,delta.zw);float finalDelta=max(maxDelta.x,maxDelta.y);edges*=step(finalDelta,LOCAL_CONTRAST_ADAPTATION_FACTOR*delta.xy);gl_FragColor=vec4(edges,0.0,1.0);\n#endif\n}", vertexShader: "uniform vec2 texelSize;varying vec2 vUv;varying vec2 vUv0;varying vec2 vUv1;\n#if EDGE_DETECTION_MODE != 0\nvarying vec2 vUv2;varying vec2 vUv3;varying vec2 vUv4;varying vec2 vUv5;\n#endif\nvoid main(){vUv=position.xy*0.5+0.5;vUv0=vUv+texelSize*vec2(-1.0,0.0);vUv1=vUv+texelSize*vec2(0.0,-1.0);\n#if EDGE_DETECTION_MODE != 0\nvUv2=vUv+texelSize*vec2(1.0,0.0);vUv3=vUv+texelSize*vec2(0.0,1.0);vUv4=vUv+texelSize*vec2(-2.0,0.0);vUv5=vUv+texelSize*vec2(0.0,-2.0);\n#endif\ngl_Position=vec4(position.xy,1.0,1.0);}" }), this.edgeDetectionMode = t } set depthBuffer(e) { this.uniforms.depthBuffer.value = e } set depthPacking(e) { this.defines.DEPTH_PACKING = e.toFixed(0), this.needsUpdate = !0 } setDepthBuffer(e, t = u.Rkk) { this.depthBuffer = e, this.depthPacking = t } get edgeDetectionMode() { return Number(this.defines.EDGE_DETECTION_MODE) } set edgeDetectionMode(e) { this.defines.EDGE_DETECTION_MODE = e.toFixed(0), this.needsUpdate = !0 } getEdgeDetectionMode() { return this.edgeDetectionMode } setEdgeDetectionMode(e) { this.edgeDetectionMode = e } get localContrastAdaptationFactor() { return Number(this.defines.LOCAL_CONTRAST_ADAPTATION_FACTOR) } set localContrastAdaptationFactor(e) { this.defines.LOCAL_CONTRAST_ADAPTATION_FACTOR = e.toFixed("6"), this.needsUpdate = !0 } getLocalContrastAdaptationFactor() { return this.localContrastAdaptationFactor } setLocalContrastAdaptationFactor(e) { this.localContrastAdaptationFactor = e } get edgeDetectionThreshold() { return Number(this.defines.EDGE_THRESHOLD) } set edgeDetectionThreshold(e) { this.defines.EDGE_THRESHOLD = e.toFixed("6"), this.defines.DEPTH_THRESHOLD = (.1 * e).toFixed("6"), this.needsUpdate = !0 } getEdgeDetectionThreshold() { return this.edgeDetectionThreshold } setEdgeDetectionThreshold(e) { this.edgeDetectionThreshold = e } get predicationMode() { return Number(this.defines.PREDICATION_MODE) } set predicationMode(e) { this.defines.PREDICATION_MODE = e.toFixed(0), this.needsUpdate = !0 } getPredicationMode() { return this.predicationMode } setPredicationMode(e) { this.predicationMode = e } set predicationBuffer(e) { this.uniforms.predicationBuffer.value = e } setPredicationBuffer(e) { this.uniforms.predicationBuffer.value = e } get predicationThreshold() { return Number(this.defines.PREDICATION_THRESHOLD) } set predicationThreshold(e) { this.defines.PREDICATION_THRESHOLD = e.toFixed("6"), this.needsUpdate = !0 } getPredicationThreshold() { return this.predicationThreshold } setPredicationThreshold(e) { this.predicationThreshold = e } get predicationScale() { return Number(this.defines.PREDICATION_SCALE) } set predicationScale(e) { this.defines.PREDICATION_SCALE = e.toFixed("6"), this.needsUpdate = !0 } getPredicationScale() { return this.predicationScale } setPredicationScale(e) { this.predicationScale = e } get predicationStrength() { return Number(this.defines.PREDICATION_STRENGTH) } set predicationStrength(e) { this.defines.PREDICATION_STRENGTH = e.toFixed("6"), this.needsUpdate = !0 } getPredicationStrength() { return this.predicationStrength } setPredicationStrength(e) { this.predicationStrength = e } setSize(e, t) { this.uniforms.texelSize.value.set(1 / e, 1 / t) } }), ea = class extends u.BKk { constructor(e = new u.I9Y, t = new u.I9Y) { super({ name: "SMAAWeightsMaterial", defines: { MAX_SEARCH_STEPS_INT: "16", MAX_SEARCH_STEPS_FLOAT: "16.0", MAX_SEARCH_STEPS_DIAG_INT: "8", MAX_SEARCH_STEPS_DIAG_FLOAT: "8.0", CORNER_ROUNDING: "25", CORNER_ROUNDING_NORM: "0.25", AREATEX_MAX_DISTANCE: "16.0", AREATEX_MAX_DISTANCE_DIAG: "20.0", AREATEX_PIXEL_SIZE: "(1.0 / vec2(160.0, 560.0))", AREATEX_SUBTEX_SIZE: "(1.0 / 7.0)", SEARCHTEX_SIZE: "vec2(66.0, 33.0)", SEARCHTEX_PACKED_SIZE: "vec2(64.0, 16.0)" }, uniforms: { inputBuffer: new u.nc$(null), searchTexture: new u.nc$(null), areaTexture: new u.nc$(null), resolution: new u.nc$(t), texelSize: new u.nc$(e) }, blending: u.XIg, toneMapped: !1, depthWrite: !1, depthTest: !1, fragmentShader: "#define sampleLevelZeroOffset(t, coord, offset) texture2D(t, coord + offset * texelSize)\n#if __VERSION__ < 300\n#define round(v) floor(v + 0.5)\n#endif\n#ifdef FRAMEBUFFER_PRECISION_HIGH\nuniform mediump sampler2D inputBuffer;\n#else\nuniform lowp sampler2D inputBuffer;\n#endif\nuniform lowp sampler2D areaTexture;uniform lowp sampler2D searchTexture;uniform vec2 texelSize;uniform vec2 resolution;varying vec2 vUv;varying vec4 vOffset[3];varying vec2 vPixCoord;void movec(const in bvec2 c,inout vec2 variable,const in vec2 value){if(c.x){variable.x=value.x;}if(c.y){variable.y=value.y;}}void movec(const in bvec4 c,inout vec4 variable,const in vec4 value){movec(c.xy,variable.xy,value.xy);movec(c.zw,variable.zw,value.zw);}vec2 decodeDiagBilinearAccess(in vec2 e){e.r=e.r*abs(5.0*e.r-5.0*0.75);return round(e);}vec4 decodeDiagBilinearAccess(in vec4 e){e.rb=e.rb*abs(5.0*e.rb-5.0*0.75);return round(e);}vec2 searchDiag1(const in vec2 texCoord,const in vec2 dir,out vec2 e){vec4 coord=vec4(texCoord,-1.0,1.0);vec3 t=vec3(texelSize,1.0);for(int i=0;i<MAX_SEARCH_STEPS_INT;++i){if(!(coord.z<float(MAX_SEARCH_STEPS_DIAG_INT-1)&&coord.w>0.9)){break;}coord.xyz=t*vec3(dir,1.0)+coord.xyz;e=texture2D(inputBuffer,coord.xy).rg;coord.w=dot(e,vec2(0.5));}return coord.zw;}vec2 searchDiag2(const in vec2 texCoord,const in vec2 dir,out vec2 e){vec4 coord=vec4(texCoord,-1.0,1.0);coord.x+=0.25*texelSize.x;vec3 t=vec3(texelSize,1.0);for(int i=0;i<MAX_SEARCH_STEPS_INT;++i){if(!(coord.z<float(MAX_SEARCH_STEPS_DIAG_INT-1)&&coord.w>0.9)){break;}coord.xyz=t*vec3(dir,1.0)+coord.xyz;e=texture2D(inputBuffer,coord.xy).rg;e=decodeDiagBilinearAccess(e);coord.w=dot(e,vec2(0.5));}return coord.zw;}vec2 areaDiag(const in vec2 dist,const in vec2 e,const in float offset){vec2 texCoord=vec2(AREATEX_MAX_DISTANCE_DIAG,AREATEX_MAX_DISTANCE_DIAG)*e+dist;texCoord=AREATEX_PIXEL_SIZE*texCoord+0.5*AREATEX_PIXEL_SIZE;texCoord.x+=0.5;texCoord.y+=AREATEX_SUBTEX_SIZE*offset;return texture2D(areaTexture,texCoord).rg;}vec2 calculateDiagWeights(const in vec2 texCoord,const in vec2 e,const in vec4 subsampleIndices){vec2 weights=vec2(0.0);vec4 d;vec2 end;if(e.r>0.0){d.xz=searchDiag1(texCoord,vec2(-1.0,1.0),end);d.x+=float(end.y>0.9);}else{d.xz=vec2(0.0);}d.yw=searchDiag1(texCoord,vec2(1.0,-1.0),end);if(d.x+d.y>2.0){vec4 coords=vec4(-d.x+0.25,d.x,d.y,-d.y-0.25)*texelSize.xyxy+texCoord.xyxy;vec4 c;c.xy=sampleLevelZeroOffset(inputBuffer,coords.xy,vec2(-1,0)).rg;c.zw=sampleLevelZeroOffset(inputBuffer,coords.zw,vec2(1,0)).rg;c.yxwz=decodeDiagBilinearAccess(c.xyzw);vec2 cc=vec2(2.0)*c.xz+c.yw;movec(bvec2(step(0.9,d.zw)),cc,vec2(0.0));weights+=areaDiag(d.xy,cc,subsampleIndices.z);}d.xz=searchDiag2(texCoord,vec2(-1.0,-1.0),end);if(sampleLevelZeroOffset(inputBuffer,texCoord,vec2(1,0)).r>0.0){d.yw=searchDiag2(texCoord,vec2(1.0),end);d.y+=float(end.y>0.9);}else{d.yw=vec2(0.0);}if(d.x+d.y>2.0){vec4 coords=vec4(-d.x,-d.x,d.y,d.y)*texelSize.xyxy+texCoord.xyxy;vec4 c;c.x=sampleLevelZeroOffset(inputBuffer,coords.xy,vec2(-1,0)).g;c.y=sampleLevelZeroOffset(inputBuffer,coords.xy,vec2(0,-1)).r;c.zw=sampleLevelZeroOffset(inputBuffer,coords.zw,vec2(1,0)).gr;vec2 cc=vec2(2.0)*c.xz+c.yw;movec(bvec2(step(0.9,d.zw)),cc,vec2(0.0));weights+=areaDiag(d.xy,cc,subsampleIndices.w).gr;}return weights;}float searchLength(const in vec2 e,const in float offset){vec2 scale=SEARCHTEX_SIZE*vec2(0.5,-1.0);vec2 bias=SEARCHTEX_SIZE*vec2(offset,1.0);scale+=vec2(-1.0,1.0);bias+=vec2(0.5,-0.5);scale*=1.0/SEARCHTEX_PACKED_SIZE;bias*=1.0/SEARCHTEX_PACKED_SIZE;return texture2D(searchTexture,scale*e+bias).r;}float searchXLeft(in vec2 texCoord,const in float end){vec2 e=vec2(0.0,1.0);for(int i=0;i<MAX_SEARCH_STEPS_INT;++i){if(!(texCoord.x>end&&e.g>0.8281&&e.r==0.0)){break;}e=texture2D(inputBuffer,texCoord).rg;texCoord=vec2(-2.0,0.0)*texelSize+texCoord;}float offset=-(255.0/127.0)*searchLength(e,0.0)+3.25;return texelSize.x*offset+texCoord.x;}float searchXRight(vec2 texCoord,const in float end){vec2 e=vec2(0.0,1.0);for(int i=0;i<MAX_SEARCH_STEPS_INT;++i){if(!(texCoord.x<end&&e.g>0.8281&&e.r==0.0)){break;}e=texture2D(inputBuffer,texCoord).rg;texCoord=vec2(2.0,0.0)*texelSize.xy+texCoord;}float offset=-(255.0/127.0)*searchLength(e,0.5)+3.25;return-texelSize.x*offset+texCoord.x;}float searchYUp(vec2 texCoord,const in float end){vec2 e=vec2(1.0,0.0);for(int i=0;i<MAX_SEARCH_STEPS_INT;++i){if(!(texCoord.y>end&&e.r>0.8281&&e.g==0.0)){break;}e=texture2D(inputBuffer,texCoord).rg;texCoord=-vec2(0.0,2.0)*texelSize.xy+texCoord;}float offset=-(255.0/127.0)*searchLength(e.gr,0.0)+3.25;return texelSize.y*offset+texCoord.y;}float searchYDown(vec2 texCoord,const in float end){vec2 e=vec2(1.0,0.0);for(int i=0;i<MAX_SEARCH_STEPS_INT;i++){if(!(texCoord.y<end&&e.r>0.8281&&e.g==0.0)){break;}e=texture2D(inputBuffer,texCoord).rg;texCoord=vec2(0.0,2.0)*texelSize.xy+texCoord;}float offset=-(255.0/127.0)*searchLength(e.gr,0.5)+3.25;return-texelSize.y*offset+texCoord.y;}vec2 area(const in vec2 dist,const in float e1,const in float e2,const in float offset){vec2 texCoord=vec2(AREATEX_MAX_DISTANCE)*round(4.0*vec2(e1,e2))+dist;texCoord=AREATEX_PIXEL_SIZE*texCoord+0.5*AREATEX_PIXEL_SIZE;texCoord.y=AREATEX_SUBTEX_SIZE*offset+texCoord.y;return texture2D(areaTexture,texCoord).rg;}void detectHorizontalCornerPattern(inout vec2 weights,const in vec4 texCoord,const in vec2 d){\n#if !defined(DISABLE_CORNER_DETECTION)\nvec2 leftRight=step(d.xy,d.yx);vec2 rounding=(1.0-CORNER_ROUNDING_NORM)*leftRight;rounding/=leftRight.x+leftRight.y;vec2 factor=vec2(1.0);factor.x-=rounding.x*sampleLevelZeroOffset(inputBuffer,texCoord.xy,vec2(0,1)).r;factor.x-=rounding.y*sampleLevelZeroOffset(inputBuffer,texCoord.zw,vec2(1,1)).r;factor.y-=rounding.x*sampleLevelZeroOffset(inputBuffer,texCoord.xy,vec2(0,-2)).r;factor.y-=rounding.y*sampleLevelZeroOffset(inputBuffer,texCoord.zw,vec2(1,-2)).r;weights*=clamp(factor,0.0,1.0);\n#endif\n}void detectVerticalCornerPattern(inout vec2 weights,const in vec4 texCoord,const in vec2 d){\n#if !defined(DISABLE_CORNER_DETECTION)\nvec2 leftRight=step(d.xy,d.yx);vec2 rounding=(1.0-CORNER_ROUNDING_NORM)*leftRight;rounding/=leftRight.x+leftRight.y;vec2 factor=vec2(1.0);factor.x-=rounding.x*sampleLevelZeroOffset(inputBuffer,texCoord.xy,vec2(1,0)).g;factor.x-=rounding.y*sampleLevelZeroOffset(inputBuffer,texCoord.zw,vec2(1,1)).g;factor.y-=rounding.x*sampleLevelZeroOffset(inputBuffer,texCoord.xy,vec2(-2,0)).g;factor.y-=rounding.y*sampleLevelZeroOffset(inputBuffer,texCoord.zw,vec2(-2,1)).g;weights*=clamp(factor,0.0,1.0);\n#endif\n}void main(){vec4 weights=vec4(0.0);vec4 subsampleIndices=vec4(0.0);vec2 e=texture2D(inputBuffer,vUv).rg;if(e.g>0.0){\n#if !defined(DISABLE_DIAG_DETECTION)\nweights.rg=calculateDiagWeights(vUv,e,subsampleIndices);if(weights.r==-weights.g){\n#endif\nvec2 d;vec3 coords;coords.x=searchXLeft(vOffset[0].xy,vOffset[2].x);coords.y=vOffset[1].y;d.x=coords.x;float e1=texture2D(inputBuffer,coords.xy).r;coords.z=searchXRight(vOffset[0].zw,vOffset[2].y);d.y=coords.z;d=round(resolution.xx*d+-vPixCoord.xx);vec2 sqrtD=sqrt(abs(d));float e2=sampleLevelZeroOffset(inputBuffer,coords.zy,vec2(1,0)).r;weights.rg=area(sqrtD,e1,e2,subsampleIndices.y);coords.y=vUv.y;detectHorizontalCornerPattern(weights.rg,coords.xyzy,d);\n#if !defined(DISABLE_DIAG_DETECTION)\n}else{e.r=0.0;}\n#endif\n}if(e.r>0.0){vec2 d;vec3 coords;coords.y=searchYUp(vOffset[1].xy,vOffset[2].z);coords.x=vOffset[0].x;d.x=coords.y;float e1=texture2D(inputBuffer,coords.xy).g;coords.z=searchYDown(vOffset[1].zw,vOffset[2].w);d.y=coords.z;d=round(resolution.yy*d-vPixCoord.yy);vec2 sqrtD=sqrt(abs(d));float e2=sampleLevelZeroOffset(inputBuffer,coords.xz,vec2(0,1)).g;weights.ba=area(sqrtD,e1,e2,subsampleIndices.x);coords.x=vUv.x;detectVerticalCornerPattern(weights.ba,coords.xyxz,d);}gl_FragColor=weights;}", vertexShader: "uniform vec2 texelSize;uniform vec2 resolution;varying vec2 vUv;varying vec4 vOffset[3];varying vec2 vPixCoord;void main(){vUv=position.xy*0.5+0.5;vPixCoord=vUv*resolution;vOffset[0]=vUv.xyxy+texelSize.xyxy*vec4(-0.25,-0.125,1.25,-0.125);vOffset[1]=vUv.xyxy+texelSize.xyxy*vec4(-0.125,-0.25,-0.125,1.25);vOffset[2]=vec4(vOffset[0].xz,vOffset[1].yw)+vec4(-2.0,2.0,-2.0,2.0)*texelSize.xxyy*MAX_SEARCH_STEPS_FLOAT;gl_Position=vec4(position.xy,1.0,1.0);}" }) } set inputBuffer(e) { this.uniforms.inputBuffer.value = e } setInputBuffer(e) { this.uniforms.inputBuffer.value = e } get searchTexture() { return this.uniforms.searchTexture.value } set searchTexture(e) { this.uniforms.searchTexture.value = e } get areaTexture() { return this.uniforms.areaTexture.value } set areaTexture(e) { this.uniforms.areaTexture.value = e } setLookupTextures(e, t) { this.searchTexture = e, this.areaTexture = t } get orthogonalSearchSteps() { return Number(this.defines.MAX_SEARCH_STEPS_INT) } set orthogonalSearchSteps(e) { let t = Math.min(Math.max(e, 0), 112); this.defines.MAX_SEARCH_STEPS_INT = t.toFixed("0"), this.defines.MAX_SEARCH_STEPS_FLOAT = t.toFixed("1"), this.needsUpdate = !0 } setOrthogonalSearchSteps(e) { this.orthogonalSearchSteps = e } get diagonalSearchSteps() { return Number(this.defines.MAX_SEARCH_STEPS_DIAG_INT) } set diagonalSearchSteps(e) { let t = Math.min(Math.max(e, 0), 20); this.defines.MAX_SEARCH_STEPS_DIAG_INT = t.toFixed("0"), this.defines.MAX_SEARCH_STEPS_DIAG_FLOAT = t.toFixed("1"), this.needsUpdate = !0 } setDiagonalSearchSteps(e) { this.diagonalSearchSteps = e } get diagonalDetection() { return void 0 === this.defines.DISABLE_DIAG_DETECTION } set diagonalDetection(e) { e ? delete this.defines.DISABLE_DIAG_DETECTION : this.defines.DISABLE_DIAG_DETECTION = "1", this.needsUpdate = !0 } isDiagonalDetectionEnabled() { return this.diagonalDetection } setDiagonalDetectionEnabled(e) { this.diagonalDetection = e } get cornerRounding() { return Number(this.defines.CORNER_ROUNDING) } set cornerRounding(e) { let t = Math.min(Math.max(e, 0), 100); this.defines.CORNER_ROUNDING = t.toFixed("4"), this.defines.CORNER_ROUNDING_NORM = (t / 100).toFixed("4"), this.needsUpdate = !0 } setCornerRounding(e) { this.cornerRounding = e } get cornerDetection() { return void 0 === this.defines.DISABLE_CORNER_DETECTION } set cornerDetection(e) { e ? delete this.defines.DISABLE_CORNER_DETECTION : this.defines.DISABLE_CORNER_DETECTION = "1", this.needsUpdate = !0 } isCornerRoundingEnabled() { return this.cornerDetection } setCornerRoundingEnabled(e) { this.cornerDetection = e } setSize(e, t) { let i = this.uniforms; i.texelSize.value.set(1 / e, 1 / t), i.resolution.value.set(e, t) } }, eo = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAAAQCAYAAACm53kpAAAAeElEQVRYR+2XSwqAMAxEJ168ePEqwRSKhIIiuHjJqiU0gWE+1CQdApcVAMUAuARaMGCX1MIL/Ow13++9lW2s3mW9MWvsnWc/2fvGygwPAN4E8QzAA4CXAB6AHjG4JTHYI1ey3pcx6FHnEfhLDOIBKAmUBK6/ANUDTlROXAHd9EC1AAAAAElFTkSuQmCC", el = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAKAAAAIwCAYAAAABNmBHAAAgAElEQVR4Xuy9CbhlV1ktOvbpq09DkiIkUBI6kxASIH0DlAQiIK1wRfSJTx+i4JX7vKIigs8HXpXvqVcvrcC9agQ7IDTSSWgqCQQliDRBJKkkhDSkqVPNqVOnP+8b//rH3P+eZ+199tlznVTlvVrft7+1T7OaueZY42/m37QALKNk2wHg1pITlB17mC+Pp11W3X/LHyT32vhg48/5SOv+PnwpsHA70JoGlueB1iKApeqzvOzn44GatTB76Xzhd7suBR7+WWADgDEAwwCG/L54b/poDLrHuvvm70Z2Avhsc+PVcxscBU8F8C8ADg5+ipIjD/PlGwfgju8B924E5seARUfLsiNmqQW0IjL8+7L2NYD/7COBzfcCm+aB8SVgdAkYIRCXKyDax4EdAanL5PuNPllNvXDlAHwFgP8AcC2AhRIoDXbsYb48dl5WkVFTE3LGDcC9m4CZCWBuFFgeAZaGAYJQQCRqDHT+McJrVb8zwATUXH02MHYfMHEIGFsAxgjApQqACYQORjtd/B7Axt/z79sC0+cMPgjjlwPwVwHcA+DfAHzTxcVgWBroqMN8+cYBeM71wH0TwKExYHYUWCIAHYRLTlkCYgcIBcAgU/n3qy8GRu4HRgnAOWBkERhddPAJhGJDBxkvw7cqimr+zFM/ZLnZF64cgL8BYD+AWwB8x/dlWuWagHiYL984AJ/0RWBy1AE4AizyM1yxYAcTigW55xMbAkxEiwEdkJ/ZCQxPAiOHgBECcKEC4TBZcKkSv+mTieNcNPNC26mLNsj45QD8LQDTAO4GcJt/7iw2bfoG4WG+vAGwm9ExiEg69zpg/wgwPQLMjgALzn4E4aIzoJjQ9g4024uygkj+pyuAoX0VAIfngOH5NgCHMhAm8Sv2y3XDZeBhNIp8OzJE8OsBzAKYBHAXgDt8/4O+MVT0j4f58o0D8Pxrgf3DwMwIMEPQEYRkNwfgsuuDZLskip0No0gWMD/9HGDoADAkAC4Aw/wsAgZAgs2Z0ABI0GU6IVmKv+f28KDnHxkA/G0A8y6G73N9kOCjXnh/Ebb6OvgwX75xAF5wLTA1VIHPADgMLDj4yIA5AAm6aCUnv4oz46eeDwxNAUMzwJAz4BABSNDFTwSfg7DDKHE23MG5PqIY8A1u/dINs9dBdy8AgnGPM2NfUBrsnw7z5RsH4IXXAAcJviFgluAbygBINnSLWOAjGxJ4pgOKDV0v/OSLKp8iGXBovhLBBOCQM2ACoTOhnYrAdItYbCij5JFzRyIAqRccAnDAQUjg6UNQ7hsMXP0cRQAexss3DsCLCECCLwCQzMcPwUi2MwAScAKbfnY/YRLFQ8DHX+IAJAMSfDkAF13kLvleIjhjQQHxUVS3jjgGpKeeNzYVQEjgUS8k+PghONdhIwAP4+XXBYCHKIJbwJyDTgaIAdCBJx3Q2M8tYAHP9m4df/ylQOsQ0JqtRLCx30K1wtLBggScQOgsKBGcWHAJeOwRC0BSM1mQIKRbhh+Bj98JQP6t4U0APEyXXxcAEnxkQAFwoVUxID9kvQg+c1C7vidRbIDkc24B//hTQGumDcCWA5DgMxASdNIFBUI5pCML8v8API5zfEQx4BudgqiczviSnJhQwCP4BMCGl+wO8+U7AJi/W4O4YS6+pmK/2ciADsAOBhTIIiAJnPB7AvNjP+0AnANaYkAHX2JBAc+tYaJXOqBZv24Vc386XW5dtkHGW+4HFAJonpOe+YYQZAShgKjv3PNvPQaxVoI8zJdfFwASfPzMUwS3Kt1v0UFIlos6oDFdAGFcliMAP/ryAEAGNwQRnDOgLbdlIEwrIs6AZ/QgkMMHQF6ZAKQcJAsSYPwIeAIk9wJgoPK1gi7+PwF4GC/fOAAvIQPSs0URTPBJ/Pp3GSEGRHfBCIQ0xowBtUbcAj7ys5X4Jfu1HIAGQrIgQRXEsAFQIORDFhiDY/rMHmrU4QUgR08AkgUjCAW6CD6CkwBsAIQC4GG6fPMA3OXiNzCg2I9gNCMksmAAoemDzoimFwL48M85AKkiuQVMAAp8CYRRDAt8GQiJ67N6GJODAXAHlsGguscA2AJg1IPGYmxOpBxFWkRN9LsATgIwXnNs/v/5z/9XCf8BO3YAtxbc/46/KDt+5+ea1Yku2VUxHz/z0v24FwMGK1gWsK2OUUxHHdCBeRUB6OxHABr4ZICIBd0QWSF+XRdMTAjgCdTrG9cBNwE4F8CpDkICyYLGsuhFt6zs+gISwUen8zEAjgMw4cfx2H6O/90yAFo84Cbg4ID3/9TfLTt+5+ebnRABkODjx0SwPi5ec/FrYpmqSAxM8Dn60CsqAFI6GfhqAMiDE/gokmvEr0C4PgDkBQm40wE8zMFEUDKEVoxIMLl/KS73mE7H9d+vcKHQQcjwW0Yu9nP8m8sAmOIBuWY6wP2/4s0ezjjg8TuvaR6ABJ70vxUApGrm7EbGE+i472BAB+WHfqHS/eoAaEwY2E9+wLSXTqhI7CXgnB6LCoOJ4BiST+hTnG0HcCwAglCx3ARoZEVFXnBPp/O/A/hXACc7CPs9/i1lAOyIB+RDX+P9/+pbQjjjAMfv/PL6AFDs1wFAgs/9fgKfgdE/ZEpuiQlbwAde6QAMBgiRmsSwA9BY0JfjovGRDBMH4TlcXGhcBOc6HkF0gjPhZgchxTLZMAci/04W/B6Ab3t09EPXcPyflgFwRTwgJ2MN9/8bf5qFM67x+B/aW4XQz42FeL0YrRyikztUFw0704mf9kXgxhOAqc3AAsPyRxxQCs/PdXOFY0W1KHy3QIUGtx+6vdnx1vsB+dsTncm2AogglFgVEAlUWrOMB2RyEmMCGQ/Y7/HvKns6tfGAnJQ+r/9b76oJZ1zD8WdyQjYBh8aBhVEHjELouQ8ukQ7VRSCJAALwkr+sALhnGzDD3JAJYJHg9uhoi4bx8ytkWUtvHT/7+Zc4dw1uZ3612fH2dkQf7yxIEEockwkJQn4IQoq8unhAhmPRKKFx0uv4K8ueTs94wD7u//VX9ghn7OP4c+4G7h8HpseB+dF2AKlFLwuAIZ8jD6NPrOhAffmfA9/ZBuzZCkyRWSeqBCWyoYGQ5yQrBpDbum/ME1HoPo0XEkSD2zlfbna8q6+EUJcTCxKEtHL5EQjP6BEPyIgYAZBvYt3xHyx7OqvGA65y/7/9wVXCGVc5/sl7qxD66dEqiYgRzAqhN1A4CBNAAlDyAFI+iZ9/N3DLJuC+jcDUBmCWyUnOrmTYCMIOkNclLg0B8/RsNLg9+UvNjnd1APLmmQpFHyEBROuWACQT8nN+H/GAvY7/VNnT6SsesMf13/CpahGnZzhjj+PPmwX2MYdDIfQexWyBAwEUOQDrRDN/98p3A7dvAO6fAA5sqHJDBEAyoUVGkwEd6HR12XU4kwzfl6fCXTZzjy57vvnR513X7Hj7AyDvggAUi9EyFgiZqNxPQF6345nOWbD1HQ/Y5fpvuLa/2+82/vNHgAPDFQDnhoF5j2C2qBWCI8bw1eRw5CL5l94L3DEOTI4DB8Y9OWmsEu/zBJ3rgsaybqBob/7A4C7jtWcooRrczr+u2fH2D0AOQgAUCxKEP7aGgLy64+m6KdjWFA9Yc/03/Osa4glrjr+AupqHz1sEs0cxG0BC9HIePLoit9eNkVf9L+DuUWByDJgaq4ybGYLPAWgiXmLedUE7dwC7saL7CqfPKXi4NYdaykCD410bAHlDEsNiwZ9wAPYbkJcfz6T2gm3N8YDZ9d/wHxUA+739fPwXPrSKYGb+BuP3jAFDElFH9HIWwbzCIGkBr/or4J4RYO8oMOW6ZVcAuvi1Cgoha04BCwT5gfMKHm7NoRde2+x41w5A3hQZkADk5+cGiAeMx3+/7AENFA8Yrv/G71cAXFM4Yzj+otOAaQLQA0gZxaIIZtMDFTigKJV8H9Iq6aZ59ZXAvSPAvpEKgBTtBODcSCWCZeRYtpzrmLyeGNCAyFl1v+Hei8qeb370Rdc2O97BAMi7EgB/2QG41nhAHU9LuWAbOB7Qr//GPRUA13r7Gv9FZwIMoVcEswEwfDoimEP0shKKtIphaZQAXv1+YM+wA3DEdcvRKkGJADQQEsQuhi1Tjt95vBsh5nx2IO59SsHDrTmUOStNjndwAAqEry0IyCMICkOyiuIBNwBvPFQQT7gBuPjc9oRYAIHyOEL4vIFEYVNaOou5vCGE/tV/A0wOVcnpzI47NOri3QFIBpSeaSDUdYLOSWvYImSGgftpJDa4MWJbAGxivGUA5MAOc0Be6eVLj7/4Mk+hzCOYPYpZDBiNkLh+G/M3yFyv/ltgL3W3YQfgcFUhgRY2PwY+Z7/EhAR1SFyXCOb57r28QfQBsJQBMn5D4y0HYLPje9Cd7RIC0PM3EiMofF4gVCBp1P840ix/gyz56r+vAMjk9Gl375iB4+CzveuZdLkkEPJ8ZEfX/6R73vOjzT5Si9hucLxHAVg4PwJgRwh9CKOXK8YA4ZEqKZXSQWh5P+5AftXfA/uGKvYjCKn72cctbFrZNECka5L5CPwIPtMH3TVz17MLB5gdLgA2Nd6jACycHwLQxFEUSR5ASvARDB0h9AQb9bXIgCGk6lUfAPYTgEPAITKgg1BObk58srTJgG58WMkWMaAbQQT1nc8rHGANAJsc71EAFs4PAagQestgC1lsBJ4BMCSOK6dDUcwqqaFiQr/0QeAAAdjy+jBiQQeeMSBZT3nCPUDIa9z+/MIB1gCwyfEeBWDh/BCAeQSzgkjFfGLBBD5nxQ4DxN0wv3hVxX5TBGDwL5obxvVA5YqYL5BeMLd66YYxJpRB0gK+96LCAdYAsMnxHgVg4fwIgMrhUPKQ2C+Bz0PmBTqBMQehAbDlIjj4F80KJguSVZ0FuXpjoCOgXawLjALhbT9eOMAuAGxqvEcBWDg/l1IE05Ed0ygZnyHdz0VwCqEPIfNyx0QQvvLDFQCp+8nfZk5und8tXwIgWcHSNX0N2CJmnAl3v6RwgNnhl17T7HiPArBwfghAS7mV/hey2JS9FvM3BLpUUi1YwDRMXvkRYJoAlAh2l0dcZ04s6JUTDIjyBcrl4yDc/dLCAdYAsMnxHgVg4fxwKVwJgGEJNmWtxpQMpX9on2eRhVA+O56AjMfnP+e3Xvf3NwG4xIPTleiY55bpGh6UbafNU0l0z0p+5Jh5HqYJ6b51nP6XP8cx12XNHQVgIQB/bFPVg2OC7Q+WgVFWng/FvtWLI06uWh5oguKEcXVS/9sEAF//VGD7t4ETDgJbF4CNi8CGZWBs2fPL/H6Vwp2KEtVk4fJ+v/EIYPN9wKa5qu+IncfPwXHVZe/aOL3EbwS7xv8A1rQvnO0j8PArTgTGZ4BxFv9mIxhOCGsv+0OPYDRghcLfkWkEuq0+G00x4OtfDGz+d2DbHmDLjL8si8AYP/7CGIAiEEMTG92zXqSbH+d9R2aA0XnvO+JjthiIrOVDHHPOkBrzUQAWAPsZp3oPDpa/Xag6EVkLBK+5rAnJC3/nYk/APD704WiEAV8OTHwX2LQH2DgFbJgFNrBhjd8r79deGoEwsllgNBOzy8CdjweG9wBj08AIAci2D6HafmyAk4/Z7SJ72hGYRwFYAMDLTwOGp4FRFgD3HhzqRGQiyeurqOdG6r0Rm8IEZjzRlkiqCWoEgK8Axm4BJu4HJhyAbFhDxmbDGnZO4j0SgLGDkpibgEq66TJw/1nA0F5gdLpq+zDqFfd5LMeWqu5HNST0uJOIllg+qgMWgI+HPv0xwLA3gWHpW2sC441gCECbmKziaGrnUdMO4aHeh6MxAP4SMHI7ML4HGD8AjHvHJGNAgpDgY/ck3stipRemvVhc+uASMPUEYGh/9dIRgGx8Y+MNbR/00uVtH0wEx94j/v0oAxaA8Ed+GBieAYZZg5kADC0QWGOFzGJlcGPzl1BxNLXD8sk4xftwNAbA/wwM3wGMUmxOOQBnHXzetIYvibonmSiuYTNjriVg7glAiwBk0fNZH6+PmX9P6kfNmCXGpftJ7TgKwBIAnln14BAAYxMYm5C6RjCyCoOyr0qkD/c+HI0B8DXA8N3AyCQwesD1VQKH7EcASm1Q+y4CkN9pUKiVF5nLvy+fBbTUd8QBaH1HvNBROiZvfsNnrF4kcvPwpdsBLBeU18Nf7AB23Dp4ecHC8oBgUlJJecLS+7+WOpE3gbE+HKw+yoevCYkMGKqPJrdEKARutaFYRs1fiEZ0wP8CDN8LDO8FRqYq3W10pgKgfYLaYCzootgA6KXaTA90y374TKB1sBozy77xHFZ536utRgAmEaw6g5kUSFZwSXnA330qsOlfgHMPDlZesLA8IOjoLypPWHj/11EnCiVwkz7kAExtsGraYUWdSDX5TmsagL8KDBGA7Bd30JsW0oWivnEOQNP7yGTSBR101AlZSUtGyfgZDkCWY1HnJdcBVe6325hTvelg2CQjZNDygG/2An0j1wKnL6y9vGBheUC8prQ8YeH9X39OVQSc7Mc6fCaKvAeHdCIVf4yMYCynTpX+nb97NJmlSQb8r8DQHm9YOFUZTKOzoXGhs6AxF0HIexcLBvWBuiHN8s2ne98R3qc6L4Vyb2oBVjfm9MIFHbjDCh6kPOBbQoG+oW8CO5bWVl6wsDwgfr20PGHh/X/1iaEIuDcCTIW/1Q4rFv8OnYiW3c+W2iKwUjKbyjQNwL1uuR6sAEgDgq1brXOmV81PxhNB6DUDBSYzQJwFtz623XcktX1Q1VWKaTF/zZhVazBVYA1tX5MazsGvobwe/jQr0Ne6BTh5uf/ygoXlAfG60vKEhff/rSe1i4DnTWDUACY1guFTDqLYdCBvf6DJYSMYATBfOx1kLfj1v1axH10nQ3Sd0GUkBnTfpemtBJgseIKQAHLQcVxa2TnuMW0Aqui5es8xBIegVdVVE8VhzHnLh65WMB9An+X18K6aAn2tO4ETl6vqbKuVFywsDwhevqg8YeH93/Rk70JE90nowxZbIJjvS3WYNSGUwGHJTpPxwwcbBuBrgRYBeKACn7VtpdUu/c0NJxO9BIxcKu4TTODzbkonPLoaL0vyUQRb2y8HsL1ckfWzMeuFi40Qezqi+yiPhyt7FOjr6/gCFwgP7Xb5vssTFt7/nQRg6MGRWmDRoeyTlpgw68GRTwgZgo1gGmXAX6/8dtaylSKY/koyID9BhzML3q1gAos2AcOrZYSoq/pJp1VtODRm9Z3LS/7WjVkvXOzEtOpKyGrlAT+4SoG+VY8vBGCvy/dVnrDw/vee65NBJiAjBIVcAJQjOm+DkCZEeiGAMw6sAwDZsJrAdhFM9rPGhd4904Co5oVuCZPV6kD40Ec6+9W8dBTBsfdc3nkpvnB82fp2RPcs79dHgb51LA9ofsDV6vut5/3PnxcAmLVBiDqgevDaJLkYrpuQxzcNwN8AWgIgRbB8loEBzXDwl4cGiDGft58SCOWGedgjvOJ+bPvgRkiuA+ZjzhnQQOiFNVbloa7l/fos0LdO5QENgEXlCfs8Qbf7HyMA3QVjYihYhLENgjX9y/qwxQmRU/asfd0ZcLU2CHVGyusJQLKfVi98CS12T5f7iECkHpsMkAhCF8+nshWH2I/jXsOYO144GV/9ApAIrS3vt4YCfetQHtAA2G+/4PW4/2PPbzMgmUMi2NoeSCRxIt2/FvuxWURIWCXg357gfTjEDNIHnTRXRCpH5ugKwGl3HpMBXQc0v6WLYVm/5limj04rG762K2uYY9jBkr9+rI03NL5ZbczS/dJ+LQyoga4o77fGAn0NlwdMAOy3vl/T938KAcj121z8Bn+Y9eWQJRz8Y6kNagDh2ey5EvxjxQD8TWdAuneCCO4An1vw5vdzQMmdktwq7pLZQR+dM34+ZumAxvY1Y04uqOAJ6FsExzeto7zfAAX6GiwPaLWR1lrfr8n7f/Rl3QGzmsis+/uO71V9OFgP2gpPhgr7TGRqRUT6dyvr4aIs/pm/2zVUNbBSv6G8e5pEv0Cvec7Po7+bTtjlBRlkvAMBkDeQyvsNWKCvofKACYBrre/X1P0/oWEAnnFD1YdjhtXxR73mX10FfCHHE9pVWcGAI/S0gKsfA2y+twrFZw6Hxf/F0Pk8Ri/kpGSnMuDx5T0iACgQHioo0NdAecBUHW6QdsV2/cL7v/Cyqr5gnc42CCOcfX1VIZ/V8We9IDmTzVXwPDJiXuKXPxtDBma8+lzP4WAgKkPxCUAPE4v5GzEuMX0PYJPLhB6FJsc7MAMmkVxaYC/K9gG+F1++8AQ7Gwbgk78I7GFpXgIwFiRXOwaJZPUbiR0yCUDRk+cHf+YpwMj9HgfI8ClGPyvsSiH0WSKRuYlitLb/zHM/JOSs5C/YIC9cMQDZr/dwxgOW9gtGYUBi0wA8l304vDQvAchilFbpIBQhZ7Ejq6ZQ0/Yhil8y4j89Axie9DAsD6FX9HOK3QtROTFkviN83kG4felIY8DCeLrSeMDSfsEovAECUFsTjHD+tcB+tkFgcXKvBRir7qtFl9owmO4Xy/1G3bAFfPrZHorFNWBFwHjQAFctIghj2kBarw06If/+MM9ZqTN6DgsDojCerjQesLRfMApvoGkAWh8Ob/tgAPSKWCp8ngNQtadjmTdltvNvn3peFYhgQQgh+iUmEaUAUoXM1yRLmWuFLaE9Z+XIAWBhPF1pPGBpv2AU3kDTALzwmqo6qtVh9kJErAudABia38TC5wJgS2xIhAwBn3yhByL4EhzXfRXxYsDTJ4IvrNN2JFMxZcBzVo4cABbG05XGA5b2C0bhDTQNQLZBYH1AVsQSAAU+imI1obHyblnjG/kJk3U8BHz8xVUQAhnQIl5CyNgKAGp5LKSSCoAySh5Jj79vTagcxUaIBeRNe79g9gq+DXig4wGzy+PONfT7RWFA4noAkGXZVAhcBckJQgNgrLiaNb3paIDo1vHHX+oA9LQBi4DxJcOUPJUnTgU2NJUyROs8irGARxQAC+PpCtsFd40H/AEf0gMQkLgeACT41PiGoLOKqyrJq3K/Ya9mNyr5FusN/uPLPIeDa8Bc+w3rtyl4VFHaMZc3i9RWBM9jjzgAFsbTFbYLRmm/YBTeQNMAtD4cBKDXBTQGdAB2MGBo8SCLmEuS1AFVAJ3A/NhPt0PoCcA8bSDG76XI7aySg6JYuGfKwJHFgH0E5B3ueMCe/Y4L+xVHAOZ+9EHcEgQgwbeiEYx6jwTdz4qfu7EhEJqxGqruf/RnHIAEnxgwBM0aC8aUAYWNBRCmoIll4HTqO122QcZbrgMWxtMVtgvuOx6wa7/jwhtoGoDWh4MBJ16WN4lfr8AqI0TVV1O1fa9BbQzovkAy4Ed+NgCQUSxZCFWvCOaOFREXyUwZOPIA2GdA3uGOB6wPaOz+QPv5S+MA3OXiN9aclghW+d3IgupBF2pPqxcxGenDPxfSRh2ASiKKiVP2PaZScvAKoA0VDc6cOlIB2GdA3uGOB1zR77iwX/F6AFB9ONSOQW0frA50sILVcckWJyIDSgwPAVcJgFbYuZ3FJvAlEHbJ3IsgJLGedeBIA+AAAXmHOx6wo99xYb/i9QKg2iAIfDJEJHqj4SExbEty0gkdhB/6P9oZbBZIGiKYVb9GKaN50lRHBLOvhDxh/5EKwDUG5B3ueMB2QGM/grb7/6wHAPNGMAY+GSGUjC52VX2f2CD4+HO0gqkZfegXKgBaHkcWtS0AWii9xG1ImrLlN5XR8L8fmQD05BVrmEENmpYSP9QX+KHiqj2/82+HqqDWwnbBRfGATdzAegGwru2DpRq7Mzq2fpAf0Nq0Rl2wBXzglZ4yUAPAmDSVWDBPHQjLcgTqOZ6zUvdKHh4ruDCerox/Dnu7YqwXAC1NI/QcEQuK6WK/kdgCTGC0PYAP/KIDMBgglq+hIkrOfsaCviLSofcJgJ5AdM7kkSaCj/HqQKVIGvD4swF8bcBjmzjsaQ2H5D/6acBd9wALB4DFWWB5AVherMp4GKIYEOp7+26UF0aSfT/xYuDG7wDjrIpAERytXf2vajj7ueryQXSFl10K/ON3gIWDwCLvjfGB8Z54O+Ee4ve6513uB2R1yzsqC+twbC8HcNVhfAeaBuDP/TvwtS3A/ePAIfYFVlPq2HHTuyulZCTlhbjhETF5yxTQGgPGhoHhIWC4VSXGD3n0tLkMHXHxu+YyB+MlPwDuZs5K6FlsbCzdVO9DuKfkHM8AEkP7B8fOkwDcD+B7np42+JkGOvKdAL4E4K8P0zvQdET0b14D3DgB3D0B7B8HZka9WzrD88N6sFm+YcUjrn7E1ZDvMtF9DBgeAYaHgSGB0PNHCD4BLwLRsByAyX/ij0/dDUxuqlIG5hix7eFhvLcOVUAtyPSydAFmOQNe6EYGV/9ZESiKgIEgtbaD/gHALQC4ovY5r5KwtjOU/XfTAHzzLuCmIeDuMWDvKHBwpMoN0WQzNtAaYSs0K4ZlOSAjGG9kPjCBRwZ0ABKEBJexYAZEAU3A7Oi1BeDym4EDnjQ1TwCGWMW8MXcKks0YOyZNlQOQjcgYIUHllEzYQ0ktm+r6oz8G4F4AXwXwRd8/kO9A0wB8y65KmPxgGJgcqYJTKYpTv2CCzyddQJRDOjKivn+Deh8BF8BnwBtaCUA+YYEyAU8h+c6Az9gNHHRmrgOgmDA3jHQ+iWupCeUAvNSrA9HNwqx+muk9nJVNg/CTfrmbAPwbgK8D+PcHkIibjob5o13A3XypWsAkG1cPA9PDFQDZM1id0i1KxsWfOrKnAFXlifCFFMMRcASigOcs2MGAIfE9iWXplS6On7UbmPaUUTXQrgsVMzcRj5Folg2V5ayUA5BWYKwOxKUafnosWjcJwk+7W5F2EKvlE3xcXaNYfiCYsGkA/smuqug6hcleAnAImPbO6YwRpMgjCAVAm/yQmKTv5hNsAf/i7SyNBSl2a8Qv/4/M1yF+BZSYlNQCnnVrpbC+mToAACAASURBVJcaI7sOSEY2NpaDXLqpR+vE/OVksDgImgGgghHoYJbTWc7oJtFWc65/cg2AYvh2ALsB3AzgVv95nS/f4QdsIkT9T3cBrGtITWZfC5hqtQHInsEGQn3UDDvEDEY/ICf7SxMOrAg8T+c00JGkvHGd2DABUYZIAONzCUDppCFhSukCBsLQrFtZe/IixYQpSyEoJoqnuPWrVRAubQh83HNlZB23z7j1ywmj6CIIqUPxw2Xeu9bx2jx10wz4Z7sqTYZaDD8EIDuoE3hMVEphWg66JIp90k0sBxBcy+iPIIaT1RtEsHS/yIAqw+VSNPWQfe5tlVEk8auXgVa5BUsEJuT5uoliAbE5AGotmIAjCPnR9xDG3TQernYAUupTdBGEFMf83OkApHG+XlvTAPwfuyrgSZOhas3u6cwTsUBVn2gTwyFMi8wjHZAA1M9fYGHDULJD1m8Cpa8fRxDad+l+Ykf/3XNvd11U+qiL39SxXevSsshdDFvgbI1O2AwAtRZMZzTBRuDFjxe1Xg8QEIB8yyj5yYIUxfQIkfkIRnmHCM712JoG4FsdgHHp3ACoMH2G6jM4lWzoQarSvwQ6MSB/vporVaFkh+mCLlpVR8Z+dqDZLoDOpHSiQeAFDkBjPrlgCHgCUaFifg67H/9uYjn4Ai1vpTERTAASBaoQJBAKeNqHlL6mwPDZYAOROag/EYRkPX34MwHIvzW9rQcA+TLpI22G7EcQKlJGsYIJhC6ClUMiXfBTbFUQAej6nPS/OuAl9pOOqIc2BLzg++3VmWgIEUz82cRuCAtLIHQQm0gO52uOAb22sC3JEWgRfPpZf2sQBQIgLydPEIFGwPEj8MlF2bSbsulghLftqsCXq9HGgHysznrGgi5qzTUTFH8FLhAUn3hIJwCN0HLncw37qaF2zoYvuKNivmQIuUNc7GvWt6sHNs26twA6vhyq8NEMAHlyntFrDCcQehyaPTl+FwAbXDcmAKMRThakEk8Q8kPg8SPL0qzLBl+A9QCgR6uZGs3vfHz8TtBZvkgGQrEPBVAUg2Sij50QAOjiVKI3saADJRm7dSLYWfSFDkCem/dhZeMy9pPY5QvSDYQyUJoDIK8qMezh3wY6fSL49PcGgCAA8pScJLIgAUYQEmz8RPA17StvGoBv39W24eREiBoNQSgWNI1HBkdgxJSw1AI+dFIbgOYmkjimQ1r6XXC3rAbCHycAgytohf8vsB/r2KRaRq7zpZ+D37HMX0s3DDcCUGLYaw53MJ4YUODzusqlGCQAOQCejuxA8UULUkxIwAmMAp8Wa3qkN/R9W+sBwOhIEPjk5SLr8HeKFbTQfb77csPIMHGl/4MPbReslPhNe4+MiTpi9AFGV4nI7MfvagNQLh/pfrYnDAS8aJQ42A2w4em2cAyWQUuJVQTGWLs1uL7DG9J1RjhA+jvYk4t3KXeMqijpzrud4At9z3XtP16yGfjKZmCGooYh1tZzvv8xXPFl4PoJYC97k9FlwZWD+Azi/deMZWeP13eQCGEyoERudChIjbb3mJYwH7V0QIKuCwj/gfMj0asn2I0FXRSHXfL/iRkNgLyeVj8ccMY//J1fyxzTAXT2+xoQViKYD/1hDqLxPiYxTgSvQrphphG97tz4Slqafnj7uk1kIQDZrvWTw8B3jwEW+RLxPgSiCERdPwPR7+wCPg/gulFgfruDkOMQkFc5x84e708JAMmCuRNBXi4TIg5CGRzGiBGE/D4E/C2r2vcAYJoify62i0aJSMhB+2IHoNwu0fkcjQ85pu3ack5nIBREqneYFyWLkAXIJHESe00Cyx5QyeL6F/tyEcDcrOW2n7fX8df0mME+/vQ/PQjhoy3gzo3AISYf80MQaQx1peH9wb7v2mrtmCBkIMMejp3jIJD1MsaxaMZ8v5N/67INAsB3BAYU4JL4DSo1J15AFPAEwuQHZJzkKfUAtOHLJSOQRWndBYQvCQA01cfnNopfsaCJaD2baBn79QjSTiOEP1EcawIpkq2kegBTNgHWEpOKF8Uwq2NRFPM4AqCf46/rA2U9/uVDvurB01zvAJpiiwOl3fEeciCGF+Ij11f+QkbSfMPfIzqw57mEFZ9Dl3Ps5HXWAYByHJAJKV7N+s0cCQQhwSlfm4lGZ0KB8C/rABgZUS6ZHITBSEhCowUYAAksF7cStWREyxRwtuPpOlgw+5s9sq6OaIJIIlUgEhA1edoTgHxa9HVw5jibZNF+j/9yGQA/7pbujZ4bwv2+cWB6tFo0NzYnkxFA+cvEAo43VBoEo2e+48EMXEOmD9F6xhCE8RwZEJ80VblKvDlmzwicfqy93/o+8K8TwB2jVSgW138FrJQTXBNlnJgmrjZwanow9CBP/rL9wF0jwAGWDtFyoN9PHutnIHT05mPXz93dMGQAPniJsjiBXiTbxDZFMF9NLUPQxKR5qezz1Y6/YZDH0D6GkdAkYJIvRalAdHAMmPZoYhb6NhDWvEyf/ma737CXN7R1ZC7hUbPgcFgqt/ZZjADnM1xqEVhYBpb4CUk5UsL7jQvj///5buDrLeCOEeD+YQchYwG9VIfyg1NaZszFiCH6DkRGLze5/dgk8IMWcMCjdCiCzR8od1B8OTwvJM8JEShFut1fzMhi+eRJr6LI7hYP2M/xVLwKNoZjUTwRMAQQmYyhWGQxsSADOflZ4kukj7PhZ75bETjBpkAGahMkcrGgwhsXeCyBHBj1wmOBQwvAwqKzoFeRV8ZaerjKYAuirmPY/o9X7q5Cyr7fAvYMAftCPGAEoYlBiVtFwLjtp2U4irj7yOANbi+crHyrfCbTquJV44O0F1FrwQGIMZFqdQDyP/gGSZ8TC0ZRRsOlVzzgasd/u+zpMByLehAfCgMQCDyGZJHFCCgLZ2f8mgI5qauEcVx9e5vACTgCTwEMWr5TdIpWKJb5MvrnoocDswvAPAG4VLGg6UKeqmi4iuDz4er30oX0FP7u5moMvIf7W8B+jwlUNAzFnlZCIhvGFRCeWzrgXSSIBreXTFZSgVLHAp4UHOFuociEEsn2PJwl/XEk0dzfSojeerFg1IOo5BKAveIBex1P67lgUzgWQaJwLAKRH04i14ItgDKEtGsRnWx49b2Vkk9wUefTGrKCF7R0JxZMqxN8cmPAxWcAcxGABKEAKPA5u9lEaAbCmKMI+sDN1X3z+ro24wEZFc0VEE64ABgT180PF9ZdBcDb6JpqcPtPk+1ACbmKjJnllwyuILunEAWjZHkBsrsRUnfD0qEiC5IJfyisgMhzWhcP2O14Ro4WbASgAMQJ48SJwchmBCDFa8qpyBbSP7OvU4PQ0p2W7+LSnSJUFOrI4V7w5IoBTQQTfJ6oTSYk2mQcpGRyH2syGjIF6EM3V/fM++C1CfwUExhCsmzCaQT43lZC3e1hBpEHh36XEqrB7Scmq5dV0XZxmV8WuDFzAF9iwhow9seAGoBcGtKjqAc+1l9rLb/1igesO55ysmCrC8ei6IxRMAKTWNBi6Xw98xNTFUi0jEcmpYgRAPhddpVi9OIEPP5cYD4CcLkCooHPwaW9kV+iwWrQHT8uA1fd3F7DFvgUHUP2k8jTiogAqLoxFpDgbMj9jXSuN7i9dLIdaxzBp5XVBMIMgFEnFAPKT9qPd6A9BIGI7MfPmf4U+40HzI8nWgq2PBxL4FEkjKJixGRRFyQQPzzd1iAUzCAQas1YOmAEoFjwkecDC/PAwhKw6CxIkCXwOdVJLxTobMjBdyIgfvimNvNJ7Evf4jWtdnRYD1YNGVuG93VWuWs4Jf+mlZCCZxwP/cnJ6mXVKk2+tK8lQQVHRTGc64SDAZB3Ey3JcxyACkToJx4wHl+YwqloGDICmYmTFgMQFBET8yyYzyAG/AfWX8mCGQg0BTRoHwt9KVaPE/HQ890AIfgWK+CRAaMRYnVdxHbhdY8Wslw1V93UDsmPIj9GxgiAioRRMIJNvoti+SW/Ikd0gwAU8+XxJcbGITJPDvI6XdCFREFSknTB83xka40H1PGF9dnycCxFwygkK0bASJQSVAbAYeD98xUAe5U3jKIwBosSgNsuABYogl3/IwgFPrOIg1Xc4ZrpAsSrvruykl2ucykapkMMh4CExD5DwJfWAYAxwk4MKPAJgOIjGSEGwuCakRhemw6Yv0UUwRf7L00L9pnsNx6Qx4feY4O8pDEcixOjsoTKKpMYjSFYYjOC8Eq3Wnnr0YYS+0Tmi2HysrPGLqwASNYzBnT2Mz2QD91laxLB0gs12GAh81cf/o/OcHyJ+qj0S/zxnhUZbSyYWaL8+Rq2S29wowiWkJPan4MvgrDDGAlRe7KIywDIgR3meEDWg9HbJgApNTkXo8o0i7oVgxnEgFr8F7jEdnU5GvqfJQKQKyEOPlsNIQvyvupAGHS/Okv4qv9oh+PHxMLk8ggBCRxvAmEN+AiEzz2iQfQBeNmkh4K52hJBKOaNe/FSLobLRXCz43rQnu2yi9oMSMDxs2jo8303ERz1wsCGZECF4kd3DwEYYwJjhoNlQrgIjlYodbBPrwMAZfEmyzcIv27gs6XDzC/IR1DOgA9a6DRz4wZAsZ+LYXvQYsHoD4ziOFklna6YD3+nnU6dZ7bGDAcBUImIAmEUw/zbJ1i/scGNDJiLXmle3RhQ+l/aq57gUQCWzwwBKPeLsZ/LFrGg/ShRXAe64Ajkv30kALAjF8R11Dy3K7KRwJcsUTaqWScARou3w/INVnCH+A36n8RvM3nB5XP4oD6DATBYwGb5ajlOLOh6X8JaBKRG77+7ygGYp1bn+V25/01AzBnwQ1ypanD7KWfA1QDYC3zJIj7KgOUzc9nFbetX/r+O5biwNhyX5uSEDr5o0xsJwLp8/m4A7GaJUv/j3/5+HQFYJ3oFPPkho/hNeqBcMkcB2BAA6XrxmMBkfFAci/m0JpwzXw0TXvXtzrz+PKc/Ml/ugzM9MDqCAbz/keVjjGcQA/YLvjoguo1mRslRI6RwfsiA5nqhL5D6nscF8gfTdfxpS+/hLzvWfzMQCoB1Fq/8b3VWaPIDZqsRV64DALsZHVHs1gEvsqFAeBSApQC8pHK90Oql4UEAyvCwNeGcBXNLOPMLftgZsI75ouUr9ousp2TEyIJ/sU4AzC1e+WIFshyAHPZREVwItrrD3wGAhibTYBhxVpe/xePyrNBuWaoNp3DgFwC81O+RAepK/a5Lfe51jxr7JwA83nPXYgq1asl0yX5N48+f4VEGLATlK1vAo5YB1gBSRmsM+NFE57lcfPD5pPFWCJImtyvGgGfOAacBYO59zFglgHgPefZsXV6/gPXBYeC0RVgyJNOGYuJjPka9eHWgjL9bWzhWk0/n/wPn+k8bgFNmgYcsVflZnBRmIShtJM/m7JGibGBoOIIez9wKPP4AcNpylfbNlGfdI+9NjBjz8JVzppckZuJ+dBw4aQ44drk6j1LIY9JkPD7P4s2lwVEGLHwJnncscNIh4Nh5YMsSsHm5ndOu1BGFThJ8/K6JrZtoslST2+XHA6ftB05ZAE5crgAups5TfaL6EF+UyIif3gAcOwtsXep82eIYY9JkXpMgMp/AeZQBC2b8OduBYw8C2+aALQvARgJwGZhY7swEzbNa88IRvAVO1qkF91J36DNOBE7eD2yfB45fqphLnevzdGeBKBfL8UX5/CZgyyyweRHYsFwxYHzRNK6oetSBMDLjUQAWTPqPngpsnQK2zgKbCMAlYMMSME4ALrcnR6JYQIwsoUnjpDRstOLy7cBJB4CHUGwuAtuW2nUDVH1EFUhycSwWjGD64mZg0xywcaECoI0z5P3X5P6nWlHdgHgUgAUAfOYOYMtBYNMssHEe2LgITBCADkIzSJZXpCOnIg25uPrhgnupO/TyhwLHHwSOmwW2LVSik2pCrDsQskzNIBGIpBdGI+VfNgMb5oENCxX4yPRjPj4xaJ0+WGeEHRXBDUz2Mx4FbDoIbJypADixUAFwzAFI8KUJChMV2SUaAGc1cE/xFJef3FYRti64nkqWDrqqEhbrsm5zvZCdPCd8nHzJOLZuABRz9hTHZwPL7LnLnoNMIY2VyaKcjtZLHOAbNgNPngKe4BacfGF1pnydD+hphQ/8XV5UiEueLGnDN1tWXj/3/4cTwAUzwGPcRcFJiDpPt3FLmf5vjwE2HAQ2zPrEzDv7OQg5OSM+ScYQy5Xbo8465u/ZfLTJ7fKHAdumKxVh8wKwealSE6inEoSy2MWCdbUHIghv3AqMzwHji9VLZuDzD8cXxxWZs5c7apmW0fMBnIHKn5X7d6I5npvRz94O7LgXuGIReJSb+Xl1tzqflybwRwqf9i97BQRWomWJQ7oZVFtJoqDX/b/oGODsvcBTATB9gsfGqmzdjtVz+G+PAyamgYmZCoDjFE2anCVg1CeJwOMnTRB/DmUINVkkgia3y08BtkwDW+YqAFJFMD1VAAw6XG61R31O9/fdrcDYPDDmY0zjc1UjivBuAMx1QdMB+WAYXU8dhEU16dOSkppbcHFSrng8MHwnsGMPcN5ypURHp2xMIa7zDz2z8Gn/kVe0YomO0wEwBYKujL7v/zHA6C3AxfOVh58g5AsZxx4fZM7sf3h6BcDxWWeGBZ+cMEFiwGEHHRnDzun7ONHs/djkRgBunql0VDOSHIDU3cxSD4aEajhFXS4H4S1bgVGN0V8we7E0Fh9jVDG6Obr1LJMRwn+kOCaTEYT0dsfqZHXl/p7PrLi9wIY7gO0H2yAgCAWCWCowKrYE8nMLn/a7PQn9X7zIJPPkCcK+758y7x7guNsB6l98gZjLLYet3Ay5n0sv4R+fCYxPA2MOwLEAQLIDPyP8uBg2cRYmzFweAYilKkn+OC8/Fdh0CNhEA4nGA40kd6FES13WLO8v1qHKAfh9B+DoYjU2Ak/js/8NAIwg7OUb7LCC+WAfB4CpBJoIiTRNRmS1l13kqWh3Adv2A8cdqqp1MB+aIOSxWv6pq5D2kkIAvt8rF7BLJksN/jMqfa7v+7/Ak4B3A6ceqpasKMq5akAmlLWY37t8ZW97PDB2qALg2BxgAFwANEGcnI5JcrDZRPlkaXL4u1KJUAfAjbTQ59x6dSvdLPXAgGYshZWR6JIRaXB/NwFI8C1WwLMXzMeSwLfcXuKrA2G+wrLCDcN/IIg4ERRn0qvyySAQX6mG1XuA4fuAbTOVwktRRr2MLCoQyvEZ/UY/WwjAj3jtFJZkU79g1ghkgEBf98+0Umb/3A2M3lkBl/fOcdMok2EjkZyv8773LAfgHDDKjwNwxEUw9yailpwdxBAEYhBbAuGzG3aKkQEJwAkCkOCjlb7Y6SYyf2UwlAS+vKYnAXjfNmDEX7DEfA5CjUcsnzvbu1nDtUMmCDkRZEEyGdlAk6G6lQTSa6m0MP6HuY73AxNTlcJLZ6WOJYC5/CNxLpHMgdKIKNl69Qvu6/75AjHOiTU87gKOOViJb748BKCWrnK/maTA+58AjM0Ao7PA6Lx/xBAupoYDC9okBRAmPdBZ47lNA/DhwMRsxX7mPgl+SrmK5EaRNRslXFQ9CKB9DkADn79cZtkHFkysJ103eBbqlh97DpmTQTYgk9VNxu+xYbXKU3lhFoJPOgdFGY+lPkgQxokkgF9Xgj4AvfoFs84eX4Ke9x9fIC+tRfDxvvniif358sSir2LCj5wNjBKAc8CIi2AxxLCzIAGY9L7AhGIKgpATw4l8wToB0JjPrfTkp+SLQbHrOqm5jNyajS6VCMIpApDAWwQ4LrGgXqzIfnq5cv0vN0ZXHTInME5GBNLb1DGdOYQsI7AfGKFjlgqve8wJwG4T+fuFAFytXzCLb+VgWnH/fIGYfc46Hs7iHC8ZkPcdXx4VfVXJw8+cA4wIgM6AHSLKWZCTESfLfg7WsIyRF3ckiRQ+HACXkwHptyP4KHrpJvKVGnOhRF9eBF9wE0mUEogz2wC+WGI/vVxiQQIxAs9+rmHA6E1YFYB8DJwQMZl0OrLZ++i7sfT8zroYHLS9df4RACWKxSZvLXzG/fQLZqk2gqn2/vUCUQ9UZaM9wDaPeSPrC4A5C1KV+NITKwCS/SiCR/jRBDlLmP7nHynsxno1IPwJSyRpbiMADXzuPDYfZfBTEoAmcuVQdiaW0zwXwQsCYDYmMaDA1wG8TBSvaoR0G77EcGSET6hjOvVApfRPAUN0zjr45JzVcSqiTxD+VeGzXku/4Nr7JwDJOkxFIwt6j6+RqUrlkO4bXzp1gCAAv04AzgLDDsBhKugLFUvQUhTwCEKbnKCw14HwJ9cDgGQ9WegRgDI8XEcVEDvAl7lVlglAgi+I4CR+Zf1mLGgMmDFhBGFfDCicRJFERviSABjLS7FC0MFKMU+07wOPE0kGvaoQgGvtF9z1/iODkwn3VWoEXxres5ib9xx1wZufBAwLgAQexbAD0JiQwJOuJBA68/H3Zhk6+3CifqqwWNMKN8wjKgbk6gWJgC+FMaBb5vJVmsUbV2vCqo3cRWZcCIACoax53+ulkqNd7iqOcU1WcC9cxEm5kQBUdZ+sTnSL/jEtTWngi21jhJNJBivZBukXvOL+yYBkcOqxKjJ4AGgxzMrBVwdAMmHrZOAYF2l6y/mwV6xD17zmWo6MbRyeWtOHwxJ91IIhr6rqZS70DPPLXDVUrfBwzHKr1EUp6/h0T/6L/GcCqslt4IhoTcwdAqDSs7I60WQH6R329pHuFyuXDJmEjuOSbdB+wSvuP5bGUjmsA5XoUvcvBXKKAQnApUdXwah0b8jXR2YzJTsC0ZHB33FL+2yiX3h/1YeD1fFZGT81g/H6yqkVa9YEpqMhTADle8erHA6t7Mh6j4ZBXdBGjFyO4CSIm9wGBiBvgqxwIAJQlXIyEJLyI/i0SkAG/FbhaEr6BXfcv+5dLKhCg4z1C1HEBJ8+BODQGZXfk/quAZC6ketAZEQCTWAU8PIJt0fgwHzZvVWNaKqi7JLOmtDWFy42g1FxH/XfqGkII0C+a0tnDkfsGxQjn3VPsk7tXmuy+Xp0JhtoJosAaFcUAJUYKiYJxcqHqKAH9rPlG2cMrmCUbMX9guMLpGTcCMKDlZGhMK8IPnPIn1X5PA2AwegwEEYmDGBMjOI5whGQP3NPBT7VJlRNaKvF4t2IWHbDErtDlSk1p4lJ7/zd246tglGZryIfrFhQ7pU8WCAX0ZENG+57U14Z4YrCeLrSxXdev6TfLwrbxT7znMrfKQXfHLQCnyvmRIv0Q3430ezMmL98P393G3wqz6am1NYzzoGn+svqRmTAU2citctqAX/2EI8F9ACEmLHXLZGoFxtSl2xyK2bAYwrj6Xr12+1noL/jUTCD9vvFrn6u0v1/nvGkaoVBAQi0eummMAuXQHMWJAA7gCixG8U0gFfcXdlBKk4Z6zELgAJfZEKrxpC1xOIl/+Sk7jkcdYlSco90y9+gK6vJrRiADD0piad7RuFo3udNCgft94vCdrGXn+tujgV3QAcHLcFnroelivHkchEL8ue0uQ74S3eubAITS3IQhKkMRjBMokgWG3L//2z3VSnP4VDgQWxUEEUxAZFHL0eR3HDfm3IRbDHkBfF0zy4EIKNhSvr9goGEBdvTz/MIYQLQdVsTwRTFDj5jQmdArRDYJQNDSs961R3tPhx5NXoVgoxleHnarjohgLec3D2HI492yQNvIwvqO9fJm9zKGbAwnu6FhaP5pFuMg/b7tTbpBdvTz68cz/zI8azVj8iAHTqgmFHXDUB89R2dtaC7tUGw4kDOgFb0R2wYRDGZ8g9O8aU4XwPOczhiwGlMjqqLWiFYGu570wADFsbTvaxg8nkow7E8nM/atfKzln6/1mS4YHv6BQ4+Z0BbqHcd0NwwYbVD3+1yWhXJxPBrbq8AqE/XApSqAxiBV2MZ/54DMOZwKE00rnDUWcR5KiV/brjtSAMALIyn+/mCyeehjIYp6fdrvVELth8RAClyHXxmhPi6r1m8FM0ucgk8+y4RHC1kAK/5XgW+2hZYofafWcPq1B5AqDqEYsQ3nepR2gqhV2yiol1COkD0C+aOaoGx4aL7DQCwMJ7uVwomn4fm7VrX2u/XAlELth+5sHPtN+l/Ap6sX2dCsZ/phZkIJgv9l++1wbcq+2WFv2NXIjNKAPzuw7MUAV8DTuynFIEsQy83RgTAhiv+NgBABaQOGE/3mwWTLwAqHnaQfr9GnwUbARgDNBUlkpzQboyYCyYDYdILdf0l4NduW9kGoa4geNdazLElKoA3Prx7DofiETtC6XvE7hGEzJlpcis3Qgrj6d5UOJoYDcMglrX2+y0NPtl5UZUjkfx/Hqbecoe0OZzdF1gHQrln9Bhee4s3f3Zxm4MvAk9VSFdUIw0i+Q2PaBtISiBSSFgCYMjMW00MP7pwvvLDmwFgQTzdHxcOSGvBg/b7ZRZByWYAlOERluKM3Ra9CKWc0q73dTBhMFT4ZwIw9l5Lrpes+HjeBiGCUOKXeuBvPcKTiEIOR0f+RhDBMYi0Lhea4GTaa5NbOQAVDzhgPB1La5RssV3rIP1+7yy5OAADoAchEHBkFbKfGRpiweAPtMs5IFNokyOGk/7rAYC9OhBFwNXVY1at5tftCBHaWVS2AJdEcEinrDNC+Lumiyc1B8AB4+muLARAXTDCWvr93lR4/Z0Xt6ODFQkj8WtumEwHTKDLQejAfN3uds/dfjoQdatGLxb8jQBAYz6/boxiFgAVudzNIc2/s3xLk1szAORoB4yn+2DhaATAGJCtbpkCYq9+v4V+aBgAQ4i66XtaC85YkDog/zdZvzUgfN1N7a633Xqv6fe9msDIHfNaB6Ay2JRE1AHAEDIfI5nzZCLeN4Nbm9yaA+CA8XSsul6yqV0rJ2WQfr+splCyCYBR/HJyKX4phs0PKBZ0lqOYTpvniAiUAmAd+HKjo1cvDjHgr+3wPJQsVCymUZrPMuRsRBDG4AQCsunyJtFGHwAAIABJREFUcc0BUJlxQoH62q8ST8cggpKNAFRGwCD9fkuvbwAkyGgJE3C+Nz1P1q9/T3F1EZBxvZh50s6AEYC5yyUHXt5/Q8zI5/KrAmAIkkipkyGPYwXz1aRT8v5ZO6jJrRyAvKOvNXlLazsXs9bo/ztc29Pohgotp5J49Rcj/pzfIwGS//3OM4CNd1dpntQpFUmjEH4LYIgnyn/OLjL8FeDGhwJbNgFjI8DIEDA8BAy1PFK7FSKf43cNKrvHx+8C/vmxwMgmYHgEaA35J0StpvvzL/nP8RbLAfhyT207TChgDRiu/ZL9DsfWNABvYzbhCDBKoBAk/pEobGWTqp819hzQ1/0k0PoaMDEJbJjxVZFgDad0SaUO5LksWVj+XScDmw5UEUDJ6U4d0nVbC91S3ovfVHp5al64cgC+k7mZAP768KCA0WD3A/ieLz090CDceVmlAuhBljLgrfcAw6PAyDAwPFwBkCAbItM4a/FiNtERjBl76W9ffD2AbwJDdwFj+6syImRXrd5Y2FjIYcnzWPLEqnsfC0zsr6qBMQmfIDR/pyJ6xMhKyMrSDiKD2xja6TADTt0/AGAs1KcAUCFrOLF6tbtiRVFavT/wuMCa7MfVTlH098YBeBcwNAIMEYAUlS4uBULOmK3LCnwOPANlEIOSoF9+C4DvVoWXhvdWZVOYqWgi3vOXDUQhgieB0EElViMYJ08HxqeqnG8D4IIDkAzo51DKQQJvBKUmKACzbM4+5hUivwrgiwC4LzvjmgCh6nBcgiMTcv9Abo0D8E6g5eCjfpUA6AxoQIzgi8ALmWwC4z//DxcPPwBak8DQFDB8yJPpPZHeGCyC0KN5DFCByfh9/+OAsekKgEzCTwD047X0SCPM1IYQjCv2E/MJoGVwUUQoPboq0MdqkWVn7RtDDMahB4g+P6qhXFpjVtkDtRGA2nKjos7IyOyHFUbIrXe0FXsTuzIYfNb4O2M3ATGIYQOmPn6hG6gi3eUkQQAeAIYOAUOzALMVh2pAlESqGFBAXAYOMQVjxll03iO/yYKRAT0FQXkwZkjp1pz51LO2XAT3KtD3AIAwj4Wg05kfiuUHYlsXAJLVnP0INLM0OYFx78AzcRySeTsw2AJueI+Dj2Fne4EWKz5MA0MzDkCCkAByUWqsJzarEanzj2zXwjEGFHuGY+pYsMojzZL1G9EBexXou339IRBrC3lJGmNDuSHX+w7WC4Cm6wWxm8DngLTImgC8pBcGBuTXf/1fXnyTugnFwxTQOgi0CECyIFlsvvJfEnh0mhsYI/s5uxFYi1xZof7oOqSAawwYjRGBzYGXbtWXaCIrlvHUagX6SP/ruMVYCEbEqECXAMjfree2HgA0ESur1/0vtnNwGSsG0RsZME20/+/XWH6Mugk/yngPAGy5GDYALjiIHIgRUIrsZjM7Ax+BSx1S4pfffQVIep8dL7dMDsTGjJB+CvQxTHmdtrw4l0CovFruC2NOe975egDQsCXRK/eK634JhBK90q2C7I1i+Gt0jxF40k1cPJAB7UP2m3MGJAAFQrGei9iUTH9yBUDTHfU3B5+BOIKQ43BWtNtPcWIOzEZE8FoK9K0DCGNxLi3FqaKA9gTgeoFwPQAoI0OulWT11oEwiFz7cwbErzNxWtEYBB+VY76Vh4DWrH8IOoGQ7Ocg1CqMRLPltmxvs1/SHaP4dcAJePYyyUCRIzrTB8tE8FoL9DUMwl61kQQ87Rmy2PS2rgB0a1ci18RudEJH57OsY02y/+83/sZdBKr4FXQTApBvprGgQCg9UEAM+h9F6ugJDkC3gJPBEvRGrYoYCBX9IxEcS5K4i6cZAHIw8oXQ4mLBb35YH5d7OekadtTV1UZSjaEIPH4nQzYNwgjAHNwDuWGYpZc7lzPfX1cQur5oBorfzDf+zi0yVTuSkuxBI2Q+PhQDIUEnMLo1TBCZLufGw/ixbQa0KB8CTODjPohdY78IQmfDjmW7Yo/doAX6GqIiAtDHaYswSmeMubV81kp11L6hy2PdAcgblfslOKC1IiKRmyRxZgV/8++DS8BFrxXi5Hd/U6MeSKdqEsEKhpBRsgRMbAtuG4KU/+9ry5brzP/lPVMv1EPOQegharrVcgZUhVHFxNPcp9VFtlOWkL437C0WABWypFRGsV0sb5Hn2zYBwvUGoKl10v1knDgo0y7XA8Pfv0UACnjaK33Co9gJQAOe64FkNvtZAHQdjz9v2Nz2GSa3jYej2W3KGuZ9ixGdIVSoKT13B2s5AHkGheST6qn0erHv5AIgAAU+LVfw/wq3CEAV7clBKDDGZG9/5oVXx/oyYARczcqH5GyH8eFplTawFvAtrtXLGpNrQDGbejupB3omlIHQGc/ErzOcGSRs8zrhAbbuL1Tco/JfbLlNwHOmi2kIcs3owbdwNpYtynDQhsFcgvuG9/YapGFvYX22zZcAU0/GwA2LJ/4AmGF9mwEbBu98Y3cMF+uAGQCj2HVp3BbPuo3IlqxAy5wHAq4OfARmEBXGfNIBa0BIsG0ecwC67merHgRpZLwocrWaovuTxew/V0txJQ2DWeae3WAGbdhb2DB4+wRw7w5g8Qpv88liyGtoWHzMi4C9fAEHbBi8kwUKu2xNAdBxaGBLbJdZux1LwAGECYAEm6wyfpelJrEgFnRDxESwgyUxIUsVMwjVy5AYO0bG89Auu1/5BF38KqjBHlUAYXsteNCGwTeWNuwtk4JMkrlzGNizA1hm69g1Nix+zDOBW0aBeRZZGqBh8M4emfWNADDT+zqMjQyESdQFHfDbZECCLRgdHeCTe8CBaKJY1rDnBRCIAuGW4TYAZeFG8ZuMkGiQ1IEwGCJtHZBmy1obBsvVMnDD3jIAerti3LEBOMjGcOpa3WfD4ic9t6oveDtLfw7QMHjnH6wPAybW6yaG4+8D4HIQfvtDIVtLejpBFsVvUI7NIBHw3DUjRzL3rDVtsYPOkAScuX3coNDynT2VYJCkn+PjqvUD8hVbS8NgjphGxcANe8sAGNoVY/824BCBtIaGxRe8pLKZdpMkTvXiJ2toGHzSNHDPScAyq3er4qPyGaNc7JCRXWLT2TjwGmCOeQashq6+qSpZmp8vojQpheF58ncdZVjLnjWPHr4VWKTKxrHGUqq97qXu3jp0wPy+eEC/DYNZsZAO6IEb9pY9lNCuGPcNV830ZmkM9dmw+OKfbdcXvJMPdY0Ng0/7GnDXKcDMccBS7MwdKz8KCAKQIgY0MWGCtr4TOHAasMwOkTqf6unyuLykfd254nkb7qsw/iVg7jhgmSX31Vpd9yRHeLx+zRhjEGRbB6wDYT8NdymyubzDzCCGfpMJWfSRYfr9HP/aMgBm7YoxNQHMbQHm+ID6aFh8yS93tAvGQb7da2gYfPoXgbtPAqaPA+a3AEubgGU1RM6B060fgkRoCzj+TcD+04CFE4BldZdRc4/YxlxgjJMewSiwN1zWfsOngdljq3EmY08vm5i/7j5yIMqpvupKyGoNg9lngYosl9wY/0dZdrMzYl8Ne8sAWNOu2MA3zw/F2CoNiy99XbvftrcLriz6PhsGn3U9cM9xMODObQYWCMANwPJ49UliuW6SaqqBn/gGYP8pwPyJwNIxwDK76ahDeN6uXYCuYyABkEza4LbpY5WEWdSLxjF26/dQB0SJ6r4ByAN6NQxmkWcqrnQ00x1DEDJFjR8CcNWGvWVPp6ZdMQ6OVOCb3wAscPJ6NCy+7PerkP5Q3tBY1PrT9tEw+JwbgPu2AlNbgVkCcCOwtAFYcgAuiwWlM/XqDjMEbP9t4MB2YO54YJFMo/5gHIcALV1TRZ17FXOhPtvgtvkqf9H4kvHDlyKK4l6VzvVSBF22uwjOb7pbw+CfcwBSkyeFEHAUx/yw9JTyEbo27C17Ol3aFWNuAlgIn9QxO2tYfNlbK6MvaxeMRYquvL9rTcPgJ30TuH8LcHAzMOugX3QALo21WXBZLEHwRF1OgHS2eOgbgIPHA7PHAezNu7QFWFZ7JnXJ5rnqxHEulvlzwyVNN3+wern5Yovl7SXLGwvn4riLWO4fgMRJXcPd/+pmOymELEhRzBxJAo9gVL4kwVnbsLccgHEpWi3epocCAMeBRU5eTcPiy/6qtl0wpvhA+2gYfO7NwOQm4OBGYGaDs+5ExYDGgqP+ccAkINaVpB8GTv4d4OBxwNw2YGFrxYCmV0YxLNYheCXau7EhV3ga3Lb8g4+R45uoGLADgHWqhsBXA8K1AZADyRvuvtkBSArh+i9DsQhCOtf0UUgW/7aiYW/Z0+nRrhizoxXwFhyAi5y4rGHxU66qAFhT3rDSIVdpGHzencDejcDBDcDsBDBP1uX1CMJRwFiQIBzxieL3KIY1YW5MPOxNwLRb8gs0aghAss1GZ1O+SFHsdRPt0i/PLHu++dFb/x4mXfhcbWxhfCtYMFr/uWvKxfDaAcg7ipPCvFOVpuo3HrCjYW/ZA+rRrti6TS6MVQ+L4NPH2nx698GnXF0BsKa8Iab4dFZpGHz+JLBvApieqAA4J8CPOQuOBBAOV0CUYbIskRkAecrvAdNbXc/aDCxSpyT4CEIyTgRgneiLIp3nP6fs+a4A4N8B8/48CUC+ZGJA29fpuLmxJW+5h5kNFg2jiWHSi0r0Uv4pCoZsxw8DUfnhd4Vk0XGdGvaWPaBV2hVjdjgA0BlpkQ/K9bmn/HOVqtClvKEBqlfD4AtmgP3jDsBxB6DA7tdbcvYzJvQJkii2n4NOeMpbgJktbYPGACiF3wFoEx1ZMNe/4jnPLXu+KwD4t/5SO/iMBcXuesHylyACMBPDgzGg7opM8mEHIGdwrfGA1rC37AH10a64Yr4APvvOSdwEPOVbKxu+K2pdKRTmdI3dqkPPVgbSTBGAY8AsATjWniBdx0QxJylOFCcr6HBiw1P/CDgU3EgEIMW52M8YkLolQRddIN1AyKWiBretf9MJQN6HsaCPxe4rvgDdHOcOxDIAcmDFDXvLnk4f7Yqt63gEIB/Yoj+4p9xaAbBHeUPM8qF2aRh84QQwNQYcGgdmx4C50WqCFngNsgSvQ+Dxu4MuiawhwIAXVk1O+e/A7CZgThY1dcno1nHL2oDIyZULpBsAFTBZ9pjT0QQgn2V6ufRicS8QRgbs5ZYpEsENDejBfpoLrwAOjgIzZMBRZ0AHoUC+SOA56xJwNlEyTFw5FxBPeWvlzpnbANCdQ1eSGTRybMuydgMggVBsKmtYoC6Mt8znZxsZMLzAxoAOvsh+ydDqtXx4FIDl8L/omQ7A0QqA82S/ERdTI22mNfaTuBIIxR4BhKe+y61punQC+MytI/Zz/c9EuvyBeetLAfGZ5WOMZ9j2/gqABB1fMLsHAVBqhfTcyH5d9MByEdzs+B50Z7voGZX+NzNSsd8cwUcG5ASRKYbdHRNYwhhDIHRgGmO0gFP+HJh15jOXjnyKblVT5Cbfoq+yJOszF8P8+VnNPlICkMAzds/YLxlYznrJwIpO6egTPMqA5ZNDAB6iCCYAyYBcBqTRQ0e4630SxZyQJQIvMJ8mSeLrYe+p/GzGfnTpEIBy6US/out+K1wg+brs88rHmDOgAVCMnrEfxxMte1Mt6j7u9zzKgIXzczEBOJIB0BnCJoqgIfDEhM58SWzJEPGJe9hfVH42un/Mfxl9bgSiBySIBWnAJBDGEDAB8QWFA8wO3/a+wH4+rg4RLPYLul8tCI8CsJmJMQAOuwFC9qMI9g9Z0CxhZz65K0wfFBPqu7PEyVdWAOTHVlTcpxhXHZLz1w0ZA6EDLhkCskRf0sw4dRYC0PQ/vVSRAYPo7QCdj7GqVOSMeBSAzUzMxZcDMwLgcKX/zbv45SQlHXDIgagJc+bjZBqAWhUoH/Y+B2D0J7rFa6LYDRmzomsAaOeKqxEvbWacHQB08JkRIteSXiSBLYJOLB+X4xrzAzY7vgfd2S4RAKkDDgPzNEAIxMASSWF38WsgkuXLyXTRSRCe/DduSZMBMwe6ObTd8JBj24Aot07uDObPP9XsIzUGFPs5+JJ/M6oT4buxHv9X7BeY8KgOWDg/Z58GTC9Xq5FxTXOw9c3Cm6k5fPcjgbHbgAlvVG2tH1T3Oavoq6BlniZ+12n5u/2sDbOvasqoFg8x2Lnbcd1GdhSAhXN+7qMrAC4sA8sORJ6yHwD28z+Ft4fdv8UyqUDrDmCEBcpZ39kLS6aq9l4D2rLb/KYsFTPWdfbvh86vQu2s1K/K+zIjTsXIVQ9a59Egs4Y6sZfIA/EcSp/jEXv8BWcAhxaA+SVgSQAkGAMICcwVlNLlqTc9Gbv/HAA7MrL4+f1VlXwrUq7SvCoyGcrrWpGhuur2fNGYwM8YT67hT3s1LaZvqn5MLM0bzmHMmIFSgdFNj/mIBct63NhFZwEzDsBFgpDPeanNgATfCtGsX9TIKwNrg9tuVkhlng7TI/YArX1VkXKrEe1l2SynN1RCsFJsqnQv3UIMxhwIRjU5AGN9QUteVz3BUAvahuNgjC3HxLAND7nBp/cgONXF5wCz8xUDGgCjKPbvevlzcKUHH2ag6cnYzepYBB9Zi2FxDJdjoXJv1WDFiLJ6MKqKZUzoQFTfj2HmwTKcTpVWvcxHKm6kKgoORAEvVclPD6NdzLXpMT8IYNPcLV7yJGB2AVhYrAC4SNA5AxKM9ryDPE5fs6eeVKWGZ2M3S3MQfEyJUKV8L1ZpJXpVJ9pLilmlAxWkVJHKwIhjjD9TtVXVm1HdOy/pJiaMFRWM+bo0rWl4yM1N7oPhTJecC8wRgAttBjQWdBBGESwgSiV0Pb9DRgu0TY19N+M1mRKh8niqFx3rRDsLqjgl9yaGXT80vcL1wnE252PAZCzAHQCoiqoW3yYWFIt664fUpKaREr1NPakH6XkuOQ+YDwy4FMSwgU8GSRSz0UJx3Vx/5vFNbrs/EiLRY+v4ACITww6iJEodQKwBIyBRv9vwhKzUW6z66TUGEwhDS3ezqusAyNxnJn8xa1KRPSFts9YfFB/QDZcAm78CnDBT5U8rCqjfc3yh8Gn/hGd/MsKf1+QzYJ4891Jye13iy1cAE9cDJ+6FpYrEkidxDN3OtXR+FwBGMezoMmxJLOumAuD4J4rxJrfdH/XCoLGFVKiUbw+LAPQqWWaMMLrd6/+JycSIm85w9lOpt1j1MwAwFTiqAWEUxeYH5ENn/jInUVHeMXQ/f/jRePvCa4DhTwLHfBc4frGqqaNJzLPw6iZxV+HTplFGvZrXZT45N39+HW3TujlZv8D6fp8HRq8Dts9XIOR5YtakgBgdrrrt5Qsq8Ssd0BhQ4HMwmVitAWHAY/LbLDQNQDaTVJ8Q6W4qVB51OOqDZDPVB3TLOBepW5jmqaLbec3jGgBGMSxvvemDYkQ9GoKF1ShUCSKCqBeQrvmfVZPC1keBjXcCmw911tTJ8q5XgOLaQgA+x/OdWA2EGZ98gbjleTHdQHQN+2iwls3nK3/Zhj3VeQhovYzdxmArSwQgDRA3QiSCJUrTnjfl4KozRCSCCeYmt90EoJJbVCk/1+FiCwFZxLk4dRfLFia6x8LbYkD9v9cXtLG6+O4AYQRfrgPygVIcqyhTXcWFOJH8fh3rz7EKwnUArq8mcGwK2MCC1i7WY7Zenh56feHT/jE3yliE4TZncd636gPFCKWavGhcRx2J+cvs9MlSw0Ty3cCm+c7n0G0MExdW4BMIbTXE9UCynvyCCX+Ovm4gbByA/xisVgJPpXrzLj4EoRJjJIZrWHArS9iprK+KcefgiyB0XVKGjOmCmW9xhRVMUSyRFnNeFGEdI2q+/HFXclkp9WsAbgTG9wGj08CI64WxRk/OTDcUAvBHXSLQxcVCDMQSWbzv+1e7WVbz+k5w2tJtsbcCYV6WJY7hmAsDA7r1Sz3OgOgoM+KTOJbcjSI5yGIaNE1uuwlAAU/MF+tF5/0sIghVLdVdM2S0bSzHx2Mi+FTxXf8X925NC4BycK8QwfmgVX1LlcFiykEMcL2BndJJ7aQfijKfxLGDwAhByM7aC5U4qwPzNwufNnNuOH4VZaCPlPo2AahqFqoPVFc14ga2m+WEEL0cAz9kdPrOmMu8r1o/rTsXz7f9oswFs+jO6LAqkvC3Ggg5Fg6mwW03CUI6X12h8lyfcz3QHqr3DIl64DbqaQKc9mI87QXACD6vpJqY0EVxz2CEyCI5eMSGX2e7VtI5J4yTRyZhscrvt1nQuivOAaNLlYESwcySgiVbr37Bfd0/u31yEgg2FVaiPCeVOguqAfGov0iR0R9JABJ0bnwk9nMxw+fOh55EbgRhzozrBUA1polN9CLwok5HEEUQBjFMQB7D+j656PW+IrJ8O/bBCo4sGFdGejqiyYCx3mKe9/JtTiBvmI5OFiTisg9LtJFF7gZGDrUbHKs79+hyu5hSaUvh1foFr3r/6vZJCiXgCDwVVFJ7MVmRLsrGltuFCc68yFdACMDAflwR4QM3HPoKgIExt4gz42SuaQb8hBOE2oZmlu+KFlKR3QSssMJxDPWbbjpfLoJrxG8CYT8MKGZSVTCxYFTIb84nkCxCIPLDiby30gXFghaF4c2ReR466Uu2fvoFr3r/fKAEFxvpqMcd9yonIrkuK5LLV7MVCM+/uDJCyIC2J8a0z1iwqyESgMl15Sa33QKgmtPEBnp11mwuXgO70Ud4DHWzfgDYC3zBEOk7HlA6XKyHQzb8HgGoCSQLqsxorIy1Bxie7Wx0rFaf+wr9Xv32C+56/7HbJ5VHtRYT+GJrsehHcya57PyKAQk6+vBkBZPpjPEExlwU59awg3C24W6KBsC6tqHR+MidyVG3i3rdAnAsH2T093XT+zLr197MTA80h3SfsZP2UqpCrPQ46oF317VrpeiKXTJ9MhMLkgGdCacKG/mupV9w1/vnwyGgCDCKWzJe3lqsyzLWZWe6/kc/oKzgKH4jC7oolhdC4jiuzM0WPo+cPQ2AsX1obFCTO5Jzn566PwbReiwnfTWjI4KvDoh1juh+aT+WKSYD3i8Aql2rJk+VsVQly5kkddv2FvHT61icqO7Fr71/IkLNXOi0FQjV0046oBy6wZ922Q95ICqDEaL4XWw3COcf9Mw73DFB9AqE6wZAAS8XuzGQIDKf+oVkqxt00ttAc+YT0PJ9qRFSB8xoye5Xu1ZVeCSgCLbYLVNswoncHxoeLwCzBGjBNki/4BX3z9lXgUCyIIGmhova83cRgO5Te9yLgP3MfmsBS8xs8/U67ePQOqy9umBUruDchqo8sHSd3PMfT5ifo+ack8eFHI6QEcnT5GvdOnVdXof+ptJ+BVPWceiaRHA8Us/nkACo8mzqlqmWrbFDppT5A5UIZm7CPA2Vgm3QfsEd909kKIqB1qJAKCBG8ZstZz3xHOAAiwmpDIdng1maZQAkZzsHZ537YfQrwNyxoQ+HakrnS0h1mUA1C96TdJTmORyhC3oeqdwROi+GDhkFI6bYNrcNDEDeAkXwQizPRpmnIs3OdqZPSaRFUcbchHlgie6agq2kX7Dd/+d8lUJVXuUzk8ERmS+2vfd4uvN2VOV5rSwb0y3JhgIh9wJeN3YMQCIgR78Q+nDEVYBYZUrUpbXFnM7COSdf7N4IPvtDnT2BY/h8Chh10MXQeYGS+7GGjaQiABpuNIFiECnzdWJMIUHcazLptC7YivsF8/7FgLFMqpiQL5TuNbKfA/DC46rqqAbAwIKWK+timRUBEiNGsOQsyQm+Gpjd4n046hbT84KPuYjOmHHyp92gcgDS2OoIuVIeh/xyUkaVwyEWdLrewHE3uBUDcKIwnq40HpDXL+n3CzbaKdguel5VnFJl2awaghLQBTzteZ0cjLq2A2n0M6EPh2pC57Wg41poLzZsAZNso0Hw6eVR/J8bF9YjWGmVCpGKwQLBRCcrbiSxNLgVAxCF8XSl8YDHHFPW7xeFBRwv/rGqOKUBkODzqgdWPYAM53vTASMQu4Bx9J+69OHIF+N71F1O1gUB+AsBfFqKC+4Wi4BWX+CYgOTAU36wdMVNVKka3MoBWBhPxyiuko3xkSX9fvGMkqsDlzzHC1N6SQ4DoINOe7KelWWTheziObeKCdARApD1AdVnRH048gKUAmAEYi6Oh4DJV4VoGDWqjq4XLbO5o1jBoimEPhPJmwu9FvnTLgdgYTwd2wyXbMyRKen3i2eXXB245FlVYUpVxUpGiLtmGBlrTEhVUwV8dEkVKAq3MHJ1uzRbRx+OOgDWFX6MsXJU/36lJoEoA2AKvw8+uwTEDIBbStdOs8ddDsDCeDom7ZdszBIs6fcL9ror2C75US9IxJJsEsHdGFBil4yYuUwknofJgF4XcEUfjrz+X7fKo4EJJ//PkMORO6FrVjQMeL5kJhZMMXzLwNZCt1nzDFgYT8cQwpLt4hDON0i/X7ys5OrAJVe0S/ISgFY7j9ZvnQ7I3+lyqpYaL98CWp/N+nDkZdhi6bW8An1kP3fRTLKVWlwF6RZCH2L4zDDR0k1IqeTNb2OQSYNbOQMWxtMxeqtkY6I+ny9VEz6btfb7xc+XXB249AoXv85+tIBVgJJ6n4lf6oV+mfjdDJNMH0wAVFX90GMk1f5TxlS3Fggh92DyN0IORy5665KIfCktsl+K3VsGtpVOWOMiuDCerlSnjQ2rB+n3C+pIBdulz8wqonrNPLKgwKaC5B3s53qhXVq6oDNg6sOhqvqhEr3V2VNLBjmnSSNdrOLJ1zkAu6VPRjFcFz4fXDJ8i45hG94Gt3IGjOFYA8TTlQZ/qGH1oP1+8ZtlT1MAtHK8mQg25zOZUSCLIliWcbw8wfW5Ln04ssqnHX04euiCk6/3de66MPpuAQVZAEFkw2MKFw6a1wEL4+lSBvmAOMhD8vkOkFX77feLNw14YT/ssmc4A6oOdHBEkwXlgjH2k4Nal6wB4fIuX9LzZjAmorNeHMo5Tc0OewHwDTUh9HXxfGJsYkAbAAAgAElEQVS/uvCpoAcew6zBBrdyBlQwwoDxdLZWXLDFkHyF8xGE/fb7xR8XXByAAVC1oB18HQYIT+8uGfP75SCUs1o64he8v4j6cIQ+IqkPhxrBCHjdjBH6AblQkAeY1ondukSiELmsUPpjbyp7XuvDgAXxdNZVvWCLIfmKg6Bbhrjup98v3lVwcQLw8gqA5v9zC9jErutltg8gMxDWWMBaMVkmANWFyEV6R0uH2I1IzW7ypbkQOTP5f2ch9KsFkwp0kQlDAOmxzHpscGuGAQvi6VD4RgmAg/b7xZVlT5MATNXwqQc6KGwf2U2uGV2uzg3D4ua7fDnPwZcKgIdq9GaIBPZb0YdD7hgyIFWMXiH0eQ5vXS5HcMkc++9lz2t9GLAgns7KxxZsCkgdtN8vWD+vYDMAUpcja7lOR9eLVcIP4tcuob/3AOHCdW02VTX62ApB4Mv1v24gnPy9HiH03fJ366KYHYTHsgBBg1s5AxbG0+HLZaOp65i+ln6/YM5EwdYBwGj1cmUkE7+8THLNdAHhwrUOXtcrO/pwhF4cct2oN68BMDCfmsJM/n6PEPoYPp8bH3kCkbtjji2tJJA962YAWBBPZ0WBCrbYsFoOf9pDAiENk179fkuvf9nTXewKcBSjsn7ldonWbgQpx+26otaLIwAlfi2QQSJY3Yjy5i9dmsFM/oEDMM/Z7Uf0RiYUA7J+ToNbOQC3e0WBBm9qLad6HICG1ZK1XB5PoxnuOOIcxSXe/Of8xHV/P+FpwN47gKUpYHmuSve0pKZgCKSq5wqniWE1WZz/xouBm74KTMwBI17lVBXwtWSs+8/vL45Ff3vhpcAnvwos8d48DZX3M2hx9XIAnu0IIO0chu35AOgLL0yuG/jOmwbg028G/mNz1YWdETbm4I5BrFlov+EtD2wIo7l+Atg8D2xY7iw3V5diEqO54mnj6XdMAYcU+6gon7A3NSO2qFjlyZYDkAX6uD5Iam44YaUfVNDNxaJcLIPXcGGpfi6PnZdVD1wPspQBX/wl4OaNwN6Jqg+xwrxslcVFuYJblehkcYYZGPS3L20BxueBcS8nwg5H5kZkx6TQSbXFZcCQKadx5Cz5mPurAFxrRaa17pAR2PFC+ElSHKQ/0QjQcgCyGyM9v3SnsDBRJgL6msWCf6IfWeUJac8UFlpY8500DcCfvgb43hiwZwyYVhd2D/VSrKGAmIDnBkiafEcN9cprHgKMzgNjS1V7rRjRlceyrqif6KAkMgXIM+6tAnDl+zSL36O9+U8p9jGHQo285/2XA/AnXeNnKAorDXH/AILwbSvLEz6Ql2+cAf/3XcCdw8DkKHBwpOpFbE2wadzIdyh3jjNQirYWEwYq+/zJwMh8pf+xKNSwM6DZMmzNRRbM2K+2Ii6TlFrAWfd5V3i/F7IgT2LBF5LbIdkqxLPWvtzlAGQ3RpU3Y7AiixMxLOUB2t7pKQ8M0qCTnp8HkojJgNqaMEJesQv4AR3Iw8DB4QqAs+6SWRiqgJgY0HVDAdBA4Ba4xN7ndlSFAAjAYX4IPO5dBDMAdS2i+Jx7XTf1eEdTDfgAQnR34p/wQkRmjNAoByDT/ugFphXAmjAEn8qaPQAgZCs0lSckCNmVigEbFMsPBBE3DcBX7gLuawH7hoAD7EM8DMw48AhATrjtQwiXoqkTEwWd7LOneXNCbz6Tiq/TInb2M8ZzIFrTQbGiy92oGz7pXl/7jvdAJnb2470IbB3T77Sai+hyAP5voTqW6sKwFAc/TAdc5+3dvcsTrvPVYSK4SQb8xV3+6IaAqSHg0FDVh3iOIFTIFxtit9orL5Z/LD1Q4s+B8OnHVuXwhhdd5DoLGsgCCJ04q66X/Ju/vSaeAxDPvbdtmdtKDV90gVEPIl/xySkviOhmAEjrlzSkwj40SlQZYZ39I+8JBMx8mZryhOsKwqYB+KpdVSDFvhYwPVR9BD7uyX4SwRS59nNI+bRck/DzJ05v12M0nY8fAk8iWL5BB5qASPGRCi8EVjzv3mqpkC9ACrrwhKukB67GhpqRRowQMqCiYbj8oOoHeUWpdYIBAUj8c8WjrjyhNIJ1unzjDPjqXdUjJAAP8TMEzLYq9uOHICQALe/EwWe+QgddAqCzzD8+vgIgg0qp+5nYjaDzCgjmnCYone0klqP4JSgvvK+6LoFPoFMlkPGh+0rPWta4RHTNJJQz4M8EAGoNTPVU8opS64CC9zoAWTFChcq7lCdch6s3L4J/2QFIEBKA1P9mHIBmhPh3Ai354RyAAmWsR/PRs6vOR8Z8FMPS97yxtIlYgVB/I7jC0rIKSfLXF1EEB+BFFjQ3jCLA49OWsRTTEPzvzQEwry7VrZ5KwzAQAPssT9jw1dcHgCrORQCS/bgn+1HsCYQSveaHkzvGv1scgU/6R55Y1YIxhvOm1EZekQWl8wVDxJgwc88QiJc6AKX/meHDawX9z16M/Em7bO8Q08GBP/jEkAEVjMBoAFWXUjRA3KtNwOBXW3EkAZhrALktpC6lKtTV4OU7RHB+3kHWgv/zrnYZl2kCkF4uF8MGQGc+MqEYUCA0n1tkwxbw4ScHAHr71Q7W4++c8czwcBAmHVB/c7Bcek9b3FuwbdD/kjGWgzJjQ3thGmVA3jhfOyU+RxB6FamOFp8NrhsTgLy8Cpzm5QlVptAU+6CiNgXCaIQ0BcDYV8b0P4pi30vfIxD5+w72C9aliegW8MHzqrmh/meuFhYi0pKbs6D9fsh/n1XFMrYMbPgUByCZz6J+uEknDA9AornWFRb01WZEsACoHhOqyC7wdetT0QAK2KqOb5MCUvPyhLE0oQxzqaYNXL5xBvyVXe12vByLADjXAvgxBvSPGFGMIjCmJbEW8HfntxtQmxT0cmxp9UPAdKAZ1upA6EB7qgDo6oCUxXRtPVSpAwJpnUhuxAqWCCYK1MBExZljY5S8SYr+pxAFAuBayhNG26jw8usCQLX0SAAkwwcAEngyQizaXoziIli+Oe7/9kJvNk1LmBMe9ECO3XRB7aPeF0EYHNVPdT8gj016YBcWtBfBVYJuz7mF7VgGY/pO8f5WdQ1/7U67nIKNS7j0wIbDPFZsyNHHY7od/xdlEHj8CcC3TgCWHgGAPSxiSdt4312u/8SPAl8/Dlh4pDeZW2PD4J1c9+uyDaIDkgEJQKnTfG/N8nUAmu5HUnMW5ARbPfEuIHy/ACjRK7FL5pOR4RaxgTHofKl8r/S1ZWBnAGDKefbn3AFIPRPXB7sFiVQimKVgGdl5ooNwLQ1/1U+DQGSXQ9r5Evy1q9rZbP1lGQDZsPpzI8APHgXgod7qUx11YtBbFzC+/C+BL7SAWwhgdoLkONSLqy5oLogYft3ZI1F7EAC+phsAnekokhP4HIzml/PvthQWmPB9LJ7jxkcSr14jWj4/0wFlgJD5eoDw6fe4DzAYPHokWhHJZ3TFSkn4h7YOSOBwEtiMTv1aY0uktFYTmI2/43EMQmCuAJmUE0gmVD8EFdPpdnxhVhqzDr8F4NMtYM9Jfg98EVTeNu9Q2OFZBX7vr9vtgm/lcezczZ61ZNN8DCvilYCdPXqNDQpAlfGTKm0M6AA0PTAyoMSx64cRfPQHXsniOTI+fEWDFGp+Qb9BeySRBV2kpl0QxxGAlHDmkI56X6z+EP7UDYSdRgh/IouwIZ36lHabBE0GJ0r10Rgb/xA/tt/j/6aMAf+7R4CxzuBXWRGULwBfIrY6UNfpvLae7n0I+LO/reoLMqiVMbW38oUhkNkQIzZO7tIweGePcmWlAFTjAYHPVGwXxWoLYblEDkLuTT8MDPhXLJ4jALpaJB+ggU6xfgJknT7IKXIQXh4Y0FZCog+wxiUTwSkXUbSMV1rB/A31OXWuFpPUda/mRHKi1e6U+hA7Zq7l+A+UAfDtHg/LrptkQpZ727cRWOL9542Pa3rOvuOqagUltgtmJM08j4/PILbIDKz6w5PAHsbraTnMGdZWIwIzxIfeK0rn578J3LAVuH8CODRahV/FFQ/1IumIvXP1QudNfyNT8oVqcHviPcBd48A0g2RDuoDqHdb2SalZAdG9dnfDkAE0gXnH5ijWCDbKCq5/MRiV0QD8HgHQ63jG0hdsLGxA3x9Bw1Asli7hO3BwApgng/Gjvq01IHrXJ7q3Cz7E++YziF2rs1ZLZ+8H9jJsSoECWXj6igmR87aLgfbGq4GvbgLu2gjsHwdmCEIPSI1h+SkCRjpfUC3iNWcpoRrcnrYbuGsUOMBo7QBCxSTG/igxVcBIVGPWM1h1JYQPnyKNExGZMDIJ9b66eEBGxPDY1Y5nv+GCjfGAxD+DDpiawphABWZPjwNzNLAEIH4XCH0M7/5c93bBfI8Yk2cgVAdvdT10ifDkBWC/r9lGH51NhIsnsWHOfPmEUKT94WeAG8eAO8aAfWPAwVEHISNQlKQUglJjJExqC+H6Nq93kOpUg9szbwLuHa66QzFWkaFieXxi6hgVHOMCYGRuJ+5V4jYJIDKI9KlsAvFDq8QDrnb8NWVPh9EwdFkQ79TlSMIsN0Mi5s9MoOGno4U6f3YAvefL7Y7rvdoFLxOANSA8f7xSgWmd0kCQbmZ6mTLEnJ0UqWLhUkxlrBn6n3wWuGkYuGukCsufGq2iojnRFpafsU7MDxErJuZhYCsJosHtWTcBe1oeq+hxigJgXBrMmTBPnJKLrr+VED54ibHYvZos8sO+DNcrHrDX8YVVyglAKud0LtMjFPtNMz6QLDY7VomLJd671AEH4Xu+3g7nWq28ISvX58/hguOBg8vtFQvV/hEzxfqOevuTfpjri8vAWz8L3NYCfjBc6ZYHmBcitnFd06pxyb8W4gPlgonBqffTtdTg9pybqiVNBssyUsdUD7eGO9amnf3sXtxQipl7Wg/sD4A8AwHIyZMYky50Tp/xgN2OL8y051qw2hXzwRCEdT2nmck1RxHG+w5jeO9NFQBpR6ldMIMXlFWgVndqF2dVFsJzuOgRwMElB6DcI6rznemD0RnbwQiSRS3g7Z+tVIl7PC9kahiYZm6IizuLigliT/VoUog+p8P9l3wJ7qGEanB77k3VczroUToWLCsABud4ypaLCUoxf9i/9w9ADiICULrQRWuIB6w7nuZrwaZwLBGwClSqSyz3AhHbaRGEFGOmC44D72UVgjW2C2Z4lIF4ArjodODQcqUGqAxfcpG4mJVuVqcL5tbs2z/veV0tYK/nhTAqesYNHdO5PCJZos+WuzxHJIViuXFyJxupNLg976ZK2lizUKodilGUgzyGhokF8yw5Mf+qRkjdjfuDtwkkm7DTkNaBaQ2ox1q3eMD8+B6O3H6em8Kx1Ccx9ptWl9iYIUAAWrI3I3nHgPdOtsO5eOuxXXBdj0V1vOL/so3Cxef60tlSpYwveKf0pAu6ohfdJ8k4CUqgvr5jV6VGTBKALeCAh+VbZLTnh5gu6D44A6H8cVlkNK95O1WkBrfn31R5HSy+JCwPplAxRegE/2T+AloGncNmbQyogUQx/KwB4gHj8YWNTwRAOW0FIIIndoqNkTAxz/bd09XDGLBdMM6/pLKi5whAX60gCK2ujxzEAqGL2pQ1Jis5AJEAFHvTujYAKjRf+SEugm1d2COQLU/DAwQ44caEw8AtZzSIPgAvuKkdrWMM6M7xCMBoiBn4YpCE2NCfxWAA5MEuwvCCEICwlnhAHV+YORfDsWJGgPpMKwg1b9QpFnzHbD2BK2JGul9s8KkYW17vLALQRTCBpzXZpS4gtCXXMAkduuAy8E7PijPWprXJ5CR38ygw1fJDohh2BlRAgq2OeN7uTWc1D0AFNtmL54ESBsCaJcLkDajxj5ZXRiCIGA0waDwgjy8sk5+HY+X9ppUbJSCp6TnFCMXwny1WAFQ8rUAc2wUrRL6mXTAefWnFfnz3FpbagQKLAqAzoZjAKkkpXkNO5GCEvOMLFXOnnC4xIKOjnQGNdWSM+GqHQGd7JSsxUf+JzQLwhTdV4je1nQvr1MkPGtlf9yP2Dy+gAqZ6rQytfvdHSDxgLwBF8AmAYjHWluEDiKGMiqOVvtejXTBOuRSYJwDJAARgZAGWL9Nk+IM3SzgTydE4eec1nZHbtDaNAf1Dpd/SMx2END6kD0oXtFhBXmcY+OY6AFChnKnzl7NfdMR3qCAae2B+VVMYXASvDs3/X/zHJZcB84vuiqABEo0QPnhnwqQLyRURmZBPytnwHde0M1vN2lR6picoKULaxHDIEdHkW2iWg4/7b5zb7DSQAVd0/griV2JYojfpwRGEYsGBrOBmx/OgP5sAKANkcbFzNWTRnX/GSGImMYH/LYlk+gGvdT+bW+SWH+Ig1GqL5QeTtR2EYj5LVHfjw/ZDwL8yJ6TB7UU3VVoTjTYxYDK+Ivv7dzNAZIxpZSiU8jjKgIWTcykZkBawDBBnQdMr5QeTKI5iWCB09AmEb7+ucnOQ/aTPWn6wuzyS4u+R0Ob6CUGqJpIDA97AdqINbgRgBJ69CG4Jp6q/ckjXqB/RKla4WpkO2ODgHoynigA0JiLwaNiEt95YQKJ4FRC+7brKzRH9jZbN6iJYuSHm9I5iOAOhHNJfZkh+gxsBKPbLu3+JgaWDdojhMO5kkDWSlNTg4B6MpyIAjf3IggJgMD4MCARjFMU9QCgAykhSKnUCYHB9JB0wy5aTRUxmup4h+Q1uAmDs+hpXgFLnB6ULONOn5xACNJqxghsc3IPxVBGAiQG9aLeilWUJW1FvVXEN0TKp1C6At19TMSCBpz1dHtT/JH7N9yaxp6QkF73KBxYIr10nAMproB44qQGTj6sjUrtOFPtLeFQHLES9AdDFrq1E6M13MaxVCTNAXNFThIylLcor40zxtgDAPKuVwDMrOKw+SBTbtR2MND7sZwC7Qvm4wqHa4T/uIrhb+7n0EgbQdTijoyg+agWXT8llDsAFWr/B8qP1K7bT0pvtVwHhW6+t2C/m8svvZlawi2CKe37nhFtapkDnILRqBQA+v04AjMyn79EIkXO/DnzyCBwVweX4wxs9B4rRZgyPVFqykgDd+5JSpBU5r0vHyHz+jsc3ub0KABsZMCyQgeExKyFPVIz3lmcM6OfPAGCADYPE67Jfs6h7G0o+xvi7oyK4cLZfOgpsXwC2Lq9MwuuVERonKn4nSJrcXnQKcM7dwMMXgYcsVxkSebJgzOWPqdB1ad2f3gpsnwK2LXWeR9m3danUIV1lBSCPArBwtp+7DThuBti6UDWDmWA/DvXk8LRptfPtNUlihYZTOPCi04GH3wFsnwGOW6iAs5n3GeJJ+KLoE+9VDClQ8R6vOQHYegDYwuY3S6H/iJ8jb11ck0q9Qhoc9QMWgPBZJwFbpoFN88DGRWBiqQIgWyJY3lPozaGJ1KTEPh36zpTkJrcXPRE44S7g+Cng2DlgyyKwaclfFoIwvCwx9Zn3Q1DmIPx/2/sSaMuusszvjfXq1ZRUElJkKsBEGQyYhJCBSkUqAW1tsBdpuxEVaBzowXZqe1g90G2LotjQdmMjKqtBxQERdAWUAkUlZNBGkQRNyIAEMAkxpFKpqjfUG3t9//m/c/+737njPq9uVeqcte66b7jnnn32/s6///3v//++Tz0dmD0KzC4DM6vAFpd/0L3Gh6yTDgnvLwKzAWDGiH/ThcC2OWDrErB1pRgQisIQhAa+AED+HEEY6uNLyrRnZLSl6tSbrgLOeBQ44yiw8ziwfaV4UGbdegmA5QMTLFlqsfn7XecDW+eAmePAltXiXnkuZSBkRcm4UGXtU2uo3xsAZgz6y54JzMwDWzkgBOAqMMVBCSAUObh8QuN/CiTgcWAuyWhL1amvvBbY+VgxbW477paa7gIBqCnUrbUBiQuhAKDUot13IbBlDtiyBEyvtO5VDxvvVfxW/JkWNFrCeK8NAGsY7BsvKQC4hQCkJNaKy2LRIsg6SJ3IQSe1onKKC2CsOYMeN+0Dtj0ObDsGbFsEZmWp5S74g2Ir2uA22BScAJGA+dJFwPQ8ML0ETAUAkgDTPq9zdK/+sMWpPF19NxYwA4g3PtsHxAE4SQC6FdSgmGWRRIJLZJll8EGKjHiX1jwaN10HzD4BbD0GzC4WrsKMW2pNobZoCu6CLCDfCTqzgg6sr+wFphaAKQfgZHKvpRSYg7HN5XCL2AbAZwPrZGaj6ippXhgn0kqmU1woxnHedg5AATuWHig2FE1uVRwoxoX+Wcbg89S3AqCKPONcCi8oPtVP+9++G3j+oSK2xRBFDElUxbTS+3nvc4FpDsjxllXQoJg8FgdCQoGJJTTicLcQ6vPL6wbg9cDM4cJv27oAzFA5ky9/UOSvmg8oP86n0dICBn25JwjARWDSAUgBHN6vfdbv10AbARh8X91vDM2ss+NvAECKPVLCsHoyUgRqrlbnRwB933OBc+4DXrIC0IEmiLnE75di8HsyAcjzWUVGUi6uICMpVwwJVMXdeOk3XAxc+Hng+vV2esAYw+sWoP31r3eLcLwQBeQUrEHh4Jo2h4vDmJPuAyMLGAeEn7uqbgB+I7DlSWBGCwe31Gb9aL20kGDb/EGRxY6WTz8f2wtM8l4pgL1SgM8esHCvsuylME4nn9cfQLtldg6TZ0kUKorAfij23vAPCmqp3fcCl60XFINid1PlZrf41/dnApB6wSQjutUfIDJR8CGIQOwWEH7DywpKrWc8CFzqRLHkVYrB2jS2FQH5vkuBycXCAlIUUAAkCM2iRBA6+ARCe7DjYmQduLYTleiQ/XTTS4DpI+6nLhZW2nzVCEBaMLd+soIGqjD1ampdugiYWCpeBKA9bBJC9ActAk8LES26SqsftInLZ44dQif4Igdhym5WLrPDyuYH/7HTCNwDnPko8LXrBccjQaioe6BiKad3+QY/MGTH6rS3OBvCnQDuAIyqhiDkQ9RX+29yE3on8IwjxQPI8zkTiApGU3oVkD/4fGDieAuAdMw5MFQjEgg1DYsUku+a3uI0TGBfV7PotwHwaOEmbHEATvuDIutni6UAQoFRIFRYhfe/dhEw7tbe9Of0Si1g8HkrwRcevDajz07gIJ7n05rYyWIpb4ya/7vv8PRdFpj/LXDmkQLAnA4jCCOlTBRN/rFMAJKgkkVHpGUjySSBSFeg7/azqk8EgbSEq8UDRACLKDXSyaQ7Br//DcA4LSCtwnKhTEkQcmAIQhtM+Uaajl0uS9NatITXWzpzfcdNB4DpY+6nBgDaCtanYLN6fCj4u1ay0QIqtML/EYC61wSA9tAJeP6eWsAoDysFpg1eB0HIQRCIIkVeCqQf/05P3WCB+UPA+CPAzvmCaFWDKEuYcl1yMN+Y2dckqGTeHPEvvWDSNhOAfbefX0A6rS8CUw8X9066bFIfdqMHJID++DJgLACQumyc3gyAEYRRKFCLD1eu5ODLF6QvXedx0w3A1BwwxdAJLTXjd8seQnGrZ9bPFxLyA7WIKON63tYtCQBN/sv9QPm6BkLp0vl9t/m6ietR6fbyBA4gnXtORwRRpNnTtPpW6gWLH83lKqcOFTEnDiKtoHwy8RNFhrefyeztbnrBfbWfgttsP+kIyO32ELD1cHHvInrlvWs6TsnB7qAUlg/suFtAWkE55zYQ0QpqcALoNCXTEt7A3KoaDwGQfqoAOEUBa7fUbKctltwCajVbxvSiyvoasM0BaBKwwdKb9fN7NfcqBWGiSWykWXER0umeacUEonQgCKRfIgDFjya5yq8Wfsfs8dYgiuMxgpAg/vnMzu6mF0z6Zj5APdvPQec0TEosnvQosGOhaLuIYvnwEYSithE52F1XFAA0p5yigD4otCqygFKnpHUpLYP0OcKURYv6Mj4MNR433QhM0gL6QongawOg+6rl9CswKoSkEIxPyTsuAPigCYBmAXVfYcVf+n0SRYw6dP1YwNgHsgSajiJP429RrpWOM6cxDiJB6NINM4w7LbUGMQUwB/M9mZ3dSy+YVG0EoBiDBST5ddZ+PkCsAiIlQZDa3LVatJ0WXG2PbL98AB+4omB3oP/HgTUhmGgBfRqWf2TTrUSjExDSP/qWzQDgfAFAWyzR8rkFtDAKX75jo6nUguZxZ8NByHbvvqBQ36T1swcsBaBAGGRg40Ir+rt9WUDhQ5ZAU7Es2e9LLzglqHRxNkbeuW+oQRRls5jaMjnK0a9ecNf2R4LAwO829kQB3LTtEYQPUwzQAWgW0AGo8AQH0ljp/V17pm0KRcEifGuNOnocO1rACQbKPXhs8TtNwVr5uh+n6Zf3wDgu29g2FdMtOc8B6PdpFj08ZFrplw+ZA5FTvAQQ0/BT36FPDkRqBT9Jag7xYlQItY0f88j78sZzCcKPZlrAQfSCK9uvB4h577SCotUiEJ8opq8IQFl/PUBPEoBLxbRE62LSqG4dFB8r5bHcOtiOQSqT5T7RKzYDgJx+BUCCTxZQCwhaQc9oKcEnEBKknj5FsJ1LAPo9xoWWPWDy+6IIoqbeaO0VA+zHB0zxIQDKkn1GgtXiRxMIAx0Vn0Db+lkuFjLRCt5WEwD71Qvu2H5OfekD5FaciQay/GIbFgBXriwAyGmJADR1ck3DwTE3TQ4B0LetzBJErTYAr2BBSI3HTS8tLKBZPo/fWQDZp197Z3scjGb5BDp/L3+njMweB6B83Gj9wj3atOsPWin9WgXCFlVO/3ctf4iD8XkBkH5USlAZlNPZAQqARr5vxu1yjmH0givbX0UQKI63o0Wun/xHuR8E4VnPK5JQLd4VNttTBvK2uoiKOUf/f+GjwMNBh0NMV6J0c0NpcRv7mrYv3kh8/uHxYp+bVpwLp3R7sts2YzouSq3KGa+q7+x7Co4nazAerRKsVlV1QitF59dyyFZaYY0HMu9mWL3gtvZXMbymBIFMZ1ov2h0B+LTLisxgW+Eq5uU92iZ72ud9vvR+4JFp4NjkRh2ONi0OB1/UBCkvEYRhfuNs4OmhhiPKnFQlx6aAjMnSXJUAACAASURBVPjmz1w41nnwO4cCIBvBwZgTAOUHRq3gyDExD4zRGVYEnpm5LqmQc0M5esFt7acFl0SlHiBxuTkYxxdaihUC4QVXFu5FCUD5QtJl85sjGA0ziQxqeu/fem+hw0F2fLLQGxFlYMRvo7v1WmIVtpt1DFkXvOR7LwJ2HSkyoZmEypoVVe8p7b6qEMnidGG/Vl/L2aPOIwuA1pAIQE3DAmFa4j9f7CPaFpCHKujr5xzZesGdHqAqKz5X+FLRAl58le+jui+kTBALMcgZ73CDBkpN2/7+bfcWOhwUyCEAjQTcAVhKdjkPc2RajewKyu/n1//qJcA2uhBMRGXQOcn9U6JIOjXHQqSYOsVoQp1HNgAvz8yny80H5PVz9H6RqVd849WtXQ/zA0Ow2ayGLJ474L0G79vvbulwkJi8BGCg4S01SKqofoNvSIC+5zkhFUupV8rUTpJN06KpaBkFQm5M1HlkA3AyM5/u9Zl38zrk6f0iU6/4hmscgK5ISUtCTowyDqb7UxwsqFJW3fo/vbuIBJEZ1YRgyHwQKNi0KEl1OKTCZJdxtPDn//v8ooaDaVgqFyiTD2IKfcjZS4Fo+7g+HXOPv84jG4DIzKfLzQf8KVfI/FNKrQ6h94tfz+vOA9cGAAbrpylY2SDlVTTt+uCnV3/V3a7DQQAysJAwobZJgUXi78Qayhd812WeiOAZzEyUiAkHMeu5BF5FwZQAWLPwknkLQy9CrPMy8+lIHZFzvN3T+YbV+8X7c64OHHix74V6zIxB+RJ0wQ+UU992tYoFy3fcXcTDxQkoPsCUhFIczKVCegSg5B8A/PILN9ZwxBSxtiKiUAOi7JW0dLTustF8AGbm0/1o3vjjnSGdj+lYlGwdRO8XN+c1wABIoHk6k61yuSCJITq3jDY9Vx0BqK++uwAfX6JkI/hME0SC1EGguiQ+isqcQRLrF6/0jO2w+6FMnZhyZYsQ1W50qOHgPX1NXndtODsfgMwHzMin+0+ZN0S9YOllMzWfLwKQSS396P3iY3kNOLDPM1y065H4gOW3p4uTDkB8zWdb7FgbdDhEgJkCUDRvogTmd/vPv3BVAUBuvylNzAAYi4hisVQnEHoIqWblrxqm4Mx8ujfljT+YjsWBYgIOc0oJPsq1slCpH71fKybJOEoAuuVTRSCnYlmU6P/Z4iSJEcbLv+Yu9/1EAh7JKEXDKxq4ChUiKymRbwjgHdcUWTARgLYXHSr2LOU+BV7MVwzxwOfkOWybYAGZD5iRT0edjpxD6VhcOQ6j94tP51wdOHBdMeXa9OqWRcmWXA1XLUIUH6zyCwlAs3z+YBkfs1u+VIejJEF3ckrjI9T0y/aMA2+/tgAg08VURKT8vbKMUgAMIGzzAcOi5HknHQAz8+l+MW/829KxhtH7tTz+jIMAJPCYMULAWd6fvi+EY9ouoZBM/Kx/4LUBgFLgNC5o16FrE8JJVJgkiFhaQQBv3+dVbMrWVsC8UxFRkjjaVsW2DtRdOJ/vAyohVYK7A+bTvTdj8HlqTMcaRu/XxHkzjgNkIOWuDr8jnYYDKDutgpUhra0uAlAyCCUAK8BXcjBXgLCk/h0D/hcByDxFAdAzoFUqUBYRJTUcMWdPP7ONL6i5bLQeALJRQ+bT/W7G4AuAOXq/lsGdcRgAY+glLkYclJVTsa6ptCX3uQjAKINQstFrAZKIwWxQIhIJuovB/Nx+r2LzFCwlj8Y0evl/MYk0kieVtcvrwGUnHQCVjjVkPl3mItQsIPuElx9G79dOzDgMgGkAWlNyBJn8xKprBRC+zgEo4LWRgcdVcOCjjlNvmx84DrzNAahaFZWLygKWxUNibIhTcPD9BMLLa65bzreAMSGVoXvJ/Cgh1WUfO+XTZS5CDYDs9GH1fnOrIDcAkABTTDCCLYK0Cwi/586WcKJUiEpC8CCBYDsiiSplqUIUmOjf+o2tIiKVUJbgU5uSWl4DWwX4+PcXnrQATBNS+8yny1yEopdcay+930y5YhgAg+9n2OoUeI5TdQer+32fdhmGoOBZanBo+g1yEKU4dYgFSvqB//vZBIBt9RshkTbW8ZZZ2hUgvDL3iU3uux4LSBM0ZD7dPRnTH08VAIfV+2XAOucQAMuVcKfFSD/+IAABsEoGwYAoHZIKEEYxRIHwLS8pUuhjFVs6/ZZhIVWyxVKBBIRXnbQATBNS+8ynI4tBzkEACv+chlUVIKE/5cRGsWmlKfIzudc3APLQSlg3E2OCyVRc1kpU3DgBmKoQsWtlBcswjPu+nfTYtBL+GQdgOf16GCZW6pXlBCqWSgqJypoOAFfXXDifbwFJLvi5HAjlnUsiIe6AjOp4iQNQHRlT2PlgJCUbbc2s+v/hFwFb/q7gm6HlYpBbmTV2sscQyy/qFBj2v0/cAdz/HGD7NDA1AUyOOU+1CwWOewNjKj6/O03F1/WuugW4/XJgfBoYmwDGdH7IxB5kLPIB+I8AfNwZgga5ck2fJbEm8V9zNWPfrasbgMuPAcuseJ8Exsb9FdBhA+7gaQNKB6TfcgCYug+YJT+g89aoBDMmIMScP12uTKj13uDv8zsKig/uJ1uQOsnojm3qB5P5ACRBH3OhPuzzRN9DV88HqQLEWPJnvTy5nm/t/1s4BcuSpRZtGAu4fi+wtBVYEyccrYwn6hF8/FkJp9bKxAKVFsn/d8urgbHPA9NPOEOWl4+2cfoFHhfVrJTZPKHSj5daOtup6JyCpPx8rHWRVQ7WOlrYCMx8AHIzlxkALPD9c0VB+x/A3E/+E2fUYHXdF7KTGwdvTd0AHP9r4PgWYG0KWBdfsBdsMPfPrKKsoL9XAVLAvO2fFylCE4cKliyrDVZNcGS1CqEYhWFiAZV+XntaURdTLmpCEbpchTYLqi6NrkMCzLzt5Xc4HwyJmmkJ+Z73jQOh4NWeDUZiK1K08f0EXt7CMHVawIk7gaVpYJUA9LI1Ao8bzKX1cytoFtFfpdCIWz7rgzHgth8u0oPGDwETc8CEMySUzFaikgtlpW1Ta8JqNba7lVljSRgW+Q6ZP/57WQvj6fydBjXfAjKbgEvMLwWCvhNoipgNpnQshlS4IGFWzIk6ylWwAz93ETLxGWB5ClidLABoIOS7pmGfG+33YAG5mND0G8F4678vkiPJczNOAC4UyQm2N8w94kirFlfIAl7i402d6dbPWWAtrsjOFiuCvAJZOQE0pHTFsckHYDeCvhNgipQNxoAz8/8IPr5nbvH2jd+6AThJAE4AqwTdZKEBLDoDgU4+YVkPHIBoPwareOt/BkDexsMFAFnbzNJYm0IDnVwbt4uyur1kwL7Tp+iZM/08WT9Rc7DHUmuYTr/x+6o4ovvu9fjBbgR9JyA+omwwxvZI5ULg6ZW7y9FPf9QNwKm/CgCcKABovh8ByVy/UCtJq2f+X1yYJPGU27lIZLbuEWDsWBHesZeDz4iURLUWa1TE47LqK12fZmd3OXidFctqm92KatVs1jAEsNv6sdymaa2g8+xUL4I+Pn2beCgbLGWHI/h8G3oTr45iK86POlbBU9yKI/AcfLR+ouQwH9BfmmbLlTHboOnZ/T9+5vaf8FUaAThXsFOQ45mUcgZCWTAxe0UQ+urYMO1/37GtxQmoLCBtRSp30LrDp2SFdzYMgk/R+VNwvwR9mwQDsaspGSfJgYDYNTbp8psCQFJxEIBkQjDrxt8dXCUIY+COH5MVFPi8SOn2n/QYLZ9Gp0cxANIP5IvAkzVzxivRydnKNzBa8fddM84b6AFyAriMF2pajk9kYIeoClXmA3AQgr5NQEHMBqMVFMNaIOayNRL/vhlH3RZwmhbQQUcAasrVVGz4EtjCu/3dfb/ID3PbT7uKAZ/MhcIC0vqRTo4W0IBIEAmEtFwCYqjW03bcmdwBYeoWgetUbrR8snrloiR2drpACf+rD4D9EvTVjIJu7HBV+781X752Czj9lwUZkTEgcPoNPp5Nv4oBRhCG6dd+1DkMz1JIhR1BAHJ7zwqO3fIRRM5tmDK5CoQKsSgOeBYBKFZULTqcB9r6Ni5KYmd3WKDUA0BlhNLM8EbT1QBXBU72aI5ZjUcVOxz7WLkQ8d37vsart/uA6RcPsxNSAtAXHDYNC1AEpf9s01kKwuBwGU7HgVt/1jtD1e60fgQigSe/j5bQp+KYpGB+H62jT7P8/ZypBIC8Dhcx8eY9wF015abhmnoAyJ5WSrKeNgKO9SHxnT/LSasJBim5lRjWBEIVeROInKL1qunybRawLgASdEy74qjaNNzJCgqEEYzBGvK0297mAFSHEIB6ebKDgc8J1ksmV8t29f1en6L5v6cxIK5iK6Xne/5jCTiFcTqVn/r/tWDPWwXnEPTVgIKUHU7ljASawKefIwDpMdRxRB+wFgD+RREDJABpwSzz2c0LfxczVjkVKwaYgtBBezu3SvX08d39P5uO3QKahXMQciourZRAGKZWar/YZ1xXRPe8wQr2AUK7TvbOVTZBXx4MBECRnConUBSFEXT6mf/TK+/qmzAF/0UBOPqBZYF52HrTFCw2LH5G8UCzJEko5nZqmRnPh/uCXmpnVpDTsIPPwKApOaSA2QLDLSHf97iPx0tpISLfz7bl4iFfsUsnj+HZWEeOYDCDnDmCvZkEgedcCjxGseIhBYt3vx049HwMLRh8gA9gh2MoH9ABqKJzxf0McO7XlSAU4HzhYYFq+5D7hwBu/98OQLlIBCKnW39SlXNY+nqeiq2dkQg+gnGPb9/ZpT0lq6MV5D96gLCwgDmCwbdnCvZmCgY/dxy47xxg5SWuUjigYPHFbwA+fyGwfr2rXrMvPB+vp3L3GHCgi9JOHQCkRVPppeUBigXLFymyejYTB4YsgfA20ofRAlYB0FfAlvQqP0/TsX5PLOB5DNu471cmIwiBaRww/F01J+mz2pqChxUMZvpJlmBv3iTocsW4dzewfhkGFix+2febXDAeJO/YEILBB7pU1g8LQFo98QASVGYNQ6DZfEG3fnEqrgLhbf/HV15anbkFNCvohWSl9XPQ2XTM/2s3I4DwPIZwBEDfgitH0Ek6N6x+u/iD7T4g/YdBBYPpWHEaHlqwNw+AQa4Yj54JrJO+aQDB4pt+oCAyYvOPEIQDCgYfeF/9U3AbAMX7ItAlVtAspKZdz5SOlvA2pstxjES3wJ+92NgAGK2gwi78QoVfEhBeQACqNNP1RdoA18kKdgDhxkUI/zKIYDCnqyzB3jwAJnLFOEIW7QEEi1/1Y21ywVglCAcQDD5/Efj7M4CVrZ5AKlkhxeQUaxBI4nvFzxf8IfCVC4HV7cC6ZEX5nen3VX1vAGLZq8ysrvHY+QBwbGfI2E6JpLvdX+ksthpUvQrmX/sVDGZVUJZgb17vJHLFeGQcmCdVb5+Cxd/5xjZ6QzzMLOQBBIOfTV2Ps4HFHQ7CLQUQmUrV0rgKJMsCjsxGAqTn/hzw0EXA4tnAyg5gbTYBorKkUyLnkB9YVhTxu+kT13iccwtwdBewPAus+b2ar9xJAafqfgMQO4dh+J9+BHe5gqZZZzYok1JJUcpaR6bp93P+W/N6p0KuGIemgEWKgPQhWPxdP7NBLhiHKYHUp2DwpZ8rLOD8tmJQVplOLxAqmbRKC6EDYC7/CeCRPcCx3cDSrsISrs04CPm9ArZk55UvKAspYLqPaPdR4/H0g8DRHcDyVr/X6VabLHk2PhjpPVZY7d5xwF6CwS9y/4LbbVyQsEKIufGiKe0p2JvXOx3kinF0GjhOQY+oNRtljji9TQPf/fOV9IZY4Gq4D8Hgy/4W+Oo2YG5bUUy04vUcLCqSJVRWszJbNgxSmMau+q/Ao2cBR88EjtOqbgNWWaTkIFz3YiWrF4nAjtN0nBZrJnU+/8PA3CxwfMYB6LUra3oglL0tps6wlVha5rLiqd9AdDfB4Je6U0s/0BXTDYh80Sr2FOzNA2AXuWIszABL1JaKWq1R+nwGeM17OsoFY5XTVw/B4Cv+Djg0C8xvLYqJCECzgsxmZlq9T8e0XGUyaUizavPtxoFr/zvw2BnA0Z3A8e2FVV3x6c4sqwObckeyhiXAowUSADhD1XhceDMwx37lvU4XxVN2n3rJIocygkr/Vbs7fe+EdBLcfaXXQ3IPWIrpBB6XlnwpR76jYG9e7/SQKzarxM7qJFj8mg8UarMV9IZ4gvNDD8HgKx8HDs8A8zMFAFnPYQPDl0Co2g4fpDZLqKCxT0/7fhJ4fCdwbFvhRiwRgJruCOwUgCpeCvUjZmEFxhfk9W969kW/B8xvKQqnVgg+B6CB0MsI7P70AHgmd2n1NQ0rv7FvALIlVYK73MnQCDLThSGZoDpuP7uCeuX5n8zroB5yxThGnQ0CgyBMxY63Aq/5aBHG6EBviDlOLV0Eg1+0AByZLgbl+HRxnZXJoqqttA4ODovlJZVuSjTQFtq+NwNPbHMAzramdVpVs6wEoPtdNg37wJfvsYiJP9NFqvHY+7vAwjSwxAeNxVO8T6aNVRRRlT6hHrJ0Ovaw0WDJCKng7g86APvNB9wg2JvXO33IFWOBgn8EIf2nRLD4tbe1+AU7yAWbZeskGHwVdd2mgAUCcNKnJgLQrZ/V9/Jnn5JUYmnAE3hCmv3+t8AWQfSzyPK/POOgJgDdsgqA5nfJAvLdLV+bz0kK4RqPZ3wQWJxyAPqDVhZQyQr7gyaXI9axWCFVAGLvRUhV46PgLnUWBs0HbBPszeudPuWKsTRZAJDTo8l8ui/42juL5veQC7ZpsEow+OrZQlqVVuH4FLA8WVyDAOTAmHUQCAWQkOlsQAwDt/9/AE8SgPQpNa07+AhAA6HLXbb5Xr4IaAMfv/eGvP5NzyYA7UGjBWTWjh40v9fSyscHLtaxhJWxFVsNNAXH1khw983+DYPmA5aCvXkdNIBccemfceooAfhAAcA+6A2xLuAGucxrzgKOMexDfV9OwbS2BB/BEoqLSrBoYGgJ3E8qLcIEsP/ngCPuUy7S13L3wb6PU56/m/Xj4Ps0TKCXQA6AXuNeZY3HMz5QANAeND1kwcKXlj6wOZQ+b7R+Pi0PD0DeFAfk590CKg8qncfoFzIRVWVqfFfBhgn25vXOAHLFWCDbvPstBsJZ4LUPt+jdesgFg+qVptWq11bg2gtgfuLiRAAgQeg+oEmsOujsXb5SsAoCIN/3vx04OlNM6Yv0tdx1MKvK7/TFjVmeCD4HQQQhf159eV7/pmc/kwCcKABoeYvR0oept7SEoZQ0Tr1lPuPQFlAtO0nyAcWhpzw/FSjFzGjLx+RGvxzoSeC1hwsA9klvaFN5FAy+9mJgnhaQ0qqagglADo4c9AhCDpJPl5ZommQ8738HcGw6AJBW1VecZv0cePwOY0/wl1lAD/WUCx0mMlDLr8bjmb+Dwp3x4nkDYbD0thIO5aNtfmDi/xGEeRawxhs7Vb/q2huABQJwAlhyy2cC0xoggjAAUCWWAkksOiIY978TmOOqeqqwqAx3WGhHK06n7TDwOcAV/iipPAKjwgrZm2o8nkUA0gKmAHTrp+o9MTrEYvq44o9pZIOtgmu8mafCV72YAKT/RwAy5OPOuVlAAk9Oule6xQRTWUKlWtkU/IvAHAHti5oIwDK841ZPFtCmdr0U8PaC9hVultd4CIC8P2Ztt/m5/qC11TJXlJDGGpfGAmYODgFoCxACkLpuWh3KCgqE8gNVZK4KtxgjJAB/2X1Krao1rfN7CWZf3LSBT4uAEIyWBVpipL7GgwA0AW25GbGENBTRx3rm1M2w39mmrFVwjTd1Kn+VAZALEE5LtIDyMWUBvbLNLGHgd5H/V07BDp7r3uU+Jadgn3ptxekA5MBri0/Wp4wzBjDbCnkMWMqVpE8GJwLQqvfc0pqbkVj5aNk7gbCxgJno30cAjntowtXNaZ1suvSKNhsYTcVKmw9F5xGE+94dfEoP+JYhD/8OC8eIPUsUHokVVKB78XszbzAF4Pvd//PCKVGIpOAr78mn4DZOm8YC1jco+w6EFTDDPJqeCEBZBa5GffVbhmQ8DtZW5TYOvPhXip0GTuu22lTMLSw+aAVl9QhEWjurI/aQiLJkTMLsX9R3r/ymZ73fp1+37OU9hunXSkdl7T3QrhKCtlCM59k2i5CMMSIAGdqxEIwrmptzTsCEut5yilKoJLAcxCq3fe8tLCDBFwO+tKjyuxSCMdYEXoeDrHcHvu0tTwLzmwHA4N/Gh6zNCqqeOSxC2lb8tQSiMwbuqXIqAcjFh2JjBKGJyShQG6ygVbfJegULWBYcMR3rvb6oCRaQwFPgl1M5rR7/JtBZOIZWx/0+s4QeY5z/1/X2tFnAxPpFELaVkdLN8MWGVr4pCBsfMHN8bmTKfCjZ0Ncp456/x58zLzfw6Qf3ABd8pUgEYmqk5bGyek06IQl1bkXScnlN/u8L24Gdx1qVq91KQvrpgwaAAw9p+wnXPw1YjyWMGtDo2ASOFGMU7SIEUzdYD34vMPmXwLbHgdkFYAtlGiim6DpxJtvq9LtlVr/aWKEB8pUXAOOPAFPzwBTZ9r04vdQ9Ts4pAZ3cd+yHxgfMAOH+vcA69/9Uxijmz/AerYpdar1lNSMYzV+vWY/34I8DY58Gph8Bpo8A04vAFEFIknIHohGVR62QhFRSYjQE6qFri2z3iaPAhHNNlxKwArI0Q1IAxwfReacbC5gBPp66/5ICgLKCtqnsrKKlrFZUFPKOr7osMTtdsxzqQRZ93Q1MPARMPllohUxRqkEK6gShOP0S+dY2hlRv99y+ovRi7IiTnTvLqmg6xDPYpqAUgRgsoR7MxgJmgHD/c4E1FXu7FRRbvEgd7evXWlbPpp9EgUjiJpwe6zwOMlvpAWCMVusJYPIYMOlSDZRpoGiNxKzbdIQlXONMWJbGtw4svdgz3El47nzTRvPrrKptAJT6ZrzfintvAJgx4vsvdQvIXK5VYF3sUZxmJUvgA1FOvwF8spKyBtM1y6EepI4LqVMedbEaTp0EIKdPKh5FqYYqSxgo2jgFr13j6XXHnOiSZOeBVSvyC8qC2r05FVvVw9cAMAOA178AWPMp2LJaaekiCPXExwHw660n1oB/niGQazwOkkSepbJ/72I1x4CJ+cJ6lYI1riccrVicUuVSmIW82pkwnHHVOKbFsOozQGkFkwewnBES37ABYMaAX39ZAUCCb82nIlo+40p2gNnvsoKunxH1xGwA/LOzdQOQJPIuHzV2GBg7Cow7AI0l33XfjOsv6oVodes6ISbBsAZMX+kJxU56KY7pkmFVhOciuvTzSt05v0+ryuT/9gDrZNe4wPMsI7VJP3GcP7gUOOdvgL1rRYJ0ZI5IV3hV4/wrGYPPU3/AiRhYusy2K7mU999P+z90ObD7LuBZK0Xdkeq9NSX2+o4HLwfWlopFCC0fgciBMtAFC8CGrYXVoVjnU2G7rTXrzh4kfRzLY1kyGwBoeiGcPiXb5eAzdXWnazPCSScb4j3xfmav8Cx2p50lAMW0VXINitCogl2r9H2dcctWwQxQsn6ZTBbMNtcgdKIbiZj51VcBk38CXPxoQcfCUg8pjcYgZScw/momACnXyr4leBhs5QaBTHpf7X8dMPYJYO8XgAv9e8QJlAZZq8D4xSuANYKPJQn0AR2AHKy1MACKe9nfFI6IEqduEWoHIJ9wlsVKLekoMCa9EAegSTYQeM4TXco2SEMkAHEbBZoj4bbYtdyCVrFqGXgTSxgXYTZeHLi9AMjEQRCVUXP/n4KUaaT8vVTi+Rtg7GPAuYcAWlMCgUVkQfJ2Q12yBvPXMwHImhDWwf81imsTiLSEvHZkr+jY/p9CQRD4p8DOBwteItai05qn31FFdfLlFxYWgCDUIkRkj/TxbCEi/89jfPZ3X2VqYSJQbmUNQY3HQT7hbv2sLoerVwKQHNEEoCsm8R4MhPRjXUGzVEIKIoY7yaEYuY4dgGb5RXruoSgtSCLLarkICQ9f6QNykGjFdjsIBaI4kGlt8W+Rg5g0HJ8qAp47nihAzFpuWtPIMBZJlASILvR6fQ0DCVbJCkJOJCqnk4pGpb99tZ8MopyiKDX7WWDiwYKXiEQOehCrgKh+eJQ+EQHo1Lby/zRlyf8TIbf9XS5ftIb8I92YugH4ay2pLusorl7dAoonWtMwQSTdOFuQSLTGHyIC8kxSIQuA4hwU2WUAoO4/grBcDbsfWElSzg+JCoYDoEGM1ixSkHzgF/wG7y8sIa3J7JPAGWuFJSQIaU01iJHUiYP4e33BrPOHmG/JMaOfTZVYRhwGav87vWKPJ9/rSH4IOGO5sITqg/ggxXs4TOaBAECbeoOsgfl+DrQShFqcEIhyyt0MbMusEkx76iAZXKM8BvXiZAGlF+KaIbaadYpem4aDgpJZQz6YJABV5VcHAJZ0v4FxX6KG5UpYs0KnqjhRuagEVgPglYAl9ciHf8mdUrJh0Qx9vkDBzBywfbkYQIGwahA/kglATsHsDzKA0BATiPyZ4NEDwIeoa/uFYKKXL2f24nQoIgd9R3yQCMTFqwIAfdBWI7+yB5ZLECYLETd85YJl+2YAUNosLIel/xYlu4Jsl6bhNhD6it4WJCvA2Zc4Gxo73RcgJeOqFmGR6rcChLYACyGojmEYdj59KnZ+tIQRhH9IvWA2hiREjDeRI9Cly7fMF3EtWRFawhQIf5IJwE56wdTIYdt7tp9ys1K8JnoJvod9Wn682PNkP4hUy1ndWgstAtBDMLYN5/6PAc5DGNoF4SrZfN+4+IhT8jqwg2Cp8ThIJ5vfSWBXAVCrWN9SMxDK+skaOvhoAc8me654pmUB3f0wyt+E8FyRAGmPlOEoiSD2qgvmAKoOm52fAuiTDHSyIRxx+lI0QxxADubfF5vffMmSajrWlP7nmZ3dSy+4r/ZzAUEHnQ8R70HsXlK+PgJsW68G4XYGZj0EY2EYATCAT6tAhmE0DXcC4faapcwMgAIfLb0kuzT9Qmw5uwAAIABJREFUSi+EfeALkSrpBovbrQDnkm8wAo8/E3i+CCsZ98NCpAp8cUekZyBavI4ET/TnaAk/RQCyAXy6uNSPA0i+wMeB6ePA5HFgZq2wpNGK3FUDAHmv3fSCe7afX8CB4UNEEOolVi/3obastNwJ9cO5BOBKEQMsAcifHWzRAigWWAlCn5K2bQYAOe1KMjTIR2kRUhKVS7IrLia0v+3xwHMZMCbYNP0KfG79zAqK5DxOvyEuWu6VD5KSHy2YAEQAfpaRdl5UkuUctIpBnCIIl4psD03FtIIP1ADAlBuJM47EqqUX3LX9kSBQcuuyftK78xUkHyQ+RLqHZ3Fv1KcgLj5kAQ1s0Qo6IA1nHhNLQzA8ZxvBXuNx8DcS5UYpNnoYxsCnUIqvZo0F3wPTMa7Hv53HOJVbS/l+5bumX7d+5WLE44hxIRJB2NMCqj9ixwuE90svWCaIA6bAp959EKeWChAyA0PTOV2unGMQveCO7bfqHbcS4rJR7Ewqnw5AWhLuImg2uFQAXAVs8RGmntW4+g2hB3P79L/EJ9zGvqrxOPibiVihAOgrWQOf/EBfBcsPNBBqW9Hv6zzGqFzmoXz3B9AePgXiq6bgiv4YOB9QHS8AfpkAFMMjrWAcQA0iO9XJiQyAnos2vV7ESHOOQfWCO7Zf7F40mZFQScRKAYBaSU6vAVcTgN7xXHiUFpDTMK2dFh56912BTiDcvpkATIXzCL4g3WXTZ4jpGfjoF/oihL+fx+0yWUABLwIwtYKKIabgCzHQvi2ggBKn0McEQDaKT5cGkIOo6SuyYzEfjQB0EM5nZgAPoxe8of3sgSqCQM3jkdFLvpRvR13+7UVRuhUFSavNO6otwp88ZZ3+t4M6HLtch6OT9AG/q9cmtf//gV1JDYcnQ2zY6/YakfSrU+Pg1M45NqPt3IEtoM7WFHokyrWKkooglCMWLYjiUXMtK3g8Uzd1WL3gDe3vRRCoUEYCwGtYFxxqgA2E/jI20F5hhmQod98BHNnlxOTig1aGiDanO21yV4DygWuB8YeB6fnC9WEtiKVVKeE0ZGiXWczeJoWMIig5a9V5DA1ANoKDeDylZ9NSXxyAsiKawrQqmCv2HVf5e8aRoxfc1n7xs+khItAUvojvyWryxVcWJZksVSyZoQRA3dcAoHzax4Gj2wtu6FVKM7gMgti02jbV476oUJJs1j/AbA1mQ3Pm8eTRsoZDtR+xZKCiEKmMXTIeXHPGdhYArX8FwG4DGMEnAHIK4yvT58nWC2b73cexaZgWWaEKgU1gjNbPP7PvOYGsUSBkv3hBtmRWNzxjTk9RWktvxp6POj0vARjY9sWkFel8RWxegjIF4RjwAOnZWMPBTGjqvHmszxJOBUD3xyznL2bqROvoP3N3q84jG4C7M/PpcvMBef0cvV9k6hXv+2Yno5QfGArRbaCC0mWv2YtF3ecerNDhkNZIIsXQRv5dlTtGADJSz2gEE1EJQM//026HdIEZLC8B6A0tk0g1Ja8DuzJdphS82QBEZj5dbj7gxZN5er/IZI+67pscgE7QaDOUMyC0Wb8+gXjuR4F5J6YsaXnFhBoAGEVvUhb60jISgCQnoh/OLBgvIrL8v7DdFkEYM5dtNg97tvz5zJqzdfIBmJlPl5sP+DJP5xtW7xffnzeh7H+Z+3+RpkyWT1YxuURJYVtx6T0fCTocouQV85VkHRIGegEuEv/YKpkA/JceVmL8kv6t5/9pu62tfiPWcFQVEa0DZ9WcLJEPwMx8uvfnjT9IgZyj94t/ldeA/S9tMaGa9SNdmsIxbvVscVJ1GScoMt4UPwhAsmMZ0aXzQBsvdGRBjQz0FUpEJRAJQOq4KAnBdz+sfiPJ3bOYn8fsykyVWMfiN3BOzckS+QDMzKe7OW/88aqQzsfE5kH1fvGjeQ0wADodmVGwOeiMsUqHrGOnS4UFy9P/wAEojkEnI+IqOIJQNLgpCXhcmLAtD/D+kgQE235L93tj+YBqgTX9BiCeW/NedT4AmQ+YkU/3sbzxBymQuZhm8g1T+QbV+wWFdjKO/Te2mEFNlCb6gPF708VJ1TXHgKd91GnZpDfi1k/gM2vqU3DUnCuBmNQe3P9vw6pe229KOvB0K1k+ZS+rnrfM2AlA3JMZtah/EZKZT3drxuDz1O/yxAwu9JgJxr3lQfR+8aa8Buy/wdWQZAVl+ZzCrG3q9c/YrkmHy3IRYryAAqAkEBIlopJxNNUbER+fA/H+/+AAdP9PmS9dazicJybm7mlB8nR2dI1HvgVkOlZGPt2nM29GCamcGZjAwlQ+vvrV+8X/zGsAAUiLVPp/wd+zaTMFWw+/kAA0GQQnpCw5mDsAMIrcRB5mC/+MAffTwgfwKY2KfmCZ6ZIkUShrxXxBX4yYaV8Hzmcn13jUA8CMfDqWYeQcSkhVOl8U6uxH7xekrsg49h8oiCENgC5TUG5vKxxT8f2aRtOtcAKQ1s8soPuOVUIwpchNlEEIOyNSIrrvv3hwnckWIZPZsnbcDyzTpvg3lU8mpZQqozyfK74aj3wAKh1LgrsD5tMxiz/nkGD1sHq/YNFOxkEAcuW7oqmXlisuQOT7VV2jwi/kTgj1RkoZhBje8Z83SCAEEJZW0C3gff8tADCt4VASaWIBK0HI9q8BF5yUAMzIp8tNx5Jg9bB6v/jdDPSRns0BWIZeUitIo9IhHmhXTvzCPQddccnZ76U1V/IvC4SBCFyg26DFNg7c++Mhhb6qiCikT7WVUmr6lYn2nRKyrdZ51GMBlZIc07GUBdMjny6XCiUmpA6j94vMZbgBMFo552pu27PXAqXTyAUQcitOQjAm9xX0N9pIwIPmSCmH5QuPqER0L4kDYgp9zOUL6fYxkbZcFceyAreAF3GlV+NRDwAz8uksnT3jiILVSmpWNlhMze+k94vMZfgGAPJeHDjpCrgM01Tdry9OzvmYAzAqLVWIwEShwzbRwwSEn+MqP6bQK5tZlWyhjCCCsC19Xv7gOnBRbgp7cu/5AOyVjqVMmA75dJZ9nHF0yohWNlhMxKnS+0XmMtwAmFq4imnYbrEqNJPc+9kfd62RKh0On8qV9hXZ9askEPgAfI56ziocUgVbzGT28lEtRMoKtg7lBHtznfZNA+CQ+XQWM8k4uglWK/NLYKzS+8U9GReXD0g/Tyvh4Ne17Yb4Zbr6g6y7/aNWcoPpjKRTsJIags5IJwkEAv6en05S6GUBfRWsUExZyVZVQCQwrgN7Wfdd41GPBczIp8ODeXfTSbBa6YYxlY8/p3q/udc3C+jTbtvqt2oadnB2m4oNgMn0W0p+hYWHWbwg9yU/0Kb9EIy+5y2hiCit4UgKyTeAkN8Valk4Le/ldlONRz4AWWBRM6fdIPfHstw/G+SE5rMnVQ/kA5AkLHS0ak7V7reXfhgACaBqDtD3e/nmc5k9kA/A80JReq+U38zGVp3ObJo/BvAOD3dtwiWar9zEHsgHIGlFubqSx7+Jja36anLLcDvvgwA+NDpDfILv+qlzuXwAXuSjrkKemlO2e3U1uWUYnL8dwB/5e2apca9LNv+vsQfyAUheX4VguB+mzIsaG9ntqxhF4Xbe3QD+n7/uHLAW9wQ1tblMRQ/UA0CaHC7plXEh+q4T0OWcfhleYTSHBK0EH/mi+fcRuKQn4I6fWpeoB4AevCz3HOOm9yb3F5mBlZBNclYCj1aRfyfrbgPCTR6AzK+vD4CyglX7jpmN7HY66d1E0ctdIrEEE4wEIMlam+Pk7YF6AMj7EwAVbU82vTerCwhAXopJN9zVI+AYrOeULLZgErY2x8nZA/kAJGWr0naUWdFpy2cT+oCWjpdjLFxE5UzYIBBpEUX5nLnlvAktb76SPVAfAOUHpiAMm96bsVtCAMaKALICMyxDq6cXfycA+b/mOLl6oF4AiqBRIEzBp7/X2Af0+fi1XIioMIlAI+AIPIGPmeROWV3j1Zuvyu2B+gHoFfZiDS2lC0LiY52WUADkQoTTMH1BFSYRdHoRfKSu5v9qrizMHYPT+vx6ARhSuDcAzzmDo5ZGHT1PAKYMwQxME2jiSo/gEwBrrq+u41ZOy++oD4BaCcsXTPiSI3ey8s4KGoG8QwCMFM+0ggQhLR0BF19SXuD/ayakz7uR0/TsMcxg3SjfqWNA0hsrga/ojaq/8WPcC+YIk4Ke4CMSuB2XVht1Oj8zIfXlU8BtU8DhmYRXWdfrdF1fgr3+S8At48CD04DVjXQSDO70PTUnaJ5uOCwsIIFHSSFy1pKPWCDsZxCpw8UVgKSPxLXM937OzxxAljzcPAbcswU4Qh4V3UN8mKoeKm/bu78IfKJQa8VD48CylHQiL3O3/qg5Rf30BKACMtJXjXKQcfBSK8Dfqc3KVCwuN2VFGRnm/yKZtq4Re5ifyQQgM2A+BeB3GHaZBo5MAIue0l7Kt3cC4xhw+5eL7TuCkJk1jBtyerbUfYG5ExjZ/pqrxE5fAOrOq5SmowVIrRp1IyT2R6+fg0bgVYG4CsyZe2UsaiOGKXr4Sfp9k8CxCYAFSKyvXeY1o1BxQux91yMtfsHPutgnnyUuUvhc0ZsgUXib+nVkq6+ZKaABIHsgVZnuwD9sVo66rrR4ImdhLGSQ8zPL/JgBQxeU1ouWkO9PTgDzbgmXxrzMkatl3keivfG5x4r4IRcz5BfkO5vEZ0kgpIfBZ8yKjlL17syy0tMNcOn9dl4Fy6dLFabj1Mpvow9Ify+I4Nlo9Xt+ZqU9VdJpqZh4QDDyxUyYOYJwHDg+DhgI/WUVZl7aSEt93+GO9Ia2iuZKOfA7lhp9JpvAVy61w2mOwO5hmCgMHC1H9O24gu6UD9jP+ZmbtLRaSsei9SL4XDPbAEh/kGQ/pSUcc0lbApFWb67lQUhpVnLBsoKqqZclFMmUtrxPcwxl3X7vOCAtYLSCcugFQmqhdssH7HU+RznjiOlYXA8wqkOfkItTAom+oKygca4ES8jY+N3z7fSG4hfUtp3ihUHruVSsFy1iRvNP+1N7A5BdJACmVpAgZPhGOyCigEjlPLudn7kvFtOxuB4g6OjD8UWLRkCZFRwrLCEXJQQhp2K+37lQeBCRX1A7KPQto1prFEmSYn2mB9EAsO+kYfk8KQhZF8yjVz5gp/MztyOUjiW9bCUhEBhKRCCgSis45uQ/PhX/xfFWMgOnWu2gxB0TF/o0kEZ/kCDM1Ts+3RHYnwVUL6XhDFrAswfIB6w6P1MrTulY0sum1VICglKwCEACqvQFCUK3gHcsFQCM/ILayqP1k9JshVqrncMalOYYvgcGAyCvIwuod8YBJQmZpmGJeyRwkGw4n8jJOJQNw3idLFhMRNB0SgASTJyKoy/4ieXCeFfJBUeV2SoAclFyR0bbm1OHTUiN0/DTAwD7zQeM52dqj8VsGEkVE2jKetG7AEhQ0frJAv6RC0trC1skl+IWlNinGLbSaZg7Mc0xfA8MbgF1LQV1z08A2G8+oM7PVF9Ms2GUE0gQyp+Lwu2yagLgR9ZaYpkSypQ6a6Q2DCqzpkvietXIFdoZfuieGmcOD0DeP0HEbBhNwYPmA/L8zJQsATAKnguEqS+XTqkE4YfWWwCUFZTksYAYwZfIBeN9Tw0cjOwu8gDIZqsoSSvhEeQDiiGYFoyWiSDRypWgi69UP5sc5fIcquSCNeXqe2X9ZAHfM7Khe2pcOB+AT41+aO5iRD3QAHBEHd9ctuiBBoANEkbaAw0AR9r9zcUbADYYGGkPNAAcafc3F28A2GBgpD3QAHCk3d9cvAFgg4GR9kADwJF2f3PxBoANBkbaAw0AR9r9zcUbADYYGGkPNAAcafc3F28A2GBgpD3QAHCk3d9cfOxqYJ2au9RdPtdp/khoEOlglDYT39V1PzQFXLsMXAlgt9PCxJKPbufyf8/KHIPfBPAZABf79Xc5XQ0ZQ1Q7360NbxoHrlsDvs5ZRsgo0une06by6X1mZvtP99PNAp4F4LsBXA5gjw8EGTeqaGF4QhzQF80CX7cAvGIdeDYAfhdZ2sTKUcVrpE7nd31N5gj8e2dIo2osk7NZpMdK0Z19tv+bJ4F9K8D1ACj8yfNSikHeg+5Z969m57Y/8/ZP+dPLKZhP/rcA+AYAF7g1oRUhEMUzFMt6eSJfX78b2DkPfM0i8GIAX+uWlAMppreUUErn8p2gzTl+2flg/sDbTkvIOik+CP20//mzwAXzwDcCuNTPJeFXpEpM6QEjIHm/zTF8D7T5gATYNQCe69aAloRTGulfBESBSYNyxR5g/Bhw7hKwZwl4vk9LnM5JmsBzUyDGAX3B8G23Mz/g9BuUa/0IiutfMkj7zwKmngAuXSvOpUvAWYBtF4BTnspIj/O8zPaf7qdvWITw6eZA0JLQEhKEGgxZhUj/dz3NzSKwbR44exnYvVKcy+mM5Km0JhxInUtrGkmzCPicg3W5LMGkQiZZTm9xS9Z3+4m2o8C5c4X15pTKW2Lb+fCx7WLtjYxzqiql29Icw/dA5SqYf6RTTilg+lYCIXmICKQ4IK9wxfSJY8AZK8CuFWDnanEua9ZTAMsaCog3Dt92O/MvnRGBtGwkqKRmMEkqCaa+2k+0LQDTh4rP88UHj74kF1WaATo9QHQ7mmP4HugYhtEKj4PB6ZQ+FS0hQahpldPya1kXTOqNY8DscgG+HavAttUCvBxInitrkgL4lcO33c7spBdM3kAuSnq2nx9gQfAh4JyVwvrxwel2z3p4aMlzH6DM2z/lT+8aB+Q/OT4EEqckWQSBkGD6EQKQnDCLwBSnYgcf32fXioGUFawC4esyu7CXXnDP9tOCsyD4KLB1rmgvX7zfbu2WG/Jtme0/3U/vKxBNAMoi0KcjkATCN3HOEr3UAjDrwOP71rXixYEkeKMFlSX8ocwR6KUXTJ7AaNE2tF8WfA4Ye7Kw1mwvX/yZn+eKnvcrfzC6IK/ObP/pfnpfAGQnySoISBqUXyAASS1AK0JfagWYcRDOrAF66TxZQU7jBOEbM0egH71gcgXSFZAV54NQtj9YcNIpbONCyh8Ygi8CVospApDuB63g92W2/3Q/vW8AsqM4gLIKBBIH8bcJwMCNMX68BTqBb8s6sGWtsIA6jwDk662ZI9CvXjA5A6NVa2t/IAicnC/aGV+8T74IQPm/AmGuBc+8/VP+9IEAyLslAKMV/LgAyIUInfnjwPQqMOOgI/DstQ5Mr7UAqMF8V2YXDqoXXNl+EQQ6N9v29aKdesUpWJZbAPyPme0/3U8fGIDssDid/pUASCvCaXgJmFguAEfgEXT27gDkuwaUg/nbmSMwjF7whvbLhSDL5TwwvdRqo9oqHzACkCB8U2b7T/fThwIgO01T1IMCoAZxGRhbKoAXQUcQTjkI+a4B5e5FzjGsXvCG9gdqrLGFYrpVG/UuHzBOw2/LaXxzbh43DKeoJwlAHqLndSs4udoCoIBHQE45EPk3DuitmYOQoxdctp8+rFwIWsGFYiFFoLGNchcEQC6e+OJC5J2Z7T/dTx/aApYdJ37AyJK/DIwvFxYvWr0IwEn/H1Opco5sveDUhSAAF4HJpQJkWixp6k2n4IYfMGf0amDHev2I8+l4/UbvNw8Eozw72wJePOJ8und7EkKj9ztKGA1/7WwATo44n45pWI3e7/AAGPWZ2QBkYHCU+XTMfGGQmYIxjd7vqOE0+PXzATjifDrKtTZ6v4MP/MlyRj4AR5xPF+VaqZLJF1UzKdPV6P2eLDDr3I58AI44n07ZMARbo/d78gMubWE+AEecT8e9YOn2Uheu0fs9tUCYD8AR59MpG6bR+z21gKfW1gNAz4geRT5dTEZo9H5PPRDmAzBmRM8BJzqfLiYjSKKr0fs9dYBYDwBHmE9XtRfMsIz04aQZ1+j9npygrA+Akqs8wfl0BCCTWRq935MTYL1aVQ8Ao1zlAnAi8+kEQGZTNXq/vYb75Pt/fQAcUT5dBGCj93vyAaxXi+oDoFLyT3A+3Rcavd9eY3xS/z8fgCQX/LPR3SOzkon55jg1eyAfgD8M4NcAPD6aDmBtB1e4NMDNcer1QD4AbwbwxwDe4UvRE9wHZG1gNSXDLlwLNcep1QP5APxzzwj9IIAPnXhT5ORc5EYCA9HNcWr1QD4AmRH6FQBMTSZZH98ZmD5Bh5g1FopiNns1x6nTA/kAvAfAEwDudnI+EvQxPfkEzYfaCXRSBluQMB7YHKdGD+QDsBNBH/9+AkAobqTADGK7Inw1x8nfA/kA7EXQt8kgrGAGMfBxZ5Cv5ji5eyAfgL0I+r68uR0QmUFoBQU8vfNvzXHy9kA9AORoMw7CdGQCjoUZDwL4kv/+8OZ1gJhBIjGDgMh3vTavBc035/RAPgD7JegjODfhiMwgoqeJwNPPTaB6Ezq/hq+sB4AcXeXEP+ZhGVo9vRimIQD5v5oPAZCupgDI9wg8/qz/1Xz55usyeyAfgMMQ9GU2Op4eAchpOIJQQEz/VuPlm6/K7IH6AMjgGzdl6QtyX5jWjpQFevF3lq3xf6yhrOlIAUgQCojR8gmE+l9Nl2++JrMH6gEgR5UA5KYsc+AZmCbQCDi+IvgEQMob1XBEAHIajgBMLV+0kCdws6aGu3zqfkV9AGTwjftg3JRVVRAtHQEXX/wbAcoXP5d5CID8GoJKvqDAloKOoIz/y7x8c3pmD4zhaqwjRzCYyQg5gr2ZgsFTLweWr8XQgsXjbwLWrnNtMlKgNoLBmZAa7PTCAuYIBlMvlWQswwr2UlUw45jdDSx8HbD+Ctd+HVCwePKbgJV9aASDM8Yg59TWFDysYPBtmYK91IbNOHaPA/M7gUXKXA4hWDz79cA8+W0aweCMURj+1HYfcBjBYO54MMY3tGDv8I3nmWSHOzYOLJ0LLPGXAQWLz3oB8MQUsEa16kYwOG8whjh74yJkUMFgbsNlCfYO0epwissVY34bsHw2sEIRkAEEi/dcU0SP5qhF1ggG5w3GEGdXr4L5134Fg4kAjuDQgr1DtDqcUmZETwArZwAru4BVqsv0KVh8/o3F4v0QXZBGMDhvMIY4u3MYhv95Zh+Cu1xBcxuOU/HfeDIq5cv7FuwdotXhlCBXjOXZAnyrO4BV6in0IVh8wStLuWCsUAyvEQzOG5ABz+4eB+R/ewnu/kOP/3G/l4kJTERlljQtIot2e53/IwO2OPl4FLtcnCqAp9cahT56CBZf+LpSLhhz1N5qBIPzBmTAs/sLRHcTDKbiNHdBGGymOC/3hglEvgjAnoK9A7Y4+XgiV4zVWYDAs/etxaubYPFFP1QkLtCIP8neaASD8wZkwLP7AyC/tJNg8L/xLNBu+YBdBXsHbHEFAINcMVamgdWZAoRrfPdXm8KitLdmgYveWAq+2y7iMqfuRjA4b1AGOLt/APJLqwSD3+y5T1yI0AoSbAxMMzGV1o8/My2ro2DvAK2t+GgiV4zj4+3AIwDXtwBrVJeuECze+9aW4Dut4PxkIhYsdetGMDhvoDqcPRgA+SWp4O4veQ5Uv/mAGwR78+6rQq4Yq9PAOi2fA4/vBkKudKVU7VZw77uKvWFuZbtcMNb5v0YwOG9g+jx7cADyi6Pg7gccgIxlcA5TKhaD01yYKBmVFpBZMfx/m2Bvny3t8LGqoqTliZbVI+gMgHwnMAnCIFi897cLAAZ6QyzFzzSCwXkD1OPs4QDIL5XgLmk5JHk/SD5gKdibd38VcsVYGmuBTaAzEHLHgyCcaokB7/1IkUET5IKxwF5pBIPzBqbPs4cHIC/AaeqvPL9pmHxAE+zts6VdLCD/lcgVY3UyWD0Bj1ZwqgCggXA7sPfWAoAJvaEtZBrB4Lyx6efsPADyCtmCvf00s/NnOsgVY3m8BTRZPZuGBUACdArY+5lWDqGmYbIrLHEx0ggG5w1OH2fnA7CPizQfaXqgUw80AGywMdIeaAA40u5vLt4AsMHASHugAeBIu7+5eAPABgMj7YEGgCPt/ubiDQAbDIy0BxoAjrT7m4s3AGwwMNIeaAA40u5vLt4AsMHASHugAeBIu7+5eAPABgMj7YEGgCPt/ubiDQAbDIy0B8ZYNMbkX+ZekpuIiOQrPar+xs889HJg6jZg5jAwvVZ8B+ll9PlO5/Fc/o+ECjnHfi8zYfkvM5ulmp4qJXVqx5deD4zfAkw/CGxdAZgoHfuh131QkaI5hu8Bs4Ds8B0AWLnIRGCBsFfn87JffDMwdjOw5R5g8giwZa34jnQQUwDo99wBfJ4TM7COiNdlaj2rA/jeV/vfDeATAP4UGH8I2Lrc6gc+SHqY4oMZ74VSKM0xfA+UUzB/oBUUCKMl6zSQ/PsXqZD5KQC/A0w/DEwcAcYXgYnVwppwADuBkefnCim90FmBWXwnK87Uen53BI8sbuwqaz9p5UgnQhBS+ZN1zE8Ak0utviCwq8DI8/nx5hi+Bzb4gJzKZE1SEFZZgS9/2pWR/gTAJ4HJQ8DEMWB8ARhfBsaWCwDquwQKvvNgHXvOcYVbPFJPkw+dDxC/W1Y4tWDpw/Rlgo4lo1T4/KxTihDNpJwj3/UiMLXemprjffC7eWpzDN8DlYsQDiKtVxzEqoHkyX9HRizW+nIgaQnvAiaeBCbmC0s4tgSMu2rMePAR9X252jXklaTFU108K0MHav/nvJ6ZxVVk9OI7GR2IZoGQNc/HgbHgIwqILIVujuF7oOMqWFawCoRxkfEIB5CWgkREBCNf9wMTc8A4QciBWyoGz16rwNgaML5eWKpctYZL3N+TWLX0gvtuP0HHk2n16JDyxXmVhfU0qywbJbr5GSuXKxA/sV5Y9UYWdnjwyS3qKKgarWA69Wg6fjQOIK0HadnIjPVFB+AiME4AuiUkCFnESyCSkmAuU7Cjm15wX+2X2ifBRn9A8mKcW2UFjULVQcgVDl80u40SYh763FfvquhLCxitoBYUsoJfjXKttByMq9CKcHn4sPuCbgXNJwyWkECcz5Q376UX3LNncZyQAAADEklEQVT9fFgIJs6lBBwtn3Tt6FpIz4RWnuQxPh2XIGzm4CwQ9hWIFgBTK0gQHiIAJddKq0ELQh+KL1qUR4MvSEsoENIKrgALHNiMox+94K7tl9qnnMio8MSf6SNwGpYVjCDk/Ju7isq496fCqX0BkDeqlWwKwic1gAQSpzGREnFgREz01eALLvvq2Kfi45m6cf3qBXdsfxRbJMho8dimqOhEK8cXQRr9QVpvPoDNMXQP9A3ACELFxPh+jACkP0fLIKFCCRRqKuPUdqjlC9o07JZwKVNHeBC94DQcZO0XAAkmgotAk9QYrR9f/BvByYfMSATDVMzwTXMM3QMDAVAgVHCZ7/MaQK4QZUHiNCbBQlqUw74YCb7gcmYkelC9YFlwvVv7RRAorTuBkECU9asCID9/x9B935zYzyKkqpfiNHxcA0gLQgvBAaPVkCqm3h2AtC5m/RyEqzw/4xhGL3hD++MmslgqCbgUfLKAcRrmTlBzDN0DA1tAXUlWcDm1IOIIJAjlT/Fd05lbFQFwjdtgGcewesFt7Rc/Gx8iWjUCjGCT1YvWT1MwgUqrf3NG45tTbcu0aximWx9xENcEQHGbcYAEwtSXSqY0gnCdgeuMI0cvuGx/FUGgFhwEYrR80QckWN+X0fjm1DwAWv8RgJFilJZBznz0pQg+AZAAlVWh1GvGka0XzB0cCQi30aSGVa9AF62fLOB7MhrfnJoPwPER59Px+o3e76mL5Kwp2G57xPl0kxc3er+nLvyKtLmhfUC78RHn081ONnq/pzcAR5xPR9mRRu/31IVgvgUccT4dNaobvd/TGYAjzqejumqj93s6A3DE+XRUg2VSCjdaGr3fUw+I+VPwiPPpqJjO8J1Nw43e7ymHwHoAKMFd7QErAeEE5NNJMb3R+z3lsGcNzgfgiPPpomJ6o/d76oGwPgCOKJ8uKqY3er+nKwBHmE+noqRG7/fUA199U/AI8+kEwEbv93QHoEhZTnA+nYqSGr3fBoAtaiqBUImdm5hPJwA2er+nKwBHnE+X1gUzSbnR+z11wPj/AeCpPDD3t7rvAAAAAElFTkSuQmCC", eu = class extends H { constructor({ blendFunction: e = B.SRC, preset: t = er.MEDIUM, edgeDetectionMode: i = et.COLOR, predicationMode: r = ei.DISABLED } = {}) { let n, s; super("SMAAEffect", "uniform sampler2D weightMap;varying vec2 vOffset0;varying vec2 vOffset1;void movec(const in bvec2 c,inout vec2 variable,const in vec2 value){if(c.x){variable.x=value.x;}if(c.y){variable.y=value.y;}}void movec(const in bvec4 c,inout vec4 variable,const in vec4 value){movec(c.xy,variable.xy,value.xy);movec(c.zw,variable.zw,value.zw);}void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){vec4 a;a.x=texture2D(weightMap,vOffset0).a;a.y=texture2D(weightMap,vOffset1).g;a.wz=texture2D(weightMap,uv).rb;vec4 color=inputColor;if(dot(a,vec4(1.0))>=1e-5){bool h=max(a.x,a.z)>max(a.y,a.w);vec4 blendingOffset=vec4(0.0,a.y,0.0,a.w);vec2 blendingWeight=a.yw;movec(bvec4(h),blendingOffset,vec4(a.x,0.0,a.z,0.0));movec(bvec2(h),blendingWeight,a.xz);blendingWeight/=dot(blendingWeight,vec2(1.0));vec4 blendingCoord=blendingOffset*vec4(texelSize,-texelSize)+uv.xyxy;color=blendingWeight.x*texture2D(inputBuffer,blendingCoord.xy);color+=blendingWeight.y*texture2D(inputBuffer,blendingCoord.zw);}outputColor=color;}", { vertexShader: "varying vec2 vOffset0;varying vec2 vOffset1;void mainSupport(const in vec2 uv){vOffset0=uv+texelSize*vec2(1.0,0.0);vOffset1=uv+texelSize*vec2(0.0,1.0);}", blendFunction: e, attributes: P.CONVOLUTION | P.DEPTH, uniforms: new Map([["weightMap", new u.nc$(null)]]) }), arguments.length > 1 && (n = arguments[0], s = arguments[1], arguments.length > 2 && (t = arguments[2]), arguments.length > 3 && (i = arguments[3])), this.renderTargetEdges = new u.nWS(1, 1, { depthBuffer: !1 }), this.renderTargetEdges.texture.name = "SMAA.Edges", this.renderTargetWeights = this.renderTargetEdges.clone(), this.renderTargetWeights.texture.name = "SMAA.Weights", this.uniforms.get("weightMap").value = this.renderTargetWeights.texture, this.clearPass = new C(!0, !1, !1), this.clearPass.overrideClearColor = new u.Q1f(0), this.clearPass.overrideClearAlpha = 1, this.edgeDetectionPass = new Z(new es), this.edgeDetectionMaterial.edgeDetectionMode = i, this.edgeDetectionMaterial.predicationMode = r, this.weightsPass = new Z(new ea); let a = new u.KPJ; a.onLoad = () => { let e = new u.gPd(n); e.name = "SMAA.Search", e.magFilter = u.hxR, e.minFilter = u.hxR, e.generateMipmaps = !1, e.needsUpdate = !0, e.flipY = !0, this.weightsMaterial.searchTexture = e; let t = new u.gPd(s); t.name = "SMAA.Area", t.magFilter = u.k6q, t.minFilter = u.k6q, t.generateMipmaps = !1, t.needsUpdate = !0, t.flipY = !1, this.weightsMaterial.areaTexture = t, this.dispatchEvent({ type: "load" }) }, a.itemStart("search"), a.itemStart("area"), void 0 !== n && void 0 !== s ? (a.itemEnd("search"), a.itemEnd("area")) : "undefined" != typeof Image && (n = new Image, s = new Image, n.addEventListener("load", () => a.itemEnd("search")), s.addEventListener("load", () => a.itemEnd("area")), n.src = eo, s.src = el), this.applyPreset(t) } get edgesTexture() { return this.renderTargetEdges.texture } getEdgesTexture() { return this.edgesTexture } get weightsTexture() { return this.renderTargetWeights.texture } getWeightsTexture() { return this.weightsTexture } get edgeDetectionMaterial() { return this.edgeDetectionPass.fullscreenMaterial } get colorEdgesMaterial() { return this.edgeDetectionMaterial } getEdgeDetectionMaterial() { return this.edgeDetectionMaterial } get weightsMaterial() { return this.weightsPass.fullscreenMaterial } getWeightsMaterial() { return this.weightsMaterial } setEdgeDetectionThreshold(e) { this.edgeDetectionMaterial.edgeDetectionThreshold = e } setOrthogonalSearchSteps(e) { this.weightsMaterial.orthogonalSearchSteps = e } applyPreset(e) { let t = this.edgeDetectionMaterial, i = this.weightsMaterial; switch (e) { case er.LOW: t.edgeDetectionThreshold = .15, i.orthogonalSearchSteps = 4, i.diagonalDetection = !1, i.cornerDetection = !1; break; case er.MEDIUM: t.edgeDetectionThreshold = .1, i.orthogonalSearchSteps = 8, i.diagonalDetection = !1, i.cornerDetection = !1; break; case er.HIGH: t.edgeDetectionThreshold = .1, i.orthogonalSearchSteps = 16, i.diagonalSearchSteps = 8, i.cornerRounding = 25, i.diagonalDetection = !0, i.cornerDetection = !0; break; case er.ULTRA: t.edgeDetectionThreshold = .05, i.orthogonalSearchSteps = 32, i.diagonalSearchSteps = 16, i.cornerRounding = 25, i.diagonalDetection = !0, i.cornerDetection = !0 } } setDepthTexture(e, t = u.Rkk) { this.edgeDetectionMaterial.depthBuffer = e, this.edgeDetectionMaterial.depthPacking = t } update(e, t, i) { this.clearPass.render(e, this.renderTargetEdges), this.edgeDetectionPass.render(e, t, this.renderTargetEdges), this.weightsPass.render(e, this.renderTargetEdges, this.renderTargetWeights) } setSize(e, t) { this.edgeDetectionMaterial.setSize(e, t), this.weightsMaterial.setSize(e, t), this.renderTargetEdges.setSize(e, t), this.renderTargetWeights.setSize(e, t) } dispose() { let { searchTexture: e, areaTexture: t } = this.weightsMaterial; null !== e && null !== t && (e.dispose(), t.dispose()), super.dispose() } static get searchImageDataURL() { return eo } static get areaImageDataURL() { return el } }, eh = (u.BKk, u.BKk, class extends u.BKk { constructor() { super({ name: "AdaptiveLuminanceMaterial", defines: { MIP_LEVEL_1X1: "0.0" }, uniforms: { luminanceBuffer0: new u.nc$(null), luminanceBuffer1: new u.nc$(null), minLuminance: new u.nc$(.01), deltaTime: new u.nc$(0), tau: new u.nc$(1) }, extensions: { shaderTextureLOD: !0 }, blending: u.XIg, toneMapped: !1, depthWrite: !1, depthTest: !1, fragmentShader: "#include <packing>\n#define packFloatToRGBA(v) packDepthToRGBA(v)\n#define unpackRGBAToFloat(v) unpackRGBAToDepth(v)\nuniform lowp sampler2D luminanceBuffer0;uniform lowp sampler2D luminanceBuffer1;uniform float minLuminance;uniform float deltaTime;uniform float tau;varying vec2 vUv;void main(){float l0=unpackRGBAToFloat(texture2D(luminanceBuffer0,vUv));\n#if __VERSION__ < 300\nfloat l1=texture2DLodEXT(luminanceBuffer1,vUv,MIP_LEVEL_1X1).r;\n#else\nfloat l1=textureLod(luminanceBuffer1,vUv,MIP_LEVEL_1X1).r;\n#endif\nl0=max(minLuminance,l0);l1=max(minLuminance,l1);float adaptedLum=l0+(l1-l0)*(1.0-exp(-deltaTime*tau));gl_FragColor=(adaptedLum==1.0)?vec4(1.0):packFloatToRGBA(adaptedLum);}", vertexShader: T }) } set luminanceBuffer0(e) { this.uniforms.luminanceBuffer0.value = e } setLuminanceBuffer0(e) { this.uniforms.luminanceBuffer0.value = e } set luminanceBuffer1(e) { this.uniforms.luminanceBuffer1.value = e } setLuminanceBuffer1(e) { this.uniforms.luminanceBuffer1.value = e } set mipLevel1x1(e) { this.defines.MIP_LEVEL_1X1 = e.toFixed(1), this.needsUpdate = !0 } setMipLevel1x1(e) { this.mipLevel1x1 = e } set deltaTime(e) { this.uniforms.deltaTime.value = e } setDeltaTime(e) { this.uniforms.deltaTime.value = e } get minLuminance() { return this.uniforms.minLuminance.value } set minLuminance(e) { this.uniforms.minLuminance.value = e } getMinLuminance() { return this.uniforms.minLuminance.value } setMinLuminance(e) { this.uniforms.minLuminance.value = e } get adaptationRate() { return this.uniforms.tau.value } set adaptationRate(e) { this.uniforms.tau.value = e } getAdaptationRate() { return this.uniforms.tau.value } setAdaptationRate(e) { this.uniforms.tau.value = e } }), ec = class extends E { constructor(e, { minLuminance: t = .01, adaptationRate: i = 1 } = {}) { super("AdaptiveLuminancePass"), this.fullscreenMaterial = new eh, this.needsSwap = !1, this.renderTargetPrevious = new u.nWS(1, 1, { minFilter: u.hxR, magFilter: u.hxR, depthBuffer: !1 }), this.renderTargetPrevious.texture.name = "Luminance.Previous"; let r = this.fullscreenMaterial; r.luminanceBuffer0 = this.renderTargetPrevious.texture, r.luminanceBuffer1 = e, r.minLuminance = t, r.adaptationRate = i, this.renderTargetAdapted = this.renderTargetPrevious.clone(), this.renderTargetAdapted.texture.name = "Luminance.Adapted", this.copyPass = new M(this.renderTargetPrevious, !1) } get texture() { return this.renderTargetAdapted.texture } getTexture() { return this.renderTargetAdapted.texture } set mipLevel1x1(e) { this.fullscreenMaterial.mipLevel1x1 = e } get adaptationRate() { return this.fullscreenMaterial.adaptationRate } set adaptationRate(e) { this.fullscreenMaterial.adaptationRate = e } render(e, t, i, r, n) { this.fullscreenMaterial.deltaTime = r, e.setRenderTarget(this.renderToScreen ? null : this.renderTargetAdapted), e.render(this.scene, this.camera), this.copyPass.render(e, this.renderTargetAdapted) } }, ed = class extends H { constructor({ blendFunction: e = B.SRC, adaptive: t = !1, mode: i = t ? en.REINHARD2_ADAPTIVE : en.AGX, resolution: r = 256, maxLuminance: n = 4, whitePoint: s = n, middleGrey: a = .6, minLuminance: o = .01, averageLuminance: l = 1, adaptationRate: h = 1 } = {}) { super("ToneMappingEffect", "#include <tonemapping_pars_fragment>\nuniform float whitePoint;\n#if TONE_MAPPING_MODE == 2 || TONE_MAPPING_MODE == 3\nuniform float middleGrey;\n#if TONE_MAPPING_MODE == 3\nuniform lowp sampler2D luminanceBuffer;\n#else\nuniform float averageLuminance;\n#endif\nvec3 Reinhard2ToneMapping(vec3 color){color*=toneMappingExposure;float l=luminance(color);\n#if TONE_MAPPING_MODE == 3\nfloat lumAvg=unpackRGBAToFloat(texture2D(luminanceBuffer,vec2(0.5)));\n#else\nfloat lumAvg=averageLuminance;\n#endif\nfloat lumScaled=(l*middleGrey)/max(lumAvg,1e-6);float lumCompressed=lumScaled*(1.0+lumScaled/(whitePoint*whitePoint));lumCompressed/=(1.0+lumScaled);return clamp(lumCompressed*color,0.0,1.0);}\n#elif TONE_MAPPING_MODE == 4\n#define A 0.15\n#define B 0.50\n#define C 0.10\n#define D 0.20\n#define E 0.02\n#define F 0.30\nvec3 Uncharted2Helper(const in vec3 x){return((x*(A*x+C*B)+D*E)/(x*(A*x+B)+D*F))-E/F;}vec3 Uncharted2ToneMapping(vec3 color){color*=toneMappingExposure;return clamp(Uncharted2Helper(color)/Uncharted2Helper(vec3(whitePoint)),0.0,1.0);}\n#endif\nvoid mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){\n#if TONE_MAPPING_MODE == 2 || TONE_MAPPING_MODE == 3\noutputColor=vec4(Reinhard2ToneMapping(inputColor.rgb),inputColor.a);\n#elif TONE_MAPPING_MODE == 4\noutputColor=vec4(Uncharted2ToneMapping(inputColor.rgb),inputColor.a);\n#else\noutputColor=vec4(toneMapping(inputColor.rgb),inputColor.a);\n#endif\n}", { blendFunction: e, uniforms: new Map([["luminanceBuffer", new u.nc$(null)], ["maxLuminance", new u.nc$(n)], ["whitePoint", new u.nc$(s)], ["middleGrey", new u.nc$(a)], ["averageLuminance", new u.nc$(l)]]) }), this.renderTargetLuminance = new u.nWS(1, 1, { minFilter: u.$_I, depthBuffer: !1 }), this.renderTargetLuminance.texture.generateMipmaps = !0, this.renderTargetLuminance.texture.name = "Luminance", this.luminancePass = new X({ renderTarget: this.renderTargetLuminance }), this.adaptiveLuminancePass = new ec(this.luminancePass.texture, { minLuminance: o, adaptationRate: h }), this.uniforms.get("luminanceBuffer").value = this.adaptiveLuminancePass.texture, this.resolution = r, this.mode = i } get mode() { return Number(this.defines.get("TONE_MAPPING_MODE")) } set mode(e) { if (this.mode === e) return; let t = u.sPf.replace(/\D+/g, ""); switch (this.defines.clear(), this.defines.set("TONE_MAPPING_MODE", e.toFixed(0)), e) { case en.LINEAR: this.defines.set("toneMapping(texel)", "LinearToneMapping(texel)"); break; case en.REINHARD: this.defines.set("toneMapping(texel)", "ReinhardToneMapping(texel)"); break; case en.CINEON: case en.OPTIMIZED_CINEON: this.defines.set("toneMapping(texel)", t >= 168 ? "CineonToneMapping(texel)" : "OptimizedCineonToneMapping(texel)"); break; case en.ACES_FILMIC: this.defines.set("toneMapping(texel)", "ACESFilmicToneMapping(texel)"); break; case en.AGX: this.defines.set("toneMapping(texel)", "AgXToneMapping(texel)"); break; case en.NEUTRAL: this.defines.set("toneMapping(texel)", "NeutralToneMapping(texel)"); break; default: this.defines.set("toneMapping(texel)", "texel") }this.adaptiveLuminancePass.enabled = e === en.REINHARD2_ADAPTIVE, this.setChanged() } getMode() { return this.mode } setMode(e) { this.mode = e } get whitePoint() { return this.uniforms.get("whitePoint").value } set whitePoint(e) { this.uniforms.get("whitePoint").value = e } get middleGrey() { return this.uniforms.get("middleGrey").value } set middleGrey(e) { this.uniforms.get("middleGrey").value = e } get averageLuminance() { return this.uniforms.get("averageLuminance").value } set averageLuminance(e) { this.uniforms.get("averageLuminance").value = e } get adaptiveLuminanceMaterial() { return this.adaptiveLuminancePass.fullscreenMaterial } getAdaptiveLuminanceMaterial() { return this.adaptiveLuminanceMaterial } get resolution() { return this.luminancePass.resolution.width } set resolution(e) { let t = Math.max(0, Math.ceil(Math.log2(e))), i = Math.pow(2, t); this.luminancePass.resolution.setPreferredSize(i, i), this.adaptiveLuminanceMaterial.mipLevel1x1 = t } getResolution() { return this.resolution } setResolution(e) { this.resolution = e } get adaptive() { return this.mode === en.REINHARD2_ADAPTIVE } set adaptive(e) { this.mode = e ? en.REINHARD2_ADAPTIVE : en.REINHARD2 } get adaptationRate() { return this.adaptiveLuminanceMaterial.adaptationRate } set adaptationRate(e) { this.adaptiveLuminanceMaterial.adaptationRate = e } get distinction() { return console.warn(this.name, "distinction was removed."), 1 } set distinction(e) { console.warn(this.name, "distinction was removed.") } update(e, t, i) { this.adaptiveLuminancePass.enabled && (this.luminancePass.render(e, t), this.adaptiveLuminancePass.render(e, null, null, i)) } initialize(e, t, i) { this.adaptiveLuminancePass.initialize(e, t, i) } }, ef = (u.BKk, u.BKk, class extends u.BKk { constructor(e, t, i, r, n = !1) { super({ name: "EffectMaterial", defines: { THREE_REVISION: u.sPf.replace(/\D+/g, ""), DEPTH_PACKING: "0", ENCODE_OUTPUT: "1" }, uniforms: { inputBuffer: new u.nc$(null), depthBuffer: new u.nc$(null), resolution: new u.nc$(new u.I9Y), texelSize: new u.nc$(new u.I9Y), cameraNear: new u.nc$(.3), cameraFar: new u.nc$(1e3), aspect: new u.nc$(1), time: new u.nc$(0) }, blending: u.XIg, toneMapped: !1, depthWrite: !1, depthTest: !1, dithering: n }), e && this.setShaderParts(e), t && this.setDefines(t), i && this.setUniforms(i), this.copyCameraSettings(r) } set inputBuffer(e) { this.uniforms.inputBuffer.value = e } setInputBuffer(e) { this.uniforms.inputBuffer.value = e } get depthBuffer() { return this.uniforms.depthBuffer.value } set depthBuffer(e) { this.uniforms.depthBuffer.value = e } get depthPacking() { return Number(this.defines.DEPTH_PACKING) } set depthPacking(e) { this.defines.DEPTH_PACKING = e.toFixed(0), this.needsUpdate = !0 } setDepthBuffer(e, t = u.Rkk) { this.depthBuffer = e, this.depthPacking = t } setShaderData(e) { this.setShaderParts(e.shaderParts), this.setDefines(e.defines), this.setUniforms(e.uniforms), this.setExtensions(e.extensions) } setShaderParts(e) { return this.fragmentShader = "#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#define packFloatToRGBA(v) packDepthToRGBA(v)\n#define unpackRGBAToFloat(v) unpackRGBAToDepth(v)\n#ifdef FRAMEBUFFER_PRECISION_HIGH\nuniform mediump sampler2D inputBuffer;\n#else\nuniform lowp sampler2D inputBuffer;\n#endif\n#if DEPTH_PACKING == 3201\nuniform lowp sampler2D depthBuffer;\n#elif defined(GL_FRAGMENT_PRECISION_HIGH)\nuniform highp sampler2D depthBuffer;\n#else\nuniform mediump sampler2D depthBuffer;\n#endif\nuniform vec2 resolution;uniform vec2 texelSize;uniform float cameraNear;uniform float cameraFar;uniform float aspect;uniform float time;varying vec2 vUv;vec4 sRGBToLinear(const in vec4 value){return vec4(mix(pow(value.rgb*0.9478672986+vec3(0.0521327014),vec3(2.4)),value.rgb*0.0773993808,vec3(lessThanEqual(value.rgb,vec3(0.04045)))),value.a);}float readDepth(const in vec2 uv){\n#if DEPTH_PACKING == 3201\nreturn unpackRGBAToDepth(texture2D(depthBuffer,uv));\n#else\nreturn texture2D(depthBuffer,uv).r;\n#endif\n}float getViewZ(const in float depth){\n#ifdef PERSPECTIVE_CAMERA\nreturn perspectiveDepthToViewZ(depth,cameraNear,cameraFar);\n#else\nreturn orthographicDepthToViewZ(depth,cameraNear,cameraFar);\n#endif\n}vec3 RGBToHCV(const in vec3 RGB){vec4 P=mix(vec4(RGB.bg,-1.0,2.0/3.0),vec4(RGB.gb,0.0,-1.0/3.0),step(RGB.b,RGB.g));vec4 Q=mix(vec4(P.xyw,RGB.r),vec4(RGB.r,P.yzx),step(P.x,RGB.r));float C=Q.x-min(Q.w,Q.y);float H=abs((Q.w-Q.y)/(6.0*C+EPSILON)+Q.z);return vec3(H,C,Q.x);}vec3 RGBToHSL(const in vec3 RGB){vec3 HCV=RGBToHCV(RGB);float L=HCV.z-HCV.y*0.5;float S=HCV.y/(1.0-abs(L*2.0-1.0)+EPSILON);return vec3(HCV.x,S,L);}vec3 HueToRGB(const in float H){float R=abs(H*6.0-3.0)-1.0;float G=2.0-abs(H*6.0-2.0);float B=2.0-abs(H*6.0-4.0);return clamp(vec3(R,G,B),0.0,1.0);}vec3 HSLToRGB(const in vec3 HSL){vec3 RGB=HueToRGB(HSL.x);float C=(1.0-abs(2.0*HSL.z-1.0))*HSL.y;return(RGB-0.5)*C+HSL.z;}FRAGMENT_HEAD void main(){FRAGMENT_MAIN_UV vec4 color0=texture2D(inputBuffer,UV);vec4 color1=vec4(0.0);FRAGMENT_MAIN_IMAGE color0.a=clamp(color0.a,0.0,1.0);gl_FragColor=color0;\n#ifdef ENCODE_OUTPUT\n#include <colorspace_fragment>\n#endif\n#include <dithering_fragment>\n}".replace(D.FRAGMENT_HEAD, e.get(D.FRAGMENT_HEAD) || "").replace(D.FRAGMENT_MAIN_UV, e.get(D.FRAGMENT_MAIN_UV) || "").replace(D.FRAGMENT_MAIN_IMAGE, e.get(D.FRAGMENT_MAIN_IMAGE) || ""), this.vertexShader = "uniform vec2 resolution;uniform vec2 texelSize;uniform float cameraNear;uniform float cameraFar;uniform float aspect;uniform float time;varying vec2 vUv;VERTEX_HEAD void main(){vUv=position.xy*0.5+0.5;VERTEX_MAIN_SUPPORT gl_Position=vec4(position.xy,1.0,1.0);}".replace(D.VERTEX_HEAD, e.get(D.VERTEX_HEAD) || "").replace(D.VERTEX_MAIN_SUPPORT, e.get(D.VERTEX_MAIN_SUPPORT) || ""), this.needsUpdate = !0, this } setDefines(e) { for (let t of e.entries()) this.defines[t[0]] = t[1]; return this.needsUpdate = !0, this } setUniforms(e) { for (let t of e.entries()) this.uniforms[t[0]] = t[1]; return this } setExtensions(e) { for (let t of (this.extensions = {}, e)) this.extensions[t] = !0; return this } get encodeOutput() { return void 0 !== this.defines.ENCODE_OUTPUT } set encodeOutput(e) { this.encodeOutput !== e && (e ? this.defines.ENCODE_OUTPUT = "1" : delete this.defines.ENCODE_OUTPUT, this.needsUpdate = !0) } isOutputEncodingEnabled(e) { return this.encodeOutput } setOutputEncodingEnabled(e) { this.encodeOutput = e } get time() { return this.uniforms.time.value } set time(e) { this.uniforms.time.value = e } setDeltaTime(e) { this.uniforms.time.value += e } adoptCameraSettings(e) { this.copyCameraSettings(e) } copyCameraSettings(e) { e && (this.uniforms.cameraNear.value = e.near, this.uniforms.cameraFar.value = e.far, e instanceof u.ubm ? this.defines.PERSPECTIVE_CAMERA = "1" : delete this.defines.PERSPECTIVE_CAMERA, this.needsUpdate = !0) } setSize(e, t) { let i = this.uniforms; i.resolution.value.set(e, t), i.texelSize.value.set(1 / e, 1 / t), i.aspect.value = e / t } static get Section() { return D } }), ep = (u.BKk, u.sPf.replace(/\D+/g, ""), 255 / 256); function em(e, t, i) { for (let r of t) { let t = "$1" + e + r.charAt(0).toUpperCase() + r.slice(1), n = RegExp("([^\\.])(\\b" + r + "\\b)", "g"); for (let e of i.entries()) null !== e[1] && i.set(e[0], e[1].replace(n, t)) } } new Float32Array([255 / 256 / 0x1000000, 255 / 256 / 65536, 255 / 256 / 256, 255 / 256]), new Float32Array([ep, ep / 256, ep / 65536, 1 / 0x1000000]); var eg = class extends E {
      constructor(e, ...t) { super("EffectPass"), this.fullscreenMaterial = new ef(null, null, null, e), this.listener = e => this.handleEvent(e), this.effects = [], this.setEffects(t), this.skipRendering = !1, this.minTime = 1, this.maxTime = Number.POSITIVE_INFINITY, this.timeScale = 1 } set mainScene(e) { for (let t of this.effects) t.mainScene = e } set mainCamera(e) { for (let t of (this.fullscreenMaterial.copyCameraSettings(e), this.effects)) t.mainCamera = e } get encodeOutput() { return this.fullscreenMaterial.encodeOutput } set encodeOutput(e) { this.fullscreenMaterial.encodeOutput = e } get dithering() { return this.fullscreenMaterial.dithering } set dithering(e) { let t = this.fullscreenMaterial; t.dithering = e, t.needsUpdate = !0 } setEffects(e) { for (let e of this.effects) e.removeEventListener("change", this.listener); for (let t of (this.effects = e.sort((e, t) => t.attributes - e.attributes), this.effects)) t.addEventListener("change", this.listener) } updateMaterial() {
        let e = new O, t = 0; for (let i of this.effects) if (i.blendMode.blendFunction === B.DST) e.attributes |= i.getAttributes() & P.DEPTH; else if ((e.attributes & i.getAttributes() & P.CONVOLUTION) != 0) throw Error(`Convolution effects cannot be merged (${i.name})`); else !function (e, t, i) {
          let r = t.getFragmentShader(), n = t.getVertexShader(), s = void 0 !== r && /mainImage/.test(r), a = void 0 !== r && /mainUv/.test(r); if (i.attributes |= t.getAttributes(), void 0 === r) throw Error(`Missing fragment shader (${t.name})`); if (a && (i.attributes & P.CONVOLUTION) != 0) throw Error(`Effects that transform UVs are incompatible with convolution effects (${t.name})`); if (s || a) {
            let o = /\w+\s+(\w+)\([\w\s,]*\)\s*{/g, l = i.shaderParts, h = l.get(D.FRAGMENT_HEAD) || "", c = l.get(D.FRAGMENT_MAIN_UV) || "", d = l.get(D.FRAGMENT_MAIN_IMAGE) || "", f = l.get(D.VERTEX_HEAD) || "", p = l.get(D.VERTEX_MAIN_SUPPORT) || "", m = new Set, g = new Set; if (a && (c += `	${e}MainUv(UV);
`, i.uvTransformation = !0), null !== n && /mainSupport/.test(n)) { let t = /mainSupport *\([\w\s]*?uv\s*?\)/.test(n); for (let r of (p += `	${e}MainSupport(`, p += t ? "vUv);\n" : ");\n", n.matchAll(/(?:varying\s+\w+\s+([\S\s]*?);)/g))) for (let e of r[1].split(/\s*,\s*/)) i.varyings.add(e), m.add(e), g.add(e); for (let e of n.matchAll(o)) g.add(e[1]) } for (let e of r.matchAll(o)) g.add(e[1]); for (let e of t.defines.keys()) g.add(e.replace(/\([\w\s,]*\)/g, "")); for (let e of t.uniforms.keys()) g.add(e); g.delete("while"), g.delete("for"), g.delete("if"), t.uniforms.forEach((t, r) => i.uniforms.set(e + r.charAt(0).toUpperCase() + r.slice(1), t)), t.defines.forEach((t, r) => i.defines.set(e + r.charAt(0).toUpperCase() + r.slice(1), t)); let v = new Map([["fragment", r], ["vertex", n]]); em(e, g, i.defines), em(e, g, v), r = v.get("fragment"), n = v.get("vertex"); let y = t.blendMode; if (i.blendModes.set(y.blendFunction, y), s) {
              null !== t.inputColorSpace && t.inputColorSpace !== i.colorSpace && (d += t.inputColorSpace === u.er$ ? "color0 = sRGBTransferOETF(color0);\n	" : "color0 = sRGBToLinear(color0);\n	"), t.outputColorSpace !== u.jf0 ? i.colorSpace = t.outputColorSpace : null !== t.inputColorSpace && (i.colorSpace = t.inputColorSpace), d += `${e}MainImage(color0, UV, `, (i.attributes & P.DEPTH) != 0 && /MainImage *\([\w\s,]*?depth[\w\s,]*?\)/.test(r) && (d += "depth, ", i.readDepth = !0), d += "color1);\n	"; let n = e + "BlendOpacity"; i.uniforms.set(n, y.opacity), d += `color0 = blend${y.blendFunction}(color0, color1, ${n});

	`, h += `uniform float ${n};

`} if (h += r + "\n", null !== n && (f += n + "\n"), l.set(D.FRAGMENT_HEAD, h), l.set(D.FRAGMENT_MAIN_UV, c), l.set(D.FRAGMENT_MAIN_IMAGE, d), l.set(D.VERTEX_HEAD, f), l.set(D.VERTEX_MAIN_SUPPORT, p), null !== t.extensions) for (let e of t.extensions) i.extensions.add(e)
          } else throw Error(`Could not find mainImage or mainUv function (${t.name})`)
        }("e" + t++, i, e); let i = e.shaderParts.get(D.FRAGMENT_HEAD), r = e.shaderParts.get(D.FRAGMENT_MAIN_IMAGE), n = e.shaderParts.get(D.FRAGMENT_MAIN_UV), s = /\bblend\b/g; for (let t of e.blendModes.values()) i += t.getShaderCode().replace(s, `blend${t.blendFunction}`) + "\n"; for (let [t, s] of ((e.attributes & P.DEPTH) != 0 ? (e.readDepth && (r = "float depth = readDepth(UV);\n\n	" + r), this.needsDepthTexture = null === this.getDepthTexture()) : this.needsDepthTexture = !1, e.colorSpace === u.er$ && (r += "color0 = sRGBToLinear(color0);\n	"), e.uvTransformation ? (n = "vec2 transformedUv = vUv;\n" + n, e.defines.set("UV", "transformedUv")) : e.defines.set("UV", "vUv"), e.shaderParts.set(D.FRAGMENT_HEAD, i), e.shaderParts.set(D.FRAGMENT_MAIN_IMAGE, r), e.shaderParts.set(D.FRAGMENT_MAIN_UV, n), e.shaderParts)) null !== s && e.shaderParts.set(t, s.trim().replace(/^#/, "\n#")); this.skipRendering = 0 === t, this.needsSwap = !this.skipRendering, this.fullscreenMaterial.setShaderData(e)
      } recompile() { this.updateMaterial() } getDepthTexture() { return this.fullscreenMaterial.depthBuffer } setDepthTexture(e, t = u.Rkk) { for (let i of (this.fullscreenMaterial.depthBuffer = e, this.fullscreenMaterial.depthPacking = t, this.effects)) i.setDepthTexture(e, t) } render(e, t, i, r, n) { for (let i of this.effects) i.update(e, t, r); if (!this.skipRendering || this.renderToScreen) { let n = this.fullscreenMaterial; n.inputBuffer = t.texture, n.time += r * this.timeScale, e.setRenderTarget(this.renderToScreen ? null : i), e.render(this.scene, this.camera) } } setSize(e, t) { for (let i of (this.fullscreenMaterial.setSize(e, t), this.effects)) i.setSize(e, t) } initialize(e, t, i) { for (let r of (this.renderer = e, this.effects)) r.initialize(e, t, i); this.updateMaterial(), void 0 !== i && i !== u.OUM && (this.fullscreenMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = "1") } dispose() { for (let e of (super.dispose(), this.effects)) e.removeEventListener("change", this.listener), e.dispose() } handleEvent(e) { "change" === e.type && this.recompile() }
    }; new Float32Array(3), new Float32Array(3), new Float32Array(3), new Float32Array(3), new Float32Array(3), new Float32Array(3), new Float32Array([0, 0, 0]), new Float32Array([1, 0, 0]), new Float32Array([1, 1, 0]), new Float32Array([1, 1, 1]), new Float32Array([0, 0, 0]), new Float32Array([1, 0, 0]), new Float32Array([1, 0, 1]), new Float32Array([1, 1, 1]), new Float32Array([0, 0, 0]), new Float32Array([0, 0, 1]), new Float32Array([1, 0, 1]), new Float32Array([1, 1, 1]), new Float32Array([0, 0, 0]), new Float32Array([0, 1, 0]), new Float32Array([1, 1, 0]), new Float32Array([1, 1, 1]), new Float32Array([0, 0, 0]), new Float32Array([0, 1, 0]), new Float32Array([0, 1, 1]), new Float32Array([1, 1, 1]), new Float32Array([0, 0, 0]), new Float32Array([0, 0, 1]), new Float32Array([0, 1, 1]), new Float32Array([1, 1, 1]); var ev = [new Float32Array(2), new Float32Array(2)], ey = (new Float32Array([0, -.25, .25, -.125, .125, -.375, .375]), new Float32Array([0, 0]), new Float32Array([.25, -.25]), new Float32Array([-.25, .25]), new Float32Array([.125, -.125]), new Float32Array([-.125, .125]), new Uint8Array([0, 0]), new Uint8Array([3, 0]), new Uint8Array([0, 3]), new Uint8Array([3, 3]), new Uint8Array([1, 0]), new Uint8Array([4, 0]), new Uint8Array([1, 3]), new Uint8Array([4, 3]), new Uint8Array([0, 1]), new Uint8Array([3, 1]), new Uint8Array([0, 4]), new Uint8Array([3, 4]), new Uint8Array([1, 1]), new Uint8Array([4, 1]), new Uint8Array([1, 4]), new Uint8Array([4, 4]), [new Uint8Array([0, 0]), new Uint8Array([1, 0]), new Uint8Array([0, 2]), new Uint8Array([1, 2]), new Uint8Array([2, 0]), new Uint8Array([3, 0]), new Uint8Array([2, 2]), new Uint8Array([3, 2]), new Uint8Array([0, 1]), new Uint8Array([1, 1]), new Uint8Array([0, 3]), new Uint8Array([1, 3]), new Uint8Array([2, 1]), new Uint8Array([3, 1]), new Uint8Array([2, 3]), new Uint8Array([3, 3])]); function ex(e, t, i, r, n, s) { let a = 0; for (let o = 0; o < 30; ++o)for (let l = 0; l < 30; ++l)(function (e, t, i, r, n, s) { let a = e === i && t === r; return a || (a = (r - t) * (n - (e + i) / 2) + (e - i) * (s - (t + r) / 2) > 0), a })(e, t, i, r, n + l / 29, s + o / 29) && ++a; return a / 900 } function eS(e, t, i, r) { var n; return (n = e + (t - e) * .75) + (i + (r - i) * .75 - n) * .875 } eS(0, 0, 0, 0), new Float32Array([0, 0, 0, 0]), eS(0, 0, 0, 1), new Float32Array([0, 0, 0, 1]), eS(0, 0, 1, 0), new Float32Array([0, 0, 1, 0]), eS(0, 0, 1, 1), new Float32Array([0, 0, 1, 1]), eS(0, 1, 0, 0), new Float32Array([0, 1, 0, 0]), eS(0, 1, 0, 1), new Float32Array([0, 1, 0, 1]), eS(0, 1, 1, 0), new Float32Array([0, 1, 1, 0]), eS(0, 1, 1, 1), new Float32Array([0, 1, 1, 1]), eS(1, 0, 0, 0), new Float32Array([1, 0, 0, 0]), eS(1, 0, 0, 1), new Float32Array([1, 0, 0, 1]), eS(1, 0, 1, 0), new Float32Array([1, 0, 1, 0]), eS(1, 0, 1, 1), new Float32Array([1, 0, 1, 1]), eS(1, 1, 0, 0), new Float32Array([1, 1, 0, 0]), eS(1, 1, 0, 1), new Float32Array([1, 1, 0, 1]), eS(1, 1, 1, 0), new Float32Array([1, 1, 1, 0]), eS(1, 1, 1, 1), new Float32Array([1, 1, 1, 1]); var eA = i(3900); class e_ extends H { constructor() { super("RadialBlurEffect", "precision mediump float;\n#define GLSLIFY 1\n\nuniform float uProgress;\n\n//Box blur implementation\nvec4 blur(sampler2D t, vec2 uv, float kernel, float w, float pixelSize) {\n  vec4 sum = vec4(0.0);\n  vec4 acc = vec4(0.0);\n  float weightSum = 0.0;\n\n  for (float i = -kernel; i <= kernel; i++) {\n    vec4 s = texture2D(t, uv + vec2(i * pixelSize, i * pixelSize));\n    float weight = w;\n\n    acc += s * weight;\n    weightSum += weight;\n  }\n\n  sum = acc / weightSum;\n  return sum;\n}\n\nvoid mainImage(const in vec4 inputColor, const in vec2 uv, out vec4 outputColor) {\n  float dtc = length(uv - 0.5);\n  dtc = smoothstep(0.3, 0.7, dtc);\n  dtc *= uProgress;\n\n  float pixelSize = 1.0 / resolution.x;\n  vec4 blurred = blur(inputBuffer, uv, 10. * dtc ,1., pixelSize);\n\n  vec3 color = vec3(1.0);\n  color = vec3(dtc);\n\n  outputColor = blurred;\n\n}", { uniforms: new Map([["uProgress", new u.nc$(0)]]) }), this.originalDispose = H.prototype.dispose, this.unsub = eA.w.subscribe(({ progress: e }) => { let t = this.uniforms.get("uProgress"); t && (t.value = e) }) } dispose() { this.originalDispose(), this.unsub() } } var eE = i(9530); function eb() { let e = (0, g.useRef)(null), t = (0, eE.UR)(), i = (0, y.zo)(`/images/noise/fbm.${t ? "avif" : "webp"}`), n = tM(e => e.sceneObject), { store: s } = (0, m.F)(), a = (0, g.useRef)(null), o = (0, g.useRef)(null); (0, g.useEffect)(() => { if (!s) return; let { camera: e, scene: t, gl: i } = s.getState(); o.current = new L(i, { alpha: !0, multisampling: 0, depthBuffer: !0, stencilBuffer: !1 }); let r = o.current; function l() { r.setSize(window.innerWidth, window.innerHeight) } r.autoRenderToScreen = !1, r.setMainCamera(e), r.setMainScene(n), r.addPass(new $(n, e)), r.addPass(new eg(e, new eu, new e_, new Q({ brightness: .09, contrast: -.1 }), new ed({ blendFunction: B.SCREEN, mode: 7 }))), l(), window.addEventListener("resize", l); let u = x.o.subscribe(e => { e.inTransition && !e.isStory && (0, S.i)(0, 1, { onUpdate: e => { a.current && (a.current.uniforms.uProgress.value = e) }, onComplete: () => { x.o.setState({ isStory: !0, inTransition: !1 }) }, ease: "easeOut", delay: 2.4, duration: 2 }) }); return () => { window.removeEventListener("resize", l), u() } }, []); let h = new u.qUd(-.5, .5, .5, -.5); return (0, l.C)(({ gl: e, clock: t, scene: i }, r) => { o.current && (e.clear(), o.current.render(r), a.current.uniforms.tDiffuse.value = o.current.outputBuffer.texture, e.setRenderTarget(null), e.clear(), e.render(i, h)) }, 1), (0, r.jsx)(r.Fragment, { children: (0, r.jsxs)("mesh", { ref: e, position: [0, 0, -5], children: [(0, r.jsx)("planeGeometry", {}), (0, r.jsx)("shaderMaterial", { ref: a, vertexShader: "#define GLSLIFY 1\nvarying vec2 vUv;\n\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n  vUv = uv;\n}", fragmentShader: "precision mediump float;\n#define GLSLIFY 1\n\nuniform float uProgress;\nuniform sampler2D uNoise;\nuniform sampler2D tDiffuse;\n\nvarying vec2 vUv;\n\nvoid main() {\n    vec4 outputColor = texture2D(tDiffuse, vUv);\n    vec4 noise = texture2D(uNoise, vUv);\n    float progressMod = smoothstep(0.0, 0.1, uProgress);\n    float alpha = smoothstep(uProgress * progressMod, (uProgress + 0.2) * progressMod, pow(noise.r, 0.75));\n\n    gl_FragColor = vec4(outputColor.rgb, outputColor.a * alpha);\n}\n", uniforms: { tDiffuse: new u.nc$(null), uNoise: new u.nc$(i), uProgress: new u.nc$(0) }, transparent: !0, visible: !0 })] }) }) } var eT = i(2428), ew = i(4164), eM = i(1323); let eR = (0, eM.v)(() => ({ preloaderScene: null, scene: null, baseCamera: null })), eC = () => { let { store: e } = (0, m.F)(), t = (0, g.useRef)(null); return (0, g.useEffect)(() => { if (!t.current) return; let { viewport: { getCurrentViewport: i }, camera: r } = e?.getState(), n = new u.ubm(r.fov); n.position.z = 5, n.position.y = 10; let s = new u.ubm(r.fov); s.position.z = 5; let a = new u.Pq0, o = new u.Pq0; t.current.getWorldPosition(o), n.lookAt(o); let l = () => { if (!t.current) return; let e = i(n, o), r = i(s, a); eR.setState({ preloaderScene: e, scene: r, baseCamera: s }) }; return window.addEventListener("resize", l), l(), () => { window.removeEventListener("resize", l) } }, [e]), (0, r.jsx)("mesh", { ref: t }) }, eI = (0, eM.v)(() => ({ uniform: new u.nc$(new u.I9Y) })); var eL = i(4684), eP = (i(2805), i(9183)); let eD = g.forwardRef(function ({ children: e, follow: t = !0, lockX: i = !1, lockY: r = !1, lockZ: n = !1, ...s }, a) { let o = g.useRef(null), h = g.useRef(null), c = new u.PTz; return (0, l.C)(({ camera: e }) => { if (!t || !h.current) return; let s = o.current.rotation.clone(); h.current.updateMatrix(), h.current.updateWorldMatrix(!1, !1), h.current.getWorldQuaternion(c), e.getWorldQuaternion(o.current.quaternion).premultiply(c.invert()), i && (o.current.rotation.x = s.x), r && (o.current.rotation.y = s.y), n && (o.current.rotation.z = s.z) }), g.useImperativeHandle(a, () => h.current, []), g.createElement("group", (0, eP.A)({ ref: h }, s), g.createElement("group", { ref: o }, e)) }); var eO = i(8823); let ek = (e, t) => { let i, r; let n = t.width / t.height, s = e.scale.x / e.scale.y; return n > s ? (i = n / s, r = 1) : n < s ? (i = 1, r = s / n) : (i = 1, r = 1), [i, r] }; function eF(e, t, i, r) { var n; return (n = class extends u.BKk { constructor(n) { for (let r in super({ vertexShader: t, fragmentShader: i, ...n }), e) this.uniforms[r] = new u.nc$(e[r]), Object.defineProperty(this, r, { get() { return this.uniforms[r].value }, set(e) { this.uniforms[r].value = e } }); null == r || r(this) } }).key = u.cj9.generateUUID(), n } let eU = eF({ uIndex: { value: 0 }, uOpacity: { value: 1 }, uFogMask: { value: null } }, `
    varying vec2 vUv;
  
    vec2 offset = vec2(0.5, 0.5);
  
    void main() {
      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
  
      vec2 scaledUv = offset + (uv - offset);
      vUv = scaledUv;
      vUv = uv;
    }
  
  `, `
    varying vec2 vUv;
  
    uniform float uIndex;
    uniform float uOpacity;
    uniform sampler2D uFogMask;
  
    void main() {
      vec4 fogMask = texture2D(uFogMask, vUv);
  
      vec2 st = vUv * 2.0 - 1.0;
  
      // Add Fog
      float f1 = fogMask.r * 0.6;
      float f2 = fogMask.g * 0.1;
      float f3 = fogMask.b * 0.3;
      vec3 fogFinal = vec3(f1) + vec3(f2) + vec3(f3);
  
      float value;
      if (uIndex == 0.0) {
        value = fogMask.r;
        value *= 1.5;
      } else if (uIndex == 1.0) {
        value = fogMask.g;
      } else {
        value = fogMask.b;
      }
      vec4 final = vec4(vec3(value), value * uOpacity);
  
      gl_FragColor = final;
    }
  
  
  `); (0, l.e)({ FogMaterial: eU }); let eN = eF({ uTime: 0, uOpacity: 0, uPlaneSizes: new u.I9Y, uTexture: { value: null }, uNoiseMap: { value: null } }, `
  uniform vec2 uPlaneSizes;

  varying vec2 vUv;

  vec2 offset = vec2(0.5, 0.5);

  void main() {
    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);

    vec2 scaledUv = offset + (uv - offset) / uPlaneSizes;
    vUv = scaledUv;
  }

`, `
  varying vec2 vUv;

  uniform float uTime;
  uniform float uOpacity;
  uniform sampler2D uTexture;
  uniform sampler2D uNoiseMap;

  void main() {
    // Create distorted uv coords
    float zoom = 1.0;
    vec2 distorted = vUv;
    float d = texture2D(uNoiseMap, vec2(distorted.x + uTime *0.08, distorted.y)).r * 0.5;

    distorted += d*0.02;

    // Sample textures with distorted uv
    vec4 t1 = texture2D(uTexture, distorted * 0.95);
    vec4 final = t1;

    gl_FragColor = final;
    gl_FragColor.a *= uOpacity;
  }


`); (0, l.e)({ MorphMaterial: eN }); var eB = i(2753); let ez = () => { let { state: e, store: t } = (0, m.F)(), { camera: i } = e, n = (0, eE.UR)(), s = (0, g.useRef)(null), a = (0, g.useRef)(null), h = (0, g.useRef)(null), c = (0, g.useRef)(null), d = (0, g.useRef)(null), f = (0, g.useRef)(null), p = (0, g.useRef)(null), v = (0, g.useRef)(null), x = (0, g.useRef)(null), [A, _] = (0, g.useState)(!0), [E, b, T, w] = (0, y.zo)([`/images/backdrop/bg2-4k.${n ? "avif" : "webp"}`, `/images/backdrop/preloader_bg.${n ? "avif" : "webp"}`, "/images/backdrop/fog-mask-2-1k.webp", `/images/backdrop/distort.${n ? "avif" : "webp"}`], e => { e[0].colorSpace = u.er$, e[1].colorSpace = u.er$, e[2].colorSpace = u.er$, e[3].wrapS = u.kTW, e[3].wrapT = u.kTW }); return (0, g.useEffect)(() => { if (!s.current) return; i.position.y = 10; let e = new u.Pq0; s.current.getWorldPosition(e), i.lookAt(e), f.current && (f.current.enabled = !1, f.current.target.copy(e)); let t = () => { if (!a.current) return; let t = new u.Pq0().copy(e), r = new u.Pq0, n = new u.Pq0(0, 0, 0); f.current && (f.current.enabled = !1); let s = o.R2.SWORD_INTRO; s.volume(.5), (0, S.i)(0, 1, { duration: 5, ease: eL.e2, onPlay() { setTimeout(() => { s.fade(0, .5, 1200).play() }, 500) }, onUpdate(e) { i.position.y = (0, eO.Cc)(10, 0, e), r.lerpVectors(t, n, e), i.lookAt(r), a.current.position.y = (0, eO.Cc)(-5, -9, e), a.current.position.z = (0, eO.Cc)(.3, 0, e), d.current.position.y = (0, eO.Cc)(5, -2, e), h.current.traverse(t => { t.isMesh && (t.position.y = (0, eO.Cc)(t.userData.y, t.userData.y - 1 * t.position.z, e)) }) }, onComplete() { f.current && (f.current.enabled = !0, f.current.target.copy(n)), s.playing() || (s.stop(), s.unload()), _(!1), eB.o.setState({ preloaderAnimationDone: !0 }) } }), (0, S.i)(0, 1, { duration: 5, ease: eL.e2, onUpdate(e) { h.current.traverse(t => { if (t.isMesh) { if (e < .2) { let i = (0, eO.U4)(0, .2, Math.min(e, .2)); t.material.uniforms.uOpacity.value = (0, eO.Cc)(0, t.material.userData.uOpacity, i) } else if (e > .8) { let i = (0, eO.U4)(.8, 1, Math.min(e, 1)); t.material.uniforms.uOpacity.value = (0, eO.Cc)(t.material.userData.uOpacity, 0, i) } } }) } }), (0, S.i)(0, [0, 1, 1, 1, 0], { duration: 5, ease: eL.e2, onUpdate(e) { c.current.material.opacity = e } }), (0, S.i)(0, [0, .2, .2, 0, 0], { duration: 2, delay: 1.25, ease: eL.e2, onUpdate(e) { d.current.material.opacity = e } }) }; return eB.o.setState(e => ({ introAnimationFunc: [...e.introAnimationFunc, t] })), () => { eB.o.setState({ preloaderAnimationDone: !1 }) } }, [i]), (0, g.useEffect)(() => { if (!s.current) return; let e = () => { if (!s.current) return; let { height: e, width: t } = eR.getState().preloaderScene; p.current.scale.set(t, e + 2, 1), p.current.position.x = -t, p.current.position.y = -1, v.current.scale.set(t, e + 2, 1), v.current.position.x = t, v.current.position.y = -1, s.current.scale.set(t, e + 2, 1), s.current.position.y = -1 }, t = eR.subscribe(e); e(); let i = e => { if (!s.current) return; let t = s.current.material.uniforms, i = p.current.material.uniforms, r = v.current.material.uniforms; t.uResolution = e.uniform, i.uResolution = e.uniform, r.uResolution = e.uniform; let [n, a] = ek(s.current, E.image); t.uPlaneSizes.value.set(n, a), i.uPlaneSizes.value.set(n, a), r.uPlaneSizes.value.set(n, a) }, r = eI.subscribe(i); return i(eI.getState()), (0, S.i)(s.current.material.uniforms.uOpacity, { value: 1 }, { duration: .5, onUpdate(e) { p.current && v.current && (p.current.material.uniforms.uOpacity.value = e, v.current.material.uniforms.uOpacity.value = e) } }), () => { t(), r() } }, [E.image, t]), (0, l.C)(({ clock: e }, t) => { if (!s.current || !A || !x.current) return; let i = e.getElapsedTime(); s.current.material.uniforms.uTime.value = i, p.current.material.uniforms.uTime.value = i, v.current.material.uniforms.uTime.value = i, x.current.scale.setScalar((0, eO.qE)(x.current.scale.x + .015 * t, 1, 1.7)) }), (0, r.jsxs)(r.Fragment, { children: [!1, A && (0, r.jsxs)(eD, { children: [(0, r.jsxs)("group", { ref: x, children: [(0, r.jsxs)("mesh", { ref: p, renderOrder: -1, rotation: [0, Math.PI, 0], children: [(0, r.jsx)("planeGeometry", {}), (0, r.jsx)("morphMaterial", { depthTest: !1, uTexture: E, uNoiseMap: w, transparent: !0, side: u.hsX })] }), (0, r.jsxs)("mesh", { ref: s, name: "preloader-backdrop", renderOrder: -1, children: [(0, r.jsx)("planeGeometry", {}), (0, r.jsx)("morphMaterial", { depthTest: !1, uTexture: E, uNoiseMap: w, transparent: !0 })] }), (0, r.jsxs)("mesh", { ref: v, renderOrder: -1, rotation: [0, Math.PI, 0], children: [(0, r.jsx)("planeGeometry", {}), (0, r.jsx)("morphMaterial", { depthTest: !1, uTexture: E, uNoiseMap: w, transparent: !0, side: u.hsX })] })] }), (0, r.jsxs)("group", { renderOrder: 1, ref: h, name: "inbetween-clouds", children: [(0, r.jsxs)("mesh", { position: [-3, -3, .01], userData: { y: -3 }, children: [(0, r.jsx)("planeGeometry", { args: [12, 12] }), (0, r.jsx)("fogMaterial", { depthTest: !1, uFogMask: T, uIndex: 0, transparent: !0, uOpacity: 0, userData: { uOpacity: .5 } })] }), (0, r.jsxs)("mesh", { position: [3, -2, .01], rotation: [0, 0, Math.PI / 2], userData: { y: -2 }, children: [(0, r.jsx)("planeGeometry", { args: [12, 12] }), (0, r.jsx)("fogMaterial", { depthTest: !1, uFogMask: T, uIndex: 0, transparent: !0, uOpacity: 0, userData: { uOpacity: .5 } })] }), (0, r.jsxs)("mesh", { position: [-3, -8, .011], userData: { y: -8 }, children: [(0, r.jsx)("planeGeometry", { args: [12, 12] }), (0, r.jsx)("fogMaterial", { depthTest: !1, uFogMask: T, uIndex: 0, transparent: !0, uOpacity: 0, userData: { uOpacity: 1.5 } })] }), (0, r.jsxs)("mesh", { position: [0, -8, .012], userData: { y: -8 }, children: [(0, r.jsx)("planeGeometry", { args: [12, 12] }), (0, r.jsx)("fogMaterial", { depthTest: !1, uFogMask: T, uIndex: 0, transparent: !0, uOpacity: 0, userData: { uOpacity: 1 } })] }), (0, r.jsxs)("mesh", { position: [3, -8, .012], rotation: [0, 0, Math.PI / 2], userData: { y: -8 }, children: [(0, r.jsx)("planeGeometry", { args: [12, 12] }), (0, r.jsx)("fogMaterial", { depthTest: !1, uFogMask: T, uIndex: 0, transparent: !0, uOpacity: 0, userData: { uOpacity: 1.1 } })] }), (0, r.jsxs)("mesh", { position: [-3, -7, .3], userData: { y: -7 }, children: [(0, r.jsx)("planeGeometry", { args: [6, 6] }), (0, r.jsx)("fogMaterial", { depthTest: !1, uFogMask: T, uIndex: 0, transparent: !0, uOpacity: 0, userData: { uOpacity: .5 } })] }), (0, r.jsxs)("mesh", { position: [3, -7, .8], rotation: [0, 0, Math.PI / 4], userData: { y: -7 }, children: [(0, r.jsx)("planeGeometry", { args: [6, 6] }), (0, r.jsx)("fogMaterial", { depthTest: !1, uFogMask: T, uIndex: 0, transparent: !0, uOpacity: 0, userData: { uOpacity: .5 } })] }), (0, r.jsxs)("mesh", { position: [0, -6, .5], rotation: [0, 0, Math.PI / 2], userData: { y: -6 }, children: [(0, r.jsx)("planeGeometry", { args: [8, 8] }), (0, r.jsx)("fogMaterial", { depthTest: !1, uFogMask: T, uIndex: 0, transparent: !0, uOpacity: 0, userData: { uOpacity: .5 } })] }), (0, r.jsxs)("mesh", { position: [0, -7, 1], rotation: [0, 0, Math.PI], userData: { y: -7 }, children: [(0, r.jsx)("planeGeometry", { args: [8, 8] }), (0, r.jsx)("fogMaterial", { depthTest: !1, uFogMask: T, uIndex: 2, transparent: !0, uOpacity: 0, userData: { uOpacity: .1 } })] }), (0, r.jsxs)("mesh", { position: [0, -8, 1], rotation: [0, 0, Math.PI], userData: { y: -8 }, children: [(0, r.jsx)("planeGeometry", { args: [8, 8] }), (0, r.jsx)("fogMaterial", { depthTest: !1, uFogMask: T, uIndex: 1, transparent: !0, uOpacity: 1, userData: { uOpacity: 1.1 } })] }), (0, r.jsxs)("mesh", { position: [0, -10, 1], rotation: [0, 0, 0], userData: { y: -8 }, children: [(0, r.jsx)("planeGeometry", { args: [8, 8] }), (0, r.jsx)("fogMaterial", { depthTest: !1, uFogMask: T, uIndex: 1, transparent: !0, uOpacity: 1, userData: { uOpacity: 1.1 } })] })] }), (0, r.jsxs)("group", { ref: a, position: [0, -5, .3], children: [(0, r.jsxs)("mesh", { position: [0, 0, 0], ref: c, children: [(0, r.jsx)("planeGeometry", { args: [18, 18] }), (0, r.jsx)("meshBasicMaterial", { map: b, color: "#484f60", transparent: !0, opacity: .8, alphaMap: b })] }), (0, r.jsxs)("mesh", { ref: d, position: [0, 5, 0], children: [(0, r.jsx)("planeGeometry", { args: [25, 15] }), (0, r.jsx)("meshBasicMaterial", { color: "#484f60", transparent: !0, opacity: 0 })] }), (0, r.jsxs)("mesh", { position: [0, 5, 5], children: [(0, r.jsx)("planeGeometry", { args: [25, 15] }), (0, r.jsx)("meshBasicMaterial", { color: "#484f60", transparent: !0, opacity: .7 })] })] })] })] }) }; var eG = i(6749), eH = i(4945); let eV = ((e, t) => "undefined" != typeof window && "function" == typeof (null == (e = window.document) ? void 0 : e.createElement) && "string" == typeof (null == (t = window.navigator) ? void 0 : t.userAgent))(), eW = null; async function ej(...e) { var t; null !== (t = eW) && void 0 !== t || (eW = await Promise.resolve().then(i.bind(i, 4945))); let r = eW.default; return r.isSupported() ? new r(...e) : null } let eY = (e, t) => { (0, g.useEffect)(() => { let i; if (!t || !e.requestVideoFrameCallback) return; let r = (...n) => { t(...n), i = e.requestVideoFrameCallback(r) }; return e.requestVideoFrameCallback(r), () => e.cancelVideoFrameCallback(i) }, [e, t]) }; var eX = i(3668), eK = i(9613); let eq = () => { let e = (0, g.useRef)(null), t = (0, eK.A)(eX.$.tablet.max, !1), i = function (e, { unsuspend: t = "loadedmetadata", start: i = !0, hls: r = {}, crossOrigin: n = "anonymous", muted: s = !0, loop: a = !0, playsInline: o = !0, onVideoFrame: h, ...c } = {}) { let d = (0, l.A)(e => e.gl), f = (0, g.useRef)(null), p = (0, eG.DY)(() => new Promise(async i => { let l, h; "string" == typeof e ? l = e : h = e; let p = Object.assign(document.createElement("video"), { src: l, srcObject: h, crossOrigin: n, loop: a, muted: s, playsInline: o, ...c }); if (l && eV && l.endsWith(".m3u8")) { let e = f.current = await ej(r); e && (e.on(eH.Events.MEDIA_ATTACHED, () => void e.loadSource(l)), e.attachMedia(p)) } let m = new u.Nv2(p); m.colorSpace = d.outputColorSpace, p.addEventListener(t, () => i(m)) }), [e]); return eY(p.source.data, h), (0, g.useEffect)(() => (i && p.image.play(), () => { f.current && (f.current.destroy(), f.current = null) }), [p, i]), p }("/videos/preloader-h264.mp4", { start: !1, loop: !1 }); (0, g.useEffect)(() => { let t; if (!i) return; let r = (0, S.i)(0, .9, { duration: 1, onUpdate(t) { e.current && (e.current.material.opacity = t) } }), n = i.source.data, s = o.R2.INTRO_START; s.load(); let a = o.R2.INTRO_LOOP; a.load(), a.loop(!0); let l = o.R2.AMBIENCE_INTRO; l.load(), l.volume(0), l.play(), l.fade(0, .25, 1e3); let u = !1, h = e => { t && cancelAnimationFrame(t); let i = e / 100 * 5.5; n.paused && n.play().then(() => { u || (s.play(), a.play(), s.fade(0, .4, 1e3), a.fade(0, .4, 1e3), u = !0) }).catch(() => { eB.o.setState({ glyphsPreloaderDone: !0 }) }); let r = () => { n.currentTime <= i && !1 === n.paused ? t = requestAnimationFrame(r) : (n.pause(), 100 == e && eB.o.setState({ glyphsPreloaderDone: !0 })) }; r() }; h(eB.o.getState().percentage); let c = eB.o.subscribe(e => e.percentage, h), d = () => { cancelAnimationFrame(t), n.play().catch(e => console.error(e)) }; return eB.o.setState(e => ({ introAnimationFunc: [...e.introAnimationFunc, d] })), () => { c(), a.stop(), s.stop(), l.stop(), r.stop(), u = !1 } }, [i]), (0, g.useEffect)(() => () => { eB.o.setState({ canLoadSwordScene: !1 }) }, []); let n = t ? .2 : .39, s = function (e, t, i = 1) { let r = (0, l.A)(e => e.viewport), n = t * (r.aspect > e / t ? r.width / e : r.height / t); return [e * (r.aspect > e / t ? r.width / e : r.height / t) * i, n * i, 1] }(2086 * n, 1484 * n, 1 * n); return (0, r.jsxs)("mesh", { ref: e, scale: s, position: [0, .14, 1], children: [(0, r.jsx)("planeGeometry", { args: [1, 1] }), (0, r.jsx)("meshBasicMaterial", { color: "#FFF5EB", map: i, transparent: !0, opacity: 0, blending: u.EZo })] }) }, eQ = (0, g.memo)(function () { return (0, r.jsx)(r.Fragment, { children: (0, r.jsx)("group", { rotation: [.5, 0, 0], position: [0, 8, 0], children: (0, r.jsxs)("group", { position: [0, 5, 0], children: [(0, r.jsx)(eC, {}), (0, r.jsx)(eq, {}), (0, r.jsx)(ez, {})] }) }) }) }); var eZ = i(1194); let e$ = new u.Q1f("#ffffff"), eJ = new u.Q1f("#ffdcc5"); function e0(e) { let t = (0, eE.UR)(), { store: i } = (0, m.F)(), n = (0, g.useRef)(null), [s, a, o] = (0, y.zo)([`/images/rock/rock-2k.${t ? "avif" : "webp"}`, `/images/rock/rock-normal-2k.${t ? "avif" : "webp"}`, `/images/rock/rock-alpha-2k.${t ? "avif" : "webp"}`]), l = (0, g.useRef)(null); return (0, g.useEffect)(() => { let e = window.matchMedia(eX.$.ultrawide.min), t = e.matches; e.addEventListener("change", e => { t = e.matches }); let r = eR.getState().baseCamera, { viewport: { getCurrentViewport: a } } = i?.getState(), o = new u.Pq0(0, 0, .5), h = () => { if (!n.current) return; let { width: e, height: i } = a(r, o), u = Math.max(1 * e, 9), h = s.image.width / 475; n.current.scale.set(u, u / h, 1); let c = t ? .4 : .8; n.current.position.set(0, -i / 2 + c, .5), l.current.fit() }, c = eR.subscribe(h); h(); let d = () => { if (!n.current) return; let e = n.current.position.y, t = n.current.scale.clone(), i = t.clone().multiplyScalar(1.5); (0, S.i)(0, 1, { duration: 1.5, delay: 2.2, onUpdate(r) { n.current.position.y = (0, eO.Cc)(e - 4, e, r), n.current.scale.lerpVectors(i, t, r) } }) }; eB.o.setState(e => ({ introAnimationFunc: [...e.introAnimationFunc, d] })); let f = eA.w.subscribe(({ progress: e }) => { l.current && l.current.color.lerpColors(e$, eJ, e) }); return () => { c(), f() } }, []), (0, r.jsx)(r.Fragment, { children: (0, r.jsxs)("mesh", { ref: n, children: [(0, r.jsx)("planeGeometry", {}), (0, r.jsx)("coverMaterial", { ref: l, transparent: !0, map: s, normalMap: a, alphaMap: o, normalScale: new u.I9Y(1), args: [n, new u.I9Y(.5, 1)], roughness: .45, lightMapIntensity: .2, emissive: 0, alphaTest: .25, color: e$ })] }) }) } var e1 = i(3771), e2 = i(1671); let e3 = () => { let e = (0, g.useRef)(null), t = (0, g.useRef)(null), i = (0, g.useRef)(null), n = (0, y.zo)("/images/clans/wheel-2k-v2.webp"), s = (0, g.useRef)({ uMap: new u.nc$(n), uTime: new u.nc$(0), uColor: new u.nc$(new u.Q1f("#eeeeee")), uPixelSize: new u.nc$(1 / n.image.width), uProgress: new u.nc$(0), uOpacity: new u.nc$(0) }); return (0, g.useEffect)(() => { let e = () => { let e = 1; if (window.innerWidth < 1080 && window.innerWidth > 400) { if (e = 1 - .17 * Math.abs((window.innerWidth - 1080) / 400), !i.current) return; i.current.scale.setScalar(e) } }; return e(), window.addEventListener("resize", e), () => { window.removeEventListener("resize", e) } }, []), (0, l.C)(({ clock: t }) => { if (!e.current) return; let i = t.getElapsedTime(); e.current.material.uniforms.uTime.value = i }), (0, g.useEffect)(() => { if (!e.current) return; let i = () => { if (!e.current) return; let i = new u.Pq0(.8, .8, .8), r = new u.Pq0(1, 1, 1); (0, S.i)(0, 1, { duration: 1, delay: 4, onUpdate(n) { e.current && t.current && (e.current.scale.lerpVectors(i, r, n), t.current.scale.lerpVectors(i, r, n), s.current.uOpacity.value = n) } }) }; eB.o.setState(e => ({ introAnimationFunc: [...e.introAnimationFunc, i] })); let r = eA.w.subscribe(({ progress: i }) => { if (!e.current || !t.current) return; let r = e.current.material.uniforms, n = t.current.material.uniforms; r.uProgress.value = i, n.uProgress.value = i }); return () => { r() } }, []), (0, r.jsxs)("group", { ref: i, position: [.35, -.8, -1], children: [(0, r.jsxs)("mesh", { ref: e, children: [(0, r.jsx)("planeGeometry", { args: [14, 14] }), (0, r.jsx)("shaderMaterial", { depthTest: !1, uniforms: s.current, defines: { TAU: 2 * Math.PI }, vertexShader: "#define GLSLIFY 1\nvarying vec2 vUv;\n\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n  vUv = uv;\n}", fragmentShader: "precision mediump float;\n#define GLSLIFY 1\n\nuniform sampler2D uMap;\nuniform float uTime;\nuniform float uPixelSize;\nuniform float uProgress;\nuniform vec3 uColor;\nuniform float uOpacity;\n\nvarying vec2 vUv;\n\nvec2 rotate(vec2 uv, float angle, vec2 pivot) {\n  mat2 rm = mat2(vec2(cos(angle), -sin(angle)), vec2(sin(angle), cos(angle)));\n\n  uv -= pivot;\n  uv = rm * uv;\n  uv += pivot;\n  return uv;\n}\n\n//Box blur implementation\nvec4 blur(sampler2D t, vec2 uv, float kernel, float w, float pixelSize) {\n  vec4 sum = vec4(0.0);\n  vec4 acc = vec4(0.0);\n  float weightSum = 0.0;\n\n  for(float i = -kernel; i <= kernel; i++) {\n    vec4 s = texture2D(t, uv + vec2(i * pixelSize, 0.0));\n    float weight = w; // You might want to calculate weight differently\n\n    acc += s * weight;\n    weightSum += weight;\n  }\n\n  sum = acc / weightSum;\n  return sum;\n}\n\nvoid main() {\n  vec2 uv = vUv;\n\n  float duration = 50.0;\n  float time = mod(uTime / duration, 1.0);\n  float angle = TAU * time;\n  vec2 ruv = rotate(uv, angle, vec2(0.5));\n\n  vec4 baseTexture = texture2D(uMap, uv);\n  vec4 baseTextureRotate = texture2D(uMap, uv);\n  float blurRing = baseTexture.b;\n\n  float blurStrength = mix(0.0, 7.0, uProgress);\n  vec4 blurredWheel = blur(uMap, ruv, blurStrength * blurRing, 1., uPixelSize);\n  float wheel = (blurredWheel.r - (blurredWheel.g * (1.0 - blurredWheel.r)));\n\n  wheel *= 0.6;\n\n  vec4 wheelTexels = vec4(wheel) * 2.5;\n\n  float opacity = 0.6;\n  wheelTexels.a *= uOpacity * opacity;\n\n  if(wheelTexels.a < 0.3)\n    discard;\n\n  gl_FragColor = wheelTexels;\n\n}", transparent: !0 })] }), (0, r.jsxs)("mesh", { ref: t, children: [(0, r.jsx)("planeGeometry", { args: [14, 14] }), (0, r.jsx)("shaderMaterial", { depthTest: !1, uniforms: s.current, defines: { TAU: 2 * Math.PI }, vertexShader: "#define GLSLIFY 1\nvarying vec2 vUv;\n\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n  vUv = uv;\n}", fragmentShader: "precision mediump float;\n#define GLSLIFY 1\n\nuniform sampler2D uMap;\nuniform float uOpacity;\n\nvarying vec2 vUv;\n\nvoid main() {\n  vec2 uv = vUv;\n\n  vec4 baseTexture = texture2D(uMap, uv);\n\n  float lines = baseTexture.g;\n\n  vec4 linesTexels = vec4(lines);\n  linesTexels.rgb = vec3(1.0);\n\n  linesTexels.a *= 0.6 * uOpacity;\n\n  if(linesTexels.a < 0.01)\n    discard;\n\n  gl_FragColor = linesTexels;\n}", transparent: !0 })] })] }) }, e4 = new u.Q1f("#ffbd60"); function e5(e) {
      let { size: t } = e, i = (0, eE.UR)(), n = (0, g.useRef)(null), s = (0, y.zo)(`/images/sword/sword-glow-2k.${i ? "avif" : "webp"}`); return (0, g.useEffect)(() => eA.w.subscribe(({ progress: e }) => { n.current && (n.current.uniforms.uStrength.value = e) }), []), (0, l.C)(({ clock: e }) => { let t = e.getElapsedTime(); n.current && (n.current.uniforms.uTime.value = t) }), (0, r.jsx)(r.Fragment, {
        children: (0, r.jsxs)("mesh", {
          scale: 1.02, position: [0, 0, -.1], children: [(0, r.jsx)("planeGeometry", { args: [t, t, 1, 1] }), (0, r.jsx)("shaderMaterial", {
            depthWrite: !1, ref: n, uniforms: { uGlow: new u.nc$(s), uColor: new u.nc$(e4), uOpacity: new u.nc$(.6), uStrength: new u.nc$(0), uTime: new u.nc$(0) }, vertexShader: `
            varying vec2 vUv;
            void main() {
              gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
              vUv = uv;
            }
          `, fragmentShader: `
            uniform sampler2D uGlow;
            uniform vec3 uColor;
            uniform float uOpacity;
            uniform float uStrength;
            uniform float uTime;
            varying vec2 vUv;
            void main() {
              vec4 t = texture2D(uGlow, vUv);
              t.a *= t.r;
              t.rgb *= uColor;

              t += t*0.1; // Extra glow :)
              t += t*0.2; // Extra glow :)
              t += t*0.3; // Extra glow :)

              t.a *= uOpacity;

              float m = (sin(uTime*2.) + 1.0) / 2.0;
              float glowStrength = mix(0.7, 1.0, m);
              t *= glowStrength;

              gl_FragColor = t * uStrength;
            }
          `, transparent: !0
          })]
        })
      })
    } let e8 = new u.Q1f("#ffffff"), e6 = new u.Q1f("#feeecd"); function e9(e) { let t = (0, eE.UR)(), i = (0, g.useRef)(null), n = (0, g.useRef)(null), s = (0, g.useRef)(0), a = (0, g.useRef)([]), l = (0, g.useRef)(o.R2.SWORD_HANDLE), h = (0, eK.A)(eX.$.laptop.max, !1), [c, d, f] = (0, y.zo)([`/images/sword/sword-2k.${t ? "avif" : "webp"}`, `/images/sword/sword-alpha-2k.${t ? "avif" : "webp"}`, `/images/sword/sword-normal-2k.${t ? "avif" : "webp"}`]); return (0, g.useEffect)(() => { a.current = [o.R2.SWORD_HOVER_1, o.R2.SWORD_HOVER_2, o.R2.SWORD_HOVER_3], a.current.forEach(e => e.volume(.8)), l.current.volume(.4); let e = () => { if (!n.current) return; let e = n.current.position.y, t = new u.Pq0(2, 2, 2), i = new u.Pq0(1, 1, 1); (0, S.i)(0, 1, { duration: 1.5, delay: 2, ease: e1.vT, onUpdate(r) { n.current.position.y = (0, eO.Cc)(e - 4, e, r), n.current.scale.lerpVectors(t, i, r) } }) }; eB.o.setState(t => ({ introAnimationFunc: [...t.introAnimationFunc, e] })); let t = eA.w.subscribe(({ progress: e }) => { i.current && i.current.color.lerpColors(e8, e6, e) }); return () => { t() } }, []), (0, r.jsx)(r.Fragment, { children: (0, r.jsxs)("group", { position: [-.3, 0, 0], children: [(0, r.jsxs)("group", { ref: n, scale: h ? .9 : 1, position: [.25, h ? -1 : -.7, 0], children: [(0, r.jsxs)("mesh", { rotation: [-.1, 0, -.2], scale: [.3, .8, 1], onPointerOver: e => { if (e.point.y > 1.4) l.current.play(); else { let e = (0, e2.L)(0, a.current.length, s.current); a.current[e].play(), s.current++ } }, children: [(0, r.jsx)("planeGeometry", { args: [9, 9, 1, 1] }), (0, r.jsx)("meshBasicMaterial", { depthTest: !1, color: "red", visible: !1 })] }), (0, r.jsxs)("mesh", { rotation: [-.1, 0, -.2], frustumCulled: !1, children: [(0, r.jsx)("planeGeometry", { args: [9, 9, 1, 1] }), (0, r.jsx)("meshStandardMaterial", { ref: i, map: c, alphaMap: d, normalMap: f, normalScale: new u.I9Y(2.5), roughness: .6, metalness: .2, transparent: !0, alphaTest: .1, color: e8 }), (0, r.jsx)(e5, { size: 9 })] })] }), (0, r.jsx)(e3, {})] }) }) } var e7 = i(984); function te(e) { let t = (0, g.useRef)(null); return (0, g.useEffect)(() => { let e = x.o.subscribe(({ inTransition: e }) => { e && (0, S.i)(0, 1, { onUpdate: e => { if (!t.current) return; let i = (0, eO.Cc)(1, 1.5, e), r = (0, eO.Cc)(0, .035, e); t.current.scale.set(i, i, 1), t.current.rotation.z = r }, delay: 1, ease: "easeInOut", duration: 6 }) }); return () => { e(), t.current && (t.current.scale.setScalar(1), t.current.rotation.z = 0) } }, []), (0, g.useEffect)(() => () => { e7.o.setState({ showHoverState: !1 }) }, []), (0, r.jsxs)(r.Fragment, { children: [(0, r.jsx)(eZ.V, {}), (0, r.jsxs)("group", { ref: t, children: [(0, r.jsx)(e9, {}), (0, r.jsx)(e0, {})] })] }) } new u.Pq0(1.5, 1.5, 1); let tt = eF({ uResolution: new u.I9Y, uTime: 0, uProgress: 0, uPlaneSizes: new u.I9Y, uScale: new u.Pq0(1, 1, 1), uTextureA: { value: null }, uTextureB: { value: null }, uNoiseMap: { value: null }, uFogMask: { value: null }, uDisplace: { value: null } }, `
  uniform vec2 uPlaneSizes;

  varying vec2 vUv;
  varying vec2 dUv;

  vec2 offset = vec2(0.5, 0.5);

  void main() {
    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);

    vec2 scaledUv = offset + (uv - offset) / uPlaneSizes;
    vUv = scaledUv;
    dUv = uv;
  }

`, `
  varying vec2 vUv;
  varying vec2 dUv;

  uniform float uProgress;
  uniform float uTime;
  uniform vec2 uResolution;
  uniform vec3 uScale;
  uniform sampler2D uTextureA;
  uniform sampler2D uTextureB;
  uniform sampler2D uNoiseMap;
  uniform sampler2D uFogMask;
  uniform sampler2D uDisplace;

  float circle(vec2 st) {
    float aspect = uResolution.x / uResolution.y;
    st.x *= aspect;

    float max_dist = length(vec2(aspect, 1.0));
    float dtc = distance(st, vec2(0.0, 0.0));

    dtc /= max_dist;
    return dtc;
  }

  float smoothWarp(float sdf, float noise) {
    float startProgress = 0.0;
    float remainder = (1.0 - startProgress) * (uProgress);
    float stepValue = startProgress + remainder;

    sdf = smoothstep(stepValue, stepValue + noise + 0.2, sdf);
    sdf = 1.0 - sdf;
    sdf *= uProgress;

    return sdf;
  }

  void main() {
    // Create distorted uv coords
    float zoom = 1.0;
    vec2 distorted = vUv;
    float d = texture2D(uNoiseMap, vec2(distorted.x + uTime *0.05, distorted.y)).r * 0.5;

    vec2 displacementUv = vUv;
    displacementUv.x = vUv.x / (1. - uScale.x) - (uScale.x/2.);
    displacementUv.y = vUv.y / (1. - uScale.y) - (uScale.y/2.);
    displacementUv.y += uScale.z;

    vec4 displacement = texture2D(uDisplace, displacementUv);
    vec2 disp = displacement.rg * 0.01;

    // distorted -= disp;

    vec2 distorted2 = distorted;
    distorted += d*0.06;
    distorted2 -= d * 0.08;

    // Sample textures with distorted uv
    vec4 t1 = texture2D(uTextureA, distorted * 0.95);
    vec4 t2 = texture2D(uTextureB, distorted2 * 0.95);

    float fnoise = texture2D(uNoiseMap, vec2(vUv.x + uTime*0.05, vUv.y  + uTime*0.08)).b;

    vec4 fogMask = texture2D(uFogMask, vUv + fnoise * 0.03 - disp);

    // Noise
    float n = texture2D(uNoiseMap, vUv).g;
    // Strength
    n *= 0.2;

    // Normalize -1, 1
    vec2 st = vUv * 2.0 - 1.0;

    // Get SDF
    float c = circle(st);

    // Warp SDF
    float alpha = smoothWarp(c, n);

    // Add Fog
    float f1 = fogMask.r * 0.6;
    float f2 = fogMask.g * 0.1;
    float f3 = fogMask.b * 0.3;
    vec3 fogFinal = vec3(f1) + vec3(f2) + vec3(f3);

    vec4 snowTexture = t1 + vec4(fogFinal, 1.0);
    // Mix using warped SDF
    vec4 final = mix(snowTexture,t2,alpha);

    gl_FragColor = final;
  }


`); (0, l.e)({ BackdropMaterial: tt }); let ti = { size: 128, falloff: .3, alpha: 1, dissipation: .98 }; class tr { constructor(e) { let { size: t, falloff: i, alpha: r, dissipation: n, renderer: s } = { ...ti, ...e }; this.size = t, this.renderer = s, this.falloff = i, this.alpha = r, this.dissipation = n, this.camera = new u.qUd(-.5, .5, .5, -.5), this.camera.position.z = 1, this.scene = new u.Z58, this.mouse = new u.I9Y(.5, .5), this.velocity = new u.I9Y(0, 0); let a = this; this.mask = { read: new u.nWS(t, t, { format: u.GWd, type: u.RQf, internalFormat: "RGBA32F", minFilter: u.hxR, magFilter: u.hxR, wrapS: u.ghU, wrapT: u.ghU, depthBuffer: !1 }), write: new u.nWS(t, t, { format: u.GWd, type: u.RQf, internalFormat: "RGBA32F", minFilter: u.hxR, magFilter: u.hxR, wrapS: u.ghU, wrapT: u.ghU, depthBuffer: !1 }), swap() { let e = this.read; this.read = this.write, this.write = e, a.uniform.value = a.mask.read.texture } }, this.uniform = new u.nc$(this.mask.read), this.uniforms = { uTexture: this.uniform, uMouse: new u.nc$(this.mouse), uVelocity: new u.nc$(this.velocity), uFalloff: new u.nc$(.5 * this.falloff), uAlpha: new u.nc$(this.alpha), uDissipation: new u.nc$(this.dissipation) }, this.mask.swap(), this.material = new u.BKk({ vertexShader: "#define GLSLIFY 1\nvarying vec2 vUv;\n\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n  vUv = uv;\n}", fragmentShader: "precision mediump float;\n#define GLSLIFY 1\n\nuniform sampler2D uTexture;\n\nuniform float uFalloff;\nuniform float uAlpha;\nuniform float uDissipation;\n\nuniform float uAspect;\nuniform vec2 uMouse;\nuniform vec2 uVelocity;\n\nvarying vec2 vUv;\n\nvoid main() {\n  vec4 color = texture2D(uTexture, vUv) * uDissipation;\n\n  vec2 cursor = vUv - uMouse;\n  cursor.x *= 1.0;\n\n  vec3 stamp = vec3(uVelocity * vec2(1, -1), 1.0 - pow(1.0 - min(1.0, length(uVelocity)), 3.0));\n  float falloff = smoothstep(uFalloff, 0.0, length(cursor)) * uAlpha;\n\n  color.rgb = mix(color.rgb, stamp, vec3(falloff));\n\n  gl_FragColor = color;\n}\n", uniforms: this.uniforms }); let o = new u.eaF(new u.bdM(1, 1), this.material); this.scene.add(o) } update() { this.renderer.setRenderTarget(this.mask.write), this.renderer.render(this.scene, this.camera), this.mask.swap(), this.renderer.setRenderTarget(null) } } function tn(e) { let t = (0, g.useRef)(null), i = (0, g.useRef)(new u.I9Y(0, 0)), r = (0, g.useRef)(new u.I9Y(0, 0)); return (0, g.useEffect)(() => { let n; let s = new tr(e); t.current = s; let a = new u.I9Y(0, 0), o = new u.I9Y; function l(t) { let s = e.renderer.getSize(o); i.current.set(t.x / s.x, 1 - t.y / s.y), n || (n = performance.now(), i.current.set(t.x, t.y)); let l = t.x - a.x, u = t.y - a.y; a.set(t.x, t.y); let h = performance.now(), c = Math.max(14, h - n); n = h, r.current.x = l / c, r.current.y = u / c, r.current.needsUpdate = !0 } return window.addEventListener("mousemove", l), () => { window.removeEventListener("mousemove", l) } }, []), (0, l.C)((e, n) => { if (t.current) { r.current.needsUpdate || (i.current.setScalar(-1), r.current.setScalar(0)), r.current.needsUpdate = !1, t.current.mouse.copy(i.current); let e = 60 * n; t.current.velocity.lerp(r.current, r.current.length() ? .35 * e : .07 * e), t.current.update() } }), { flowmap: t } } function ts() { let e = (0, eE.UR)(), { state: t } = (0, m.F)(), { flowmap: i } = tn({ renderer: t.gl, size: 512, alpha: .3, dissipation: .96, falloff: .24 }), [n, s, a] = (0, y.zo)([`/images/backdrop/bg2-4k.${e ? "avif" : "webp"}`, "/images/backdrop/bg-hover4-2k.webp", "/images/backdrop/fog-mask-2-1k.webp"], e => { e.forEach(e => { e.colorSpace = u.er$ }) }), o = (0, y.zo)(`/images/backdrop/distort.${e ? "avif" : "webp"}`, e => { e.wrapS = u.kTW, e.wrapT = u.kTW }), h = (0, g.useRef)(null), c = (0, g.useRef)(null); return (0, g.useEffect)(() => { if (!c.current && !h.current) return; c.current?.uniforms && (c.current.uniforms.uTextureA.value = n, c.current.uniforms.uTextureB.value = s, c.current.uniforms.uNoiseMap.value = o, c.current.uniforms.uFogMask.value = a, i.current && (c.current.uniforms.uDisplace = i.current.uniform)); let e = () => { if (!h.current || !c.current) return; let { width: e, height: t } = eR.getState().scene; h.current.scale.set(e + 1, t + 1, 1), h.current.position.y = .5, c.current.uniforms.uScale.value.set(1 / (e + 1), 1 / (t + 1), .5 / (e + 1)) }, t = eR.subscribe(e); e(); let r = eA.w.subscribe(({ progress: e }) => { c.current && (c.current.uniforms.uProgress.value = e) }), l = e => { if (!c.current) return; let t = c.current.uniforms; if (t.uResolution = e.uniform, !h.current) return; let [i, r] = ek(h.current, n.image); t.uPlaneSizes.value.set(i, r) }, u = eI.subscribe(l); return l(eI.getState()), () => { t(), r(), u() } }, []), (0, l.C)(({ clock: e }) => { c.current && (c.current.uniforms.uTime.value = e.getElapsedTime(), c.current.uniformsNeedUpdate = !0) }), (0, r.jsx)(r.Fragment, { children: (0, r.jsxs)("mesh", { ref: h, children: [(0, r.jsx)("planeGeometry", {}), (0, r.jsx)("backdropMaterial", { ref: c, depthTest: !1 })] }) }) } let ta = g.forwardRef(({ children: e, enabled: t = !0, speed: i = 1, rotationIntensity: r = 1, floatIntensity: n = 1, floatingRange: s = [-.1, .1], autoInvalidate: a = !1, ...o }, h) => { let c = g.useRef(null); g.useImperativeHandle(h, () => c.current, []); let d = g.useRef(1e4 * Math.random()); return (0, l.C)(e => { var o, l; if (!t || 0 === i) return; a && e.invalidate(); let h = d.current + e.clock.elapsedTime; c.current.rotation.x = Math.cos(h / 4 * i) / 8 * r, c.current.rotation.y = Math.sin(h / 4 * i) / 8 * r, c.current.rotation.z = Math.sin(h / 4 * i) / 20 * r; let f = Math.sin(h / 4 * i) / 10; f = u.cj9.mapLinear(f, -.1, .1, null !== (o = null == s ? void 0 : s[0]) && void 0 !== o ? o : -.1, null !== (l = null == s ? void 0 : s[1]) && void 0 !== l ? l : .1), c.current.position.y = f * n, c.current.updateMatrix() }), g.createElement("group", o, g.createElement("group", { ref: c, matrixAutoUpdate: !1 }, e)) }); function to() { return (0, eK.A)(eX.$.tablet.max, !1) ? null : (0, r.jsx)(tu, {}) } let tl = (0, eM.v)(() => !1); function tu(e) { let { store: t, state: i } = (0, m.F)(), n = (0, g.useRef)([]), s = (0, g.useRef)([]); return (0, g.useEffect)(() => { let e = e => { let { viewport: t } = e; n.current.forEach(({ ref: e, x: i }) => { e.position.x = i + Math.max(-t.width / 2 + .5, -3.4) }), s.current.forEach(({ ref: e, x: i }) => { e.position.x = i + Math.min(t.width / 2 - .5, 3.4) }) }; e(i); let r = t?.subscribe(e); return () => { r && r() } }, []), (0, g.useEffect)(() => { function e() { tl.setState(!0) } return eB.o.setState(t => ({ introAnimationFunc: [...t.introAnimationFunc, e] })), () => { tl.setState(!1) } }, []), (0, r.jsxs)(r.Fragment, { children: [(0, r.jsx)("group", { ref: e => { e && n.current.push({ ref: e, x: 0 }) }, scale: .75, position: [0, 2.25, 0], children: (0, r.jsx)(th, { z: .1, delay: 0, type: 1 }) }), (0, r.jsx)("group", { ref: e => { e && n.current.push({ ref: e, x: -1.5 }) }, scale: .75, position: [0, -1, 0], children: (0, r.jsx)(th, { z: -.1, delay: .5, type: 4 }) }), (0, r.jsx)("group", { ref: e => { e && s.current.push({ ref: e, x: 0 }) }, scale: .95, position: [0, 2, 0], children: (0, r.jsx)(th, { z: -.1, delay: .9, type: 3 }) }), (0, r.jsx)("group", { ref: e => { e && s.current.push({ ref: e, x: 2 }) }, scale: .85, position: [0, -.5, 0], children: (0, r.jsx)(th, { z: 0, delay: .6, type: 2 }) })] }) } function th(e) { let { type: t, delay: i, z: n, ...s } = e, a = (0, eE.UR)(), o = (0, g.useRef)(null), h = (0, g.useRef)(null), [c, d] = (0, y.zo)([`/images/glyphs/glyph-blur.${a ? "avif" : "webp"}`, `/images/noise-025k.${a ? "avif" : "webp"}`]); return (0, l.C)(({ clock: e }) => { let t = e.getElapsedTime(); o.current && (o.current.uniforms.uTime.value = t) }), (0, g.useEffect)(() => { let e; let t = tl.subscribe(t => { o.current && t && (e = (0, S.i)(0, 1, { onUpdate: e => { o.current && (o.current.uniforms.uProgress.value = e, h.current?.position.setZ(eO.Cc(5, n, e))) }, delay: i + 2, ease: "circOut", duration: 3.5 })) }); return () => { t(), e && e.cancel() } }, []), (0, r.jsx)(ta, { speed: 3, floatIntensity: 2, rotationIntensity: 2, children: (0, r.jsxs)("mesh", { ref: h, position: [0, 0, 0], ...s, children: [(0, r.jsx)("planeGeometry", {}), (0, r.jsx)("shaderMaterial", { ref: o, uniforms: { uMap: new u.nc$(c), uProgress: new u.nc$(0), uPixelSize: new u.nc$(1 / c.image.width), uNoise: new u.nc$(d), uTime: new u.nc$(0) }, defines: { TYPE: t }, vertexShader: "#define GLSLIFY 1\nvarying vec2 vUv;\n\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n  vUv = uv;\n}", fragmentShader: "precision mediump float;\n#define GLSLIFY 1\n\nuniform sampler2D uMap;\nuniform sampler2D uNoise;\nuniform float uTime;\nuniform float uProgress;\nuniform float uPixelSize;\n\nvarying vec2 vUv;\n\nvec4 blur(sampler2D t, vec2 uv, float kernel, float w, float pixelSize) {\n  vec4 sum = vec4(0.0);\n  vec4 acc = vec4(0.0);\n  float weightSum = 0.0;\n\n  for (float i = -kernel; i <= kernel; i++) {\n    vec4 s = texture2D(t, uv + vec2(i * pixelSize, 0.0));\n    float weight = w; // You might want to calculate weight differently\n\n    acc += s * weight;\n    weightSum += weight;\n  }\n\n  sum = acc / weightSum;\n  return sum;\n}\n\nvec4 getGlyph(vec2 uv) {\n  vec4 glyph = vec4(0.0);\n  float sineTime = (sin(uTime*2.) + 1.0) / 2.0;\n  float progress = 1.0 - pow(uProgress, 6.0) + sineTime * 0.5;\n  \n  // Map progress from 0-1 to 0.1-0.9\n  progress = 0.1 + (progress * 0.9);\n\n  vec4 blurred = blur(uMap, uv, 40. * progress, 1., uPixelSize*2.);\n  // vec4 t = texture2D(uMap, uv);\n  if(TYPE == 1) {\n    glyph = vec4(blurred.r);\n  } else if (TYPE == 2) {\n    glyph = vec4(blurred.g);\n  }\n  else if (TYPE == 3) {\n    glyph = vec4(blurred.b);\n  }\n  else if (TYPE == 4) {\n    glyph = vec4(blurred.a);\n  }\n  return glyph;\n}\n\nvoid main() {\n  vec4 t = texture2D(uMap, vUv);\n\n  float zoom = 0.2;\n\n  vec2 nUv = vUv * (1.0 - zoom);\n\n  zoom /= 2.0;\n  nUv.x += zoom + cos(uTime) * zoom;\n  nUv.y += zoom + sin(uTime) * zoom;\n\n  float n = texture2D(uNoise, nUv).r;\n  float n2 = texture2D(uNoise, vUv).r;\n  vec4 color = getGlyph(vUv + n*0.05);\n\n  float dv = pow(uProgress, 1.);\n\n  color.a *= 0.35;\n  color.a *= floor(dv + min(1.0 ,pow(n2, 3.0)));\n  color.a *= pow(uProgress, 8.0);\n\n  gl_FragColor = color;\n\n}", transparent: !0 })] }) }) } function tc(e) { let t = (0, g.useRef)(null), i = (0, g.useRef)(null), n = (0, g.useRef)({ x: 0, y: 0 }); return (0, l.C)((e, r) => { let s = 144 * r * .1, a = eR.getState().scene; a && (t.current && (t.current.position.y = (0, eO.Cc)(t.current.position.y, n.current.y * a.height * .5, s), t.current.position.x = (0, eO.Cc)(t.current.position.x, n.current.x * a.width * .5, s)), i.current && (i.current.position.y = (0, eO.Cc)(i.current.position.y, n.current.y * a.height * .5, s), i.current.position.x = (0, eO.Cc)(i.current.position.x, n.current.x * a.width * .5, s))) }), (0, g.useEffect)(() => { let e = (e, t) => { let i = e / window.innerWidth * 2 - 1, r = -(2 * (t / window.innerHeight)) + 1; n.current = { x: i, y: r } }, t = t => { if ("touches" in t) { let { clientX: i, clientY: r } = t.touches[0]; e(i, r) } else e(t.clientX, t.clientY) }; return window.addEventListener("mousemove", t, { passive: !0 }), window.addEventListener("touchmove", t, { passive: !0 }), () => { window.removeEventListener("mousemove", t), window.removeEventListener("touchmove", t) } }, []), (0, r.jsxs)(r.Fragment, { children: [(0, r.jsx)("ambientLight", { intensity: 1.5 }), (0, r.jsx)("pointLight", { ref: t, args: [0xf1f1f1, 1, 0, 2], position: [2, 2, .5] }), (0, r.jsx)("pointLight", { ref: i, args: [0xf1f1f1, .9, 0, 0], position: [2, -5, .5] })] }) } let td = { count: 1800, depth: [4.6, -2], opacity: [.1, .4] }; function tf(e) { (0, eK.A)(eX.$.laptop.max, !1) && (td.count = 600); let t = { ...td, ...e }, { size: i, depth: n } = t, { store: s, state: a } = (0, m.F)(), o = tn({ renderer: a.gl, size: 512, alpha: .4, dissipation: .95, falloff: .3 }), h = (0, g.useRef)(null), { position: c, speeds: d, opacities: f, zDepth: p, activeDuringGust: v } = function (e) { let { store: t } = (0, m.F)(), { count: i, opacity: r, depth: n } = e, s = (0, g.useMemo)(() => new Float32Array(3 * i), [i]), a = (0, g.useMemo)(() => new Float32Array(3 * i), [i]), o = (0, g.useMemo)(() => new Float32Array(i), [i]), l = (0, g.useMemo)(() => new Float32Array(i), [i]), u = (0, g.useMemo)(() => new Float32Array(i), [i]); return (0, g.useEffect)(() => { let e = t?.getState(); if (e) for (let t = 0; t < i; t++) { let i = 3 * t, h = Math.pow(Math.random(), .41), c = n[0] + (n[1] - n[0]) * h; s[i + 0] = (0, eO.fs)(e.viewport.width), s[i + 1] = (0, eO.fs)(e.viewport.height), s[i + 2] = c, a[i + 0] = (0, eO.YR)(.8, 1.1), a[i + 1] = (0, eO.YR)(1.3, 2.6), a[i + 2] = (0, eO.YR)(.1, .3), o[t] = (0, eO.YR)(r[0], r[1]), u[t] = .2 > Math.random() ? 1 : 0, 0 === u[t] && (a[i + 0] = (0, eO.YR)(-3, 5), a[i + 1] = (0, eO.YR)(2.6, 3)), l[t] = (0, eO.my)(c, n[0], n[1], 0, 1) } }, [t]), { position: s, speeds: a, opacities: o, zDepth: l, activeDuringGust: u } }(t), y = (0, g.useRef)(null), x = (0, g.useRef)({ uTime: new u.nc$(0), uSize: new u.nc$(i * Math.min(2, window.devicePixelRatio)), uWorld: new u.nc$(new u.IUQ), uGravity: new u.nc$(new u.I9Y(.1, 1)), uVisiblity: new u.nc$(1), uDisplace: new u.nc$(null), uGust: new u.nc$(0) }); return (0, g.useEffect)(() => { h.current && (h.current.setAttribute("position", new u.THS(c, 3)), h.current.setAttribute("speed", new u.THS(d, 3)), h.current.setAttribute("opacity", new u.THS(f, 1)), h.current.setAttribute("depth", new u.THS(p, 1)), h.current.setAttribute("activeDuringGust", new u.THS(v, 1)), o.flowmap.current && (x.current.uDisplace = o.flowmap.current.uniform)) }, []), (0, g.useEffect)(() => { let e = new u.ubm(a.camera.fov); function t({ viewport: t }) { let i = x.current.uWorld.value, r = new u.Pq0(0, 0, n[0]), s = t.getCurrentViewport(e, r), a = new u.Pq0(0, 0, n[1]), o = t.getCurrentViewport(e, a); i.set(s.width, s.height, o.width, o.height) } e.position.z = 5, t(a); let i = (0, S.i)(x.current.uGust, { value: [0, 1, 0] }, { duration: 8, delay: 5, repeatDelay: 15, repeat: 1 / 0, repeatType: "mirror" }), r = s?.subscribe(t); return () => { r && r(), i.stop() } }, []), (0, l.C)(({ clock: e }) => { let t = e.getElapsedTime(); x.current.uTime.value = t }), (0, g.useEffect)(() => eA.w.subscribe(({ progress: e }) => { y.current && (y.current.uniforms.uVisiblity.value = 1 - e) }), []), (0, r.jsxs)("points", { renderOrder: 1, frustumCulled: !1, children: [(0, r.jsx)("bufferGeometry", { ref: h }), (0, r.jsx)("shaderMaterial", { ref: y, transparent: !0, depthTest: !1, vertexColors: !0, vertexShader: "precision mediump float;\n#define GLSLIFY 1\n\nattribute float opacity;\nattribute vec3 speed;\nattribute float depth;\nattribute float activeDuringGust;\n\nuniform float uSize;\nuniform float uTime;\nuniform vec4 uWorld;\nuniform vec2 uGravity;\nuniform sampler2D uDisplace;\n\nvarying float vOpacity;\nvarying vec2 vSpeed;\nvarying vec4 vPos;\nvarying float vDepth;\nvarying float vActiveDuringGust;\n\nfloat map(float value, float min1, float max1, float min2, float max2) {\n  return min2 + (value - min1) * (max2 - min2) / (max1 - min1);\n}\n\nvoid main() {\n  vec4 pos = modelMatrix * vec4(position, 1.0);\n\n  // World\n  vec2 world = mix(uWorld.xy, uWorld.zw, depth);\n  vec2 halfWorld = world.xy / 2.0;\n\n  // Position\n  vec2 gravity = uGravity.xy;\n\n  float newY = pos.y - uTime * speed.y * gravity.y;\n  pos.y = mod(newY, world.y) - world.y / 2.0;\n\n  float xWave = cos(pos.y + uTime * speed.x) * 0.3;\n  float newX = pos.x + uTime * speed.x * gravity.x + xWave;\n  pos.x = mod(newX, world.x) - world.x / 2.0;\n\n  // Sample texture based on screen position\n  float xuv = map(pos.x, -halfWorld.x, halfWorld.x, 0.0, 1.0);\n  float yuv = map(pos.y, -halfWorld.y, halfWorld.y, 1.0, 0.0);\n  vec2 screenUv = vec2(xuv, 1.0 - yuv);\n  vec4 mouse = texture2D(uDisplace, screenUv);\n\n  pos.x += mouse.r * 0.14;\n  pos.x += mouse.g * 0.1;\n\n  vec4 viewPosition = viewMatrix * pos;\n\n  gl_Position = projectionMatrix * viewMatrix * pos;\n  gl_PointSize = uSize;\n  gl_PointSize *= (1.0 / -viewPosition.z);\n\n  vOpacity = opacity;\n  vSpeed = vec2(speed.x, speed.y);\n  vPos = vec4(pos.xyz, 1.0);\n  vDepth = depth;\n  vActiveDuringGust = activeDuringGust;\n}", fragmentShader: "precision mediump float;\n#define GLSLIFY 1\n\n// uniform sampler2D uMouseOffset;\nuniform vec4 uWorld;\nuniform float uVisiblity;\nuniform float uGust;\n\nvarying float vOpacity;\nvarying vec2 vSpeed;\nvarying vec4 vPos;\nvarying float vDepth;\nvarying float vActiveDuringGust;\n\nvec3 white = vec3(1.0);\n\nfloat map(float value, float min1, float max1, float min2, float max2) {\n  return min2 + (value - min1) * (max2 - min2) / (max1 - min1);\n}\n\nvec2 distort(vec2 uv, vec2 k) {\n    // Convert UVs from (0,1) range to (-1,1) range\n  vec2 p = uv * 2.0 - 1.0;\n\n    // Convert to polar coordinates\n  float r = length(p);\n  float th = atan(p.y, p.x);\n\n    // Apply distortion factor\n  float rd = r * (1.0 + k.x * cos(2.0 * th) + k.y * sin(2.0 * th));\n\n    // Convert back to Cartesian coordinates\n  vec2 distorted = vec2(cos(th), sin(th)) * rd;\n\n    // Convert back to (0,1) UV space\n  return distorted * 0.5 + 0.5;\n}\n\nvoid main() {\n  // Calculate screen uvs\n  // vec2 hWorld = uWorld.xy / 2.0;\n  // float xuv = map(vPos.x, -hWorld.x, hWorld.x, 0.0, 1.0);\n  // float yuv = map(vPos.y, -hWorld.y, hWorld.y, 1.0, 0.0);\n  // vec2 screenUv = vec2(xuv, yuv);\n\n  vec2 uv = gl_PointCoord;\n  // vec4 mouse = texture2D(uMouseOffset, screenUv);\n\n  // Smooth\n  float smoothness = mix(0.0, 0.1, vDepth);\n\n  // Stretch\n  // float strength = .2;\n  // vec2 duv = distort(uv, vec2(vSpeed * strength));\n\n  float dtc = length(uv - 0.5);\n  dtc = smoothstep(smoothness, 0.65 - smoothness, dtc);\n  dtc = 1.0 - dtc;\n\n  if(dtc <= 0.001) {\n    discard;\n  }\n\n  vec4 color = vec4(vec3(dtc), dtc * vOpacity);\n\n  float addedAlpha = 1.0;\n  if(vActiveDuringGust == 0.0) {\n    addedAlpha = uGust;\n  }\n\n  gl_FragColor = color;\n  gl_FragColor.a *= uVisiblity * addedAlpha;\n}", uniforms: x.current })] }) } let tp = [new u.Q1f("#ffa500"), new u.Q1f("rgba(255, 217, 0, 1)"), new u.Q1f("hsla(36, 100%, 32%, 1.00)")], tm = { count: 300, depth: [4.5, -2], opacity: [.3, .6] }; function tg(e) { let t = { ...tm, ...e }, { size: i, depth: n } = t, { store: s, state: a } = (0, m.F)(), o = (0, g.useRef)(null), { position: h, speeds: c, opacities: d, zDepth: f, aSize: p, variant: v, color: y } = function (e) { let { store: t } = (0, m.F)(), { count: i, opacity: r, depth: n } = e, s = (0, g.useMemo)(() => new Float32Array(3 * i), []), a = (0, g.useMemo)(() => new Float32Array(3 * i), []), o = (0, g.useMemo)(() => new Float32Array(i), []), l = (0, g.useMemo)(() => new Float32Array(i), []), u = (0, g.useMemo)(() => new Float32Array(i), []), h = (0, g.useMemo)(() => new Float32Array(i), []), c = (0, g.useMemo)(() => new Float32Array(3 * i), []); return (0, g.useEffect)(() => { let e = t?.getState(); if (e) for (let t = 0; t < i; t++) { let i = 3 * t, d = Math.pow(Math.random(), .41), f = n[0] + (n[1] - n[0]) * d; s[i + 0] = (0, eO.fs)(e.viewport.width), s[i + 1] = (0, eO.fs)(e.viewport.height), s[i + 2] = f, a[i + 0] = (0, eO.YR)(.7, 1.2), a[i + 1] = (0, eO.YR)(.9, 1.3), a[i + 2] = (0, eO.YR)(.1, .3), o[t] = (0, eO.YR)(r[0], r[1]), l[t] = (0, eO.my)(f, n[0], n[1], 0, 1), u[t] = Math.random(), h[t] = Math.random(); let p = tp[Math.floor(3 * Math.random())]; c[i + 0] = p.r, c[i + 1] = p.g, c[i + 2] = p.b } }, [t]), { position: s, speeds: a, opacities: o, zDepth: l, aSize: u, variant: h, color: c } }(t), x = (0, g.useRef)(null), S = (0, g.useRef)({ uTime: new u.nc$(0), uSize: new u.nc$(i * Math.min(2, window.devicePixelRatio)), uWorld: new u.nc$(new u.IUQ), uGravity: new u.nc$(new u.I9Y(.1, 1)), uVisiblity: new u.nc$(0) }); return (0, g.useEffect)(() => { o.current && (o.current.setAttribute("position", new u.THS(h, 3)), o.current.setAttribute("speed", new u.THS(c, 3)), o.current.setAttribute("opacity", new u.THS(d, 1)), o.current.setAttribute("depth", new u.THS(f, 1)), o.current.setAttribute("size", new u.THS(p, 1)), o.current.setAttribute("variant", new u.THS(v, 1)), o.current.setAttribute("aColor", new u.THS(y, 3))) }, []), (0, g.useEffect)(() => { let e = new u.ubm(a.camera.fov); function t({ viewport: t }) { let i = S.current.uWorld.value, r = new u.Pq0(0, 0, n[0]), s = t.getCurrentViewport(e, r), a = new u.Pq0(0, 0, n[1]), o = t.getCurrentViewport(e, a); i.set(s.width, s.height, o.width, o.height) } return e.position.z = 5, t(a), s?.subscribe(t) }, []), (0, l.C)(({ clock: e }) => { let t = e.getElapsedTime(); S.current.uTime.value = t }), (0, g.useEffect)(() => eA.w.subscribe(({ progress: e }) => { x.current && (x.current.uniforms.uVisiblity.value = e) }), []), (0, r.jsxs)("points", { renderOrder: 1, frustumCulled: !1, children: [(0, r.jsx)("bufferGeometry", { ref: o }), (0, r.jsx)("shaderMaterial", { ref: x, transparent: !0, blending: u.EZo, alphaTest: .001, vertexColors: !0, vertexShader: "precision mediump float;\n#define GLSLIFY 1\n\nattribute float opacity;\nattribute vec3 speed;\nattribute float depth;\nattribute float size;\nattribute vec3 aColor;\nattribute float variant;\n\nuniform float uSize;\nuniform float uTime;\nuniform vec4 uWorld;\nuniform vec2 uGravity;\n// uniform sampler2D uMouseOffset;\n\nvarying float vOpacity;\nvarying vec2 vSpeed;\nvarying vec4 vPos;\nvarying float vDepth;\nvarying vec3 vColor;\nvarying float vVariant;\n\nfloat map(float value, float min1, float max1, float min2, float max2) {\n  return min2 + (value - min1) * (max2 - min2) / (max1 - min1);\n}\n\nvoid main() {\n  vec4 pos = modelMatrix * vec4(position, 1.0);\n\n  // World\n  vec2 world = mix(uWorld.xy, uWorld.zw, depth);\n  vec2 halfWorld = world.xy / 2.0;\n\n  // Position\n  vec2 gravity = uGravity.xy;\n\n  float newY = pos.y + uTime * speed.y * gravity.y;\n  pos.y = mod(newY, world.y) - world.y / 2.0;\n\n  float waveSpeed = 3.0;\n  float xWave = cos(pos.y + uTime * waveSpeed * speed.x) * 0.2;\n  float newX = pos.x + uTime * speed.x * gravity.x + xWave;\n  pos.x = mod(newX, world.x) - world.x / 2.0;\n\n  // Sample texture based on screen position\n  float xuv = map(pos.x, -halfWorld.x, halfWorld.x, 0.0, 1.0);\n  float yuv = map(pos.y, -halfWorld.y, halfWorld.y, 1.0, 0.0);\n  vec2 screenUv = vec2(xuv, yuv);\n  // vec4 mouse = texture2D(uMouseOffset, screenUv);\n\n  // pos.x += mouse.r*0.1;\n  // pos.y -= mouse.y*0.1;\n\n  vec4 viewPosition = viewMatrix * pos;\n\n  gl_Position = projectionMatrix * viewPosition;\n  gl_PointSize = uSize * mix(0.3, 3.0, size);\n  gl_PointSize *= (1.0 / -viewPosition.z);\n\n  vOpacity = opacity;\n  vSpeed = vec2(speed.x, speed.y);\n  vPos = vec4(pos.xyz, 1.0);\n  vDepth = depth;\n  vColor = aColor;\n  vVariant = variant;\n}", fragmentShader: "precision mediump float;\n#define GLSLIFY 1\n\n// uniform sampler2D uMouseOffset;\nuniform vec4 uWorld;\nuniform float uVisiblity;\n\nvarying float vOpacity;\nvarying vec2 vSpeed;\nvarying vec4 vPos;\nvarying float vDepth;\nvarying vec3 vColor;\nvarying float vVariant;\n\nvec3 white = vec3(1.0);\n\nfloat map(float value, float min1, float max1, float min2, float max2) {\n  return min2 + (value - min1) * (max2 - min2) / (max1 - min1);\n}\n\nvec2 distort(vec2 uv, vec2 k) {\n    // Convert UVs from (0,1) range to (-1,1) range\n  vec2 p = uv * 2.0 - 1.0;\n\n    // Convert to polar coordinates\n  float r = length(p);\n  float th = atan(p.y, p.x);\n\n    // Apply distortion factor\n  float rd = r * (1.0 + k.x * cos(2.0 * th) + k.y * sin(2.0 * th));\n\n    // Convert back to Cartesian coordinates\n  vec2 distorted = vec2(cos(th), sin(th)) * rd;\n\n    // Convert back to (0,1) UV space\n  return distorted * 0.5 + 0.5;\n}\n\nvoid main() {\n  // Calculate screen uvs\n  vec2 hWorld = uWorld.xy / 2.0;\n  float xuv = map(vPos.x, -hWorld.x, hWorld.x, 0.0, 1.0);\n  float yuv = map(vPos.y, -hWorld.y, hWorld.y, 1.0, 0.0);\n  vec2 screenUv = vec2(xuv, yuv);\n\n  vec2 uv = gl_PointCoord;\n  // vec4 mouse = texture2D(uMouseOffset, screenUv);\n\n  // Smooth\n\n  float smoothness = mix(0.0, 0.1, vDepth);\n\n  // Stretch\n  vec2 duv = uv;\n\n  float dtc = length(duv - 0.5);\n  dtc = smoothstep(smoothness, 0.65 - smoothness, dtc);\n  dtc = 1.0 - dtc;\n\n  // TWo\n  if(vVariant > 0.3) {\n    dtc = 0.1 / (distance(duv, vec2(0.5)));\n  }\n\n  // Three\n  if(vVariant > 0.6) {\n    dtc = 0.3 / (distance(vec2(duv.x, (duv.y - 0.5) * 5.0 + 0.5), vec2(0.5)));\n    dtc *= 0.3 / (distance(vec2(duv.y, (duv.x - 0.5) * 5.0 + 0.5), vec2(0.5)));\n  }\n\n  vec4 color = vec4(vec3(dtc), dtc * vOpacity);\n  color.rgb *= vColor;\n\n  gl_FragColor = color;\n  gl_FragColor.a *= uVisiblity;\n  // gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);\n  // gl_FragColor = vec4(screenUv, 0.0, 1.0);\n  // gl_FragColor = vec4(mouse.rg, .5, 1.0);\n\n}", uniforms: S.current })] }) } function tv() { let e = (0, g.useRef)(null), t = (0, g.useRef)(null); return (0, g.useEffect)(() => eA.w.subscribe(({ progress: i }) => { e.current && t.current && (e.current.visible = !0, t.current.visible = !0, 0 === i ? (e.current.visible = !0, t.current.visible = !1) : 1 === i && (e.current.visible = !1, t.current.visible = !0)) }), []), (0, r.jsxs)(r.Fragment, { children: [(0, r.jsx)("group", { ref: e, children: (0, r.jsx)(tf, { size: 43 }) }), (0, r.jsx)("group", { ref: t, visible: !1, children: (0, r.jsx)(tg, { size: 38, count: 80 }) })] }) } function ty(e) { let t = (0, g.useRef)(null), i = new u.Pq0(0, 0, 4), { state: n } = (0, m.F)(), s = (0, g.useRef)(0), a = (0, g.useMemo)(() => ({ uAlpha: new u.nc$(s.current), uRadius: new u.nc$(.3) }), []); return (0, g.useEffect)(() => { let e = new u.I9Y(i.x, i.y), r = () => { let r = n.camera.getViewSize(i.z, e); t.current && t.current.scale.set(r.x, r.y, 1) }; return window.addEventListener("resize", r), r(), () => { window.removeEventListener("resize", r) } }, []), (0, g.useEffect)(() => eA.w.subscribe(({ isHovering: e }) => { s.current = e ? .9 : 0 }), []), (0, l.C)((e, t) => { a.uAlpha.value = (0, eO.L2)(a.uAlpha.value, s.current, .2, (0, eL.lu)(t)) }), (0, r.jsxs)("mesh", { ref: t, position: i, children: [(0, r.jsx)("planeGeometry", { args: [1, 1, 1, 1] }), (0, r.jsx)("shaderMaterial", { vertexShader: "#define GLSLIFY 1\nvarying vec2 vUv;\n\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n  vUv = uv;\n}", fragmentShader: "#define GLSLIFY 1\nvarying vec2 vUv;\nuniform float uAlpha;\nuniform float uRadius;\n\nvoid main() {\n  vec3 color = vec3(0.);\n\n  float x = abs(vUv.x - 0.5) * 2.0;\n  float y = abs(vUv.y - 0.5) * 2.0;\n  float v = (sqrt((x * x) + (y * y)) / uRadius);\n\n  vec4 final = vec4(color, v * uAlpha);\n  gl_FragColor = final;\n}", transparent: !0, uniforms: a, depthTest: !1 })] }) } let tx = (0, g.memo)(function () { let e = (0, g.useRef)(null), t = (0, g.useRef)(1), i = (0, g.useRef)(0); return (0, g.useEffect)(() => { let e; let r = eA.w.subscribe(r => { r.isHovering && (e = setTimeout(() => { t.current = 1.2, i.current = 0 }, 200)) }); return () => { r(), clearTimeout(e) } }, []), (0, l.C)(({ clock: r }, n) => { if (!e.current) return; if (!eA.w.getState().isHovering) { let e = (Math.sin(.3 * r.getElapsedTime()) + 1) / 2; t.current = 1 + .02 * e, i.current = -.3 * e } let s = (0, eO.L2)(e.current.scale.x, t.current, .45, (0, eL.lu)(.5 * n)); e.current.scale.setScalar(s); let a = (0, eO.L2)(e.current.position.y, i.current, .45, (0, eL.lu)(.5 * n)); e.current.position.y = a }), (0, r.jsxs)(r.Fragment, { children: [(0, r.jsx)(ty, {}), (0, r.jsxs)("group", { ref: e, children: [(0, r.jsx)(ts, {}), (0, r.jsx)(eA.L, {}), (0, r.jsx)(tv, {}), (0, r.jsx)(tc, {}), (0, r.jsx)(te, {}), (0, r.jsx)(to, {})] })] }) }); var tS = i(4196), tA = i(4978); let t_ = (0, g.memo)(function () { return (0, g.useEffect)(() => { x.o.setState({ isStory: !1 }), x.o.getState().resetTransition(), tA.jS.setState(0), tS.Howler.stop() }, []), (0, r.jsxs)(r.Fragment, { children: [(0, r.jsx)(eQ, {}), (0, r.jsx)(tx, {})] }) }); var tE = i(7443); let tb = () => ((0, g.useEffect)(() => { let e = () => { let e = tE.p.getState(); eB.o.setState({ percentage: Math.round(e.progress) }) }; return e(), tE.p.subscribe(e) }, []), null); var tT = i(7767), tw = i.n(tT); let tM = (0, eM.v)(() => ({ sceneObject: new u.Z58 })), tR = (0, g.memo)(function (e) { let t = tM(e => e.sceneObject); return (0, r.jsx)("div", { className: (0, ew.A)(tw().Canvas), children: (0, r.jsxs)(eT.Hl, { gl: { powerPreference: "high-performance", antialias: !1, toneMapping: u.y_p }, camera: { position: [0, 10, 5] }, onCreated: e => { e.camera.lookAt(new u.Pq0(0, 15, 0)) }, children: [(0, l.o)((0, r.jsxs)(r.Fragment, { children: [(0, r.jsx)(tb, {}), (0, r.jsx)(t_, {}), (0, r.jsx)(v, {})] }), t), (0, r.jsx)(eb, {})] }) }) }); var tC = i(151), tI = i(6520), tL = i(6715); let tP = [tI.a.HOME, tI.a.STORY]; function tD({ siteSettings: e }) { let t = (0, tL.useRouter)(), [i, n] = (0, g.useState)(!1), s = (0, g.useRef)(""); (0, g.useEffect)(() => { e && e.setting && tC.t.setState(e.setting) }, [e]); let a = (0, g.useCallback)(e => { let t = [...tP]; x.o.getState().hasStarted || (t = t.filter(e => e !== tI.a.STORY)); let i = tP.includes(s.current), r = t.includes(e); n(e === tI.a.HOME || i && r), s.current = e }, []); return (0, g.useEffect)(() => x.o.subscribe((e, t) => { e.isStory !== t.isStory && n(!e.isStory) })), (0, g.useEffect)(() => (s.current = t.pathname, "/story" === t.pathname ? n(!1) : a(t.pathname), t.events.on("routeChangeComplete", a), () => { t.events.off("routeChangeComplete", a) }), []), i && (0, r.jsx)(r.Fragment, { children: (0, r.jsx)(tR, {}) }) } var tO = i(9539), tk = i.n(tO), tF = i(4247), tU = i(4770); let tN = () => { let e = (0, tL.useRouter)(), [t, i] = (0, g.useState)(!1), [n, s] = (0, g.useState)(!1), { triggerTransition: a } = (0, tU.w)(), [o, l] = (0, tF.l)(); return (0, g.useEffect)(() => { let t = () => { n && i(!0) }; return e.events.on("routeChangeComplete", t), () => { e.events.off("routeChangeComplete", t) } }, [n, e.events]), (0, g.useEffect)(() => { "" === a || n || (async () => { await l(o.current, { opacity: 1, visibility: "visible" }, { duration: .8, ease: eL.lu }), e.push(a), s(!0) })() }, [n, o, e, a]), (0, g.useEffect)(() => { t && n && (async () => { await l(o.current, { opacity: 0, visibility: "hidden" }, { duration: .8, ease: eL.lu }), tU.w.setState({ triggerTransition: "" }), s(!1), i(!1) })() }, [n, o, t]), (0, r.jsx)("div", { className: tk()["page-transition"], ref: o }) }; function tB(e) { return (0, r.jsx)("div", { className: "visually-hidden", role: "presentation", "aria-hidden": !0 }) } i(4087); var tz = i(7039), tG = i(4066), tH = i(5128), tV = i(104); let tW = () => { (0, tH.E)(() => { let e = new tG.A({ overscroll: !1 }); tz.s.setState({ Lenis: e }); let t = t => { e.raf(t.timestamp) }; return tV.Gt.update(t, !0), () => { (0, tV.WG)(t), e.destroy() } }, []) }, tj = () => (0, eK.A)("(hover: hover) and (pointer: fine)", !1), tY = (0, eM.v)(() => !1), tX = () => { let e = (0, g.useRef)({ x: 0, y: 0 }), t = tj(); return (0, g.useEffect)(() => { let i = !1, r = matchMedia("(hover: hover) and (pointer: fine)"), n = e => { i = !e.matches }; i = !r.matches, r.addEventListener("change", n); let s = (i, r) => { e.current.x = i, e.current.y = r; let n = !0; t && (i > window.innerWidth - 50 || i < 50 || r > window.innerHeight - 50 || r < 50) && (n = !1), e7.o.setState({ showCursor: n }) }, a = e => { if ("touches" in e) { let { clientX: t, clientY: i } = e.touches[0]; s(t, i) } else s(e.clientX, e.clientY); !e.target?.dataset?.cursorHoverState && i && e7.o.setState({ showCursor: !1 }) }, o = e => { "Tab" === e.key && document.activeElement && requestAnimationFrame(() => { let e = document.activeElement.getBoundingClientRect(); s(e.left + e.width / 2, e.top + e.height / 2) }) }; return window.addEventListener("pointermove", a), window.addEventListener("touchmove", a, { passive: !0 }), window.addEventListener("touchstart", a), window.addEventListener("keyup", o), document.oncontextmenu = document.body.oncontextmenu = function () { return !1 }, () => { window.removeEventListener("pointermove", a), window.removeEventListener("touchmove", a), window.removeEventListener("touchstart", a), r.removeEventListener("change", n), window.removeEventListener("keyup", o) } }, [t]), { cursor: e, isHolding: tY } }; var tK = i(4953), tq = i.n(tK); class tQ { constructor(e, { smoothing: t = 10, radius: i = 5, opacity: r = 1 } = {}) { this.ctx = e, this.x = 0, this.y = 0, this.nx = 0, this.ny = 0, this.smoothing = t, this.radius = i, this.opacity = r, this.nOpacity = r } draw() { let e = this.ctx; e.save(), e.globalAlpha = this.opacity, e.beginPath(), e.arc(this.x, this.y, this.radius, 0, 2 * Math.PI), e.fillStyle = "#fff5eb", e.fill(), e.restore() } update(e) { this.x = (0, eO.L2)(this.x, this.nx, this.smoothing, e), this.y = (0, eO.L2)(this.y, this.ny, this.smoothing, e), this.opacity = (0, eO.L2)(this.opacity, this.nOpacity, this.smoothing, e) } setN(e, t) { this.nx = e, this.ny = t } setOpacity(e) { this.nOpacity = e } } let tZ = () => { let e = (0, g.useRef)(!1), t = tj(), i = (0, g.useCallback)(() => { let i; let r = () => { e.current = !0 }, n = () => { e.current = !1 }, s = () => e7.o.setState({ showCursor: !0 }), a = () => e7.o.setState({ showCursor: !1 }); return t && (document.documentElement.addEventListener("mousemove", s, { once: !0, passive: !0 }), document.documentElement.addEventListener("mouseenter", s), document.documentElement.addEventListener("mouseleave", a), window.addEventListener("mousedown", r), window.addEventListener("mouseup", n)), () => { i?.stop(), document.documentElement.removeEventListener("mouseenter", s), document.documentElement.removeEventListener("mouseleave", a), window.removeEventListener("mousedown", r), window.removeEventListener("mouseup", n) } }, [t]); return { mousedown: e, setupMouseEvents: i } }; function t$(e, t) { return (t$ = Object.setPrototypeOf || function (e, t) { return e.__proto__ = t, e })(e, t) } function tJ(e, t) { (null == t || t > e.length) && (t = e.length); for (var i = 0, r = Array(t); i < t; i++)r[i] = e[i]; return r } function t0(e, t) { return function (e) { if (Array.isArray(e)) return e }(e) || function (e, t) { var i, r, n = null == e ? null : "undefined" != typeof Symbol && e[Symbol.iterator] || e["@@iterator"]; if (null != n) { var s = [], a = !0, o = !1; try { for (n = n.call(e); !(a = (i = n.next()).done) && (s.push(i.value), !t || s.length !== t); a = !0); } catch (e) { o = !0, r = e } finally { try { a || null == n.return || n.return() } finally { if (o) throw r } } return s } }(e, t) || function (e, t) { if (e) { if ("string" == typeof e) return tJ(e, t); var i = Object.prototype.toString.call(e).slice(8, -1); if ("Object" === i && e.constructor && (i = e.constructor.name), "Map" === i || "Set" === i) return Array.from(e); if ("Arguments" === i || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(i)) return tJ(e, t) } }(e, t) || function () { throw TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.") }() } new u.I9Y, new u.I9Y; var t1 = function (e) { return 1 / (1 + e + .48 * e * e + .235 * e * e * e) }; class t2 { constructor(e, { smoothing: t = 10, radius: i = 5, opacity: r = 1 } = {}) { this.VELOCITY_MAX = 50, this.pulseSpeed = .7, this.pulseAmount = 40, this.pulseTimer = 0, this.holdDuration = .15, this.ctx = e, this.x = 0, this.y = 0, this.nx = 0, this.ny = 0, this.scale = 1, this.nScale = 1, this.opacity = r, this.nOpacity = r, this.smoothing = t, this.initialRadius = i, this.radius = i, this.progress = 0, this.nProgress = 0 } draw() { let e = this.ctx; e.save(), e.translate(this.x, this.y), e.globalAlpha = this.opacity, e.beginPath(), e.strokeStyle = "#fff5eb", e.shadowBlur = 4, e.shadowColor = "#fff5eb"; let t = 1 - (0, eO.my)(this.progress, 0, .5, 0, 1), i = (0, eO.my)(this.progress, .5, 1, 1, 0); t = (0, eO.qE)(t, 0, 1), i = (0, eO.qE)(i, 0, 1); let r = (0, eO.qE)(2 * Math.PI * t, 0, 2 * Math.PI - 1e-4), n = (0, eO.qE)(2 * Math.PI * (i + 1e-4), 0, 2 * Math.PI), s = 1 + this.progress; e.arc(0, 0, this.radius * this.scale * s, -Math.PI / 2 - r, -Math.PI / 2 - n), e.stroke(), e.restore() } update(e) { this.x = (0, eO.L2)(this.x, this.nx, this.smoothing, e), this.y = (0, eO.L2)(this.y, this.ny, this.smoothing, e), this.scale = (0, eO.L2)(this.scale, this.nScale, this.smoothing, e), this.opacity = (0, eO.L2)(this.opacity, this.nOpacity, this.smoothing, e), function (e, t, i) { var r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : .25, n = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : .01, s = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : 1 / 0, a = arguments.length > 6 && void 0 !== arguments[6] ? arguments[6] : t1, o = arguments.length > 7 && void 0 !== arguments[7] ? arguments[7] : .001, l = "velocity_" + t; if (void 0 === e.__damp && (e.__damp = {}), void 0 === e.__damp[l] && (e.__damp[l] = 0), Math.abs(e[t] - i) <= o) return e[t] = i; var u = 2 / (r = Math.max(1e-4, r)), h = a(u * n), c = e[t] - i, d = i, f = s * r; c = Math.min(Math.max(c, -f), f), i = e[t] - c; var p = (e.__damp[l] + u * c) * n; e.__damp[l] = (e.__damp[l] - u * p) * h; var m = i + (c + p) * h; d - e[t] > 0 == m > d && (m = d, e.__damp[l] = (m - d) / n), e[t] = m }(this, "progress", this.nProgress, .3, e) } pulse(e) { this.pulseTimer += e * this.pulseSpeed; let t = 1 + this.holdDuration, i = this.pulseTimer % t; i <= 1 ? (this.radius = this.initialRadius + i * this.pulseAmount, this.opacity = Math.sin(i * Math.PI)) : (this.radius = this.initialRadius + this.pulseAmount, this.opacity = 0) } setN(e, t) { this.nx = e, this.ny = t } setScale(e) { this.nScale = e } setOpacity(e) { this.nOpacity = e } setProgress(e) { this.nProgress = e } getVelocity(e) { let t = Math.sqrt(((this.nx - this.x) / e) ** 2 + ((this.ny - this.y) / e) ** 2); return (0, eO.qE)(t, 0, this.VELOCITY_MAX) / 50 * 1 } } var t3 = i(8288); let t4 = () => ((0, g.useEffect)(() => { let e; if (!t3.B) return; let t = !1; function i() { Array.from(document.querySelectorAll("[data-cursor-hover-state]:not([data-events-added])")).forEach(e => { e.setAttribute("data-events-added", "true"), e.addEventListener("mouseenter", n), e.addEventListener("mouseleave", s), e.addEventListener("click", u), e.addEventListener("touchstart", a), e.addEventListener("touchend", o), e.addEventListener("touchcancel", o), e.addEventListener("pointerleave", o) }) } i(); let r = new MutationObserver(i); function n(e) { let t = e.target.getAttribute("data-cursor-hover-state"); e7.o.setState({ showHoverState: !0, hoverStateColor: t }) } function s() { e7.o.setState({ showHoverState: !1 }) } function a(i) { let r = i.target.getAttribute("data-cursor-hover-state"); e7.o.setState({ showCursor: !0, showHoverState: !0, hoverStateColor: r }), e = setTimeout(() => { t = !0, i.target.click(), o(i) }, 2700) } function o(i) { !matchMedia("(hover: hover) and (pointer: fine)").matches && (e7.o.setState({ showCursor: !1, showHoverState: !1 }), clearTimeout(e), t && (t = !1)) } function l(e) { e.removeEventListener("mouseenter", n), e.removeEventListener("mouseleave", s), e.removeEventListener("click", u), e.removeEventListener("touchstart", a), e.removeEventListener("touchend", o), e.removeEventListener("touchcancel", o), e.removeEventListener("pointerleave", o), e.removeAttribute("data-events-added") } function u(e) { if (e7.o.setState({ showHoverState: !1 }), !matchMedia("(hover: hover) and (pointer: fine)").matches && !t) { e.stopPropagation(); return } l(e.target), e.target?.removeAttribute("data-cursor-hover-state") } return r.observe(document.body, { subtree: !0, childList: !0 }), () => { r.disconnect(), Array.from(document.querySelectorAll("[data-cursor-hover-state][data-events-added]")).forEach(e => { l(e) }) } }, []), null); var t5 = i(2555), t8 = i.n(t5); let t6 = { OUTER: { SIZE: 40, SMOOTHING: 9, OPACITY: .5 }, INNER: { SIZE: 5, SMOOTHING: 10, OPACITY: .7 } }; function t9(e) { let t = (0, g.useRef)(null), i = !tj(), { cursor: n, isHolding: s } = tX(), { mousedown: a, setupMouseEvents: o } = tZ(); return t4(), (0, g.useEffect)(o, [o]), (0, g.useEffect)(() => { if (!t.current) return; let e = t.current, r = e.getContext("2d"); if (!r) return; let o = Math.min(window.devicePixelRatio, 2); function l() { r && (e.width = window.innerWidth * o, e.height = window.innerHeight * o, e.style.width = `${window.innerWidth}px`, e.style.height = `${window.innerHeight}px`, r.scale(o, o)) } l(), window.addEventListener("resize", l); let u = e7.o.getState().showCursor, h = new tQ(r, { smoothing: t6.INNER.SMOOTHING, radius: t6.INNER.SIZE / 2, opacity: u ? t6.INNER.OPACITY : 0 }), c = new t2(r, { smoothing: t6.OUTER.SMOOTHING, radius: t6.OUTER.SIZE / 2, opacity: u ? t6.OUTER.OPACITY : 0 }), d = s.subscribe(e => { e && (h.x = n.current.x, h.y = n.current.y, h.setN(n.current.x, n.current.y), c.x = n.current.x, c.y = n.current.y, c.setN(n.current.x, n.current.y)) }), f = e7.o.subscribe(({ showCursor: e, showHoverState: t }) => { i ? (c.setOpacity(e ? 1 : 0), h.setOpacity(e ? t6.INNER.OPACITY : 0)) : (c.setProgress(t ? 1 : 0), h.setOpacity(t ? 0 : t6.INNER.OPACITY)), i || (c.setOpacity(e ? t6.OUTER.OPACITY : 0), h.setOpacity(e && !t ? t6.INNER.OPACITY : 0)) }), p = tV.Gt.update(({ delta: t }) => { r.clearRect(0, 0, e.width, e.height); let s = t / 1e3, { showCursor: o, showHoverState: l } = e7.o.getState(); if (l) c.setScale(i ? 1 : 1.5); else { let e = a.current ? .67 : 1; c.setScale((1 - .8 * c.getVelocity(t)) * e) } h.setN(n.current.x, n.current.y), c.setN(n.current.x, n.current.y), h.update(s), c.update(s), i && o && l && c.pulse(s), h.draw(), c.draw() }, !0, !0); return () => { (0, tV.WG)(p), window.removeEventListener("resize", l), d(), f() } }, [i]), (0, r.jsx)("article", { className: (0, ew.A)(t8().Cursor), children: (0, r.jsx)("canvas", { ref: t, id: "cursor-canvas" }) }) } tq()(() => Promise.all([i.e(704), i.e(360)]).then(i.bind(i, 7360)).then(e => e.DesignHelper), { loadableGenerated: { webpack: () => [7360] }, ssr: !1 }); let t7 = tq()(() => i.e(412).then(i.bind(i, 6412)).then(e => e.CookieBanner), { loadableGenerated: { webpack: () => [6412] }, ssr: !1 }); function ie({ Component: e, pageProps: t }) { return tW(), (0, o.V4)(), (0, eE._K)(), tX(), !function () { let e = () => { eI.setState(e => (e.uniform.value.set(window.innerWidth, window.innerHeight), { ...e })) }; (0, g.useEffect)(() => (window.addEventListener("resize", e), e(), () => { window.removeEventListener("resize", e) }), []) }(), (0, r.jsxs)(r.Fragment, { children: [(0, r.jsx)(t7, {}), (0, r.jsxs)(a, { children: [(0, r.jsx)(e, { ...t }), (0, r.jsx)(tB, {})] }), (0, r.jsx)(tN, {}), (0, r.jsx)(tD, { siteSettings: t.siteSettings }), (0, r.jsx)(t9, {})] }) }
  }, 819: (e, t, i) => { "use strict"; i.d(t, { D: () => r }); let r = (0, i(1323).v)(() => ({ enableCanvasFrameloop: "always" })) }, 984: (e, t, i) => { "use strict"; i.d(t, { o: () => s }); var r = i(1323), n = i(7134); let s = (0, r.v)((0, n.eh)(() => ({ coords: { x: 0, y: 0 }, delta: { x: 0, y: 0 }, showCursor: !1, showHoverState: !1, hoverStateColor: "orange" }))) }, 7039: (e, t, i) => { "use strict"; i.d(t, { s: () => r }); let r = (0, i(1323).v)(() => ({ Lenis: void 0, scrollLayoutLenis: void 0 })) }, 4770: (e, t, i) => { "use strict"; i.d(t, { w: () => r }); let r = (0, i(1323).v)(e => ({ triggerTransition: "", setTriggerTransition: t => e({ triggerTransition: t }) })) }, 151: (e, t, i) => { "use strict"; i.d(t, { t: () => r }); let r = (0, i(1323).v)(() => null) }, 1538: (e, t, i) => { "use strict"; i.d(t, { o: () => r }); let r = (0, i(1323).v)((e, t) => ({ inTransition: !1, isStory: !1, hasStarted: !1, triggerTransition: 0, transition() { e({ triggerTransition: Math.random(), inTransition: !0 }) }, resetTransition() { e({ hasStarted: !1, inTransition: !1 }) } })) }, 1290: (e, t, i) => { "use strict"; i.d(t, { g: () => o, h: () => s }); var r = i(1323), n = i(6540); let s = (0, r.v)(e => ({ closed: !1, bottomless: !1, sideless: !1, focusMode: !1 })), a = { closed: !1, bottomless: !1, sideless: !1, focusMode: !1 }; function o(e) { (0, n.useEffect)(() => { let t = { ...a, ...e }; return s.setState(t), () => { s.setState(a) } }, Object.values(e)) } }, 9978: (e, t, i) => { "use strict"; i.d(t, { F: () => n }); var r = i(2111); function n() { let e = (0, r.A)(e => e.get), t = e().gl; return { store: r._.get(t.domElement)?.store, state: e() } } }, 3580: (e, t, i) => { "use strict"; i.d(t, { B: () => r }); let r = !0 }, 3668: (e, t, i) => {
    "use strict"; i.d(t, { $: () => s }); let r = { mobile: "30em", tablet: "48em", laptop: "62em", desktop: "75em", ultrawide: "96em" }; function n(e) { return r[e] ? r[e] : parseInt(e, void 0) ? e : (console.error("No valid breakpoint or size specified for media."), "0") } let s = {
      mobile: { min: `(min-width: ${n("mobile")})`, max: `(max-width: ${n("mobile")})` }, tablet: { min: `(min-width: ${n("tablet")})`, max: `(max-width: ${n("tablet")})` }, laptop: { min: `(min-width: ${n("laptop")})`, max: `(max-width: ${n("laptop")})` }, desktop: { min: `(min-width: ${n("desktop")})`, max: `(max-width: ${n("desktop")})` }, ultrawide: { min: `(min-width: ${n("ultrawide")})`, max: `(max-width: ${n("ultrawide")})` }, min: e => `@media (min-width: ${n(e)})`, max: e => `@media (max-width: ${n(e)})`, between: (e, t) => `
    @media (min-width: ${n(e)}) and (max-width: ${n(t)})`
    }
  }, 6520: (e, t, i) => { "use strict"; i.d(t, { a: () => r, c: () => n }); let r = { HOME: "/", CLANS: "/clans/", LINEAGES: "/lineages/", CHARACTERS: "/characters/", MAP: "/map/", STORY: "/story/", EPISODES: "/episodes/" }, n = { [r.HOME]: "Home", [r.CLANS]: "Clans", [r.LINEAGES]: "Lineages", [r.CHARACTERS]: "Characters", [r.MAP]: "Map", [r.STORY]: "Story", [r.EPISODES]: "Episodes" } }, 9530: (e, t, i) => { "use strict"; i.d(t, { UR: () => n, _K: () => a }); var r = i(6540); let n = (0, i(1323).v)(() => !1), s = () => new Promise(e => { var t = new Image; t.onload = function () { n.setState(!0), e(!0) }, t.onerror = function () { e(!1) }, t.src = "data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAAB0AAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAIAAAACAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQ0MAAAAABNjb2xybmNseAACAAIAAYAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAACVtZGF0EgAKCBgANogQEAwgMg8f8D///8WfhwB8+ErK42A=" }), a = () => ((0, r.useEffect)(() => { s() }, []), null) }, 4684: (e, t, i) => { "use strict"; function r(e) { return 0 === e ? 0 : 1 === e ? 1 : e < .5 ? Math.pow(2, 20 * e - 10) / 2 : (2 - Math.pow(2, -20 * e + 10)) / 2 } function n(e) { return 1 === e ? 1 : 1 - Math.pow(2, -10 * e) } function s(e) { return 1 - (1 - e) * (1 - e) } function a(e) { return e < .5 ? 8 * e * e * e * e : 1 - Math.pow(-2 * e + 2, 4) / 2 } i.d(t, { WD: () => s, e2: () => r, hn: () => a, lu: () => n }) }, 4087: () => { }, 4704: e => { e.exports = { main: "BaseLayout_main__AZAQI" } }, 7767: e => { e.exports = { Canvas: "Canvas_Canvas__8554X", disabled: "Canvas_disabled__WdIlI" } }, 2555: e => { e.exports = { Cursor: "Cursor_Cursor__rdIFa", ring: "Cursor_ring__JGcpx", dot: "Cursor_dot__C_xri" } }, 4841: e => { e.exports = { circleGlyphTouchPoint: "Excalibur_circleGlyphTouchPoint__lCWY_" } }, 9539: e => { e.exports = { "page-transition": "PageTransition_page-transition__fsHrG" } }, 2833: e => { e.exports = { StickyScrollContainer: "StickyScrollContainer_StickyScrollContainer__YqUg7" } }, 6385: e => { e.exports = { wrapper: "StorySectionWrapper_wrapper__o7CDl", backgroundImageHolder: "StorySectionWrapper_backgroundImageHolder__6Jc_M", "background-image": "StorySectionWrapper_background-image__YCHTA", "content-wrapper": "StorySectionWrapper_content-wrapper__pmLR0", content: "StorySectionWrapper_content__maPBT", ContentContainer: "StorySectionWrapper_ContentContainer__HvMko", "mobile-rows": "StorySectionWrapper_mobile-rows__9MZk2" } }, 4953: (e, t, i) => { e.exports = i(5946) }, 9965: (e, t, i) => { e.exports = i(2364) }, 1106: (e, t, i) => { e.exports = i(6397) }, 6715: (e, t, i) => { e.exports = i(8440) }, 2677: (e, t) => { "use strict"; t.ConcurrentRoot = 1, t.ContinuousEventPriority = 8, t.DefaultEventPriority = 32, t.DiscreteEventPriority = 2 }, 5725: (e, t, i) => { "use strict"; var r = i(7836); e.exports = function (e) { function t(e, t, i, r) { return new rD(e, t, i, r) } function n() { } function s(e) { var t = "https://react.dev/errors/" + e; if (1 < arguments.length) { t += "?args[]=" + encodeURIComponent(arguments[1]); for (var i = 2; i < arguments.length; i++)t += "&args[]=" + encodeURIComponent(arguments[i]) } return "Minified React error #" + e + "; visit " + t + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings." } function a(e) { return null === e || "object" != typeof e ? null : "function" == typeof (e = na && e[na] || e["@@iterator"]) ? e : null } function o(e) { if (null == e) return null; if ("function" == typeof e) return e.$$typeof === no ? null : e.displayName || e.name || null; if ("string" == typeof e) return e; switch (e) { case r1: return "Fragment"; case r0: return "Portal"; case r3: return "Profiler"; case r2: return "StrictMode"; case r9: return "Suspense"; case r7: return "SuspenseList" }if ("object" == typeof e) switch (e.$$typeof) { case r8: return (e.displayName || "Context") + ".Provider"; case r5: return (e._context.displayName || "Context") + ".Consumer"; case r6: var t = e.render; return (e = e.displayName) || (e = "" !== (e = t.displayName || t.name || "") ? "ForwardRef(" + e + ")" : "ForwardRef"), e; case ne: return null !== (t = e.displayName || null) ? t : o(e.type) || "Memo"; case nt: t = e._payload, e = e._init; try { return o(e(t)) } catch (e) { } }return null } function l(e) { if (void 0 === nr) try { throw Error() } catch (e) { var t = e.stack.trim().match(/\n( *(at )?)/); nr = t && t[1] || "", nn = -1 < e.stack.indexOf("\n    at") ? " (<anonymous>)" : -1 < e.stack.indexOf("@") ? "@unknown:0:0" : "" } return "\n" + nr + e + nn } function u(e, t) { if (!e || nu) return ""; nu = !0; var i = Error.prepareStackTrace; Error.prepareStackTrace = void 0; try { var r = { DetermineComponentFrameRoot: function () { try { if (t) { var i = function () { throw Error() }; if (Object.defineProperty(i.prototype, "props", { set: function () { throw Error() } }), "object" == typeof Reflect && Reflect.construct) { try { Reflect.construct(i, []) } catch (e) { var r = e } Reflect.construct(e, [], i) } else { try { i.call() } catch (e) { r = e } e.call(i.prototype) } } else { try { throw Error() } catch (e) { r = e } (i = e()) && "function" == typeof i.catch && i.catch(function () { }) } } catch (e) { if (e && r && "string" == typeof e.stack) return [e.stack, r.stack] } return [null, null] } }; r.DetermineComponentFrameRoot.displayName = "DetermineComponentFrameRoot"; var n = Object.getOwnPropertyDescriptor(r.DetermineComponentFrameRoot, "name"); n && n.configurable && Object.defineProperty(r.DetermineComponentFrameRoot, "name", { value: "DetermineComponentFrameRoot" }); var s = r.DetermineComponentFrameRoot(), a = s[0], o = s[1]; if (a && o) { var u = a.split("\n"), h = o.split("\n"); for (n = r = 0; r < u.length && !u[r].includes("DetermineComponentFrameRoot");)r++; for (; n < h.length && !h[n].includes("DetermineComponentFrameRoot");)n++; if (r === u.length || n === h.length) for (r = u.length - 1, n = h.length - 1; 1 <= r && 0 <= n && u[r] !== h[n];)n--; for (; 1 <= r && 0 <= n; r--, n--)if (u[r] !== h[n]) { if (1 !== r || 1 !== n) do if (r--, n--, 0 > n || u[r] !== h[n]) { var c = "\n" + u[r].replace(" at new ", " at "); return e.displayName && c.includes("<anonymous>") && (c = c.replace("<anonymous>", e.displayName)), c } while (1 <= r && 0 <= n); break } } } finally { nu = !1, Error.prepareStackTrace = i } return (i = e ? e.displayName || e.name : "") ? l(i) : "" } function h(e) { try { var t = ""; do t += function (e) { switch (e.tag) { case 26: case 27: case 5: return l(e.type); case 16: return l("Lazy"); case 13: return l("Suspense"); case 19: return l("SuspenseList"); case 0: case 15: return e = u(e.type, !1); case 11: return e = u(e.type.render, !1); case 1: return e = u(e.type, !0); default: return "" } }(e), e = e.return; while (e); return t } catch (e) { return "\nError generating stack: " + e.message + "\n" + e.stack } } function c(e) { var t = e, i = e; if (e.alternate) for (; t.return;)t = t.return; else { e = t; do 0 != (4098 & (t = e).flags) && (i = t.return), e = t.return; while (e) } return 3 === t.tag ? i : null } function d(e) { if (c(e) !== e) throw Error(s(188)) } function f(e) { var t = e.alternate; if (!t) { if (null === (t = c(e))) throw Error(s(188)); return t !== e ? null : e } for (var i = e, r = t; ;) { var n = i.return; if (null === n) break; var a = n.alternate; if (null === a) { if (null !== (r = n.return)) { i = r; continue } break } if (n.child === a.child) { for (a = n.child; a;) { if (a === i) return d(n), e; if (a === r) return d(n), t; a = a.sibling } throw Error(s(188)) } if (i.return !== r.return) i = n, r = a; else { for (var o = !1, l = n.child; l;) { if (l === i) { o = !0, i = n, r = a; break } if (l === r) { o = !0, r = n, i = a; break } l = l.sibling } if (!o) { for (l = a.child; l;) { if (l === i) { o = !0, i = a, r = n; break } if (l === r) { o = !0, r = a, i = n; break } l = l.sibling } if (!o) throw Error(s(189)) } } if (i.alternate !== r) throw Error(s(190)) } if (3 !== i.tag) throw Error(s(188)); return i.stateNode.current === i ? e : t } function p(e) { return { current: e } } function m(e) { 0 > s5 || (e.current = s4[s5], s4[s5] = null, s5--) } function g(e, t) { s4[++s5] = e.current, e.current = t } function v(e) { var t = 42 & e; if (0 !== t) return t; switch (e & -e) { case 1: return 1; case 2: return 2; case 4: return 4; case 8: return 8; case 16: return 16; case 32: return 32; case 64: return 64; case 128: case 256: case 512: case 1024: case 2048: case 4096: case 8192: case 16384: case 32768: case 65536: case 131072: case 262144: case 524288: case 1048576: case 2097152: return 4194176 & e; case 4194304: case 8388608: case 0x1000000: case 0x2000000: return 0x3c00000 & e; case 0x4000000: return 0x4000000; case 0x8000000: return 0x8000000; case 0x10000000: return 0x10000000; case 0x20000000: return 0x20000000; case 0x40000000: return 0; default: return e } } function y(e, t) { var i = e.pendingLanes; if (0 === i) return 0; var r = 0, n = e.suspendedLanes, s = e.pingedLanes, a = e.warmLanes; e = 0 !== e.finishedLanes; var o = 0x7ffffff & i; return 0 !== o ? 0 != (i = o & ~n) ? r = v(i) : 0 != (s &= o) ? r = v(s) : e || 0 != (a = o & ~a) && (r = v(a)) : 0 != (o = i & ~n) ? r = v(o) : 0 !== s ? r = v(s) : e || 0 != (a = i & ~a) && (r = v(a)), 0 === r ? 0 : 0 !== t && t !== r && 0 == (t & n) && ((n = r & -r) >= (a = t & -t) || 32 === n && 0 != (4194176 & a)) ? t : r } function x(e, t) { return 0 == (e.pendingLanes & ~(e.suspendedLanes & ~e.pingedLanes) & t) } function S() { var e = ae; return 0 == (4194176 & (ae <<= 1)) && (ae = 128), e } function A() { var e = at; return 0 == (0x3c00000 & (at <<= 1)) && (at = 4194304), e } function _(e) { for (var t = [], i = 0; 31 > i; i++)t.push(e); return t } function E(e, t) { e.pendingLanes |= t, 0x10000000 !== t && (e.suspendedLanes = 0, e.pingedLanes = 0, e.warmLanes = 0) } function b(e, t, i) { e.pendingLanes |= t, e.suspendedLanes &= ~t; var r = 31 - s6(t); e.entangledLanes |= t, e.entanglements[r] = 0x40000000 | e.entanglements[r] | 4194218 & i } function T(e, t) { var i = e.entangledLanes |= t; for (e = e.entanglements; i;) { var r = 31 - s6(i), n = 1 << r; n & t | e[r] & t && (e[r] |= t), i &= ~n } } function w(e) { return 2 < (e &= -e) ? 8 < e ? 0 != (0x7ffffff & e) ? 32 : 0x10000000 : 8 : 2 } function M(e) { if ("function" == typeof ac && ad(e), ap && "function" == typeof ap.setStrictMode) try { ap.setStrictMode(af, e) } catch (e) { } } function R(e, t) { if ("object" == typeof e && null !== e) { var i = ag.get(e); return void 0 !== i ? i : (t = { value: e, source: t, stack: h(t) }, ag.set(e, t), t) } return { value: e, source: t, stack: h(t) } } function C(e, t) { av[ay++] = aS, av[ay++] = ax, ax = e, aS = t } function I(e, t, i) { aA[a_++] = ab, aA[a_++] = aT, aA[a_++] = aE, aE = e; var r = ab; e = aT; var n = 32 - s6(r) - 1; r &= ~(1 << n), i += 1; var s = 32 - s6(t) + n; if (30 < s) { var a = n - n % 5; s = (r & (1 << a) - 1).toString(32), r >>= a, n -= a, ab = 1 << 32 - s6(t) + n | i << n | r, aT = s + e } else ab = 1 << s | i << n | r, aT = e } function L(e) { null !== e.return && (C(e, 1), I(e, 1, 0)) } function P(e) { for (; e === ax;)ax = av[--ay], av[ay] = null, aS = av[--ay], av[ay] = null; for (; e === aE;)aE = aA[--a_], aA[a_] = null, aT = aA[--a_], aA[a_] = null, ab = aA[--a_], aA[a_] = null } function D(e, t) { g(aR, t), g(aM, e), g(aw, null), e = nm(t), m(aw), g(aw, e) } function O() { m(aw), m(aM), m(aR) } function k(e) { null !== e.memoizedState && g(aC, e); var t = aw.current, i = ng(t, e.type); t !== i && (g(aM, e), g(aw, i)) } function F(e) { aM.current === e && (m(aw), m(aM)), aC.current === e && (m(aC), nM ? nW._currentValue = nV : nW._currentValue2 = nV) } function U(e) { throw H(R(Error(s(418, "")), e)), ak } function N(e, t) { if (!nI) throw Error(s(175)); sM(e.stateNode, e.type, e.memoizedProps, t, e) || U(e) } function B(e) { for (aI = e.return; aI;)switch (aI.tag) { case 3: case 27: aO = !0; return; case 5: case 13: aO = !1; return; default: aI = aI.return } } function z(e) { if (!nI || e !== aI) return !1; if (!aP) return B(e), aP = !0, !1; var t = !1; if (s$ ? 3 !== e.tag && 27 !== e.tag && (5 !== e.tag || sk(e.type) && !n_(e.type, e.memoizedProps)) && (t = !0) : 3 !== e.tag && (5 !== e.tag || sk(e.type) && !n_(e.type, e.memoizedProps)) && (t = !0), t && aL && U(e), B(e), 13 === e.tag) { if (!nI) throw Error(s(316)); if (!(e = null !== (e = e.memoizedState) ? e.dehydrated : null)) throw Error(s(317)); aL = sI(e) } else aL = aI ? sS(e.stateNode) : null; return !0 } function G() { nI && (aL = aI = null, aP = !1) } function H(e) { null === aD ? aD = [e] : aD.push(e) } function V() { for (var e = aU, t = aN = aU = 0; t < e;) { var i = aF[t]; aF[t++] = null; var r = aF[t]; aF[t++] = null; var n = aF[t]; aF[t++] = null; var s = aF[t]; if (aF[t++] = null, null !== r && null !== n) { var a = r.pending; null === a ? n.next = n : (n.next = a.next, a.next = n), r.pending = n } 0 !== s && X(i, n, s) } } function W(e, t, i, r) { aF[aU++] = e, aF[aU++] = t, aF[aU++] = i, aF[aU++] = r, aN |= r, e.lanes |= r, null !== (e = e.alternate) && (e.lanes |= r) } function j(e, t, i, r) { return W(e, t, i, r), K(e) } function Y(e, t) { return W(e, null, null, t), K(e) } function X(e, t, i) { e.lanes |= i; var r = e.alternate; null !== r && (r.lanes |= i); for (var n = !1, s = e.return; null !== s;)s.childLanes |= i, null !== (r = s.alternate) && (r.childLanes |= i), 22 === s.tag && (null === (e = s.stateNode) || 1 & e._visibility || (n = !0)), e = s, s = s.return; n && null !== t && 3 === e.tag && (s = e.stateNode, n = 31 - s6(i), null === (e = (s = s.hiddenUpdates)[n]) ? s[n] = [t] : e.push(t), t.lane = 0x20000000 | i) } function K(e) { if (50 < lf) throw lf = 0, lp = null, Error(s(185)); for (var t = e.return; null !== t;)t = (e = t).return; return 3 === e.tag ? e.stateNode : null } function q(e) { var t; e !== az && null === e.next && (null === az ? aB = az = e : az = az.next = e), aH = !0, aG || (aG = !0, t = Z, nY ? nX(function () { 0 != (6 & oq) ? ai(ao, t) : t() }) : ai(ao, t)) } function Q(e, t) { if (!aV && aH) { aV = !0; do for (var i = !1, r = aB; null !== r;) { if (!t) { if (0 !== e) { var n = r.pendingLanes; if (0 === n) var s = 0; else { var a = r.suspendedLanes, o = r.pingedLanes; s = 0xc000055 & (s = (1 << 31 - s6(42 | e) + 1) - 1 & (n & ~(a & ~o))) ? 0xc000055 & s | 1 : s ? 2 | s : 0 } 0 !== s && (i = !0, ee(r, s)) } else s = o$, 0 == (3 & (s = y(r, r === oQ ? s : 0))) || x(r, s) || (i = !0, ee(r, s)) } r = r.next } while (i); aV = !1 } } function Z() { aH = aG = !1; var e = 0; 0 !== aW && (nF() && (e = aW), aW = 0); for (var t = aa(), i = null, r = aB; null !== r;) { var n = r.next, s = $(r, t); 0 === s ? (r.next = null, null === i ? aB = n : i.next = n, null === n && (az = i)) : (i = r, (0 !== e || 0 != (3 & s)) && (aH = !0)), r = n } Q(e, !1) } function $(e, t) { for (var i = e.suspendedLanes, r = e.pingedLanes, n = e.expirationTimes, s = -0x3c00001 & e.pendingLanes; 0 < s;) { var a = 31 - s6(s), o = 1 << a, l = n[a]; -1 === l ? (0 == (o & i) || 0 != (o & r)) && (n[a] = function (e, t) { switch (e) { case 1: case 2: case 4: case 8: return t + 250; case 16: case 32: case 64: case 128: case 256: case 512: case 1024: case 2048: case 4096: case 8192: case 16384: case 32768: case 65536: case 131072: case 262144: case 524288: case 1048576: case 2097152: return t + 5e3; default: return -1 } }(o, t)) : l <= t && (e.expiredLanes |= o), s &= ~o } if (t = oQ, i = o$, i = y(e, e === t ? i : 0), r = e.callbackNode, 0 === i || e === t && 2 === oJ || null !== e.cancelPendingCommit) return null !== r && null !== r && ar(r), e.callbackNode = null, e.callbackPriority = 0; if (0 == (3 & i) || x(e, i)) { if ((t = i & -i) === e.callbackPriority) return t; switch (null !== r && ar(r), w(i)) { case 2: case 8: i = al; break; case 32: default: i = au; break; case 0x10000000: i = ah }return i = ai(i, r = J.bind(null, e)), e.callbackPriority = t, e.callbackNode = i, t } return null !== r && null !== r && ar(r), e.callbackPriority = 2, e.callbackNode = null, 2 } function J(e, t) { var i = e.callbackNode; if (rT() && e.callbackNode !== i) return null; var r = o$; return 0 === (r = y(e, e === oQ ? r : 0)) ? null : (rs(e, r, t), $(e, aa()), null != e.callbackNode && e.callbackNode === i ? J.bind(null, e) : null) } function ee(e, t) { if (rT()) return null; rs(e, t, !0) } function et() { return 0 === aW && (aW = S()), aW } function ei() { if (0 == --aY && null !== aj) { null !== aK && (aK.status = "fulfilled"); var e = aj; aj = null, aX = 0, aK = null; for (var t = 0; t < e.length; t++)(0, e[t])() } } function er(e) { e.updateQueue = { baseState: e.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null, lanes: 0, hiddenCallbacks: null }, callbacks: null } } function en(e, t) { e = e.updateQueue, t.updateQueue === e && (t.updateQueue = { baseState: e.baseState, firstBaseUpdate: e.firstBaseUpdate, lastBaseUpdate: e.lastBaseUpdate, shared: e.shared, callbacks: null }) } function es(e) { return { lane: e, tag: 0, payload: null, callback: null, next: null } } function ea(e, t, i) { var r = e.updateQueue; if (null === r) return null; if (r = r.shared, 0 != (2 & oq)) { var n = r.pending; return null === n ? t.next = t : (t.next = n.next, n.next = t), r.pending = t, t = K(e), X(e, null, i), t } return W(e, r, t, i), K(e) } function eo(e, t, i) { if (null !== (t = t.updateQueue) && (t = t.shared, 0 != (4194176 & i))) { var r = t.lanes; r &= e.pendingLanes, i |= r, t.lanes = i, T(e, i) } } function el(e, t) { var i = e.updateQueue, r = e.alternate; if (null !== r && i === (r = r.updateQueue)) { var n = null, s = null; if (null !== (i = i.firstBaseUpdate)) { do { var a = { lane: i.lane, tag: i.tag, payload: i.payload, callback: null, next: null }; null === s ? n = s = a : s = s.next = a, i = i.next } while (null !== i); null === s ? n = s = t : s = s.next = t } else n = s = t; i = { baseState: r.baseState, firstBaseUpdate: n, lastBaseUpdate: s, shared: r.shared, callbacks: r.callbacks }, e.updateQueue = i; return } null === (e = i.lastBaseUpdate) ? i.firstBaseUpdate = t : e.next = t, i.lastBaseUpdate = t } function eu() { if (aQ) { var e = aK; if (null !== e) throw e } } function eh(e, t, i, r) { aQ = !1; var n = e.updateQueue; aq = !1; var s = n.firstBaseUpdate, a = n.lastBaseUpdate, o = n.shared.pending; if (null !== o) { n.shared.pending = null; var l = o, u = l.next; l.next = null, null === a ? s = u : a.next = u, a = l; var h = e.alternate; null !== h && (o = (h = h.updateQueue).lastBaseUpdate) !== a && (null === o ? h.firstBaseUpdate = u : o.next = u, h.lastBaseUpdate = l) } if (null !== s) { var c = n.baseState; for (a = 0, h = u = l = null, o = s; ;) { var d = -0x20000001 & o.lane, f = d !== o.lane; if (f ? (o$ & d) === d : (r & d) === d) { 0 !== d && d === aX && (aQ = !0), null !== h && (h = h.next = { lane: 0, tag: o.tag, payload: o.payload, callback: null, next: null }); e: { var p = e, m = o; switch (d = t, m.tag) { case 1: if ("function" == typeof (p = m.payload)) { c = p.call(i, c, d); break e } c = p; break e; case 3: p.flags = -65537 & p.flags | 128; case 0: if (null == (d = "function" == typeof (p = m.payload) ? p.call(i, c, d) : p)) break e; c = rZ({}, c, d); break e; case 2: aq = !0 } } null !== (d = o.callback) && (e.flags |= 64, f && (e.flags |= 8192), null === (f = n.callbacks) ? n.callbacks = [d] : f.push(d)) } else f = { lane: d, tag: o.tag, payload: o.payload, callback: o.callback, next: null }, null === h ? (u = h = f, l = c) : h = h.next = f, a |= d; if (null === (o = o.next)) { if (null === (o = n.shared.pending)) break; o = (f = o).next, f.next = null, n.lastBaseUpdate = f, n.shared.pending = null } } null === h && (l = c), n.baseState = l, n.firstBaseUpdate = u, n.lastBaseUpdate = h, null === s && (n.shared.lanes = 0), o8 |= a, e.lanes = a, e.memoizedState = c } } function ec(e, t) { if ("function" != typeof e) throw Error(s(191, e)); e.call(t) } function ed(e, t) { var i = e.callbacks; if (null !== i) for (e.callbacks = null, e = 0; e < i.length; e++)ec(i[e], t) } function ef(e, t) { if (am(e, t)) return !0; if ("object" != typeof e || null === e || "object" != typeof t || null === t) return !1; var i = Object.keys(e), r = Object.keys(t); if (i.length !== r.length) return !1; for (r = 0; r < i.length; r++) { var n = i[r]; if (!aZ.call(t, n) || !am(e[n], t[n])) return !1 } return !0 } function ep(e) { return "fulfilled" === (e = e.status) || "rejected" === e } function em() { } function eg(e, t, i) { switch (void 0 === (i = e[i]) ? e.push(t) : i !== t && (t.then(em, em), t = i), t.status) { case "fulfilled": return t.value; case "rejected": if ((e = t.reason) === a$) throw Error(s(483)); throw e; default: if ("string" == typeof t.status) t.then(em, em); else { if (null !== (e = oQ) && 100 < e.shellSuspendCounter) throw Error(s(482)); (e = t).status = "pending", e.then(function (e) { if ("pending" === t.status) { var i = t; i.status = "fulfilled", i.value = e } }, function (e) { if ("pending" === t.status) { var i = t; i.status = "rejected", i.reason = e } }) } switch (t.status) { case "fulfilled": return t.value; case "rejected": if ((e = t.reason) === a$) throw Error(s(483)); throw e }throw a1 = t, a$ } } function ev() { if (null === a1) throw Error(s(459)); var e = a1; return a1 = null, e } function ey(e) { var t = a3; return a3 += 1, null === a2 && (a2 = []), eg(a2, e, t) } function ex(e, t) { t = t.props.ref, e.ref = void 0 !== t ? t : null } function eS(e, t) { if (t.$$typeof === r$) throw Error(s(525)); throw Error(s(31, "[object Object]" === (e = Object.prototype.toString.call(t)) ? "object with keys {" + Object.keys(t).join(", ") + "}" : e)) } function eA(e) { return (0, e._init)(e._payload) } function e_(e) { function i(t, i) { if (e) { var r = t.deletions; null === r ? (t.deletions = [i], t.flags |= 16) : r.push(i) } } function r(t, r) { if (!e) return null; for (; null !== r;)i(t, r), r = r.sibling; return null } function n(e) { for (var t = new Map; null !== e;)null !== e.key ? t.set(e.key, e) : t.set(e.index, e), e = e.sibling; return t } function o(e, t) { return (e = rk(e, t)).index = 0, e.sibling = null, e } function l(t, i, r) { return (t.index = r, e) ? null !== (r = t.alternate) ? (r = r.index) < i ? (t.flags |= 0x2000002, i) : r : (t.flags |= 0x2000002, i) : (t.flags |= 1048576, i) } function u(t) { return e && null === t.alternate && (t.flags |= 0x2000002), t } function h(e, t, i, r) { return null === t || 6 !== t.tag ? (t = rz(i, e.mode, r)).return = e : (t = o(t, i)).return = e, t } function c(e, t, i, r) { var n = i.type; return n === r1 ? f(e, t, i.props.children, r, i.key) : (null !== t && (t.elementType === n || "object" == typeof n && null !== n && n.$$typeof === nt && eA(n) === t.type) ? ex(t = o(t, i.props), i) : ex(t = rU(i.type, i.key, i.props, null, e.mode, r), i), t.return = e, t) } function d(e, t, i, r) { return null === t || 4 !== t.tag || t.stateNode.containerInfo !== i.containerInfo || t.stateNode.implementation !== i.implementation ? (t = rG(i, e.mode, r)).return = e : (t = o(t, i.children || [])).return = e, t } function f(e, t, i, r, n) { return null === t || 7 !== t.tag ? (t = rN(i, e.mode, r, n)).return = e : (t = o(t, i)).return = e, t } function p(e, t, i) { if ("string" == typeof t && "" !== t || "number" == typeof t || "bigint" == typeof t) return (t = rz("" + t, e.mode, i)).return = e, t; if ("object" == typeof t && null !== t) { switch (t.$$typeof) { case rJ: return ex(i = rU(t.type, t.key, t.props, null, e.mode, i), t), i.return = e, i; case r0: return (t = rG(t, e.mode, i)).return = e, t; case nt: return p(e, t = (0, t._init)(t._payload), i) }if (nh(t) || a(t)) return (t = rN(t, e.mode, i, null)).return = e, t; if ("function" == typeof t.then) return p(e, ey(t), i); if (t.$$typeof === r8) return p(e, ih(e, t), i); eS(e, t) } return null } function m(e, t, i, r) { var n = null !== t ? t.key : null; if ("string" == typeof i && "" !== i || "number" == typeof i || "bigint" == typeof i) return null !== n ? null : h(e, t, "" + i, r); if ("object" == typeof i && null !== i) { switch (i.$$typeof) { case rJ: return i.key === n ? c(e, t, i, r) : null; case r0: return i.key === n ? d(e, t, i, r) : null; case nt: return m(e, t, i = (n = i._init)(i._payload), r) }if (nh(i) || a(i)) return null !== n ? null : f(e, t, i, r, null); if ("function" == typeof i.then) return m(e, t, ey(i), r); if (i.$$typeof === r8) return m(e, t, ih(e, i), r); eS(e, i) } return null } function g(e, t, i, r, n) { if ("string" == typeof r && "" !== r || "number" == typeof r || "bigint" == typeof r) return h(t, e = e.get(i) || null, "" + r, n); if ("object" == typeof r && null !== r) { switch (r.$$typeof) { case rJ: return c(t, e = e.get(null === r.key ? i : r.key) || null, r, n); case r0: return d(t, e = e.get(null === r.key ? i : r.key) || null, r, n); case nt: return g(e, t, i, r = (0, r._init)(r._payload), n) }if (nh(r) || a(r)) return f(t, e = e.get(i) || null, r, n, null); if ("function" == typeof r.then) return g(e, t, i, ey(r), n); if (r.$$typeof === r8) return g(e, t, i, ih(t, r), n); eS(t, r) } return null } return function (h, c, d, f) { try { a3 = 0; var v = function t(h, c, d, f) { if ("object" == typeof d && null !== d && d.type === r1 && null === d.key && (d = d.props.children), "object" == typeof d && null !== d) { switch (d.$$typeof) { case rJ: e: { for (var v = d.key; null !== c;) { if (c.key === v) { if ((v = d.type) === r1) { if (7 === c.tag) { r(h, c.sibling), (f = o(c, d.props.children)).return = h, h = f; break e } } else if (c.elementType === v || "object" == typeof v && null !== v && v.$$typeof === nt && eA(v) === c.type) { r(h, c.sibling), ex(f = o(c, d.props), d), f.return = h, h = f; break e } r(h, c); break } i(h, c), c = c.sibling } d.type === r1 ? (f = rN(d.props.children, h.mode, f, d.key)).return = h : (ex(f = rU(d.type, d.key, d.props, null, h.mode, f), d), f.return = h), h = f } return u(h); case r0: e: { for (v = d.key; null !== c;) { if (c.key === v) { if (4 === c.tag && c.stateNode.containerInfo === d.containerInfo && c.stateNode.implementation === d.implementation) { r(h, c.sibling), (f = o(c, d.children || [])).return = h, h = f; break e } r(h, c); break } i(h, c), c = c.sibling } (f = rG(d, h.mode, f)).return = h, h = f } return u(h); case nt: return t(h, c, d = (v = d._init)(d._payload), f) }if (nh(d)) return function (t, s, a, o) { for (var u = null, h = null, c = s, d = s = 0, f = null; null !== c && d < a.length; d++) { c.index > d ? (f = c, c = null) : f = c.sibling; var v = m(t, c, a[d], o); if (null === v) { null === c && (c = f); break } e && c && null === v.alternate && i(t, c), s = l(v, s, d), null === h ? u = v : h.sibling = v, h = v, c = f } if (d === a.length) return r(t, c), aP && C(t, d), u; if (null === c) { for (; d < a.length; d++)null !== (c = p(t, a[d], o)) && (s = l(c, s, d), null === h ? u = c : h.sibling = c, h = c); return aP && C(t, d), u } for (c = n(c); d < a.length; d++)null !== (f = g(c, t, d, a[d], o)) && (e && null !== f.alternate && c.delete(null === f.key ? d : f.key), s = l(f, s, d), null === h ? u = f : h.sibling = f, h = f); return e && c.forEach(function (e) { return i(t, e) }), aP && C(t, d), u }(h, c, d, f); if (a(d)) { if ("function" != typeof (v = a(d))) throw Error(s(150)); return function (t, a, o, u) { if (null == o) throw Error(s(151)); for (var h = null, c = null, d = a, f = a = 0, v = null, y = o.next(); null !== d && !y.done; f++, y = o.next()) { d.index > f ? (v = d, d = null) : v = d.sibling; var x = m(t, d, y.value, u); if (null === x) { null === d && (d = v); break } e && d && null === x.alternate && i(t, d), a = l(x, a, f), null === c ? h = x : c.sibling = x, c = x, d = v } if (y.done) return r(t, d), aP && C(t, f), h; if (null === d) { for (; !y.done; f++, y = o.next())null !== (y = p(t, y.value, u)) && (a = l(y, a, f), null === c ? h = y : c.sibling = y, c = y); return aP && C(t, f), h } for (d = n(d); !y.done; f++, y = o.next())null !== (y = g(d, t, f, y.value, u)) && (e && null !== y.alternate && d.delete(null === y.key ? f : y.key), a = l(y, a, f), null === c ? h = y : c.sibling = y, c = y); return e && d.forEach(function (e) { return i(t, e) }), aP && C(t, f), h }(h, c, d = v.call(d), f) } if ("function" == typeof d.then) return t(h, c, ey(d), f); if (d.$$typeof === r8) return t(h, c, ih(h, d), f); eS(h, d) } return "string" == typeof d && "" !== d || "number" == typeof d || "bigint" == typeof d ? (d = "" + d, null !== c && 6 === c.tag ? (r(h, c.sibling), (f = o(c, d)).return = h) : (r(h, c), (f = rz(d, h.mode, f)).return = h), u(h = f)) : r(h, c) }(h, c, d, f); return a2 = null, v } catch (e) { if (e === a$) throw e; var y = t(29, e, null, h.mode); return y.lanes = f, y.return = h, y } finally { } } } function eE(e, t) { g(a6, e = o4), g(a8, t), o4 = e | t.baseLanes } function eb() { g(a6, o4), g(a8, a8.current) } function eT() { o4 = a6.current, m(a8), m(a6) } function ew(e) { var t = e.alternate; g(oe, 1 & oe.current), g(a9, e), null === a7 && (null === t || null !== a8.current ? a7 = e : null !== t.memoizedState && (a7 = e)) } function eM(e) { if (22 === e.tag) { if (g(oe, oe.current), g(a9, e), null === a7) { var t = e.alternate; null !== t && null !== t.memoizedState && (a7 = e) } } else eR(e) } function eR() { g(oe, oe.current), g(a9, a9.current) } function eC(e) { m(a9), a7 === e && (a7 = null), m(oe) } function eI(e) { for (var t = e; null !== t;) { if (13 === t.tag) { var i = t.memoizedState; if (null !== i && (null === (i = i.dehydrated) || sp(i) || sm(i))) return t } else if (19 === t.tag && void 0 !== t.memoizedProps.revealOrder) { if (0 != (128 & t.flags)) return t } else if (null !== t.child) { t.child.return = t, t = t.child; continue } if (t === e) break; for (; null === t.sibling;) { if (null === t.return || t.return === e) return null; t = t.return } t.sibling.return = t.return, t = t.sibling } return null } function eL() { throw Error(s(321)) } function eP(e, t) { if (null === t) return !1; for (var i = 0; i < t.length && i < e.length; i++)if (!am(e[i], t[i])) return !1; return !0 } function eD(e, t, i, r, n, s) { return ot = s, oi = t, t.memoizedState = null, t.updateQueue = null, t.lanes = 0, nl.H = null === e || null === e.memoizedState ? op : om, oo = !1, s = i(r, n), oo = !1, oa && (s = ek(t, i, r, n)), eO(e), s } function eO(e) { nl.H = of; var t = null !== or && null !== or.next; if (ot = 0, on = or = oi = null, os = !1, ou = 0, oh = null, t) throw Error(s(300)); null === e || oS || null !== (e = e.dependencies) && io(e) && (oS = !0) } function ek(e, t, i, r) { oi = e; var n = 0; do { if (oa && (oh = null), ou = 0, oa = !1, 25 <= n) throw Error(s(301)); if (n += 1, on = or = null, null != e.updateQueue) { var a = e.updateQueue; a.lastEffect = null, a.events = null, a.stores = null, null != a.memoCache && (a.memoCache.index = 0) } nl.H = og, a = t(i, r) } while (oa); return a } function eF() { var e = nl.H, t = e.useState()[0]; return t = "function" == typeof t.then ? eH(t) : t, e = e.useState()[0], (null !== or ? or.memoizedState : null) !== e && (oi.flags |= 1024), t } function eU() { var e = 0 !== ol; return ol = 0, e } function eN(e, t, i) { t.updateQueue = e.updateQueue, t.flags &= -2053, e.lanes &= ~i } function eB(e) { if (os) { for (e = e.memoizedState; null !== e;) { var t = e.queue; null !== t && (t.pending = null), e = e.next } os = !1 } ot = 0, on = or = oi = null, oa = !1, ou = ol = 0, oh = null } function ez() { var e = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null }; return null === on ? oi.memoizedState = on = e : on = on.next = e, on } function eG() { if (null === or) { var e = oi.alternate; e = null !== e ? e.memoizedState : null } else e = or.next; var t = null === on ? oi.memoizedState : on.next; if (null !== t) on = t, or = e; else { if (null === e) { if (null === oi.alternate) throw Error(s(467)); throw Error(s(310)) } e = { memoizedState: (or = e).memoizedState, baseState: or.baseState, baseQueue: or.baseQueue, queue: or.queue, next: null }, null === on ? oi.memoizedState = on = e : on = on.next = e } return on } function eH(e) { var t = ou; return ou += 1, null === oh && (oh = []), e = eg(oh, e, t), t = oi, null === (null === on ? t.memoizedState : on.next) && (t = t.alternate, nl.H = null === t || null === t.memoizedState ? op : om), e } function eV(e) { if (null !== e && "object" == typeof e) { if ("function" == typeof e.then) return eH(e); if (e.$$typeof === r8) return iu(e) } throw Error(s(438, String(e))) } function eW(e) { var t = null, i = oi.updateQueue; if (null !== i && (t = i.memoCache), null == t) { var r = oi.alternate; null !== r && null !== (r = r.updateQueue) && null != (r = r.memoCache) && (t = { data: r.data.map(function (e) { return e.slice() }), index: 0 }) } if (null == t && (t = { data: [], index: 0 }), null === i && (i = od(), oi.updateQueue = i), i.memoCache = t, void 0 === (i = t.data[t.index])) for (i = t.data[t.index] = Array(e), r = 0; r < e; r++)i[r] = ns; return t.index++, i } function ej(e, t) { return "function" == typeof t ? t(e) : t } function eY(e) { return eX(eG(), or, e) } function eX(e, t, i) { var r = e.queue; if (null === r) throw Error(s(311)); r.lastRenderedReducer = i; var n = e.baseQueue, a = r.pending; if (null !== a) { if (null !== n) { var o = n.next; n.next = a.next, a.next = o } t.baseQueue = n = a, r.pending = null } if (a = e.baseState, null === n) e.memoizedState = a; else { t = n.next; var l = o = null, u = null, h = t, c = !1; do { var d = -0x20000001 & h.lane; if (d !== h.lane ? (o$ & d) === d : (ot & d) === d) { var f = h.revertLane; if (0 === f) null !== u && (u = u.next = { lane: 0, revertLane: 0, action: h.action, hasEagerState: h.hasEagerState, eagerState: h.eagerState, next: null }), d === aX && (c = !0); else if ((ot & f) === f) { h = h.next, f === aX && (c = !0); continue } else d = { lane: 0, revertLane: h.revertLane, action: h.action, hasEagerState: h.hasEagerState, eagerState: h.eagerState, next: null }, null === u ? (l = u = d, o = a) : u = u.next = d, oi.lanes |= f, o8 |= f; d = h.action, oo && i(a, d), a = h.hasEagerState ? h.eagerState : i(a, d) } else f = { lane: d, revertLane: h.revertLane, action: h.action, hasEagerState: h.hasEagerState, eagerState: h.eagerState, next: null }, null === u ? (l = u = f, o = a) : u = u.next = f, oi.lanes |= d, o8 |= d; h = h.next } while (null !== h && h !== t); if (null === u ? o = a : u.next = l, !am(a, e.memoizedState) && (oS = !0, c && null !== (i = aK))) throw i; e.memoizedState = a, e.baseState = o, e.baseQueue = u, r.lastRenderedState = a } return null === n && (r.lanes = 0), [e.memoizedState, r.dispatch] } function eK(e) { var t = eG(), i = t.queue; if (null === i) throw Error(s(311)); i.lastRenderedReducer = e; var r = i.dispatch, n = i.pending, a = t.memoizedState; if (null !== n) { i.pending = null; var o = n = n.next; do a = e(a, o.action), o = o.next; while (o !== n); am(a, t.memoizedState) || (oS = !0), t.memoizedState = a, null === t.baseQueue && (t.baseState = a), i.lastRenderedState = a } return [a, r] } function eq(e, t, i) { var r = oi, n = eG(), a = aP; if (a) { if (void 0 === i) throw Error(s(407)); i = i() } else i = t(); var o = !am((or || n).memoizedState, i); if (o && (n.memoizedState = i, oS = !0), n = n.queue, th(e$.bind(null, r, n, e), [e]), n.getSnapshot !== t || o || null !== on && 1 & on.memoizedState.tag) { if (r.flags |= 2048, ts(9, eZ.bind(null, r, n, i, t), { destroy: void 0 }, null), null === oQ) throw Error(s(349)); a || 0 != (60 & ot) || eQ(r, t, i) } return i } function eQ(e, t, i) { e.flags |= 16384, e = { getSnapshot: t, value: i }, null === (t = oi.updateQueue) ? (t = od(), oi.updateQueue = t, t.stores = [e]) : null === (i = t.stores) ? t.stores = [e] : i.push(e) } function eZ(e, t, i, r) { t.value = i, t.getSnapshot = r, eJ(t) && e0(e) } function e$(e, t, i) { return i(function () { eJ(t) && e0(e) }) } function eJ(e) { var t = e.getSnapshot; e = e.value; try { var i = t(); return !am(e, i) } catch (e) { return !0 } } function e0(e) { var t = Y(e, 2); null !== t && rn(t, e, 2) } function e1(e) { var t = ez(); if ("function" == typeof e) { var i = e; if (e = i(), oo) { M(!0); try { i() } finally { M(!1) } } } return t.memoizedState = t.baseState = e, t.queue = { pending: null, lanes: 0, dispatch: null, lastRenderedReducer: ej, lastRenderedState: e }, t } function e2(e, t, i, r) { return e.baseState = i, eX(e, or, "function" == typeof r ? r : ej) } function e3(e, t, i, r, n) { if (tI(e)) throw Error(s(485)); if (null !== (e = t.action)) { var a = { payload: n, action: e, next: null, isTransition: !0, status: "pending", value: null, reason: null, listeners: [], then: function (e) { a.listeners.push(e) } }; null !== nl.T ? i(!0) : a.isTransition = !1, r(a), null === (i = t.pending) ? (a.next = t.pending = a, e4(t, a)) : (a.next = i.next, t.pending = i.next = a) } } function e4(e, t) { var i = t.action, r = t.payload, n = e.state; if (t.isTransition) { var s = nl.T, a = {}; nl.T = a; try { var o = i(n, r), l = nl.S; null !== l && l(a, o), e5(e, t, o) } catch (i) { e6(e, t, i) } finally { nl.T = s } } else try { s = i(n, r), e5(e, t, s) } catch (i) { e6(e, t, i) } } function e5(e, t, i) { null !== i && "object" == typeof i && "function" == typeof i.then ? i.then(function (i) { e8(e, t, i) }, function (i) { return e6(e, t, i) }) : e8(e, t, i) } function e8(e, t, i) { t.status = "fulfilled", t.value = i, e9(t), e.state = i, null !== (t = e.pending) && ((i = t.next) === t ? e.pending = null : (i = i.next, t.next = i, e4(e, i))) } function e6(e, t, i) { var r = e.pending; if (e.pending = null, null !== r) { r = r.next; do t.status = "rejected", t.reason = i, e9(t), t = t.next; while (t !== r) } e.action = null } function e9(e) { e = e.listeners; for (var t = 0; t < e.length; t++)(0, e[t])() } function e7(e, t) { return t } function te(e, t) { if (aP) { var i = oQ.formState; if (null !== i) { e: { var r = oi; if (aP) { if (aL) { var n = sy(aL, aO); if (n) { aL = sS(n), r = sx(n); break e } } U(r) } r = !1 } r && (t = i[0]) } } (i = ez()).memoizedState = i.baseState = t, r = { pending: null, lanes: 0, dispatch: null, lastRenderedReducer: e7, lastRenderedState: t }, i.queue = r, i = tM.bind(null, oi, r), r.dispatch = i, r = e1(!1); var s = tC.bind(null, oi, !1, r.queue); return r = ez(), n = { state: t, dispatch: null, action: e, pending: null }, r.queue = n, i = e3.bind(null, oi, n, s, i), n.dispatch = i, r.memoizedState = e, [t, i, !1] } function tt(e) { return ti(eG(), or, e) } function ti(e, t, i) { t = eX(e, t, e7)[0], e = eY(ej)[0], t = "object" == typeof t && null !== t && "function" == typeof t.then ? eH(t) : t; var r = eG(), n = r.queue, s = n.dispatch; return i !== r.memoizedState && (oi.flags |= 2048, ts(9, tr.bind(null, n, i), { destroy: void 0 }, null)), [t, s, e] } function tr(e, t) { e.action = t } function tn(e) { var t = eG(), i = or; if (null !== i) return ti(t, i, e); eG(), t = t.memoizedState; var r = (i = eG()).queue.dispatch; return i.memoizedState = e, [t, r, !1] } function ts(e, t, i, r) { return e = { tag: e, create: t, inst: i, deps: r, next: null }, null === (t = oi.updateQueue) && (t = od(), oi.updateQueue = t), null === (i = t.lastEffect) ? t.lastEffect = e.next = e : (r = i.next, i.next = e, e.next = r, t.lastEffect = e), e } function ta() { return eG().memoizedState } function to(e, t, i, r) { var n = ez(); oi.flags |= e, n.memoizedState = ts(1 | t, i, { destroy: void 0 }, void 0 === r ? null : r) } function tl(e, t, i, r) { var n = eG(); r = void 0 === r ? null : r; var s = n.memoizedState.inst; null !== or && null !== r && eP(r, or.memoizedState.deps) ? n.memoizedState = ts(t, i, s, r) : (oi.flags |= e, n.memoizedState = ts(1 | t, i, s, r)) } function tu(e, t) { to(8390656, 8, e, t) } function th(e, t) { tl(2048, 8, e, t) } function tc(e, t) { return tl(4, 2, e, t) } function td(e, t) { return tl(4, 4, e, t) } function tf(e, t) { if ("function" == typeof t) { var i = t(e = e()); return function () { "function" == typeof i ? i() : t(null) } } if (null != t) return e = e(), t.current = e, function () { t.current = null } } function tp(e, t, i) { i = null != i ? i.concat([e]) : null, tl(4, 4, tf.bind(null, t, e), i) } function tm() { } function tg(e, t) { var i = eG(); t = void 0 === t ? null : t; var r = i.memoizedState; return null !== t && eP(t, r[1]) ? r[0] : (i.memoizedState = [e, t], e) } function tv(e, t) { var i = eG(); t = void 0 === t ? null : t; var r = i.memoizedState; if (null !== t && eP(t, r[1])) return r[0]; if (r = e(), oo) { M(!0); try { e() } finally { M(!1) } } return i.memoizedState = [r, t], r } function ty(e, t, i) { return void 0 === i || 0 != (0x40000000 & ot) ? e.memoizedState = t : (e.memoizedState = i, e = rr(), oi.lanes |= e, o8 |= e, i) } function tx(e, t, i, r) { return am(i, t) ? i : null !== a8.current ? (am(e = ty(e, i, r), t) || (oS = !0), e) : 0 == (42 & ot) ? (oS = !0, e.memoizedState = i) : (e = rr(), oi.lanes |= e, o8 |= e, t) } function tS(e, t, i, r, n) { var s = nO(); nD(0 !== s && 8 > s ? s : 8); var a = nl.T, o = {}; nl.T = o, tC(e, !1, t, i); try { var l = n(), u = nl.S; if (null !== u && u(o, l), null !== l && "object" == typeof l && "function" == typeof l.then) { var h, c, d = (h = [], c = { status: "pending", value: null, reason: null, then: function (e) { h.push(e) } }, l.then(function () { c.status = "fulfilled", c.value = r; for (var e = 0; e < h.length; e++)(0, h[e])(r) }, function (e) { for (c.status = "rejected", c.reason = e, e = 0; e < h.length; e++)(0, h[e])(void 0) }), c); tR(e, t, d, ri(e)) } else tR(e, t, r, ri(e)) } catch (i) { tR(e, t, { then: function () { }, status: "rejected", reason: i }, ri()) } finally { nD(s), nl.T = a } } function tA(e) { var t = e.memoizedState; if (null !== t) return t; var i = {}; return (t = { memoizedState: nV, baseState: nV, baseQueue: null, queue: { pending: null, lanes: 0, dispatch: null, lastRenderedReducer: ej, lastRenderedState: nV }, next: null }).next = { memoizedState: i, baseState: i, baseQueue: null, queue: { pending: null, lanes: 0, dispatch: null, lastRenderedReducer: ej, lastRenderedState: i }, next: null }, e.memoizedState = t, null !== (e = e.alternate) && (e.memoizedState = t), t } function t_() { return iu(nW) } function tE() { return eG().memoizedState } function tb() { return eG().memoizedState } function tT(e) { for (var t = e.return; null !== t;) { switch (t.tag) { case 24: case 3: var i = ri(), r = ea(t, e = es(i), i); null !== r && (rn(r, t, i), eo(r, t, i)), t = { cache: id() }, e.payload = t; return }t = t.return } } function tw(e, t, i) { var r = ri(); i = { lane: r, revertLane: 0, action: i, hasEagerState: !1, eagerState: null, next: null }, tI(e) ? tL(t, i) : null !== (i = j(e, t, i, r)) && (rn(i, e, r), tP(i, t, r)) } function tM(e, t, i) { tR(e, t, i, ri()) } function tR(e, t, i, r) { var n = { lane: r, revertLane: 0, action: i, hasEagerState: !1, eagerState: null, next: null }; if (tI(e)) tL(t, n); else { var s = e.alternate; if (0 === e.lanes && (null === s || 0 === s.lanes) && null !== (s = t.lastRenderedReducer)) try { var a = t.lastRenderedState, o = s(a, i); if (n.hasEagerState = !0, n.eagerState = o, am(o, a)) return W(e, t, n, 0), null === oQ && V(), !1 } catch (e) { } finally { } if (null !== (i = j(e, t, n, r))) return rn(i, e, r), tP(i, t, r), !0 } return !1 } function tC(e, t, i, r) { if (r = { lane: 2, revertLane: et(), action: r, hasEagerState: !1, eagerState: null, next: null }, tI(e)) { if (t) throw Error(s(479)) } else null !== (t = j(e, i, r, 2)) && rn(t, e, 2) } function tI(e) { var t = e.alternate; return e === oi || null !== t && t === oi } function tL(e, t) { oa = os = !0; var i = e.pending; null === i ? t.next = t : (t.next = i.next, i.next = t), e.pending = t } function tP(e, t, i) { if (0 != (4194176 & i)) { var r = t.lanes; r &= e.pendingLanes, i |= r, t.lanes = i, T(e, i) } } function tD(e, t, i, r) { i = null == (i = i(r, t = e.memoizedState)) ? t : rZ({}, t, i), e.memoizedState = i, 0 === e.lanes && (e.updateQueue.baseState = i) } function tO(e, t, i, r, n, s, a) { return "function" == typeof (e = e.stateNode).shouldComponentUpdate ? e.shouldComponentUpdate(r, s, a) : !t.prototype || !t.prototype.isPureReactComponent || !ef(i, r) || !ef(n, s) } function tk(e, t, i, r) { e = t.state, "function" == typeof t.componentWillReceiveProps && t.componentWillReceiveProps(i, r), "function" == typeof t.UNSAFE_componentWillReceiveProps && t.UNSAFE_componentWillReceiveProps(i, r), t.state !== e && ov.enqueueReplaceState(t, t.state, null) } function tF(e, t) { var i = t; if ("ref" in t) for (var r in i = {}, t) "ref" !== r && (i[r] = t[r]); if (e = e.defaultProps) for (var n in i === t && (i = rZ({}, i)), e) void 0 === i[n] && (i[n] = e[n]); return i } function tU(e, t) { try { (0, e.onUncaughtError)(t.value, { componentStack: t.stack }) } catch (e) { setTimeout(function () { throw e }) } } function tN(e, t, i) { try { (0, e.onCaughtError)(i.value, { componentStack: i.stack, errorBoundary: 1 === t.tag ? t.stateNode : null }) } catch (e) { setTimeout(function () { throw e }) } } function tB(e, t, i) { return (i = es(i)).tag = 3, i.payload = { element: null }, i.callback = function () { tU(e, t) }, i } function tz(e) { return (e = es(e)).tag = 3, e } function tG(e, t, i, r) { var n = i.type.getDerivedStateFromError; if ("function" == typeof n) { var s = r.value; e.payload = function () { return n(s) }, e.callback = function () { tN(t, i, r) } } var a = i.stateNode; null !== a && "function" == typeof a.componentDidCatch && (e.callback = function () { tN(t, i, r), "function" != typeof n && (null === lo ? lo = new Set([this]) : lo.add(this)); var e = r.stack; this.componentDidCatch(r.value, { componentStack: null !== e ? e : "" }) }) } function tH(e, t, i, r) { t.child = null === e ? a5(t, null, i, r) : a4(t, e.child, i, r) } function tV(e, t, i, r, n) { i = i.render; var s = t.ref; if ("ref" in r) { var a = {}; for (var o in r) "ref" !== o && (a[o] = r[o]) } else a = r; return (il(t), r = eD(e, t, i, a, s, n), o = eU(), null === e || oS) ? (aP && o && L(t), t.flags |= 1, tH(e, t, r, n), t.child) : (eN(e, t, n), t9(e, t, n)) } function tW(e, t, i, r, n) { if (null === e) { var s = i.type; return "function" != typeof s || rO(s) || void 0 !== s.defaultProps || null !== i.compare ? ((e = rU(i.type, null, r, t, t.mode, n)).ref = t.ref, e.return = t, t.child = e) : (t.tag = 15, t.type = s, tj(e, t, s, r, n)) } if (s = e.child, !t7(e, n)) { var a = s.memoizedProps; if ((i = null !== (i = i.compare) ? i : ef)(a, r) && e.ref === t.ref) return t9(e, t, n) } return t.flags |= 1, (e = rk(s, r)).ref = t.ref, e.return = t, t.child = e } function tj(e, t, i, r, n) { if (null !== e) { var s = e.memoizedProps; if (ef(s, r) && e.ref === t.ref) { if (oS = !1, t.pendingProps = r = s, !t7(e, n)) return t.lanes = e.lanes, t9(e, t, n); 0 != (131072 & e.flags) && (oS = !0) } } return tq(e, t, i, r, n) } function tY(e, t, i) { var r = t.pendingProps, n = r.children, s = 0 != (2 & t.stateNode._pendingVisibility), a = null !== e ? e.memoizedState : null; if (tK(e, t), "hidden" === r.mode || s) { if (0 != (128 & t.flags)) { if (r = null !== a ? a.baseLanes | i : i, null !== e) { for (s = 0, n = t.child = e.child; null !== n;)s = s | n.lanes | n.childLanes, n = n.sibling; t.childLanes = s & ~r } else t.childLanes = 0, t.child = null; return tX(e, t, r, i) } if (0 == (0x20000000 & i)) return t.lanes = t.childLanes = 0x20000000, tX(e, t, null !== a ? a.baseLanes | i : i, i); t.memoizedState = { baseLanes: 0, cachePool: null }, null !== e && ig(t, null !== a ? a.cachePool : null), null !== a ? eE(t, a) : eb(), eM(t) } else null !== a ? (ig(t, a.cachePool), eE(t, a), eR(t), t.memoizedState = null) : (null !== e && ig(t, null), eb(), eR(t)); return tH(e, t, n, i), t.child } function tX(e, t, i, r) { var n = im(); return n = null === n ? null : { parent: nM ? oR._currentValue : oR._currentValue2, pool: n }, t.memoizedState = { baseLanes: i, cachePool: n }, null !== e && ig(t, null), eb(), eM(t), null !== e && ia(e, t, r, !0), null } function tK(e, t) { var i = t.ref; if (null === i) null !== e && null !== e.ref && (t.flags |= 2097664); else { if ("function" != typeof i && "object" != typeof i) throw Error(s(284)); (null === e || e.ref !== i) && (t.flags |= 2097664) } } function tq(e, t, i, r, n) { return (il(t), i = eD(e, t, i, r, void 0, n), r = eU(), null === e || oS) ? (aP && r && L(t), t.flags |= 1, tH(e, t, i, n), t.child) : (eN(e, t, n), t9(e, t, n)) } function tQ(e, t, i, r, n, s) { return (il(t), t.updateQueue = null, i = ek(t, r, i, n), eO(e), r = eU(), null === e || oS) ? (aP && r && L(t), t.flags |= 1, tH(e, t, i, s), t.child) : (eN(e, t, s), t9(e, t, s)) } function tZ(e, t, i, r, n) { if (il(t), null === t.stateNode) { var s = s8, a = i.contextType; "object" == typeof a && null !== a && (s = iu(a)), s = new i(r, s), t.memoizedState = null !== s.state && void 0 !== s.state ? s.state : null, s.updater = ov, t.stateNode = s, s._reactInternals = t, (s = t.stateNode).props = r, s.state = t.memoizedState, s.refs = {}, er(t), a = i.contextType, s.context = "object" == typeof a && null !== a ? iu(a) : s8, s.state = t.memoizedState, "function" == typeof (a = i.getDerivedStateFromProps) && (tD(t, i, a, r), s.state = t.memoizedState), "function" == typeof i.getDerivedStateFromProps || "function" == typeof s.getSnapshotBeforeUpdate || "function" != typeof s.UNSAFE_componentWillMount && "function" != typeof s.componentWillMount || (a = s.state, "function" == typeof s.componentWillMount && s.componentWillMount(), "function" == typeof s.UNSAFE_componentWillMount && s.UNSAFE_componentWillMount(), a !== s.state && ov.enqueueReplaceState(s, s.state, null), eh(t, r, s, n), eu(), s.state = t.memoizedState), "function" == typeof s.componentDidMount && (t.flags |= 4194308), r = !0 } else if (null === e) { s = t.stateNode; var o = t.memoizedProps, l = tF(i, o); s.props = l; var u = s.context, h = i.contextType; a = s8, "object" == typeof h && null !== h && (a = iu(h)); var c = i.getDerivedStateFromProps; h = "function" == typeof c || "function" == typeof s.getSnapshotBeforeUpdate, o = t.pendingProps !== o, h || "function" != typeof s.UNSAFE_componentWillReceiveProps && "function" != typeof s.componentWillReceiveProps || (o || u !== a) && tk(t, s, r, a), aq = !1; var d = t.memoizedState; s.state = d, eh(t, r, s, n), eu(), u = t.memoizedState, o || d !== u || aq ? ("function" == typeof c && (tD(t, i, c, r), u = t.memoizedState), (l = aq || tO(t, i, l, r, d, u, a)) ? (h || "function" != typeof s.UNSAFE_componentWillMount && "function" != typeof s.componentWillMount || ("function" == typeof s.componentWillMount && s.componentWillMount(), "function" == typeof s.UNSAFE_componentWillMount && s.UNSAFE_componentWillMount()), "function" == typeof s.componentDidMount && (t.flags |= 4194308)) : ("function" == typeof s.componentDidMount && (t.flags |= 4194308), t.memoizedProps = r, t.memoizedState = u), s.props = r, s.state = u, s.context = a, r = l) : ("function" == typeof s.componentDidMount && (t.flags |= 4194308), r = !1) } else { s = t.stateNode, en(e, t), h = tF(i, a = t.memoizedProps), s.props = h, c = t.pendingProps, d = s.context, u = i.contextType, l = s8, "object" == typeof u && null !== u && (l = iu(u)), (u = "function" == typeof (o = i.getDerivedStateFromProps) || "function" == typeof s.getSnapshotBeforeUpdate) || "function" != typeof s.UNSAFE_componentWillReceiveProps && "function" != typeof s.componentWillReceiveProps || (a !== c || d !== l) && tk(t, s, r, l), aq = !1, d = t.memoizedState, s.state = d, eh(t, r, s, n), eu(); var f = t.memoizedState; a !== c || d !== f || aq || null !== e && null !== e.dependencies && io(e.dependencies) ? ("function" == typeof o && (tD(t, i, o, r), f = t.memoizedState), (h = aq || tO(t, i, h, r, d, f, l) || null !== e && null !== e.dependencies && io(e.dependencies)) ? (u || "function" != typeof s.UNSAFE_componentWillUpdate && "function" != typeof s.componentWillUpdate || ("function" == typeof s.componentWillUpdate && s.componentWillUpdate(r, f, l), "function" == typeof s.UNSAFE_componentWillUpdate && s.UNSAFE_componentWillUpdate(r, f, l)), "function" == typeof s.componentDidUpdate && (t.flags |= 4), "function" == typeof s.getSnapshotBeforeUpdate && (t.flags |= 1024)) : ("function" != typeof s.componentDidUpdate || a === e.memoizedProps && d === e.memoizedState || (t.flags |= 4), "function" != typeof s.getSnapshotBeforeUpdate || a === e.memoizedProps && d === e.memoizedState || (t.flags |= 1024), t.memoizedProps = r, t.memoizedState = f), s.props = r, s.state = f, s.context = l, r = h) : ("function" != typeof s.componentDidUpdate || a === e.memoizedProps && d === e.memoizedState || (t.flags |= 4), "function" != typeof s.getSnapshotBeforeUpdate || a === e.memoizedProps && d === e.memoizedState || (t.flags |= 1024), r = !1) } return s = r, tK(e, t), r = 0 != (128 & t.flags), s || r ? (s = t.stateNode, i = r && "function" != typeof i.getDerivedStateFromError ? null : s.render(), t.flags |= 1, null !== e && r ? (t.child = a4(t, e.child, null, n), t.child = a4(t, null, i, n)) : tH(e, t, i, n), t.memoizedState = s.state, e = t.child) : e = t9(e, t, n), e } function t$(e, t, i, r) { return G(), t.flags |= 256, tH(e, t, i, r), t.child } function tJ(e) { return { baseLanes: e, cachePool: iv() } } function t0(e, t, i) { return e = null !== e ? e.childLanes & ~i : 0, t && (e |= o7), e } function t1(e, i, r) { var n, a = i.pendingProps, o = !1, l = 0 != (128 & i.flags); if ((n = l) || (n = (null === e || null !== e.memoizedState) && 0 != (2 & oe.current)), n && (o = !0, i.flags &= -129), n = 0 != (32 & i.flags), i.flags &= -33, null === e) { if (aP) { if (o ? ew(i) : eR(i), aP) { var u, h = aL; (u = h) && (null !== (h = sw(h, aO)) ? (i.memoizedState = { dehydrated: h, treeContext: null !== aE ? { id: ab, overflow: aT } : null, retryLane: 0x20000000 }, (u = t(18, null, null, 0)).stateNode = h, u.return = i, i.child = u, aI = i, aL = null, u = !0) : u = !1), u || U(i) } if (null !== (h = i.memoizedState) && null !== (h = h.dehydrated)) return sm(h) ? i.lanes = 16 : i.lanes = 0x20000000, null; eC(i) } return (h = a.children, a = a.fallback, o) ? (eR(i), h = t3({ mode: "hidden", children: h }, o = i.mode), a = rN(a, o, r, null), h.return = i, a.return = i, h.sibling = a, i.child = h, (o = i.child).memoizedState = tJ(r), o.childLanes = t0(e, n, r), i.memoizedState = oA, a) : (ew(i), t2(i, h)) } if (null !== (u = e.memoizedState) && null !== (h = u.dehydrated)) { if (l) 256 & i.flags ? (ew(i), i.flags &= -257, i = t4(e, i, r)) : null !== i.memoizedState ? (eR(i), i.child = e.child, i.flags |= 128, i = null) : (eR(i), o = a.fallback, h = i.mode, a = t3({ mode: "visible", children: a.children }, h), o = rN(o, h, r, null), o.flags |= 2, a.return = i, o.return = i, a.sibling = o, i.child = a, a4(i, e.child, null, r), (a = i.child).memoizedState = tJ(r), a.childLanes = t0(e, n, r), i.memoizedState = oA, i = o); else if (ew(i), sm(h)) n = sg(h).digest, (a = Error(s(419))).stack = "", a.digest = n, H({ value: a, source: null, stack: null }), i = t4(e, i, r); else if (oS || ia(e, i, r, !1), n = 0 != (r & e.childLanes), oS || n) { if (null !== (n = oQ)) { if (0 != (42 & (a = r & -r))) a = 1; else switch (a) { case 2: a = 1; break; case 8: a = 4; break; case 32: a = 16; break; case 128: case 256: case 512: case 1024: case 2048: case 4096: case 8192: case 16384: case 32768: case 65536: case 131072: case 262144: case 524288: case 1048576: case 2097152: case 4194304: case 8388608: case 0x1000000: case 0x2000000: a = 64; break; case 0x10000000: a = 0x8000000; break; default: a = 0 }if (0 !== (a = 0 != (a & (n.suspendedLanes | r)) ? 0 : a) && a !== u.retryLane) throw u.retryLane = a, Y(e, a), rn(n, e, a), ox } sp(h) || rg(), i = t4(e, i, r) } else sp(h) ? (i.flags |= 128, i.child = e.child, sv(h, i = rL.bind(null, e)), i = null) : (e = u.treeContext, nI && (aL = sE(h), aI = i, aP = !0, aD = null, aO = !1, null !== e && (aA[a_++] = ab, aA[a_++] = aT, aA[a_++] = aE, ab = e.id, aT = e.overflow, aE = i)), i = t2(i, a.children), i.flags |= 4096); return i } return o ? (eR(i), o = a.fallback, h = i.mode, l = (u = e.child).sibling, (a = rk(u, { mode: "hidden", children: a.children })).subtreeFlags = 0x1e00000 & u.subtreeFlags, null !== l ? o = rk(l, o) : (o = rN(o, h, r, null), o.flags |= 2), o.return = i, a.return = i, a.sibling = o, i.child = a, a = o, o = i.child, null === (h = e.child.memoizedState) ? h = tJ(r) : (null !== (u = h.cachePool) ? (l = nM ? oR._currentValue : oR._currentValue2, u = u.parent !== l ? { parent: l, pool: l } : u) : u = iv(), h = { baseLanes: h.baseLanes | r, cachePool: u }), o.memoizedState = h, o.childLanes = t0(e, n, r), i.memoizedState = oA, a) : (ew(i), e = (r = e.child).sibling, (r = rk(r, { mode: "visible", children: a.children })).return = i, r.sibling = null, null !== e && (null === (n = i.deletions) ? (i.deletions = [e], i.flags |= 16) : n.push(e)), i.child = r, i.memoizedState = null, r) } function t2(e, t) { return (t = t3({ mode: "visible", children: t }, e.mode)).return = e, e.child = t } function t3(e, t) { return rB(e, t, 0, null) } function t4(e, t, i) { return a4(t, e.child, null, i), e = t2(t, t.pendingProps.children), e.flags |= 2, t.memoizedState = null, e } function t5(e, t, i) { e.lanes |= t; var r = e.alternate; null !== r && (r.lanes |= t), ir(e.return, t, i) } function t8(e, t, i, r, n) { var s = e.memoizedState; null === s ? e.memoizedState = { isBackwards: t, rendering: null, renderingStartTime: 0, last: r, tail: i, tailMode: n } : (s.isBackwards = t, s.rendering = null, s.renderingStartTime = 0, s.last = r, s.tail = i, s.tailMode = n) } function t6(e, t, i) { var r = t.pendingProps, n = r.revealOrder, s = r.tail; if (tH(e, t, r.children, i), 0 != (2 & (r = oe.current))) r = 1 & r | 2, t.flags |= 128; else { if (null !== e && 0 != (128 & e.flags)) e: for (e = t.child; null !== e;) { if (13 === e.tag) null !== e.memoizedState && t5(e, i, t); else if (19 === e.tag) t5(e, i, t); else if (null !== e.child) { e.child.return = e, e = e.child; continue } if (e === t) break; for (; null === e.sibling;) { if (null === e.return || e.return === t) break e; e = e.return } e.sibling.return = e.return, e = e.sibling } r &= 1 } switch (g(oe, r), n) { case "forwards": for (n = null, i = t.child; null !== i;)null !== (e = i.alternate) && null === eI(e) && (n = i), i = i.sibling; null === (i = n) ? (n = t.child, t.child = null) : (n = i.sibling, i.sibling = null), t8(t, !1, n, i, s); break; case "backwards": for (i = null, n = t.child, t.child = null; null !== n;) { if (null !== (e = n.alternate) && null === eI(e)) { t.child = n; break } e = n.sibling, n.sibling = i, i = n, n = e } t8(t, !0, i, null, s); break; case "together": t8(t, !1, null, null, void 0); break; default: t.memoizedState = null }return t.child } function t9(e, t, i) { if (null !== e && (t.dependencies = e.dependencies), o8 |= t.lanes, 0 == (i & t.childLanes) && (null === e || (ia(e, t, i, !1), 0 == (i & t.childLanes)))) return null; if (null !== e && t.child !== e.child) throw Error(s(153)); if (null !== t.child) { for (i = rk(e = t.child, e.pendingProps), t.child = i, i.return = t; null !== e.sibling;)e = e.sibling, (i = i.sibling = rk(e, e.pendingProps)).return = t; i.sibling = null } return t.child } function t7(e, t) { return 0 != (e.lanes & t) || !!(null !== (e = e.dependencies) && io(e)) } function ie(e, t, i) { if (null !== e) { if (e.memoizedProps !== t.pendingProps) oS = !0; else { if (!t7(e, i) && 0 == (128 & t.flags)) return oS = !1, function (e, t, i) { switch (t.tag) { case 3: D(t, t.stateNode.containerInfo), it(t, oR, e.memoizedState.cache), G(); break; case 27: case 5: k(t); break; case 4: D(t, t.stateNode.containerInfo); break; case 10: it(t, t.type, t.memoizedProps.value); break; case 13: var r = t.memoizedState; if (null !== r) { if (null !== r.dehydrated) return ew(t), t.flags |= 128, null; if (0 != (i & t.child.childLanes)) return t1(e, t, i); return ew(t), null !== (e = t9(e, t, i)) ? e.sibling : null } ew(t); break; case 19: var n = 0 != (128 & e.flags); if ((r = 0 != (i & t.childLanes)) || (ia(e, t, i, !1), r = 0 != (i & t.childLanes)), n) { if (r) return t6(e, t, i); t.flags |= 128 } if (null !== (n = t.memoizedState) && (n.rendering = null, n.tail = null, n.lastEffect = null), g(oe, oe.current), !r) return null; break; case 22: case 23: return t.lanes = 0, tY(e, t, i); case 24: it(t, oR, e.memoizedState.cache) }return t9(e, t, i) }(e, t, i); oS = 0 != (131072 & e.flags) } } else oS = !1, aP && 0 != (1048576 & t.flags) && I(t, aS, t.index); switch (t.lanes = 0, t.tag) { case 16: e: { e = t.pendingProps; var r = t.elementType, n = r._init; if (r = n(r._payload), t.type = r, "function" == typeof r) rO(r) ? (e = tF(r, e), t.tag = 1, t = tZ(null, t, r, e, i)) : (t.tag = 0, t = tq(null, t, r, e, i)); else { if (null != r) { if ((n = r.$$typeof) === r6) { t.tag = 11, t = tV(null, t, r, e, i); break e } if (n === ne) { t.tag = 14, t = tW(null, t, r, e, i); break e } } throw Error(s(306, t = o(r) || r, "")) } } return t; case 0: return tq(e, t, t.type, t.pendingProps, i); case 1: return n = tF(r = t.type, t.pendingProps), tZ(e, t, r, n, i); case 3: e: { if (D(t, t.stateNode.containerInfo), null === e) throw Error(s(387)); var a = t.pendingProps; r = (n = t.memoizedState).element, en(e, t), eh(t, a, null, i); var l = t.memoizedState; if (it(t, oR, a = l.cache), a !== n.cache && is(t, [oR], i, !0), eu(), a = l.element, nI && n.isDehydrated) { if (n = { element: a, isDehydrated: !1, cache: l.cache }, t.updateQueue.baseState = n, t.memoizedState = n, 256 & t.flags) { t = t$(e, t, a, i); break e } if (a !== r) { H(r = R(Error(s(424)), t)), t = t$(e, t, a, i); break e } for (nI && (aL = s_(t.stateNode.containerInfo), aI = t, aP = !0, aD = null, aO = !0), i = a5(t, null, a, i), t.child = i; i;)i.flags = -3 & i.flags | 4096, i = i.sibling } else { if (G(), a === r) { t = t9(e, t, i); break e } tH(e, t, a, i) } t = t.child } return t; case 26: if (sN) return tK(e, t), null === e ? (i = sG(t.type, null, t.pendingProps, null)) ? t.memoizedState = i : aP || (t.stateNode = sX(t.type, t.pendingProps, aR.current, t)) : t.memoizedState = sG(t.type, e.memoizedProps, t.pendingProps, e.memoizedState), null; case 27: if (s$) return k(t), null === e && s$ && aP && (r = t.stateNode = sJ(t.type, t.pendingProps, aR.current, aw.current, !1), aI = t, aO = !0, aL = sA(r)), r = t.pendingProps.children, null !== e || aP ? tH(e, t, r, i) : t.child = a4(t, null, r, i), tK(e, t), t.child; case 5: return null === e && aP && (sF(t.type, t.pendingProps, aw.current), (n = r = aL) && (null !== (r = sb(r, t.type, t.pendingProps, aO)) ? (t.stateNode = r, aI = t, aL = sA(r), aO = !1, n = !0) : n = !1), n || U(t)), k(t), n = t.type, a = t.pendingProps, l = null !== e ? e.memoizedProps : null, r = a.children, n_(n, a) ? r = null : null !== l && n_(n, l) && (t.flags |= 32), null !== t.memoizedState && (n = eD(e, t, eF, null, null, i), nM ? nW._currentValue = n : nW._currentValue2 = n), tK(e, t), tH(e, t, r, i), t.child; case 6: return null === e && aP && (sU(t.pendingProps, aw.current), (e = i = aL) && (null !== (i = sT(i, t.pendingProps, aO)) ? (t.stateNode = i, aI = t, aL = null, e = !0) : e = !1), e || U(t)), null; case 13: return t1(e, t, i); case 4: return D(t, t.stateNode.containerInfo), r = t.pendingProps, null === e ? t.child = a4(t, null, r, i) : tH(e, t, r, i), t.child; case 11: return tV(e, t, t.type, t.pendingProps, i); case 7: return tH(e, t, t.pendingProps, i), t.child; case 8: case 12: return tH(e, t, t.pendingProps.children, i), t.child; case 10: return r = t.pendingProps, it(t, t.type, r.value), tH(e, t, r.children, i), t.child; case 9: return n = t.type._context, r = t.pendingProps.children, il(t), r = r(n = iu(n)), t.flags |= 1, tH(e, t, r, i), t.child; case 14: return tW(e, t, t.type, t.pendingProps, i); case 15: return tj(e, t, t.type, t.pendingProps, i); case 19: return t6(e, t, i); case 22: return tY(e, t, i); case 24: return il(t), r = iu(oR), null === e ? (null === (n = im()) && (n = oQ, a = id(), n.pooledCache = a, a.refCount++, null !== a && (n.pooledCacheLanes |= i), n = a), t.memoizedState = { parent: r, cache: n }, er(t), it(t, oR, n)) : (0 != (e.lanes & i) && (en(e, t), eh(t, null, null, i), eu()), n = e.memoizedState, a = t.memoizedState, n.parent !== r ? (n = { parent: r, cache: r }, t.memoizedState = n, 0 === t.lanes && (t.memoizedState = t.updateQueue.baseState = n), it(t, oR, r)) : (it(t, oR, r = a.cache), r !== n.cache && is(t, [oR], i, !0))), tH(e, t, t.pendingProps.children, i), t.child; case 29: throw t.pendingProps }throw Error(s(156, t.tag)) } function it(e, t, i) { nM ? (g(o_, t._currentValue), t._currentValue = i) : (g(o_, t._currentValue2), t._currentValue2 = i) } function ii(e) { var t = o_.current; nM ? e._currentValue = t : e._currentValue2 = t, m(o_) } function ir(e, t, i) { for (; null !== e;) { var r = e.alternate; if ((e.childLanes & t) !== t ? (e.childLanes |= t, null !== r && (r.childLanes |= t)) : null !== r && (r.childLanes & t) !== t && (r.childLanes |= t), e === i) break; e = e.return } } function is(e, t, i, r) { var n = e.child; for (null !== n && (n.return = e); null !== n;) { var a = n.dependencies; if (null !== a) { var o = n.child; a = a.firstContext; e: for (; null !== a;) { var l = a; a = n; for (var u = 0; u < t.length; u++)if (l.context === t[u]) { a.lanes |= i, null !== (l = a.alternate) && (l.lanes |= i), ir(a.return, i, e), r || (o = null); break e } a = l.next } } else if (18 === n.tag) { if (null === (o = n.return)) throw Error(s(341)); o.lanes |= i, null !== (a = o.alternate) && (a.lanes |= i), ir(o, i, e), o = null } else o = n.child; if (null !== o) o.return = n; else for (o = n; null !== o;) { if (o === e) { o = null; break } if (null !== (n = o.sibling)) { n.return = o.return, o = n; break } o = o.return } n = o } } function ia(e, t, i, r) { e = null; for (var n = t, a = !1; null !== n;) { if (!a) { if (0 != (524288 & n.flags)) a = !0; else if (0 != (262144 & n.flags)) break } if (10 === n.tag) { var o = n.alternate; if (null === o) throw Error(s(387)); if (null !== (o = o.memoizedProps)) { var l = n.type; am(n.pendingProps.value, o.value) || (null !== e ? e.push(l) : e = [l]) } } else if (n === aC.current) { if (null === (o = n.alternate)) throw Error(s(387)); o.memoizedState.memoizedState !== n.memoizedState.memoizedState && (null !== e ? e.push(nW) : e = [nW]) } n = n.return } null !== e && is(t, e, i, r), t.flags |= 262144 } function io(e) { for (e = e.firstContext; null !== e;) { var t = e.context; if (!am(nM ? t._currentValue : t._currentValue2, e.memoizedValue)) return !0; e = e.next } return !1 } function il(e) { oE = e, ob = null, null !== (e = e.dependencies) && (e.firstContext = null) } function iu(e) { return ic(oE, e) } function ih(e, t) { return null === oE && il(e), ic(e, t) } function ic(e, t) { var i = nM ? t._currentValue : t._currentValue2; if (t = { context: t, memoizedValue: i, next: null }, null === ob) { if (null === e) throw Error(s(308)); ob = t, e.dependencies = { lanes: 0, firstContext: t }, e.flags |= 524288 } else ob = ob.next = t; return i } function id() { return { controller: new oT, data: new Map, refCount: 0 } } function ip(e) { e.refCount--, 0 === e.refCount && ow(oM, function () { e.controller.abort() }) } function im() { var e = oI.current; return null !== e ? e : oQ.pooledCache } function ig(e, t) { null === t ? g(oI, oI.current) : g(oI, t.pool) } function iv() { var e = im(); return null === e ? null : { parent: nM ? oR._currentValue : oR._currentValue2, pool: e } } function iy(e) { e.flags |= 4 } function ix(e, t) { if (null !== e && e.child === t.child) return !1; if (0 != (16 & t.flags)) return !0; for (e = t.child; null !== e;) { if (0 != (13878 & e.flags) || 0 != (13878 & e.subtreeFlags)) return !0; e = e.sibling } return !1 } function iS(e, t, i, r) { if (nR) for (i = t.child; null !== i;) { if (5 === i.tag || 6 === i.tag) nS(e, i.stateNode); else if (!(4 === i.tag || s$ && 27 === i.tag) && null !== i.child) { i.child.return = i, i = i.child; continue } if (i === t) break; for (; null === i.sibling;) { if (null === i.return || i.return === t) return; i = i.return } i.sibling.return = i.return, i = i.sibling } else if (nC) for (var n = t.child; null !== n;) { if (5 === n.tag) { var s = n.stateNode; i && r && (s = sd(s, n.type, n.memoizedProps)), nS(e, s) } else if (6 === n.tag) s = n.stateNode, i && r && (s = sf(s, n.memoizedProps)), nS(e, s); else if (4 !== n.tag) { if (22 === n.tag && null !== n.memoizedState) null !== (s = n.child) && (s.return = n), iS(e, n, !0, !0); else if (null !== n.child) { n.child.return = n, n = n.child; continue } } if (n === t) break; for (; null === n.sibling;) { if (null === n.return || n.return === t) return; n = n.return } n.sibling.return = n.return, n = n.sibling } } function iA(e, t) { if (nC && ix(e, t)) { var i = (e = t.stateNode).containerInfo, r = sl(); (function e(t, i, r, n) { if (nC) for (var s = i.child; null !== s;) { if (5 === s.tag) { var a = s.stateNode; r && n && (a = sd(a, s.type, s.memoizedProps)), su(t, a) } else if (6 === s.tag) a = s.stateNode, r && n && (a = sf(a, s.memoizedProps)), su(t, a); else if (4 !== s.tag) { if (22 === s.tag && null !== s.memoizedState) null !== (a = s.child) && (a.return = s), e(t, s, !(null !== s.memoizedProps && "manual" === s.memoizedProps.mode), !0); else if (null !== s.child) { s.child.return = s, s = s.child; continue } } if (s === i) break; for (; null === s.sibling;) { if (null === s.return || s.return === i) return; s = s.return } s.sibling.return = s.return, s = s.sibling } })(r, t, !1, !1), e.pendingChildren = r, iy(t), sh(i, r) } } function i_(e, t, i, r) { if (nR) e.memoizedProps !== r && iy(t); else if (nC) { var n = e.stateNode, s = e.memoizedProps; if ((e = ix(e, t)) || s !== r) { var a = aw.current; (s = so(n, i, s, r, !e, null)) === n ? t.stateNode = n : (nA(s, i, r, a) && iy(t), t.stateNode = s, e ? iS(s, t, !1, !1) : iy(t)) } else t.stateNode = n } } function iE(e, t, i) { if (nN(t, i)) { if (e.flags |= 0x1000000, !nB(t, i)) { if (rf()) e.flags |= 8192; else throw a1 = a0, aJ } } else e.flags &= -0x1000001 } function ib(e, t) { if (sq(t)) { if (e.flags |= 0x1000000, !sQ(t)) { if (rf()) e.flags |= 8192; else throw a1 = a0, aJ } } else e.flags &= -0x1000001 } function iT(e, t) { null !== t && (e.flags |= 4), 16384 & e.flags && (t = 22 !== e.tag ? A() : 0x20000000, e.lanes |= t, le |= t) } function iw(e, t) { if (!aP) switch (e.tailMode) { case "hidden": t = e.tail; for (var i = null; null !== t;)null !== t.alternate && (i = t), t = t.sibling; null === i ? e.tail = null : i.sibling = null; break; case "collapsed": i = e.tail; for (var r = null; null !== i;)null !== i.alternate && (r = i), i = i.sibling; null === r ? t || null === e.tail ? e.tail = null : e.tail.sibling = null : r.sibling = null } } function iM(e) { var t = null !== e.alternate && e.alternate.child === e.child, i = 0, r = 0; if (t) for (var n = e.child; null !== n;)i |= n.lanes | n.childLanes, r |= 0x1e00000 & n.subtreeFlags, r |= 0x1e00000 & n.flags, n.return = e, n = n.sibling; else for (n = e.child; null !== n;)i |= n.lanes | n.childLanes, r |= n.subtreeFlags, r |= n.flags, n.return = e, n = n.sibling; return e.subtreeFlags |= r, e.childLanes = i, t } function iR(e, t) { switch (P(t), t.tag) { case 3: ii(oR), O(); break; case 26: case 27: case 5: F(t); break; case 4: O(); break; case 13: eC(t); break; case 19: m(oe); break; case 10: ii(t.type); break; case 22: case 23: eC(t), eT(), null !== e && m(oI); break; case 24: ii(oR) } } function iC(e, t) { try { var i = t.updateQueue, r = null !== i ? i.lastEffect : null; if (null !== r) { var n = r.next; i = n; do { if ((i.tag & e) === e) { r = void 0; var s = i.create, a = i.inst; r = s(), a.destroy = r } i = i.next } while (i !== n) } } catch (e) { rM(t, t.return, e) } } function iI(e, t, i) { try { var r = t.updateQueue, n = null !== r ? r.lastEffect : null; if (null !== n) { var s = n.next; r = s; do { if ((r.tag & e) === e) { var a = r.inst, o = a.destroy; if (void 0 !== o) { a.destroy = void 0, n = t; try { o() } catch (e) { rM(n, i, e) } } } r = r.next } while (r !== s) } } catch (e) { rM(t, t.return, e) } } function iL(e) { var t = e.updateQueue; if (null !== t) { var i = e.stateNode; try { ed(t, i) } catch (t) { rM(e, e.return, t) } } } function iP(e, t, i) { i.props = tF(e.type, e.memoizedProps), i.state = e.memoizedState; try { i.componentWillUnmount() } catch (i) { rM(e, t, i) } } function iD(e, t) { try { var i = e.ref; if (null !== i) { var r = e.stateNode; switch (e.tag) { case 26: case 27: case 5: var n = np(r); break; default: n = r }"function" == typeof i ? e.refCleanup = i(n) : i.current = n } } catch (i) { rM(e, t, i) } } function iO(e, t) { var i = e.ref, r = e.refCleanup; if (null !== i) { if ("function" == typeof r) try { r() } catch (i) { rM(e, t, i) } finally { e.refCleanup = null, null != (e = e.alternate) && (e.refCleanup = null) } else if ("function" == typeof i) try { i(null) } catch (i) { rM(e, t, i) } else i.current = null } } function ik(e) { var t = e.type, i = e.memoizedProps, r = e.stateNode; try { n5(r, t, i, e) } catch (t) { rM(e, e.return, t) } } function iF(e, t, i) { try { n8(e.stateNode, e.type, i, t, e) } catch (t) { rM(e, e.return, t) } } function iU(e) { return 5 === e.tag || 3 === e.tag || !!sN && 26 === e.tag || !!s$ && 27 === e.tag || 4 === e.tag } function iN(e) { e: for (; ;) { for (; null === e.sibling;) { if (null === e.return || iU(e.return)) return null; e = e.return } for (e.sibling.return = e.return, e = e.sibling; 5 !== e.tag && 6 !== e.tag && (s$ ? 27 !== e.tag : 1) && 18 !== e.tag;) { if (2 & e.flags || null === e.child || 4 === e.tag) continue e; e.child.return = e, e = e.child } if (!(2 & e.flags)) return e.stateNode } } function iB(e, t, i) { var r = e.tag; if (5 === r || 6 === r) e = e.stateNode, t ? n6(i, e, t) : n2(i, e); else if (!(4 === r || s$ && 27 === r) && null !== (e = e.child)) for (iB(e, t, i), e = e.sibling; null !== e;)iB(e, t, i), e = e.sibling } function iz(e, t, i) { e = e.containerInfo; try { sc(e, i) } catch (e) { rM(t, t.return, e) } } function iG(e, t, i) { var r = i.flags; switch (i.tag) { case 0: case 11: case 15: iq(e, i), 4 & r && iC(5, i); break; case 1: if (iq(e, i), 4 & r) { if (e = i.stateNode, null === t) try { e.componentDidMount() } catch (e) { rM(i, i.return, e) } else { var n = tF(i.type, t.memoizedProps); t = t.memoizedState; try { e.componentDidUpdate(n, t, e.__reactInternalSnapshotBeforeUpdate) } catch (e) { rM(i, i.return, e) } } } 64 & r && iL(i), 512 & r && iD(i, i.return); break; case 3: if (iq(e, i), 64 & r && null !== (r = i.updateQueue)) { if (e = null, null !== i.child) switch (i.child.tag) { case 27: case 5: e = np(i.child.stateNode); break; case 1: e = i.child.stateNode }try { ed(r, e) } catch (e) { rM(i, i.return, e) } } break; case 26: if (sN) { iq(e, i), 512 & r && iD(i, i.return); break } case 27: case 5: iq(e, i), null === t && 4 & r && ik(i), 512 & r && iD(i, i.return); break; case 12: default: iq(e, i); break; case 13: iq(e, i), 4 & r && iW(e, i); break; case 22: if (!(n = null !== i.memoizedState || oL)) { t = null !== t && null !== t.memoizedState || oP; var s = oL, a = oP; oL = n, (oP = t) && !a ? function e(t, i, r) { for (r = r && 0 != (8772 & i.subtreeFlags), i = i.child; null !== i;) { var n = i.alternate, s = t, a = i, o = a.flags; switch (a.tag) { case 0: case 11: case 15: e(s, a, r), iC(4, a); break; case 1: if (e(s, a, r), "function" == typeof (s = (n = a).stateNode).componentDidMount) try { s.componentDidMount() } catch (e) { rM(n, n.return, e) } if (null !== (s = (n = a).updateQueue)) { var l = n.stateNode; try { var u = s.shared.hiddenCallbacks; if (null !== u) for (s.shared.hiddenCallbacks = null, s = 0; s < u.length; s++)ec(u[s], l) } catch (e) { rM(n, n.return, e) } } r && 64 & o && iL(a), iD(a, a.return); break; case 26: case 27: case 5: e(s, a, r), r && null === n && 4 & o && ik(a), iD(a, a.return); break; case 12: default: e(s, a, r); break; case 13: e(s, a, r), r && 4 & o && iW(s, a); break; case 22: null === a.memoizedState && e(s, a, r), iD(a, a.return) }i = i.sibling } }(e, i, 0 != (8772 & i.subtreeFlags)) : iq(e, i), oL = s, oP = a } 512 & r && ("manual" === i.memoizedProps.mode ? iD(i, i.return) : iO(i, i.return)) } } function iH(e, t, i) { for (i = i.child; null !== i;)iV(e, t, i), i = i.sibling } function iV(e, t, i) { if (ap && "function" == typeof ap.onCommitFiberUnmount) try { ap.onCommitFiberUnmount(af, i) } catch (e) { } switch (i.tag) { case 26: if (sN) { oP || iO(i, t), iH(e, t, i), i.memoizedState ? sV(i.memoizedState) : i.stateNode && sY(i.stateNode); break } case 27: if (s$) { oP || iO(i, t); var r = oU, n = oN; oU = i.stateNode, iH(e, t, i), s2(i.stateNode), oU = r, oN = n; break } case 5: oP || iO(i, t); case 6: if (nR) { if (r = oU, n = oN, oU = null, iH(e, t, i), oU = r, oN = n, null !== oU) { if (oN) try { se(oU, i.stateNode) } catch (e) { rM(i, t, e) } else try { n7(oU, i.stateNode) } catch (e) { rM(i, t, e) } } } else iH(e, t, i); break; case 18: nR && null !== oU && (oN ? sO(oU, i.stateNode) : sD(oU, i.stateNode)); break; case 4: nR ? (r = oU, n = oN, oU = i.stateNode.containerInfo, oN = !0, iH(e, t, i), oU = r, oN = n) : (nC && iz(i.stateNode, i, sl()), iH(e, t, i)); break; case 0: case 11: case 14: case 15: oP || iI(2, i, t), oP || iI(4, i, t), iH(e, t, i); break; case 1: oP || (iO(i, t), "function" == typeof (r = i.stateNode).componentWillUnmount && iP(i, t, r)), iH(e, t, i); break; case 21: default: iH(e, t, i); break; case 22: oP || iO(i, t), oP = (r = oP) || null !== i.memoizedState, iH(e, t, i), oP = r } } function iW(e, t) { if (nI && null === t.memoizedState && null !== (e = t.alternate) && null !== (e = e.memoizedState) && null !== (e = e.dehydrated)) try { sP(e) } catch (e) { rM(t, t.return, e) } } function ij(e, t) { var i = function (e) { switch (e.tag) { case 13: case 19: var t = e.stateNode; return null === t && (t = e.stateNode = new oO), t; case 22: return null === (t = (e = e.stateNode)._retryCache) && (t = e._retryCache = new oO), t; default: throw Error(s(435, e.tag)) } }(e); t.forEach(function (t) { var r = rP.bind(null, e, t); i.has(t) || (i.add(t), t.then(r, r)) }) } function iY(e, t) { var i = t.deletions; if (null !== i) for (var r = 0; r < i.length; r++) { var n = i[r], a = e, o = t; if (nR) { var l = o; e: for (; null !== l;) { switch (l.tag) { case 27: case 5: oU = l.stateNode, oN = !1; break e; case 3: case 4: oU = l.stateNode.containerInfo, oN = !0; break e }l = l.return } if (null === oU) throw Error(s(160)); iV(a, o, n), oU = null, oN = !1 } else iV(a, o, n); null !== (a = n.alternate) && (a.return = null), n.return = null } if (13878 & t.subtreeFlags) for (t = t.child; null !== t;)iX(t, e), t = t.sibling } function iX(e, t) { var i = e.alternate, r = e.flags; switch (e.tag) { case 0: case 11: case 14: case 15: iY(t, e), iK(e), 4 & r && (iI(3, e, e.return), iC(3, e), iI(5, e, e.return)); break; case 1: iY(t, e), iK(e), 512 & r && (oP || null === i || iO(i, i.return)), 64 & r && oL && null !== (e = e.updateQueue) && null !== (r = e.callbacks) && (i = e.shared.hiddenCallbacks, e.shared.hiddenCallbacks = null === i ? r : i.concat(r)); break; case 26: if (sN) { var n = oB; iY(t, e), iK(e), 512 & r && (oP || null === i || iO(i, i.return)), 4 & r && (r = null !== i ? i.memoizedState : null, t = e.memoizedState, null === i ? null === t ? null === e.stateNode ? e.stateNode = sW(n, e.type, e.memoizedProps, e) : sj(n, e.type, e.stateNode) : e.stateNode = sH(n, t, e.memoizedProps) : r !== t ? (null === r ? null !== i.stateNode && sY(i.stateNode) : sV(r), null === t ? sj(n, e.type, e.stateNode) : sH(n, t, e.memoizedProps)) : null === t && null !== e.stateNode && iF(e, e.memoizedProps, i.memoizedProps)); break } case 27: if (s$ && 4 & r && null === e.alternate) { n = e.stateNode; var a = e.memoizedProps; try { s0(n), s1(e.type, a, n, e) } catch (t) { rM(e, e.return, t) } } case 5: if (iY(t, e), iK(e), 512 & r && (oP || null === i || iO(i, i.return)), nR) { if (32 & e.flags) { t = e.stateNode; try { st(t) } catch (t) { rM(e, e.return, t) } } 4 & r && null != e.stateNode && (t = e.memoizedProps, iF(e, t, null !== i ? i.memoizedProps : t)), 1024 & r && (oD = !0) } break; case 6: if (iY(t, e), iK(e), 4 & r && nR) { if (null === e.stateNode) throw Error(s(162)); r = e.memoizedProps, i = null !== i ? i.memoizedProps : r, t = e.stateNode; try { n4(t, i, r) } catch (t) { rM(e, e.return, t) } } break; case 3: if (sN ? (sK(), n = oB, oB = sz(t.containerInfo), iY(t, e), oB = n) : iY(t, e), iK(e), 4 & r) { if (nR && nI && null !== i && i.memoizedState.isDehydrated) try { sL(t.containerInfo) } catch (t) { rM(e, e.return, t) } if (nC) { r = t.containerInfo, i = t.pendingChildren; try { sc(r, i) } catch (t) { rM(e, e.return, t) } } } oD && (oD = !1, function e(t) { if (1024 & t.subtreeFlags) for (t = t.child; null !== t;) { var i = t; e(i), 5 === i.tag && 1024 & i.flags && nj(i.stateNode), t = t.sibling } }(e)); break; case 4: sN ? (i = oB, oB = sz(e.stateNode.containerInfo), iY(t, e), iK(e), oB = i) : (iY(t, e), iK(e)), 4 & r && nC && iz(e.stateNode, e, e.stateNode.pendingChildren); break; case 12: default: iY(t, e), iK(e); break; case 13: iY(t, e), iK(e), 8192 & e.child.flags && null !== e.memoizedState != (null !== i && null !== i.memoizedState) && (ln = aa()), 4 & r && null !== (r = e.updateQueue) && (e.updateQueue = null, ij(e, r)); break; case 22: 512 & r && (oP || null === i || iO(i, i.return)), n = null !== e.memoizedState; var o = null !== i && null !== i.memoizedState, l = oL, u = oP; if (oL = l || n, oP = u || o, iY(t, e), oP = u, oL = l, iK(e), (t = e.stateNode)._current = e, t._visibility &= -3, t._visibility |= 2 & t._pendingVisibility, 8192 & r && (t._visibility = n ? -2 & t._visibility : 1 | t._visibility, n && (t = oL || oP, null === i || o || t || function e(t) { for (t = t.child; null !== t;) { var i = t; switch (i.tag) { case 0: case 11: case 14: case 15: iI(4, i, i.return), e(i); break; case 1: iO(i, i.return); var r = i.stateNode; "function" == typeof r.componentWillUnmount && iP(i, i.return, r), e(i); break; case 26: case 27: case 5: iO(i, i.return), e(i); break; case 22: iO(i, i.return), null === i.memoizedState && e(i); break; default: e(i) }t = t.sibling } }(e)), nR && (null === e.memoizedProps || "manual" !== e.memoizedProps.mode))) { e: if (i = null, nR) for (t = e; ;) { if (5 === t.tag || sN && 26 === t.tag || s$ && 27 === t.tag) { if (null === i) { o = i = t; try { a = o.stateNode, n ? si(a) : sn(o.stateNode, o.memoizedProps) } catch (e) { rM(o, o.return, e) } } } else if (6 === t.tag) { if (null === i) { o = t; try { var h = o.stateNode; n ? sr(h) : ss(h, o.memoizedProps) } catch (e) { rM(o, o.return, e) } } } else if ((22 !== t.tag && 23 !== t.tag || null === t.memoizedState || t === e) && null !== t.child) { t.child.return = t, t = t.child; continue } if (t === e) break e; for (; null === t.sibling;) { if (null === t.return || t.return === e) break e; i === t && (i = null), t = t.return } i === t && (i = null), t.sibling.return = t.return, t = t.sibling } } 4 & r && null !== (r = e.updateQueue) && null !== (i = r.retryQueue) && (r.retryQueue = null, ij(e, i)); break; case 19: iY(t, e), iK(e), 4 & r && null !== (r = e.updateQueue) && (e.updateQueue = null, ij(e, r)); case 21: } } function iK(e) { var t = e.flags; if (2 & t) { try { if (nR && (!s$ || 27 !== e.tag)) { e: { for (var i = e.return; null !== i;) { if (iU(i)) { var r = i; break e } i = i.return } throw Error(s(160)) } switch (r.tag) { case 27: if (s$) { var n = r.stateNode, a = iN(e); iB(e, a, n); break } case 5: var o = r.stateNode; 32 & r.flags && (st(o), r.flags &= -33); var l = iN(e); iB(e, l, o); break; case 3: case 4: var u = r.stateNode.containerInfo, h = iN(e); !function e(t, i, r) { var n = t.tag; if (5 === n || 6 === n) t = t.stateNode, i ? n9(r, t, i) : n3(r, t); else if (!(4 === n || s$ && 27 === n) && null !== (t = t.child)) for (e(t, i, r), t = t.sibling; null !== t;)e(t, i, r), t = t.sibling }(e, h, u); break; default: throw Error(s(161)) } } } catch (t) { rM(e, e.return, t) } e.flags &= -3 } 4096 & t && (e.flags &= -4097) } function iq(e, t) { if (8772 & t.subtreeFlags) for (t = t.child; null !== t;)iG(e, t.alternate, t), t = t.sibling } function iQ(e, t) { var i = null; null !== e && null !== e.memoizedState && null !== e.memoizedState.cachePool && (i = e.memoizedState.cachePool.pool), e = null, null !== t.memoizedState && null !== t.memoizedState.cachePool && (e = t.memoizedState.cachePool.pool), e !== i && (null != e && e.refCount++, null != i && ip(i)) } function iZ(e, t) { e = null, null !== t.alternate && (e = t.alternate.memoizedState.cache), (t = t.memoizedState.cache) !== e && (t.refCount++, null != e && ip(e)) } function i$(e, t, i, r) { if (10256 & t.subtreeFlags) for (t = t.child; null !== t;)iJ(e, t, i, r), t = t.sibling } function iJ(e, t, i, r) { var n = t.flags; switch (t.tag) { case 0: case 11: case 15: i$(e, t, i, r), 2048 & n && iC(9, t); break; case 3: i$(e, t, i, r), 2048 & n && (e = null, null !== t.alternate && (e = t.alternate.memoizedState.cache), (t = t.memoizedState.cache) !== e && (t.refCount++, null != e && ip(e))); break; case 12: if (2048 & n) { i$(e, t, i, r), e = t.stateNode; try { var s = t.memoizedProps, a = s.id, o = s.onPostCommit; "function" == typeof o && o(a, null === t.alternate ? "mount" : "update", e.passiveEffectDuration, -0) } catch (e) { rM(t, t.return, e) } } else i$(e, t, i, r); break; case 23: break; case 22: s = t.stateNode, null !== t.memoizedState ? 4 & s._visibility ? i$(e, t, i, r) : i0(e, t) : 4 & s._visibility ? i$(e, t, i, r) : (s._visibility |= 4, function e(t, i, r, n, s) { for (s = s && 0 != (10256 & i.subtreeFlags), i = i.child; null !== i;) { var a = i, o = a.flags; switch (a.tag) { case 0: case 11: case 15: e(t, a, r, n, s), iC(8, a); break; case 23: break; case 22: var l = a.stateNode; null !== a.memoizedState ? 4 & l._visibility ? e(t, a, r, n, s) : i0(t, a) : (l._visibility |= 4, e(t, a, r, n, s)), s && 2048 & o && iQ(a.alternate, a); break; case 24: e(t, a, r, n, s), s && 2048 & o && iZ(a.alternate, a); break; default: e(t, a, r, n, s) }i = i.sibling } }(e, t, i, r, 0 != (10256 & t.subtreeFlags))), 2048 & n && iQ(t.alternate, t); break; case 24: i$(e, t, i, r), 2048 & n && iZ(t.alternate, t); break; default: i$(e, t, i, r) } } function i0(e, t) { if (10256 & t.subtreeFlags) for (t = t.child; null !== t;) { var i = t, r = i.flags; switch (i.tag) { case 22: i0(e, i), 2048 & r && iQ(i.alternate, i); break; case 24: i0(e, i), 2048 & r && iZ(i.alternate, i); break; default: i0(e, i) }t = t.sibling } } function i1(e) { if (e.subtreeFlags & oz) for (e = e.child; null !== e;)i2(e), e = e.sibling } function i2(e) { switch (e.tag) { case 26: i1(e), e.flags & oz && (null !== e.memoizedState ? sZ(oB, e.memoizedState, e.memoizedProps) : nG(e.type, e.memoizedProps)); break; case 5: i1(e), e.flags & oz && nG(e.type, e.memoizedProps); break; case 3: case 4: if (sN) { var t = oB; oB = sz(e.stateNode.containerInfo), i1(e), oB = t } else i1(e); break; case 22: null === e.memoizedState && (null !== (t = e.alternate) && null !== t.memoizedState ? (t = oz, oz = 0x1000000, i1(e), oz = t) : i1(e)); break; default: i1(e) } } function i3(e) { var t = e.alternate; if (null !== t && null !== (e = t.child)) { t.child = null; do t = e.sibling, e.sibling = null, e = t; while (null !== e) } } function i4(e) { var t = e.deletions; if (0 != (16 & e.flags)) { if (null !== t) for (var i = 0; i < t.length; i++) { var r = t[i]; ok = r, i8(r, e) } i3(e) } if (10256 & e.subtreeFlags) for (e = e.child; null !== e;)i5(e), e = e.sibling } function i5(e) { switch (e.tag) { case 0: case 11: case 15: i4(e), 2048 & e.flags && iI(9, e, e.return); break; case 3: case 12: default: i4(e); break; case 22: var t = e.stateNode; null !== e.memoizedState && 4 & t._visibility && (null === e.return || 13 !== e.return.tag) ? (t._visibility &= -5, function e(t) { var i = t.deletions; if (0 != (16 & t.flags)) { if (null !== i) for (var r = 0; r < i.length; r++) { var n = i[r]; ok = n, i8(n, t) } i3(t) } for (t = t.child; null !== t;) { switch ((i = t).tag) { case 0: case 11: case 15: iI(8, i, i.return), e(i); break; case 22: 4 & (r = i.stateNode)._visibility && (r._visibility &= -5, e(i)); break; default: e(i) }t = t.sibling } }(e)) : i4(e) } } function i8(e, t) { for (; null !== ok;) { var i = ok; switch (i.tag) { case 0: case 11: case 15: iI(8, i, t); break; case 23: case 22: if (null !== i.memoizedState && null !== i.memoizedState.cachePool) { var r = i.memoizedState.cachePool.pool; null != r && r.refCount++ } break; case 24: ip(i.memoizedState.cache) }if (null !== (r = i.child)) r.return = i, ok = r; else for (i = e; null !== ok;) { var n = (r = ok).sibling, s = r.return; if (function e(t) { var i = t.alternate; null !== i && (t.alternate = null, e(i)), t.child = null, t.deletions = null, t.sibling = null, 5 === t.tag && null !== (i = t.stateNode) && nU(i), t.stateNode = null, t.return = null, t.dependencies = null, t.memoizedProps = null, t.memoizedState = null, t.pendingProps = null, t.stateNode = null, t.updateQueue = null }(r), r === i) { ok = null; break } if (null !== n) { n.return = s, ok = n; break } ok = s } } } function i6(e) { var t = nL(e); if (null != t) { if ("string" != typeof t.memoizedProps["data-testname"]) throw Error(s(364)); return t } if (null === (e = nq(e))) throw Error(s(362)); return e.stateNode.current } function i9(e, t) { var i = e.tag; switch (t.$$typeof) { case oH: if (e.type === t.value) return !0; break; case oV: e: { for (i = 0, t = t.value, e = [e, 0]; i < e.length;) { var r = e[i++], n = r.tag, a = e[i++], o = t[a]; if (5 !== n && 26 !== n && 27 !== n || !n$(r)) { for (; null != o && i9(r, o);)o = t[++a]; if (a === t.length) { t = !0; break e } for (r = r.child; null !== r;)e.push(r, a), r = r.sibling } } t = !1 } return t; case oW: if ((5 === i || 26 === i || 27 === i) && nJ(e.stateNode, t.value)) return !0; break; case oY: if ((5 === i || 6 === i || 26 === i || 27 === i) && null !== (e = nZ(e)) && 0 <= e.indexOf(t.value)) return !0; break; case oj: if ((5 === i || 26 === i || 27 === i) && "string" == typeof (e = e.memoizedProps["data-testname"]) && e.toLowerCase() === t.value.toLowerCase()) return !0; break; default: throw Error(s(365)) }return !1 } function i7(e) { switch (e.$$typeof) { case oH: return "<" + (o(e.value) || "Unknown") + ">"; case oV: return ":has(" + (i7(e) || "") + ")"; case oW: return '[role="' + e.value + '"]'; case oY: return '"' + e.value + '"'; case oj: return '[data-testname="' + e.value + '"]'; default: throw Error(s(365)) } } function re(e, t) { var i = []; e = [e, 0]; for (var r = 0; r < e.length;) { var n = e[r++], s = n.tag, a = e[r++], o = t[a]; if (5 !== s && 26 !== s && 27 !== s || !n$(n)) { for (; null != o && i9(n, o);)o = t[++a]; if (a === t.length) i.push(n); else for (n = n.child; null !== n;)e.push(n, a), n = n.sibling } } return i } function rt(e, t) { if (!nK) throw Error(s(363)); e = re(e = i6(e), t), t = [], e = Array.from(e); for (var i = 0; i < e.length;) { var r = e[i++], n = r.tag; if (5 === n || 26 === n || 27 === n) n$(r) || t.push(r.stateNode); else for (r = r.child; null !== r;)e.push(r), r = r.sibling } return t } function ri() { if (0 != (2 & oq) && 0 !== o$) return o$ & -o$; if (null !== nl.T) { var e = aX; return 0 !== e ? e : et() } return nk() } function rr() { 0 === o7 && (o7 = 0 == (0x20000000 & o$) || aP ? S() : 0x20000000); var e = a9.current; return null !== e && (e.flags |= 32), o7 } function rn(e, t, i) { (e === oQ && 2 === oJ || null !== e.cancelPendingCommit) && (rc(e, 0), rl(e, o$, o7, !1)), E(e, i), (0 == (2 & oq) || e !== oQ) && (e === oQ && (0 == (2 & oq) && (o6 |= i), 4 === o5 && rl(e, o$, o7, !1)), q(e)) } function rs(e, t, i) { if (0 != (6 & oq)) throw Error(s(327)); for (var r = !i && 0 == (60 & t) && 0 == (t & e.expiredLanes) || x(e, t), n = r ? function (e, t) { var i = oq; oq |= 2; var r = rp(), n = rm(); oQ !== e || o$ !== t ? (la = null, ls = aa() + 500, rc(e, t)) : o2 = x(e, t); e: for (; ;)try { if (0 !== oJ && null !== oZ) { t = oZ; var a = o0; t: switch (oJ) { case 1: oJ = 0, o0 = null, rS(e, t, a, 1); break; case 2: if (ep(a)) { oJ = 0, o0 = null, rx(t); break } t = function () { 2 === oJ && oQ === e && (oJ = 7), q(e) }, a.then(t, t); break e; case 3: oJ = 7; break e; case 4: oJ = 5; break e; case 7: ep(a) ? (oJ = 0, o0 = null, rx(t)) : (oJ = 0, o0 = null, rS(e, t, a, 7)); break; case 5: var o = null; switch (oZ.tag) { case 26: o = oZ.memoizedState; case 5: case 27: var l = oZ, u = l.type, h = l.pendingProps; if (o ? sQ(o) : nB(u, h)) { oJ = 0, o0 = null; var c = l.sibling; if (null !== c) oZ = c; else { var d = l.return; null !== d ? (oZ = d, rA(d)) : oZ = null } break t } }oJ = 0, o0 = null, rS(e, t, a, 5); break; case 6: oJ = 0, o0 = null, rS(e, t, a, 6); break; case 8: rh(), o5 = 6; break e; default: throw Error(s(462)) } } (function () { for (; null !== oZ && !an();)ry(oZ) })(); break } catch (t) { rd(e, t) } return (ob = oE = null, nl.H = r, nl.A = n, oq = i, null !== oZ) ? 0 : (oQ = null, o$ = 0, V(), o5) }(e, t) : rv(e, t, !0), a = r; ;) { if (0 === n) o2 && !r && rl(e, t, 0, !1); else if (6 === n) rl(e, t, 0, !o1); else { if (i = e.current.alternate, a && !function (e) { for (var t = e; ;) { var i = t.tag; if ((0 === i || 11 === i || 15 === i) && 16384 & t.flags && null !== (i = t.updateQueue) && null !== (i = i.stores)) for (var r = 0; r < i.length; r++) { var n = i[r], s = n.getSnapshot; n = n.value; try { if (!am(s(), n)) return !1 } catch (e) { return !1 } } if (i = t.child, 16384 & t.subtreeFlags && null !== i) i.return = t, t = i; else { if (t === e) break; for (; null === t.sibling;) { if (null === t.return || t.return === e) return !0; t = t.return } t.sibling.return = t.return, t = t.sibling } } return !0 }(i)) { n = rv(e, t, !1), a = !1; continue } if (2 === n) { if (a = t, e.errorRecoveryDisabledLanes & a) var o = 0; else o = 0 != (o = -0x20000001 & e.pendingLanes) ? o : 0x20000000 & o ? 0x20000000 : 0; if (0 !== o) { t = o; e: { n = lt; var l = nI && e.current.memoizedState.isDehydrated; if (l && (rc(e, o).flags |= 256), 2 !== (o = rv(e, o, !1))) { if (o3 && !l) { e.errorRecoveryDisabledLanes |= a, o6 |= a, n = 4; break e } a = li, li = n, null !== a && ra(a) } n = o } if (a = !1, 2 !== n) continue } } if (1 === n) { rc(e, 0), rl(e, t, 0, !0); break } e: { switch (r = e, n) { case 0: case 1: throw Error(s(345)); case 4: if ((4194176 & t) === t) { rl(r, t, o7, !o1); break e } break; case 2: li = null; break; case 3: case 5: break; default: throw Error(s(329)) }if (r.finishedWork = i, r.finishedLanes = t, (0x3c00000 & t) === t && 10 < (a = ln + 300 - aa())) { if (rl(r, t, o7, !o1), 0 !== y(r, 0)) break e; r.timeoutHandle = nb(ro.bind(null, r, i, li, la, lr, t, o7, o6, le, o1, 2, -0, 0), a); break e } ro(r, i, li, la, lr, t, o7, o6, le, o1, 0, -0, 0) } } break } q(e) } function ra(e) { null === li ? li = e : li.push.apply(li, e) } function ro(e, t, i, r, n, s, a, o, l, u, h, c, d) { var f = t.subtreeFlags; if ((8192 & f || 0x1002000 == (0x1002000 & f)) && (nz(), i2(t), null !== (t = nH()))) { e.cancelPendingCommit = t(rE.bind(null, e, i, r, n, a, o, l, 1, c, d)), rl(e, s, a, !u); return } rE(e, i, r, n, a, o, l, h, c, d) } function rl(e, t, i, r) { t &= ~o9, t &= ~o6, e.suspendedLanes |= t, e.pingedLanes &= ~t, r && (e.warmLanes |= t), r = e.expirationTimes; for (var n = t; 0 < n;) { var s = 31 - s6(n), a = 1 << s; r[s] = -1, n &= ~a } 0 !== i && b(e, i, t) } function ru() { return 0 != (6 & oq) || (Q(0, !1), !1) } function rh() { if (null !== oZ) { if (0 === oJ) var e = oZ.return; else e = oZ, ob = oE = null, eB(e), a2 = null, a3 = 0, e = oZ; for (; null !== e;)iR(e.alternate, e), e = e.return; oZ = null } } function rc(e, t) { e.finishedWork = null, e.finishedLanes = 0; var i = e.timeoutHandle; i !== nw && (e.timeoutHandle = nw, nT(i)), null !== (i = e.cancelPendingCommit) && (e.cancelPendingCommit = null, i()), rh(), oQ = e, oZ = i = rk(e.current, null), o$ = t, oJ = 0, o0 = null, o1 = !1, o2 = x(e, t), o3 = !1, le = o7 = o9 = o6 = o8 = o5 = 0, li = lt = null, lr = !1, 0 != (8 & t) && (t |= 32 & t); var r = e.entangledLanes; if (0 !== r) for (e = e.entanglements, r &= t; 0 < r;) { var n = 31 - s6(r), s = 1 << n; t |= e[n], r &= ~s } return o4 = t, V(), i } function rd(e, t) { oi = null, nl.H = of, t === a$ ? (t = ev(), oJ = 3) : t === aJ ? (t = ev(), oJ = 4) : oJ = t === ox ? 8 : null !== t && "object" == typeof t && "function" == typeof t.then ? 6 : 1, o0 = t, null === oZ && (o5 = 1, tU(e, R(t, e.current))) } function rf() { var e = a9.current; return null === e || ((4194176 & o$) === o$ ? null === a7 : ((0x3c00000 & o$) === o$ || 0 != (0x20000000 & o$)) && e === a7) } function rp() { var e = nl.H; return nl.H = of, null === e ? of : e } function rm() { var e = nl.A; return nl.A = oG, e } function rg() { o5 = 4, o1 || (4194176 & o$) !== o$ && null !== a9.current || (o2 = !0), 0 == (0x7ffffff & o8) && 0 == (0x7ffffff & o6) || null === oQ || rl(oQ, o$, o7, !1) } function rv(e, t, i) { var r = oq; oq |= 2; var n = rp(), s = rm(); (oQ !== e || o$ !== t) && (la = null, rc(e, t)), t = !1; var a = o5; e: for (; ;)try { if (0 !== oJ && null !== oZ) { var o = oZ, l = o0; switch (oJ) { case 8: rh(), a = 6; break e; case 3: case 2: case 6: null === a9.current && (t = !0); var u = oJ; if (oJ = 0, o0 = null, rS(e, o, l, u), i && o2) { a = 0; break e } break; default: u = oJ, oJ = 0, o0 = null, rS(e, o, l, u) } } (function () { for (; null !== oZ;)ry(oZ) })(), a = o5; break } catch (t) { rd(e, t) } return t && e.shellSuspendCounter++, ob = oE = null, oq = r, nl.H = n, nl.A = s, null === oZ && (oQ = null, o$ = 0, V()), a } function ry(e) { var t = ie(e.alternate, e, o4); e.memoizedProps = e.pendingProps, null === t ? rA(e) : oZ = t } function rx(e) { var t = e, i = t.alternate; switch (t.tag) { case 15: case 0: t = tQ(i, t, t.pendingProps, t.type, void 0, o$); break; case 11: t = tQ(i, t, t.pendingProps, t.type.render, t.ref, o$); break; case 5: eB(t); default: iR(i, t), t = ie(i, t = oZ = rF(t, o4), o4) }e.memoizedProps = e.pendingProps, null === t ? rA(e) : oZ = t } function rS(e, t, i, r) { ob = oE = null, eB(t), a2 = null, a3 = 0; var n = t.return; try { if (function (e, t, i, r, n) { if (i.flags |= 32768, null !== r && "object" == typeof r && "function" == typeof r.then) { if (null !== (t = i.alternate) && ia(t, i, n, !0), null !== (i = a9.current)) { switch (i.tag) { case 13: return null === a7 ? rg() : null === i.alternate && 0 === o5 && (o5 = 3), i.flags &= -257, i.flags |= 65536, i.lanes = n, r === a0 ? i.flags |= 16384 : (null === (t = i.updateQueue) ? i.updateQueue = new Set([r]) : t.add(r), rR(e, r, n)), !1; case 22: return i.flags |= 65536, r === a0 ? i.flags |= 16384 : (null === (t = i.updateQueue) ? (t = { transitions: null, markerInstances: null, retryQueue: new Set([r]) }, i.updateQueue = t) : null === (i = t.retryQueue) ? t.retryQueue = new Set([r]) : i.add(r), rR(e, r, n)), !1 }throw Error(s(435, i.tag)) } return rR(e, r, n), rg(), !1 } if (aP) return null !== (t = a9.current) ? (0 == (65536 & t.flags) && (t.flags |= 256), t.flags |= 65536, t.lanes = n, r !== ak && H(R(e = Error(s(422), { cause: r }), i))) : (r !== ak && H(R(t = Error(s(423), { cause: r }), i)), e = e.current.alternate, e.flags |= 65536, n &= -n, e.lanes |= n, r = R(r, i), n = tB(e.stateNode, r, n), el(e, n), 4 !== o5 && (o5 = 2)), !1; var a = Error(s(520), { cause: r }); if (a = R(a, i), null === lt ? lt = [a] : lt.push(a), 4 !== o5 && (o5 = 2), null === t) return !0; r = R(r, i), i = t; do { switch (i.tag) { case 3: return i.flags |= 65536, e = n & -n, i.lanes |= e, e = tB(i.stateNode, r, e), el(i, e), !1; case 1: if (t = i.type, a = i.stateNode, 0 == (128 & i.flags) && ("function" == typeof t.getDerivedStateFromError || null !== a && "function" == typeof a.componentDidCatch && (null === lo || !lo.has(a)))) return i.flags |= 65536, n &= -n, i.lanes |= n, tG(n = tz(n), e, i, r), el(i, n), !1 }i = i.return } while (null !== i); return !1 }(e, n, t, i, o$)) { o5 = 1, tU(e, R(i, e.current)), oZ = null; return } } catch (t) { if (null !== n) throw oZ = n, t; o5 = 1, tU(e, R(i, e.current)), oZ = null; return } 32768 & t.flags ? (aP || 1 === r ? e = !0 : o2 || 0 != (0x20000000 & o$) ? e = !1 : (o1 = e = !0, (2 === r || 3 === r || 6 === r) && null !== (r = a9.current) && 13 === r.tag && (r.flags |= 16384)), r_(t, e)) : rA(t) } function rA(e) { var t = e; do { if (0 != (32768 & t.flags)) { r_(t, o1); return } e = t.return; var i = function (e, t, i) { var r = t.pendingProps; switch (P(t), t.tag) { case 16: case 15: case 0: case 11: case 7: case 8: case 12: case 9: case 14: case 1: return iM(t), null; case 3: return i = t.stateNode, r = null, null !== e && (r = e.memoizedState.cache), t.memoizedState.cache !== r && (t.flags |= 2048), ii(oR), O(), i.pendingContext && (i.context = i.pendingContext, i.pendingContext = null), (null === e || null === e.child) && (z(t) ? iy(t) : null === e || e.memoizedState.isDehydrated && 0 == (256 & t.flags) || (t.flags |= 1024, null !== aD && (ra(aD), aD = null))), iA(e, t), iM(t), null; case 26: if (sN) { i = t.type; var n = t.memoizedState; return null === e ? (iy(t), null !== n ? (iM(t), ib(t, n)) : (iM(t), iE(t, i, r))) : n ? n !== e.memoizedState ? (iy(t), iM(t), ib(t, n)) : (iM(t), t.flags &= -0x1000001) : (nR ? e.memoizedProps !== r && iy(t) : i_(e, t, i, r), iM(t), iE(t, i, r)), null } case 27: if (s$) { if (F(t), i = aR.current, n = t.type, null !== e && null != t.stateNode) nR ? e.memoizedProps !== r && iy(t) : i_(e, t, n, r); else { if (!r) { if (null === t.stateNode) throw Error(s(166)); return iM(t), null } e = aw.current, z(t) ? N(t, e) : (e = sJ(n, r, i, e, !0), t.stateNode = e, iy(t)) } return iM(t), null } case 5: if (F(t), i = t.type, null !== e && null != t.stateNode) i_(e, t, i, r); else { if (!r) { if (null === t.stateNode) throw Error(s(166)); return iM(t), null } e = aw.current, z(t) ? N(t, e) : (iS(n = nx(i, r, aR.current, e, t), t, !1, !1), t.stateNode = n, nA(n, i, r, e) && iy(t)) } return iM(t), iE(t, t.type, t.pendingProps), null; case 6: if (e && null != t.stateNode) i = e.memoizedProps, nR ? i !== r && iy(t) : nC && (i !== r ? (t.stateNode = nE(r, aR.current, aw.current, t), iy(t)) : t.stateNode = e.stateNode); else { if ("string" != typeof r && null === t.stateNode) throw Error(s(166)); if (e = aR.current, i = aw.current, z(t)) { if (!nI) throw Error(s(176)); if (e = t.stateNode, i = t.memoizedProps, r = null, null !== (n = aI)) switch (n.tag) { case 27: case 5: r = n.memoizedProps }sR(e, i, t, r) || U(t) } else t.stateNode = nE(r, e, i, t) } return iM(t), null; case 13: if (r = t.memoizedState, null === e || null !== e.memoizedState && null !== e.memoizedState.dehydrated) { if (n = z(t), null !== r && null !== r.dehydrated) { if (null === e) { if (!n) throw Error(s(318)); if (!nI) throw Error(s(344)); if (!(n = null !== (n = t.memoizedState) ? n.dehydrated : null)) throw Error(s(317)); sC(n, t) } else G(), 0 == (128 & t.flags) && (t.memoizedState = null), t.flags |= 4; iM(t), n = !1 } else null !== aD && (ra(aD), aD = null), n = !0; if (!n) { if (256 & t.flags) return eC(t), t; return eC(t), null } } if (eC(t), 0 != (128 & t.flags)) return t.lanes = i, t; if (i = null !== r, e = null !== e && null !== e.memoizedState, i) { r = t.child, n = null, null !== r.alternate && null !== r.alternate.memoizedState && null !== r.alternate.memoizedState.cachePool && (n = r.alternate.memoizedState.cachePool.pool); var a = null; null !== r.memoizedState && null !== r.memoizedState.cachePool && (a = r.memoizedState.cachePool.pool), a !== n && (r.flags |= 2048) } return i !== e && i && (t.child.flags |= 8192), iT(t, t.updateQueue), iM(t), null; case 4: return O(), iA(e, t), null === e && nP(t.stateNode.containerInfo), iM(t), null; case 10: return ii(t.type), iM(t), null; case 19: if (m(oe), null === (n = t.memoizedState)) return iM(t), null; if (r = 0 != (128 & t.flags), null === (a = n.rendering)) { if (r) iw(n, !1); else { if (0 !== o5 || null !== e && 0 != (128 & e.flags)) for (e = t.child; null !== e;) { if (null !== (a = eI(e))) { for (t.flags |= 128, iw(n, !1), e = a.updateQueue, t.updateQueue = e, iT(t, e), t.subtreeFlags = 0, e = i, i = t.child; null !== i;)rF(i, e), i = i.sibling; return g(oe, 1 & oe.current | 2), t.child } e = e.sibling } null !== n.tail && aa() > ls && (t.flags |= 128, r = !0, iw(n, !1), t.lanes = 4194304) } } else { if (!r) { if (null !== (e = eI(a))) { if (t.flags |= 128, r = !0, e = e.updateQueue, t.updateQueue = e, iT(t, e), iw(n, !0), null === n.tail && "hidden" === n.tailMode && !a.alternate && !aP) return iM(t), null } else 2 * aa() - n.renderingStartTime > ls && 0x20000000 !== i && (t.flags |= 128, r = !0, iw(n, !1), t.lanes = 4194304) } n.isBackwards ? (a.sibling = t.child, t.child = a) : (null !== (e = n.last) ? e.sibling = a : t.child = a, n.last = a) } if (null !== n.tail) return t = n.tail, n.rendering = t, n.tail = t.sibling, n.renderingStartTime = aa(), t.sibling = null, e = oe.current, g(oe, r ? 1 & e | 2 : 1 & e), t; return iM(t), null; case 22: case 23: return eC(t), eT(), r = null !== t.memoizedState, null !== e ? null !== e.memoizedState !== r && (t.flags |= 8192) : r && (t.flags |= 8192), r ? 0 != (0x20000000 & i) && 0 == (128 & t.flags) && (iM(t), 6 & t.subtreeFlags && (t.flags |= 8192)) : iM(t), null !== (i = t.updateQueue) && iT(t, i.retryQueue), i = null, null !== e && null !== e.memoizedState && null !== e.memoizedState.cachePool && (i = e.memoizedState.cachePool.pool), r = null, null !== t.memoizedState && null !== t.memoizedState.cachePool && (r = t.memoizedState.cachePool.pool), r !== i && (t.flags |= 2048), null !== e && m(oI), null; case 24: return i = null, null !== e && (i = e.memoizedState.cache), t.memoizedState.cache !== i && (t.flags |= 2048), ii(oR), iM(t), null; case 25: return null }throw Error(s(156, t.tag)) }(t.alternate, t, o4); if (null !== i) { oZ = i; return } if (null !== (t = t.sibling)) { oZ = t; return } oZ = t = e } while (null !== t); 0 === o5 && (o5 = 5) } function r_(e, t) { do { var i = function (e, t) { switch (P(t), t.tag) { case 1: return 65536 & (e = t.flags) ? (t.flags = -65537 & e | 128, t) : null; case 3: return ii(oR), O(), 0 != (65536 & (e = t.flags)) && 0 == (128 & e) ? (t.flags = -65537 & e | 128, t) : null; case 26: case 27: case 5: return F(t), null; case 13: if (eC(t), null !== (e = t.memoizedState) && null !== e.dehydrated) { if (null === t.alternate) throw Error(s(340)); G() } return 65536 & (e = t.flags) ? (t.flags = -65537 & e | 128, t) : null; case 19: return m(oe), null; case 4: return O(), null; case 10: return ii(t.type), null; case 22: case 23: return eC(t), eT(), null !== e && m(oI), 65536 & (e = t.flags) ? (t.flags = -65537 & e | 128, t) : null; case 24: return ii(oR), null; default: return null } }(e.alternate, e); if (null !== i) { i.flags &= 32767, oZ = i; return } if (null !== (i = e.return) && (i.flags |= 32768, i.subtreeFlags = 0, i.deletions = null), !t && null !== (e = e.sibling)) { oZ = e; return } oZ = e = i } while (null !== e); o5 = 6, oZ = null } function rE(e, t, i, r, n, a, o, l, u, h) { var c = nl.T, d = nO(); try { nD(2), nl.T = null, function (e, t, i, r, n, a, o, l) { do rT(); while (null !== lu); if (0 != (6 & oq)) throw Error(s(327)); var u, h = e.finishedWork; if (r = e.finishedLanes, null !== h) { if (e.finishedWork = null, e.finishedLanes = 0, h === e.current) throw Error(s(177)); e.callbackNode = null, e.callbackPriority = 0, e.cancelPendingCommit = null; var c = h.lanes | h.childLanes; if (function (e, t, i, r, n, s) { var a = e.pendingLanes; e.pendingLanes = i, e.suspendedLanes = 0, e.pingedLanes = 0, e.warmLanes = 0, e.expiredLanes &= i, e.entangledLanes &= i, e.errorRecoveryDisabledLanes &= i, e.shellSuspendCounter = 0; var o = e.entanglements, l = e.expirationTimes, u = e.hiddenUpdates; for (i = a & ~i; 0 < i;) { var h = 31 - s6(i), c = 1 << h; o[h] = 0, l[h] = -1; var d = u[h]; if (null !== d) for (u[h] = null, h = 0; h < d.length; h++) { var f = d[h]; null !== f && (f.lane &= -0x20000001) } i &= ~c } 0 !== r && b(e, r, 0), 0 !== s && 0 === n && 0 !== e.tag && (e.suspendedLanes |= s & ~(a & ~t)) }(e, r, c |= aN, a, o, l), e === oQ && (oZ = oQ = null, o$ = 0), 0 == (10256 & h.subtreeFlags) && 0 == (10256 & h.flags) || ll || (ll = !0, lc = c, ld = i, u = function () { return rT(!0), null }, ai(au, u)), i = 0 != (15990 & h.flags), 0 != (15990 & h.subtreeFlags) || i ? (i = nl.T, nl.T = null, a = nO(), nD(2), o = oq, oq |= 4, function (e, t) { for (nv(e.containerInfo), ok = t; null !== ok;)if (t = (e = ok).child, 0 != (1028 & e.subtreeFlags) && null !== t) t.return = e, ok = t; else for (; null !== ok;) { var i = (e = ok).alternate; switch (t = e.flags, e.tag) { case 0: case 11: case 15: case 5: case 26: case 27: case 6: case 4: case 17: break; case 1: if (0 != (1024 & t) && null !== i) { t = void 0; var r = e, n = i.memoizedProps; i = i.memoizedState; var a = r.stateNode; try { var o = tF(r.type, n, r.elementType === r.type); t = a.getSnapshotBeforeUpdate(o, i), a.__reactInternalSnapshotBeforeUpdate = t } catch (e) { rM(r, r.return, e) } } break; case 3: 0 != (1024 & t) && nR && sa(e.stateNode.containerInfo); break; default: if (0 != (1024 & t)) throw Error(s(163)) }if (null !== (t = e.sibling)) { t.return = e.return, ok = t; break } ok = e.return } o = oF, oF = !1 }(e, h), iX(h, e), ny(e.containerInfo), e.current = h, iG(e, h.alternate, h), as(), oq = o, nD(a), nl.T = i) : e.current = h, ll ? (ll = !1, lu = e, lh = r) : rb(e, c), 0 === (c = e.pendingLanes) && (lo = null), function (e) { if (ap && "function" == typeof ap.onCommitFiberRoot) try { ap.onCommitFiberRoot(af, e, void 0, 128 == (128 & e.current.flags)) } catch (e) { } }(h.stateNode, n), q(e), null !== t) for (n = e.onRecoverableError, h = 0; h < t.length; h++)n((c = t[h]).value, { componentStack: c.stack }); 0 != (3 & lh) && rT(), c = e.pendingLanes, 0 != (4194218 & r) && 0 != (42 & c) ? e === lp ? lf++ : (lf = 0, lp = e) : lf = 0, Q(0, !1) } }(e, t, i, r, d, n, a, o, l, u, h) } finally { nl.T = c, nD(d) } } function rb(e, t) { 0 == (e.pooledCacheLanes &= t) && null != (t = e.pooledCache) && (e.pooledCache = null, ip(t)) } function rT() { if (null !== lu) { var e = lu, t = lc; lc = 0; var i = w(lh), r = 32 > i ? 32 : i; i = nl.T; var n = nO(); try { if (nD(r), nl.T = null, null === lu) var a = !1; else { r = ld, ld = null; var o = lu, l = lh; if (lu = null, lh = 0, 0 != (6 & oq)) throw Error(s(331)); var u = oq; if (oq |= 4, i5(o.current), iJ(o, o.current, l, r), oq = u, Q(0, !1), ap && "function" == typeof ap.onPostCommitFiberRoot) try { ap.onPostCommitFiberRoot(af, o) } catch (e) { } a = !0 } return a } finally { nD(n), nl.T = i, rb(e, t) } } return !1 } function rw(e, t, i) { t = R(i, t), t = tB(e.stateNode, t, 2), null !== (e = ea(e, t, 2)) && (E(e, 2), q(e)) } function rM(e, t, i) { if (3 === e.tag) rw(e, e, i); else for (; null !== t;) { if (3 === t.tag) { rw(t, e, i); break } if (1 === t.tag) { var r = t.stateNode; if ("function" == typeof t.type.getDerivedStateFromError || "function" == typeof r.componentDidCatch && (null === lo || !lo.has(r))) { e = R(i, e), null !== (r = ea(t, i = tz(2), 2)) && (tG(i, r, t, e), E(r, 2), q(r)); break } } t = t.return } } function rR(e, t, i) { var r = e.pingCache; if (null === r) { r = e.pingCache = new oK; var n = new Set; r.set(t, n) } else void 0 === (n = r.get(t)) && (n = new Set, r.set(t, n)); n.has(i) || (o3 = !0, n.add(i), e = rC.bind(null, e, t, i), t.then(e, e)) } function rC(e, t, i) { var r = e.pingCache; null !== r && r.delete(t), e.pingedLanes |= e.suspendedLanes & i, e.warmLanes &= ~i, oQ === e && (o$ & i) === i && (4 === o5 || 3 === o5 && (0x3c00000 & o$) === o$ && 300 > aa() - ln ? 0 == (2 & oq) && rc(e, 0) : o9 |= i, le === o$ && (le = 0)), q(e) } function rI(e, t) { 0 === t && (t = A()), null !== (e = Y(e, t)) && (E(e, t), q(e)) } function rL(e) { var t = e.memoizedState, i = 0; null !== t && (i = t.retryLane), rI(e, i) } function rP(e, t) { var i = 0; switch (e.tag) { case 13: var r = e.stateNode, n = e.memoizedState; null !== n && (i = n.retryLane); break; case 19: r = e.stateNode; break; case 22: r = e.stateNode._retryCache; break; default: throw Error(s(314)) }null !== r && r.delete(t), rI(e, i) } function rD(e, t, i, r) { this.tag = e, this.key = i, this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null, this.index = 0, this.refCleanup = this.ref = null, this.pendingProps = t, this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null, this.mode = r, this.subtreeFlags = this.flags = 0, this.deletions = null, this.childLanes = this.lanes = 0, this.alternate = null } function rO(e) { return !(!(e = e.prototype) || !e.isReactComponent) } function rk(e, i) { var r = e.alternate; return null === r ? ((r = t(e.tag, i, e.key, e.mode)).elementType = e.elementType, r.type = e.type, r.stateNode = e.stateNode, r.alternate = e, e.alternate = r) : (r.pendingProps = i, r.type = e.type, r.flags = 0, r.subtreeFlags = 0, r.deletions = null), r.flags = 0x1e00000 & e.flags, r.childLanes = e.childLanes, r.lanes = e.lanes, r.child = e.child, r.memoizedProps = e.memoizedProps, r.memoizedState = e.memoizedState, r.updateQueue = e.updateQueue, i = e.dependencies, r.dependencies = null === i ? null : { lanes: i.lanes, firstContext: i.firstContext }, r.sibling = e.sibling, r.index = e.index, r.ref = e.ref, r.refCleanup = e.refCleanup, r } function rF(e, t) { e.flags &= 0x1e00002; var i = e.alternate; return null === i ? (e.childLanes = 0, e.lanes = t, e.child = null, e.subtreeFlags = 0, e.memoizedProps = null, e.memoizedState = null, e.updateQueue = null, e.dependencies = null, e.stateNode = null) : (e.childLanes = i.childLanes, e.lanes = i.lanes, e.child = i.child, e.subtreeFlags = 0, e.deletions = null, e.memoizedProps = i.memoizedProps, e.memoizedState = i.memoizedState, e.updateQueue = i.updateQueue, e.type = i.type, t = i.dependencies, e.dependencies = null === t ? null : { lanes: t.lanes, firstContext: t.firstContext }), e } function rU(e, i, r, n, a, o) { var l = 0; if (n = e, "function" == typeof e) rO(e) && (l = 1); else if ("string" == typeof e) l = sN && s$ ? sB(e, r, aw.current) ? 26 : s3(e) ? 27 : 5 : sN ? sB(e, r, aw.current) ? 26 : 5 : s$ && s3(e) ? 27 : 5; else e: switch (e) { case r1: return rN(r.children, a, o, i); case r2: l = 8, a |= 24; break; case r3: return (e = t(12, r, i, 2 | a)).elementType = r3, e.lanes = o, e; case r9: return (e = t(13, r, i, a)).elementType = r9, e.lanes = o, e; case r7: return (e = t(19, r, i, a)).elementType = r7, e.lanes = o, e; case ni: return rB(r, a, o, i); default: if ("object" == typeof e && null !== e) switch (e.$$typeof) { case r4: case r8: l = 10; break e; case r5: l = 9; break e; case r6: l = 11; break e; case ne: l = 14; break e; case nt: l = 16, n = null; break e }l = 29, r = Error(s(130, null === e ? "null" : typeof e, "")), n = null }return (i = t(l, r, i, a)).elementType = e, i.type = n, i.lanes = o, i } function rN(e, i, r, n) { return (e = t(7, e, n, i)).lanes = r, e } function rB(e, i, r, n) { (e = t(22, e, n, i)).elementType = ni, e.lanes = r; var a = { _visibility: 1, _pendingVisibility: 1, _pendingMarkers: null, _retryCache: null, _transitions: null, _current: null, detach: function () { var e = a._current; if (null === e) throw Error(s(456)); if (0 == (2 & a._pendingVisibility)) { var t = Y(e, 2); null !== t && (a._pendingVisibility |= 2, rn(t, e, 2)) } }, attach: function () { var e = a._current; if (null === e) throw Error(s(456)); if (0 != (2 & a._pendingVisibility)) { var t = Y(e, 2); null !== t && (a._pendingVisibility &= -3, rn(t, e, 2)) } } }; return e.stateNode = a, e } function rz(e, i, r) { return (e = t(6, e, null, i)).lanes = r, e } function rG(e, i, r) { return (i = t(4, null !== e.children ? e.children : [], e.key, i)).lanes = r, i.stateNode = { containerInfo: e.containerInfo, pendingChildren: null, implementation: e.implementation }, i } function rH(e, t, i, r, n, s, a, o) { this.tag = 1, this.containerInfo = e, this.finishedWork = this.pingCache = this.current = this.pendingChildren = null, this.timeoutHandle = nw, this.callbackNode = this.next = this.pendingContext = this.context = this.cancelPendingCommit = null, this.callbackPriority = 0, this.expirationTimes = _(-1), this.entangledLanes = this.shellSuspendCounter = this.errorRecoveryDisabledLanes = this.finishedLanes = this.expiredLanes = this.warmLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0, this.entanglements = _(0), this.hiddenUpdates = _(null), this.identifierPrefix = r, this.onUncaughtError = n, this.onCaughtError = s, this.onRecoverableError = a, this.pooledCache = null, this.pooledCacheLanes = 0, this.formState = o, this.incompleteTransitions = new Map } function rV(e, i, r, n, s, a, o, l, u, h, c, d) { return e = new rH(e, i, r, o, l, u, h, d), i = 1, !0 === a && (i |= 24), a = t(3, null, null, i), e.current = a, a.stateNode = e, i = id(), i.refCount++, e.pooledCache = i, i.refCount++, a.memoizedState = { element: n, isDehydrated: r, cache: i }, er(a), e } function rW(e) { var t = e._reactInternals; if (void 0 === t) { if ("function" == typeof e.render) throw Error(s(188)); throw Error(s(268, e = Object.keys(e).join(","))) } return null === (e = null !== (e = f(t)) ? function e(t) { var i = t.tag; if (5 === i || 26 === i || 27 === i || 6 === i) return t; for (t = t.child; null !== t;) { if (null !== (i = e(t))) return i; t = t.sibling } return null }(e) : null) ? null : np(e.stateNode) } function rj(e, t, i, r, n, s) { var a; n = s8, null === r.context ? r.context = n : r.pendingContext = n, (r = es(t)).payload = { element: i }, null !== (s = void 0 === s ? null : s) && (r.callback = s), null !== (i = ea(e, r, t)) && (rn(i, e, t), eo(i, e, t)) } function rY(e, t) { if (null !== (e = e.memoizedState) && null !== e.dehydrated) { var i = e.retryLane; e.retryLane = 0 !== i && i < t ? i : t } } function rX(e, t) { rY(e, t), (e = e.alternate) && rY(e, t) } var rK = {}, rq = i(6540), rQ = i(9982), rZ = Object.assign, r$ = Symbol.for("react.element"), rJ = Symbol.for("react.transitional.element"), r0 = Symbol.for("react.portal"), r1 = Symbol.for("react.fragment"), r2 = Symbol.for("react.strict_mode"), r3 = Symbol.for("react.profiler"), r4 = Symbol.for("react.provider"), r5 = Symbol.for("react.consumer"), r8 = Symbol.for("react.context"), r6 = Symbol.for("react.forward_ref"), r9 = Symbol.for("react.suspense"), r7 = Symbol.for("react.suspense_list"), ne = Symbol.for("react.memo"), nt = Symbol.for("react.lazy"); Symbol.for("react.scope"), Symbol.for("react.debug_trace_mode"); var ni = Symbol.for("react.offscreen"); Symbol.for("react.legacy_hidden"), Symbol.for("react.tracing_marker"); var nr, nn, ns = Symbol.for("react.memo_cache_sentinel"), na = Symbol.iterator, no = Symbol.for("react.client.reference"), nl = rq.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, nu = !1, nh = Array.isArray, nc = e.rendererVersion, nd = e.rendererPackageName, nf = e.extraDevToolsConfig, np = e.getPublicInstance, nm = e.getRootHostContext, ng = e.getChildHostContext, nv = e.prepareForCommit, ny = e.resetAfterCommit, nx = e.createInstance, nS = e.appendInitialChild, nA = e.finalizeInitialChildren, n_ = e.shouldSetTextContent, nE = e.createTextInstance, nb = e.scheduleTimeout, nT = e.cancelTimeout, nw = e.noTimeout, nM = e.isPrimaryRenderer; e.warnsIfNotActing; var nR = e.supportsMutation, nC = e.supportsPersistence, nI = e.supportsHydration, nL = e.getInstanceFromNode; e.beforeActiveInstanceBlur, e.afterActiveInstanceBlur; var nP = e.preparePortalMount; e.prepareScopeUpdate, e.getInstanceFromScope; var nD = e.setCurrentUpdatePriority, nO = e.getCurrentUpdatePriority, nk = e.resolveUpdatePriority; e.resolveEventType, e.resolveEventTimeStamp; var nF = e.shouldAttemptEagerTransition, nU = e.detachDeletedInstance; e.requestPostPaintCallback; var nN = e.maySuspendCommit, nB = e.preloadInstance, nz = e.startSuspendingCommit, nG = e.suspendInstance, nH = e.waitForCommitToBeReady, nV = e.NotPendingTransition, nW = e.HostTransitionContext, nj = e.resetFormInstance; e.bindToConsole; var nY = e.supportsMicrotasks, nX = e.scheduleMicrotask, nK = e.supportsTestSelectors, nq = e.findFiberRoot, nQ = e.getBoundingRect, nZ = e.getTextContent, n$ = e.isHiddenSubtree, nJ = e.matchAccessibilityRole, n0 = e.setFocusIfFocusable, n1 = e.setupIntersectionObserver, n2 = e.appendChild, n3 = e.appendChildToContainer, n4 = e.commitTextUpdate, n5 = e.commitMount, n8 = e.commitUpdate, n6 = e.insertBefore, n9 = e.insertInContainerBefore, n7 = e.removeChild, se = e.removeChildFromContainer, st = e.resetTextContent, si = e.hideInstance, sr = e.hideTextInstance, sn = e.unhideInstance, ss = e.unhideTextInstance, sa = e.clearContainer, so = e.cloneInstance, sl = e.createContainerChildSet, su = e.appendChildToContainerChildSet, sh = e.finalizeContainerChildren, sc = e.replaceContainerChildren, sd = e.cloneHiddenInstance, sf = e.cloneHiddenTextInstance, sp = e.isSuspenseInstancePending, sm = e.isSuspenseInstanceFallback, sg = e.getSuspenseInstanceFallbackErrorDetails, sv = e.registerSuspenseInstanceRetry, sy = e.canHydrateFormStateMarker, sx = e.isFormStateMarkerMatching, sS = e.getNextHydratableSibling, sA = e.getFirstHydratableChild, s_ = e.getFirstHydratableChildWithinContainer, sE = e.getFirstHydratableChildWithinSuspenseInstance, sb = e.canHydrateInstance, sT = e.canHydrateTextInstance, sw = e.canHydrateSuspenseInstance, sM = e.hydrateInstance, sR = e.hydrateTextInstance, sC = e.hydrateSuspenseInstance, sI = e.getNextHydratableInstanceAfterSuspenseInstance, sL = e.commitHydratedContainer, sP = e.commitHydratedSuspenseInstance, sD = e.clearSuspenseBoundary, sO = e.clearSuspenseBoundaryFromContainer, sk = e.shouldDeleteUnhydratedTailInstances; e.diffHydratedPropsForDevWarnings, e.diffHydratedTextForDevWarnings, e.describeHydratableInstanceForDevWarnings; var sF = e.validateHydratableInstance, sU = e.validateHydratableTextInstance, sN = e.supportsResources, sB = e.isHostHoistableType, sz = e.getHoistableRoot, sG = e.getResource, sH = e.acquireResource, sV = e.releaseResource, sW = e.hydrateHoistable, sj = e.mountHoistable, sY = e.unmountHoistable, sX = e.createHoistableInstance, sK = e.prepareToCommitHoistables, sq = e.mayResourceSuspendCommit, sQ = e.preloadResource, sZ = e.suspendResource, s$ = e.supportsSingletons, sJ = e.resolveSingletonInstance, s0 = e.clearSingleton, s1 = e.acquireSingletonInstance, s2 = e.releaseSingletonInstance, s3 = e.isHostSingletonType, s4 = [], s5 = -1, s8 = {}, s6 = Math.clz32 ? Math.clz32 : function (e) { return 0 == (e >>>= 0) ? 32 : 31 - (s9(e) / s7 | 0) | 0 }, s9 = Math.log, s7 = Math.LN2, ae = 128, at = 4194304, ai = rQ.unstable_scheduleCallback, ar = rQ.unstable_cancelCallback, an = rQ.unstable_shouldYield, as = rQ.unstable_requestPaint, aa = rQ.unstable_now, ao = rQ.unstable_ImmediatePriority, al = rQ.unstable_UserBlockingPriority, au = rQ.unstable_NormalPriority, ah = rQ.unstable_IdlePriority, ac = rQ.log, ad = rQ.unstable_setDisableYieldValue, af = null, ap = null, am = "function" == typeof Object.is ? Object.is : function (e, t) { return e === t && (0 !== e || 1 / e == 1 / t) || e != e && t != t }, ag = new WeakMap, av = [], ay = 0, ax = null, aS = 0, aA = [], a_ = 0, aE = null, ab = 1, aT = "", aw = p(null), aM = p(null), aR = p(null), aC = p(null), aI = null, aL = null, aP = !1, aD = null, aO = !1, ak = Error(s(519)), aF = [], aU = 0, aN = 0, aB = null, az = null, aG = !1, aH = !1, aV = !1, aW = 0, aj = null, aY = 0, aX = 0, aK = null, aq = !1, aQ = !1, aZ = Object.prototype.hasOwnProperty, a$ = Error(s(460)), aJ = Error(s(474)), a0 = { then: function () { } }, a1 = null, a2 = null, a3 = 0, a4 = e_(!0), a5 = e_(!1), a8 = p(null), a6 = p(0), a9 = p(null), a7 = null, oe = p(0), ot = 0, oi = null, or = null, on = null, os = !1, oa = !1, oo = !1, ol = 0, ou = 0, oh = null, oc = 0, od = function () { return { lastEffect: null, events: null, stores: null, memoCache: null } }, of = { readContext: iu, use: eV, useCallback: eL, useContext: eL, useEffect: eL, useImperativeHandle: eL, useLayoutEffect: eL, useInsertionEffect: eL, useMemo: eL, useReducer: eL, useRef: eL, useState: eL, useDebugValue: eL, useDeferredValue: eL, useTransition: eL, useSyncExternalStore: eL, useId: eL }; of.useCacheRefresh = eL, of.useMemoCache = eL, of.useHostTransitionStatus = eL, of.useFormState = eL, of.useActionState = eL, of.useOptimistic = eL; var op = { readContext: iu, use: eV, useCallback: function (e, t) { return ez().memoizedState = [e, void 0 === t ? null : t], e }, useContext: iu, useEffect: tu, useImperativeHandle: function (e, t, i) { i = null != i ? i.concat([e]) : null, to(4194308, 4, tf.bind(null, t, e), i) }, useLayoutEffect: function (e, t) { return to(4194308, 4, e, t) }, useInsertionEffect: function (e, t) { to(4, 2, e, t) }, useMemo: function (e, t) { var i = ez(); t = void 0 === t ? null : t; var r = e(); if (oo) { M(!0); try { e() } finally { M(!1) } } return i.memoizedState = [r, t], r }, useReducer: function (e, t, i) { var r = ez(); if (void 0 !== i) { var n = i(t); if (oo) { M(!0); try { i(t) } finally { M(!1) } } } else n = t; return r.memoizedState = r.baseState = n, e = { pending: null, lanes: 0, dispatch: null, lastRenderedReducer: e, lastRenderedState: n }, r.queue = e, e = e.dispatch = tw.bind(null, oi, e), [r.memoizedState, e] }, useRef: function (e) { return e = { current: e }, ez().memoizedState = e }, useState: function (e) { var t = (e = e1(e)).queue, i = tM.bind(null, oi, t); return t.dispatch = i, [e.memoizedState, i] }, useDebugValue: tm, useDeferredValue: function (e, t) { return ty(ez(), e, t) }, useTransition: function () { var e = e1(!1); return e = tS.bind(null, oi, e.queue, !0, !1), ez().memoizedState = e, [!1, e] }, useSyncExternalStore: function (e, t, i) { var r = oi, n = ez(); if (aP) { if (void 0 === i) throw Error(s(407)); i = i() } else { if (i = t(), null === oQ) throw Error(s(349)); 0 != (60 & o$) || eQ(r, t, i) } n.memoizedState = i; var a = { value: i, getSnapshot: t }; return n.queue = a, tu(e$.bind(null, r, a, e), [e]), r.flags |= 2048, ts(9, eZ.bind(null, r, a, i, t), { destroy: void 0 }, null), i }, useId: function () { var e = ez(), t = oQ.identifierPrefix; if (aP) { var i = aT, r = ab; t = ":" + t + "R" + (i = (r & ~(1 << 32 - s6(r) - 1)).toString(32) + i), 0 < (i = ol++) && (t += "H" + i.toString(32)), t += ":" } else t = ":" + t + "r" + (i = oc++).toString(32) + ":"; return e.memoizedState = t }, useCacheRefresh: function () { return ez().memoizedState = tT.bind(null, oi) } }; op.useMemoCache = eW, op.useHostTransitionStatus = t_, op.useFormState = te, op.useActionState = te, op.useOptimistic = function (e) { var t = ez(); t.memoizedState = t.baseState = e; var i = { pending: null, lanes: 0, dispatch: null, lastRenderedReducer: null, lastRenderedState: null }; return t.queue = i, t = tC.bind(null, oi, !0, i), i.dispatch = t, [e, t] }; var om = { readContext: iu, use: eV, useCallback: tg, useContext: iu, useEffect: th, useImperativeHandle: tp, useInsertionEffect: tc, useLayoutEffect: td, useMemo: tv, useReducer: eY, useRef: ta, useState: function () { return eY(ej) }, useDebugValue: tm, useDeferredValue: function (e, t) { return tx(eG(), or.memoizedState, e, t) }, useTransition: function () { var e = eY(ej)[0], t = eG().memoizedState; return ["boolean" == typeof e ? e : eH(e), t] }, useSyncExternalStore: eq, useId: tE }; om.useCacheRefresh = tb, om.useMemoCache = eW, om.useHostTransitionStatus = t_, om.useFormState = tt, om.useActionState = tt, om.useOptimistic = function (e, t) { return e2(eG(), or, e, t) }; var og = { readContext: iu, use: eV, useCallback: tg, useContext: iu, useEffect: th, useImperativeHandle: tp, useInsertionEffect: tc, useLayoutEffect: td, useMemo: tv, useReducer: eK, useRef: ta, useState: function () { return eK(ej) }, useDebugValue: tm, useDeferredValue: function (e, t) { var i = eG(); return null === or ? ty(i, e, t) : tx(i, or.memoizedState, e, t) }, useTransition: function () { var e = eK(ej)[0], t = eG().memoizedState; return ["boolean" == typeof e ? e : eH(e), t] }, useSyncExternalStore: eq, useId: tE }; og.useCacheRefresh = tb, og.useMemoCache = eW, og.useHostTransitionStatus = t_, og.useFormState = tn, og.useActionState = tn, og.useOptimistic = function (e, t) { var i = eG(); return null !== or ? e2(i, or, e, t) : (i.baseState = e, [e, i.queue.dispatch]) }; var ov = { isMounted: function (e) { return !!(e = e._reactInternals) && c(e) === e }, enqueueSetState: function (e, t, i) { e = e._reactInternals; var r = ri(), n = es(r); n.payload = t, null != i && (n.callback = i), null !== (t = ea(e, n, r)) && (rn(t, e, r), eo(t, e, r)) }, enqueueReplaceState: function (e, t, i) { e = e._reactInternals; var r = ri(), n = es(r); n.tag = 1, n.payload = t, null != i && (n.callback = i), null !== (t = ea(e, n, r)) && (rn(t, e, r), eo(t, e, r)) }, enqueueForceUpdate: function (e, t) { e = e._reactInternals; var i = ri(), r = es(i); r.tag = 2, null != t && (r.callback = t), null !== (t = ea(e, r, i)) && (rn(t, e, i), eo(t, e, i)) } }, oy = "function" == typeof reportError ? reportError : function (e) { if ("object" == typeof window && "function" == typeof window.ErrorEvent) { var t = new window.ErrorEvent("error", { bubbles: !0, cancelable: !0, message: "object" == typeof e && null !== e && "string" == typeof e.message ? String(e.message) : String(e), error: e }); if (!window.dispatchEvent(t)) return } else if ("object" == typeof r && "function" == typeof r.emit) { r.emit("uncaughtException", e); return } console.error(e) }, ox = Error(s(461)), oS = !1, oA = { dehydrated: null, treeContext: null, retryLane: 0 }, o_ = p(null), oE = null, ob = null, oT = "undefined" != typeof AbortController ? AbortController : function () { var e = [], t = this.signal = { aborted: !1, addEventListener: function (t, i) { e.push(i) } }; this.abort = function () { t.aborted = !0, e.forEach(function (e) { return e() }) } }, ow = rQ.unstable_scheduleCallback, oM = rQ.unstable_NormalPriority, oR = { $$typeof: r8, Consumer: null, Provider: null, _currentValue: null, _currentValue2: null, _threadCount: 0 }, oC = nl.S; nl.S = function (e, t) { "object" == typeof t && null !== t && "function" == typeof t.then && function (e, t) { if (null === aj) { var i = aj = []; aY = 0, aX = et(), aK = { status: "pending", value: void 0, then: function (e) { i.push(e) } } } aY++, t.then(ei, ei) }(0, t), null !== oC && oC(e, t) }; var oI = p(null), oL = !1, oP = !1, oD = !1, oO = "function" == typeof WeakSet ? WeakSet : Set, ok = null, oF = !1, oU = null, oN = !1, oB = null, oz = 8192, oG = { getCacheForType: function (e) { var t = iu(oR), i = t.data.get(e); return void 0 === i && (i = e(), t.data.set(e, i)), i } }, oH = 0, oV = 1, oW = 2, oj = 3, oY = 4; if ("function" == typeof Symbol && Symbol.for) { var oX = Symbol.for; oH = oX("selector.component"), oV = oX("selector.has_pseudo_class"), oW = oX("selector.role"), oj = oX("selector.test_id"), oY = oX("selector.text") } var oK = "function" == typeof WeakMap ? WeakMap : Map, oq = 0, oQ = null, oZ = null, o$ = 0, oJ = 0, o0 = null, o1 = !1, o2 = !1, o3 = !1, o4 = 0, o5 = 0, o8 = 0, o6 = 0, o9 = 0, o7 = 0, le = 0, lt = null, li = null, lr = !1, ln = 0, ls = 1 / 0, la = null, lo = null, ll = !1, lu = null, lh = 0, lc = 0, ld = null, lf = 0, lp = null; return rK.attemptContinuousHydration = function (e) { if (13 === e.tag) { var t = Y(e, 0x4000000); null !== t && rn(t, e, 0x4000000), rX(e, 0x4000000) } }, rK.attemptHydrationAtCurrentPriority = function (e) { if (13 === e.tag) { var t = ri(), i = Y(e, t); null !== i && rn(i, e, t), rX(e, t) } }, rK.attemptSynchronousHydration = function (e) { switch (e.tag) { case 3: if ((e = e.stateNode).current.memoizedState.isDehydrated) { var t = v(e.pendingLanes); if (0 !== t) { for (e.pendingLanes |= 2, e.entangledLanes |= 2; t;) { var i = 1 << 31 - s6(t); e.entanglements[1] |= i, t &= ~i } q(e), 0 == (6 & oq) && (ls = aa() + 500, Q(0, !1)) } } break; case 13: null !== (t = Y(e, 2)) && rn(t, e, 2), ru(), rX(e, 2) } }, rK.batchedUpdates = function (e, t) { return e(t) }, rK.createComponentSelector = function (e) { return { $$typeof: oH, value: e } }, rK.createContainer = function (e, t, i, r, n, s, a, o, l, u) { return rV(e, t, !1, null, i, r, s, a, o, l, u, null) }, rK.createHasPseudoClassSelector = function (e) { return { $$typeof: oV, value: e } }, rK.createHydrationContainer = function (e, t, i, r, n, s, a, o, l, u, h, c, d) { return (e = rV(i, r, !0, e, n, s, o, l, u, h, c, d)).context = s8, i = e.current, (n = es(r = ri())).callback = null != t ? t : null, ea(i, n, r), e.current.lanes = r, E(e, r), q(e), e }, rK.createPortal = function (e, t, i) { var r = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null; return { $$typeof: r0, key: null == r ? null : "" + r, children: e, containerInfo: t, implementation: i } }, rK.createRoleSelector = function (e) { return { $$typeof: oW, value: e } }, rK.createTestNameSelector = function (e) { return { $$typeof: oj, value: e } }, rK.createTextSelector = function (e) { return { $$typeof: oY, value: e } }, rK.defaultOnCaughtError = function (e) { console.error(e) }, rK.defaultOnRecoverableError = function (e) { oy(e) }, rK.defaultOnUncaughtError = function (e) { oy(e) }, rK.deferredUpdates = function (e) { var t = nl.T, i = nO(); try { return nD(32), nl.T = null, e() } finally { nD(i), nl.T = t } }, rK.discreteUpdates = function (e, t, i, r, n) { var s = nl.T, a = nO(); try { return nD(2), nl.T = null, e(t, i, r, n) } finally { nD(a), nl.T = s, 0 === oq && (ls = aa() + 500) } }, rK.findAllNodes = rt, rK.findBoundingRects = function (e, t) { if (!nK) throw Error(s(363)); t = rt(e, t), e = []; for (var i = 0; i < t.length; i++)e.push(nQ(t[i])); for (t = e.length - 1; 0 < t; t--) { i = e[t]; for (var r = i.x, n = r + i.width, a = i.y, o = a + i.height, l = t - 1; 0 <= l; l--)if (t !== l) { var u = e[l], h = u.x, c = h + u.width, d = u.y, f = d + u.height; if (r >= h && a >= d && n <= c && o <= f) { e.splice(t, 1); break } if (r !== h || i.width !== u.width || f < a || d > o) { if (!(a !== d || i.height !== u.height || c < r || h > n)) { h > r && (u.width += h - r, u.x = r), c < n && (u.width = n - h), e.splice(t, 1); break } } else { d > a && (u.height += d - a, u.y = a), f < o && (u.height = o - d), e.splice(t, 1); break } } } return e }, rK.findHostInstance = rW, rK.findHostInstanceWithNoPortals = function (e) { return null === (e = null !== (e = f(e)) ? function e(t) { var i = t.tag; if (5 === i || 26 === i || 27 === i || 6 === i) return t; for (t = t.child; null !== t;) { if (4 !== t.tag && null !== (i = e(t))) return i; t = t.sibling } return null }(e) : null) ? null : np(e.stateNode) }, rK.findHostInstanceWithWarning = function (e) { return rW(e) }, rK.flushPassiveEffects = rT, rK.flushSyncFromReconciler = function (e) { var t = oq; oq |= 1; var i = nl.T, r = nO(); try { if (nD(2), nl.T = null, e) return e() } finally { nD(r), nl.T = i, 0 == (6 & (oq = t)) && Q(0, !1) } }, rK.flushSyncWork = ru, rK.focusWithin = function (e, t) { if (!nK) throw Error(s(363)); for (t = Array.from(t = re(e = i6(e), t)), e = 0; e < t.length;) { var i = t[e++], r = i.tag; if (!n$(i)) { if ((5 === r || 26 === r || 27 === r) && n0(i.stateNode)) return !0; for (i = i.child; null !== i;)t.push(i), i = i.sibling } } return !1 }, rK.getFindAllNodesFailureDescription = function (e, t) { if (!nK) throw Error(s(363)); var i = 0, r = []; e = [i6(e), 0]; for (var n = 0; n < e.length;) { var a = e[n++], o = a.tag, l = e[n++], u = t[l]; if ((5 !== o && 26 !== o && 27 !== o || !n$(a)) && (i9(a, u) && (r.push(i7(u)), ++l > i && (i = l)), l < t.length)) for (a = a.child; null !== a;)e.push(a, l), a = a.sibling } if (i < t.length) { for (e = []; i < t.length; i++)e.push(i7(t[i])); return "findAllNodes was able to match part of the selector:\n  " + r.join(" > ") + "\n\nNo matching component was found for:\n  " + e.join(" > ") } return null }, rK.getPublicRootInstance = function (e) { if (!(e = e.current).child) return null; switch (e.child.tag) { case 27: case 5: return np(e.child.stateNode); default: return e.child.stateNode } }, rK.injectIntoDevTools = function () { var e = { bundleType: 0, version: nc, rendererPackageName: nd, currentDispatcherRef: nl, findFiberByHostInstance: nL, reconcilerVersion: "19.0.0" }; if (null !== nf && (e.rendererConfig = nf), "undefined" == typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) e = !1; else { var t = __REACT_DEVTOOLS_GLOBAL_HOOK__; if (t.isDisabled || !t.supportsFiber) e = !0; else { try { af = t.inject(e), ap = t } catch (e) { } e = !!t.checkDCE } } return e }, rK.isAlreadyRendering = function () { return !1 }, rK.observeVisibleRects = function (e, t, i, r) { if (!nK) throw Error(s(363)); var n = n1(e = rt(e, t), i, r).disconnect; return { disconnect: function () { n() } } }, rK.shouldError = function () { return null }, rK.shouldSuspend = function () { return !1 }, rK.startHostTransition = function (e, t, i, r) { if (5 !== e.tag) throw Error(s(476)); var a = tA(e).queue; tS(e, a, t, nV, null === i ? n : function () { var t = tA(e).next.queue; return tR(e, t, {}, ri()), i(r) }) }, rK.updateContainer = function (e, t, i, r) { var n = t.current, s = ri(); return rj(n, s, e, t, i, r), s }, rK.updateContainerSync = function (e, t, i, r) { return 0 === t.tag && rT(), rj(t.current, 2, e, t, i, r), 2 }, rK }, e.exports.default = e.exports, Object.defineProperty(e.exports, "__esModule", { value: !0 }) }, 772: (e, t, i) => { "use strict"; e.exports = i(2677) }, 4845: (e, t, i) => { "use strict"; e.exports = i(5725) }, 6749: (e, t, i) => { "use strict"; i.d(t, { DY: () => o, IU: () => u, uv: () => l }); let r = e => "object" == typeof e && "function" == typeof e.then, n = []; function s(e, t, i = (e, t) => e === t) { if (e === t) return !0; if (!e || !t) return !1; let r = e.length; if (t.length !== r) return !1; for (let n = 0; n < r; n++)if (!i(e[n], t[n])) return !1; return !0 } function a(e, t = null, i = !1, o = {}) { for (let r of (null === t && (t = [e]), n)) if (s(t, r.keys, r.equal)) { if (i) return; if (Object.prototype.hasOwnProperty.call(r, "error")) throw r.error; if (Object.prototype.hasOwnProperty.call(r, "response")) return o.lifespan && o.lifespan > 0 && (r.timeout && clearTimeout(r.timeout), r.timeout = setTimeout(r.remove, o.lifespan)), r.response; if (!i) throw r.promise } let l = { keys: t, equal: o.equal, remove: () => { let e = n.indexOf(l); -1 !== e && n.splice(e, 1) }, promise: (r(e) ? e : e(...t)).then(e => { l.response = e, o.lifespan && o.lifespan > 0 && (l.timeout = setTimeout(l.remove, o.lifespan)) }).catch(e => l.error = e) }; if (n.push(l), !i) throw l.promise } let o = (e, t, i) => a(e, t, !1, i), l = (e, t, i) => void a(e, t, !0, i), u = e => { if (void 0 === e || 0 === e.length) n.splice(0, n.length); else { let t = n.find(t => s(e, t.keys, t.equal)); t && t.remove() } } }, 874: (e, t, i) => { "use strict"; var r = i(6540), n = "function" == typeof Object.is ? Object.is : function (e, t) { return e === t && (0 !== e || 1 / e == 1 / t) || e != e && t != t }, s = r.useState, a = r.useEffect, o = r.useLayoutEffect, l = r.useDebugValue; function u(e) { var t = e.getSnapshot; e = e.value; try { var i = t(); return !n(e, i) } catch (e) { return !0 } } var h = "undefined" == typeof window || void 0 === window.document || void 0 === window.document.createElement ? function (e, t) { return t() } : function (e, t) { var i = t(), r = s({ inst: { value: i, getSnapshot: t } }), n = r[0].inst, h = r[1]; return o(function () { n.value = i, n.getSnapshot = t, u(n) && h({ inst: n }) }, [e, i, t]), a(function () { return u(n) && h({ inst: n }), e(function () { u(n) && h({ inst: n }) }) }, [e]), l(i), i }; t.useSyncExternalStore = void 0 !== r.useSyncExternalStore ? r.useSyncExternalStore : h }, 2162: (e, t, i) => { "use strict"; var r = i(6540), n = i(9888), s = "function" == typeof Object.is ? Object.is : function (e, t) { return e === t && (0 !== e || 1 / e == 1 / t) || e != e && t != t }, a = n.useSyncExternalStore, o = r.useRef, l = r.useEffect, u = r.useMemo, h = r.useDebugValue; t.useSyncExternalStoreWithSelector = function (e, t, i, r, n) { var c = o(null); if (null === c.current) { var d = { hasValue: !1, value: null }; c.current = d } else d = c.current; var f = a(e, (c = u(function () { function e(e) { if (!l) { if (l = !0, a = e, e = r(e), void 0 !== n && d.hasValue) { var t = d.value; if (n(t, e)) return o = t } return o = e } if (t = o, s(a, e)) return t; var i = r(e); return void 0 !== n && n(t, i) ? (a = e, t) : (a = e, o = i) } var a, o, l = !1, u = void 0 === i ? null : i; return [function () { return e(t()) }, null === u ? void 0 : function () { return e(u()) }] }, [t, i, r, n]))[0], c[1]); return l(function () { d.hasValue = !0, d.value = f }, [f]), h(f), f } }, 9888: (e, t, i) => { "use strict"; e.exports = i(874) }, 9242: (e, t, i) => { "use strict"; e.exports = i(2162) }, 9183: (e, t, i) => { "use strict"; function r() { return (r = Object.assign ? Object.assign.bind() : function (e) { for (var t = 1; t < arguments.length; t++) { var i = arguments[t]; for (var r in i) ({}).hasOwnProperty.call(i, r) && (e[r] = i[r]) } return e }).apply(null, arguments) } i.d(t, { A: () => r }) }, 4164: (e, t, i) => { "use strict"; i.d(t, { A: () => r }); let r = function () { for (var e, t, i = 0, r = "", n = arguments.length; i < n; i++)(e = arguments[i]) && (t = function e(t) { var i, r, n = ""; if ("string" == typeof t || "number" == typeof t) n += t; else if ("object" == typeof t) { if (Array.isArray(t)) { var s = t.length; for (i = 0; i < s; i++)t[i] && (r = e(t[i])) && (n && (n += " "), n += r) } else for (r in t) t[r] && (n && (n += " "), n += r) } return n }(e)) && (r && (r += " "), r += t); return r } }, 3502: (e, t, i) => { "use strict"; i.d(t, { i: () => U, W: () => F }); var r = i(3033), n = i(6620), s = i(7331), a = i(8104), o = i(6896), l = i(1671), u = i(7795); function h(e, t) { return (0, u.h)(e) ? e[(0, l.L)(0, e.length, t)] : e } var c = i(1899), d = i(971), f = i(9896); function p(e) { return "object" == typeof e && !Array.isArray(e) } function m(e, t, i, n) { return "string" == typeof e && p(t) ? (0, r.KJ)(e, i, n) : e instanceof NodeList ? Array.from(e) : Array.isArray(e) ? e : [e] } function g(e, t, i, r) { var n; return "number" == typeof t ? t : t.startsWith("-") || t.startsWith("+") ? Math.max(0, e + parseFloat(t)) : "<" === t ? i : null !== (n = r.get(t)) && void 0 !== n ? n : e } var v = i(2358), y = i(9713); function x(e, t) { return e.at !== t.at ? e.at - t.at : null === e.value ? 1 : null === t.value ? -1 : 0 } function S(e, t) { return t.has(e) || t.set(e, {}), t.get(e) } function A(e, t) { return t[e] || (t[e] = []), t[e] } let _ = e => "number" == typeof e, E = e => e.every(_); var b = i(3379), T = i(1388), w = i(3628), M = i(2159), R = i(963), C = i(4106), I = i(2183); class L extends I.B { constructor() { super(...arguments), this.type = "object" } readValueFromInstance(e, t) { if (t in e) { let i = e[t]; if ("string" == typeof i || "number" == typeof i) return i } } getBaseTargetFromProps() { } removeValueFromRenderState(e, t) { delete t.output[e] } measureInstanceViewportBox() { return (0, C.ge)() } build(e, t) { Object.assign(e.output, t) } renderInstance(e, { output: t }) { Object.assign(e, t) } sortInstanceNodePosition() { return 0 } } function P(e) { let t = { presenceContext: null, props: {}, visualState: { renderState: { transform: {}, transformOrigin: {}, style: {}, vars: {}, attrs: {} }, latestValues: {} } }, i = (0, w.x)(e) ? new M.l(t) : new R.M(t); i.mount(e), b.C.set(e, i) } function D(e) { let t = new L({ presenceContext: null, props: {}, visualState: { renderState: { output: {} }, latestValues: {} } }); t.mount(e), b.C.set(e, t) } var O = i(2956); function k(e, t, i, r) { let n = []; if ((0, f.S)(e) || "number" == typeof e || "string" == typeof e && !p(t)) n.push((0, O.z)(e, p(t) && t.default || t, i && i.default || i)); else { let s = m(e, t, r), o = s.length; (0, a.V)(!!o, "No valid elements provided."); for (let e = 0; e < o; e++) { let r = s[e], a = r instanceof Element ? P : D; b.C.has(r) || a(r); let l = b.C.get(r), u = { ...i }; "delay" in u && "function" == typeof u.delay && (u.delay = u.delay(e, o)), n.push(...(0, T.$)(l, { ...t, transition: u }, {})) } } return n } function F(e) { return function (t, i, l) { let u = []; u = Array.isArray(t) && t.some(Array.isArray) ? function (e, t, i) { let l = []; return (function (e, { defaultTransition: t = {}, ...i } = {}, n, l) { let u = t.duration || .3, p = new Map, _ = new Map, b = {}, T = new Map, w = 0, M = 0, R = 0; for (let i = 0; i < e.length; i++) { let o = e[i]; if ("string" == typeof o) { T.set(o, M); continue } if (!Array.isArray(o)) { T.set(o.name, g(M, o.at, w, T)); continue } let [p, x, C = {}] = o; void 0 !== C.at && (M = g(M, C.at, w, T)); let I = 0, L = (e, i, n, o = 0, f = 0) => { let p = Array.isArray(e) ? e : [e], { delay: m = 0, times: g = (0, c.Z)(p), type: x = "keyframes", repeat: S, repeatType: A, repeatDelay: _ = 0, ...b } = i, { ease: T = t.ease || "easeOut", duration: w } = i, C = "function" == typeof m ? m(o, f) : m, L = p.length, P = (0, r.WH)(x) ? x : null == l ? void 0 : l[x]; if (L <= 2 && P) { let e = 100; 2 === L && E(p) && (e = Math.abs(p[1] - p[0])); let t = { ...b }; void 0 !== w && (t.duration = (0, s.f)(w)); let i = (0, r.XG)(t, e, P); T = i.ease, w = i.duration } null != w || (w = u); let D = M + C; 1 === g.length && 0 === g[0] && (g[1] = 1); let O = g.length - p.length; if (O > 0 && (0, d.f)(g, O), 1 === p.length && p.unshift(null), S) { (0, a.V)(S < 20, "Repeat count too high, must be less than 20"), w *= S + 1; let e = [...p], t = [...g], i = [...T = Array.isArray(T) ? [...T] : [T]]; for (let r = 0; r < S; r++) { p.push(...e); for (let n = 0; n < e.length; n++)g.push(t[n] + (r + 1)), T.push(0 === n ? "linear" : h(i, n - 1)) } !function (e, t) { for (let i = 0; i < e.length; i++)e[i] = e[i] / (t + 1) }(g, S) } let k = D + w; (function (e, t, i, r, n, s) { !function (e, t, i) { for (let r = 0; r < e.length; r++) { let n = e[r]; n.at > t && n.at < i && ((0, v.Ai)(e, n), r--) } }(e, n, s); for (let a = 0; a < t.length; a++)e.push({ value: t[a], at: (0, y.k)(n, s, r[a]), easing: h(i, a) }) })(n, p, T, g, D, k), I = Math.max(C + w, I), R = Math.max(k, R) }; if ((0, f.S)(p)) L(x, C, A("default", S(p, _))); else { let e = m(p, x, n, b), t = e.length; for (let i = 0; i < t; i++) { let r = S(e[i], _); for (let e in x) L(x[e], C && C[e] ? { ...C, ...C[e] } : { ...C }, A(e, r), i, t) } } w = M, M += I } return _.forEach((e, r) => { for (let n in e) { let s = e[n]; s.sort(x); let a = [], l = [], u = []; for (let e = 0; e < s.length; e++) { let { at: t, value: i, easing: r } = s[e]; a.push(i), l.push((0, o.q)(0, R, t)), u.push(r || "easeOut") } 0 !== l[0] && (l.unshift(0), a.unshift(a[0]), u.unshift("easeInOut")), 1 !== l[l.length - 1] && (l.push(1), a.push(null)), p.has(r) || p.set(r, { keyframes: {}, transition: {} }); let h = p.get(r); h.keyframes[n] = a, h.transition[n] = { ...t, duration: R, ease: u, times: l, ...i } } }), p })(e, t, i, { spring: n.o }).forEach(({ keyframes: e, transition: t }, i) => { l.push(...k(i, e, t)) }), l }(t, i, e) : k(t, i, l, e); let p = new r.P6(u); return e && e.animations.push(p), p } } let U = F() }, 2956: (e, t, i) => { "use strict"; i.d(t, { z: () => a }); var r = i(4785), n = i(9896), s = i(5807); function a(e, t, i) { let a = (0, n.S)(e) ? e : (0, r.OQ)(e); return a.start((0, s.f)("", a, t, i)), a.animation } }, 6620: (e, t, i) => { "use strict"; i.d(t, { o: () => f }); var r = i(3033), n = i(7331), s = i(2464), a = i(8426); let o = { stiffness: 100, damping: 10, mass: 1, velocity: 0, duration: 800, bounce: .3, visualDuration: .3, restSpeed: { granular: .01, default: 2 }, restDelta: { granular: .005, default: .5 }, minDuration: .01, maxDuration: 10, minDamping: .05, maxDamping: 1 }; var l = i(8104); function u(e, t) { return e * Math.sqrt(1 - t * t) } let h = ["duration", "bounce"], c = ["stiffness", "damping", "mass"]; function d(e, t) { return t.some(t => void 0 !== e[t]) } function f(e = o.visualDuration, t = o.bounce) { let i; let p = "object" != typeof e ? { visualDuration: e, keyframes: [0, 1], bounce: t } : e, { restSpeed: m, restDelta: g } = p, v = p.keyframes[0], y = p.keyframes[p.keyframes.length - 1], x = { done: !1, value: v }, { stiffness: S, damping: A, mass: _, duration: E, velocity: b, isResolvedFromDuration: T } = function (e) { let t = { velocity: o.velocity, stiffness: o.stiffness, damping: o.damping, mass: o.mass, isResolvedFromDuration: !1, ...e }; if (!d(e, c) && d(e, h)) { if (e.visualDuration) { let i = 2 * Math.PI / (1.2 * e.visualDuration), r = i * i, n = 2 * (0, s.q)(.05, 1, 1 - (e.bounce || 0)) * Math.sqrt(r); t = { ...t, mass: o.mass, stiffness: r, damping: n } } else { let i = function ({ duration: e = o.duration, bounce: t = o.bounce, velocity: i = o.velocity, mass: r = o.mass }) { let a, h; (0, l.$)(e <= (0, n.f)(o.maxDuration), "Spring duration must be 10 seconds or less"); let c = 1 - t; c = (0, s.q)(o.minDamping, o.maxDamping, c), e = (0, s.q)(o.minDuration, o.maxDuration, (0, n.X)(e)), c < 1 ? (a = t => { let r = t * c, n = r * e; return .001 - (r - i) / u(t, c) * Math.exp(-n) }, h = t => { let r = t * c * e, n = Math.pow(c, 2) * Math.pow(t, 2) * e, s = Math.exp(-r), o = u(Math.pow(t, 2), c); return (r * i + i - n) * s * (-a(t) + .001 > 0 ? -1 : 1) / o }) : (a = t => -.001 + Math.exp(-t * e) * ((t - i) * e + 1), h = t => e * e * (i - t) * Math.exp(-t * e)); let d = function (e, t, i) { let r = i; for (let i = 1; i < 12; i++)r -= e(r) / t(r); return r }(a, h, 5 / e); if (e = (0, n.f)(e), isNaN(d)) return { stiffness: o.stiffness, damping: o.damping, duration: e }; { let t = Math.pow(d, 2) * r; return { stiffness: t, damping: 2 * c * Math.sqrt(r * t), duration: e } } }(e); (t = { ...t, ...i, mass: o.mass }).isResolvedFromDuration = !0 } } return t }({ ...p, velocity: -(0, n.X)(p.velocity || 0) }), w = b || 0, M = A / (2 * Math.sqrt(S * _)), R = y - v, C = (0, n.X)(Math.sqrt(S / _)), I = 5 > Math.abs(R); if (m || (m = I ? o.restSpeed.granular : o.restSpeed.default), g || (g = I ? o.restDelta.granular : o.restDelta.default), M < 1) { let e = u(C, M); i = t => y - Math.exp(-M * C * t) * ((w + M * C * R) / e * Math.sin(e * t) + R * Math.cos(e * t)) } else if (1 === M) i = e => y - Math.exp(-C * e) * (R + (w + C * R) * e); else { let e = C * Math.sqrt(M * M - 1); i = t => { let i = Math.exp(-M * C * t), r = Math.min(e * t, 300); return y - i * ((w + M * C * R) * Math.sinh(r) + e * R * Math.cosh(r)) / e } } let L = { calculatedDuration: T && E || null, next: e => { let t = i(e); if (T) x.done = e >= E; else { let r = 0; M < 1 && (r = 0 === e ? (0, n.f)(w) : (0, a.Y)(i, e, t)); let s = Math.abs(r) <= m, o = Math.abs(y - t) <= g; x.done = s && o } return x.value = x.done ? y : t, x }, toString: () => { let e = Math.min((0, r.tu)(L), r.YE), t = (0, r.KZ)(t => L.next(e * t).value, e, 30); return e + "ms " + t } }; return L } }, 8426: (e, t, i) => { "use strict"; i.d(t, { Y: () => n }); var r = i(7177); function n(e, t, i) { let n = Math.max(t - 5, 0); return (0, r.f)(i - e(n), t - n) } }, 4247: (e, t, i) => { "use strict"; i.d(t, { l: () => a }); var r = i(8601), n = i(6540), s = i(3502); function a() { var e; let t = (0, r.M)(() => ({ current: null, animations: [] })), i = (0, r.M)(() => (0, s.W)(t)); return e = () => { t.animations.forEach(e => e.stop()) }, (0, n.useEffect)(() => () => e(), []), [t, i] } }, 5807: (e, t, i) => { "use strict"; i.d(t, { f: () => X }); var r = i(3033), n = i(7331), s = i(104), a = i(4668); let o = { current: !1 }; var l = i(1533), u = i(309), h = i(4768), c = i(4868), d = i(4721), f = i(4582), p = i(4835), m = i(8104), g = i(615); let v = (e, t) => "zIndex" !== t && !!("number" == typeof e || Array.isArray(e) || "string" == typeof e && (g.f.test(e) || "0" === e) && !e.startsWith("url(")), y = e => null !== e; function x(e, { repeat: t, repeatType: i = "loop" }, r) { let n = e.filter(y), s = t && "loop" !== i && t % 2 == 1 ? 0 : n.length - 1; return s && void 0 !== r ? r : n[s] } class S { constructor({ autoplay: e = !0, delay: t = 0, type: i = "keyframes", repeat: r = 0, repeatDelay: n = 0, repeatType: s = "loop", ...a }) { this.isStopped = !1, this.hasAttemptedResolve = !1, this.createdAt = f.k.now(), this.options = { autoplay: e, delay: t, type: i, repeat: r, repeatDelay: n, repeatType: s, ...a }, this.updateFinishedPromise() } calcStartTime() { return this.resolvedAt && this.resolvedAt - this.createdAt > 40 ? this.resolvedAt : this.createdAt } get resolved() { return this._resolved || this.hasAttemptedResolve || (0, p.q)(), this._resolved } onKeyframesResolved(e, t) { this.resolvedAt = f.k.now(), this.hasAttemptedResolve = !0; let { name: i, type: n, velocity: s, delay: a, onComplete: l, onUpdate: u, isGenerator: h } = this.options; if (!h && !function (e, t, i, n) { let s = e[0]; if (null === s) return !1; if ("display" === t || "visibility" === t) return !0; let a = e[e.length - 1], o = v(s, t), l = v(a, t); return (0, m.$)(o === l, `You are trying to animate ${t} from "${s}" to "${a}". ${s} is not an animatable value - to enable this animation set ${s} to a value animatable to ${a} via the \`style\` property.`), !!o && !!l && (function (e) { let t = e[0]; if (1 === e.length) return !0; for (let i = 0; i < e.length; i++)if (e[i] !== t) return !0 }(e) || ("spring" === i || (0, r.WH)(i)) && n) }(e, i, n, s)) { if (o.current || !a) { null == u || u(x(e, this.options, t)), null == l || l(), this.resolveFinishedPromise(); return } this.options.duration = 0 } let c = this.initPlayback(e, t); !1 !== c && (this._resolved = { keyframes: e, finalKeyframe: t, ...c }, this.onPostResolved()) } onPostResolved() { } then(e, t) { return this.currentFinishedPromise.then(e, t) } flatten() { this.options.type = "keyframes", this.options.ease = "linear" } updateFinishedPromise() { this.currentFinishedPromise = new Promise(e => { this.resolveFinishedPromise = e }) } } var A = i(2464), _ = i(8955), E = i(1339), b = i(6620), T = i(8426); function w({ keyframes: e, velocity: t = 0, power: i = .8, timeConstant: r = 325, bounceDamping: n = 10, bounceStiffness: s = 500, modifyTarget: a, min: o, max: l, restDelta: u = .5, restSpeed: h }) { let c, d; let f = e[0], p = { done: !1, value: f }, m = e => void 0 !== o && e < o || void 0 !== l && e > l, g = e => void 0 === o ? l : void 0 === l ? o : Math.abs(o - e) < Math.abs(l - e) ? o : l, v = i * t, y = f + v, x = void 0 === a ? y : a(y); x !== y && (v = x - f); let S = e => -v * Math.exp(-e / r), A = e => x + S(e), _ = e => { let t = S(e), i = A(e); p.done = Math.abs(t) <= u, p.value = p.done ? x : i }, E = e => { m(p.value) && (c = e, d = (0, b.o)({ keyframes: [p.value, g(p.value)], velocity: (0, T.Y)(A, e, p.value), damping: n, stiffness: s, restDelta: u, restSpeed: h })) }; return E(0), { calculatedDuration: null, next: e => { let t = !1; return (d || void 0 !== c || (t = !0, _(e), E(e)), void 0 !== c && e >= c) ? d.next(e - c) : (t || _(e), p) } } } var M = i(3771), R = i(7795), C = i(983), I = i(8844), L = i(1899); function P({ duration: e = 300, keyframes: t, times: i, ease: r = "easeInOut" }) { let n = (0, R.h)(r) ? r.map(C.K) : (0, C.K)(r), s = { done: !1, value: t[0] }, a = (i && i.length === t.length ? i : (0, L.Z)(t)).map(t => t * e), o = (0, I.G)(a, t, { ease: Array.isArray(n) ? n : t.map(() => n || M.am).splice(0, t.length - 1) }); return { calculatedDuration: e, next: t => (s.value = o(t), s.done = t >= e, s) } } let D = e => { let t = ({ timestamp: t }) => e(t); return { start: () => s.Gt.update(t, !0), stop: () => (0, s.WG)(t), now: () => s.uv.isProcessing ? s.uv.timestamp : f.k.now() } }, O = { decay: w, inertia: w, tween: P, keyframes: P, spring: b.o }, k = e => e / 100; class F extends S { constructor(e) { super(e), this.holdTime = null, this.cancelTime = null, this.currentTime = 0, this.playbackSpeed = 1, this.pendingPlayState = "running", this.startTime = null, this.state = "idle", this.stop = () => { if (this.resolver.cancel(), this.isStopped = !0, "idle" === this.state) return; this.teardown(); let { onStop: e } = this.options; e && e() }; let { name: t, motionValue: i, element: r, keyframes: n } = this.options, s = (null == r ? void 0 : r.KeyframeResolver) || p.h; this.resolver = new s(n, (e, t) => this.onKeyframesResolved(e, t), t, i, r), this.resolver.scheduleResolve() } flatten() { super.flatten(), this._resolved && Object.assign(this._resolved, this.initPlayback(this._resolved.keyframes)) } initPlayback(e) { let t, i; let { type: n = "keyframes", repeat: s = 0, repeatDelay: a = 0, repeatType: o, velocity: l = 0 } = this.options, u = (0, r.WH)(n) ? n : O[n] || P; u !== P && "number" != typeof e[0] && (t = (0, E.F)(k, (0, _.j)(e[0], e[1])), e = [0, 100]); let h = u({ ...this.options, keyframes: e }); "mirror" === o && (i = u({ ...this.options, keyframes: [...e].reverse(), velocity: -l })), null === h.calculatedDuration && (h.calculatedDuration = (0, r.tu)(h)); let { calculatedDuration: c } = h, d = c + a; return { generator: h, mirroredGenerator: i, mapPercentToKeyframes: t, calculatedDuration: c, resolvedDuration: d, totalDuration: d * (s + 1) - a } } onPostResolved() { let { autoplay: e = !0 } = this.options; this.play(), "paused" !== this.pendingPlayState && e ? this.state = this.pendingPlayState : this.pause() } tick(e, t = !1) { let { resolved: i } = this; if (!i) { let { keyframes: e } = this.options; return { done: !0, value: e[e.length - 1] } } let { finalKeyframe: r, generator: n, mirroredGenerator: s, mapPercentToKeyframes: a, keyframes: o, calculatedDuration: l, totalDuration: u, resolvedDuration: h } = i; if (null === this.startTime) return n.next(0); let { delay: c, repeat: d, repeatType: f, repeatDelay: p, onUpdate: m } = this.options; this.speed > 0 ? this.startTime = Math.min(this.startTime, e) : this.speed < 0 && (this.startTime = Math.min(e - u / this.speed, this.startTime)), t ? this.currentTime = e : null !== this.holdTime ? this.currentTime = this.holdTime : this.currentTime = Math.round(e - this.startTime) * this.speed; let g = this.currentTime - c * (this.speed >= 0 ? 1 : -1), v = this.speed >= 0 ? g < 0 : g > u; this.currentTime = Math.max(g, 0), "finished" === this.state && null === this.holdTime && (this.currentTime = u); let y = this.currentTime, S = n; if (d) { let e = Math.min(this.currentTime, u) / h, t = Math.floor(e), i = e % 1; !i && e >= 1 && (i = 1), 1 === i && t--, (t = Math.min(t, d + 1)) % 2 && ("reverse" === f ? (i = 1 - i, p && (i -= p / h)) : "mirror" === f && (S = s)), y = (0, A.q)(0, 1, i) * h } let _ = v ? { done: !1, value: o[0] } : S.next(y); a && (_.value = a(_.value)); let { done: E } = _; v || null === l || (E = this.speed >= 0 ? this.currentTime >= u : this.currentTime <= 0); let b = null === this.holdTime && ("finished" === this.state || "running" === this.state && E); return b && void 0 !== r && (_.value = x(o, this.options, r)), m && m(_.value), b && this.finish(), _ } get duration() { let { resolved: e } = this; return e ? (0, n.X)(e.calculatedDuration) : 0 } get time() { return (0, n.X)(this.currentTime) } set time(e) { e = (0, n.f)(e), this.currentTime = e, null !== this.holdTime || 0 === this.speed ? this.holdTime = e : this.driver && (this.startTime = this.driver.now() - e / this.speed) } get speed() { return this.playbackSpeed } set speed(e) { let t = this.playbackSpeed !== e; this.playbackSpeed = e, t && (this.time = (0, n.X)(this.currentTime)) } play() { if (this.resolver.isScheduled || this.resolver.resume(), !this._resolved) { this.pendingPlayState = "running"; return } if (this.isStopped) return; let { driver: e = D, onPlay: t, startTime: i } = this.options; this.driver || (this.driver = e(e => this.tick(e))), t && t(); let r = this.driver.now(); null !== this.holdTime ? this.startTime = r - this.holdTime : this.startTime ? "finished" === this.state && (this.startTime = r) : this.startTime = null != i ? i : this.calcStartTime(), "finished" === this.state && this.updateFinishedPromise(), this.cancelTime = this.startTime, this.holdTime = null, this.state = "running", this.driver.start() } pause() { var e; if (!this._resolved) { this.pendingPlayState = "paused"; return } this.state = "paused", this.holdTime = null !== (e = this.currentTime) && void 0 !== e ? e : 0 } complete() { "running" !== this.state && this.play(), this.pendingPlayState = this.state = "finished", this.holdTime = null } finish() { this.teardown(), this.state = "finished"; let { onComplete: e } = this.options; e && e() } cancel() { null !== this.cancelTime && this.tick(this.cancelTime), this.teardown(), this.updateFinishedPromise() } teardown() { this.state = "idle", this.stopDriver(), this.resolveFinishedPromise(), this.updateFinishedPromise(), this.startTime = this.cancelTime = null, this.resolver.cancel() } stopDriver() { this.driver && (this.driver.stop(), this.driver = void 0) } sample(e) { return this.startTime = 0, this.tick(e, !0) } } let U = new Set(["opacity", "clipPath", "filter", "transform"]), N = (0, i(4435).p)(() => Object.hasOwnProperty.call(Element.prototype, "animate")), B = { anticipate: u.b, backInOut: h.ZZ, circInOut: c.tn }; class z extends S { constructor(e) { super(e); let { name: t, motionValue: i, element: r, keyframes: n } = this.options; this.resolver = new d.K(n, (e, t) => this.onKeyframesResolved(e, t), t, i, r), this.resolver.scheduleResolve() } initPlayback(e, t) { var i, n; let { duration: s = 300, times: a, ease: o, type: l, motionValue: u, name: h, startTime: c } = this.options; if (!(null === (i = u.owner) || void 0 === i ? void 0 : i.current)) return !1; if ("string" == typeof o && (0, r.nL)() && o in B && (o = B[o]), n = this.options, (0, r.WH)(n.type) || "spring" === n.type || !(0, r.yL)(n.ease)) { let { onComplete: t, onUpdate: i, motionValue: r, element: n, ...u } = this.options, h = function (e, t) { let i = new F({ ...t, keyframes: e, repeat: 0, delay: 0, isGenerator: !0 }), r = { done: !1, value: e[0] }, n = [], s = 0; for (; !r.done && s < 2e4;)n.push((r = i.sample(s)).value), s += 10; return { times: void 0, keyframes: n, duration: s - 10, ease: "linear" } }(e, u); 1 === (e = h.keyframes).length && (e[1] = e[0]), s = h.duration, a = h.times, o = h.ease, l = "keyframes" } let d = function (e, t, i, { delay: n = 0, duration: s = 300, repeat: a = 0, repeatType: o = "loop", ease: l = "easeInOut", times: u } = {}) { let h = { [t]: i }; u && (h.offset = u); let c = (0, r.TU)(l, s); return Array.isArray(c) && (h.easing = c), e.animate(h, { delay: n, duration: s, easing: Array.isArray(c) ? "linear" : c, fill: "both", iterations: a + 1, direction: "reverse" === o ? "alternate" : "normal" }) }(u.owner.current, h, e, { ...this.options, duration: s, times: a, ease: o }); return d.startTime = null != c ? c : this.calcStartTime(), this.pendingTimeline ? ((0, r.vG)(d, this.pendingTimeline), this.pendingTimeline = void 0) : d.onfinish = () => { let { onComplete: i } = this.options; u.set(x(e, this.options, t)), i && i(), this.cancel(), this.resolveFinishedPromise() }, { animation: d, duration: s, times: a, type: l, ease: o, keyframes: e } } get duration() { let { resolved: e } = this; if (!e) return 0; let { duration: t } = e; return (0, n.X)(t) } get time() { let { resolved: e } = this; if (!e) return 0; let { animation: t } = e; return (0, n.X)(t.currentTime || 0) } set time(e) { let { resolved: t } = this; if (!t) return; let { animation: i } = t; i.currentTime = (0, n.f)(e) } get speed() { let { resolved: e } = this; if (!e) return 1; let { animation: t } = e; return t.playbackRate } set speed(e) { let { resolved: t } = this; if (!t) return; let { animation: i } = t; i.playbackRate = e } get state() { let { resolved: e } = this; if (!e) return "idle"; let { animation: t } = e; return t.playState } get startTime() { let { resolved: e } = this; if (!e) return null; let { animation: t } = e; return t.startTime } attachTimeline(e) { if (this._resolved) { let { resolved: t } = this; if (!t) return l.l; let { animation: i } = t; (0, r.vG)(i, e) } else this.pendingTimeline = e; return l.l } play() { if (this.isStopped) return; let { resolved: e } = this; if (!e) return; let { animation: t } = e; "finished" === t.playState && this.updateFinishedPromise(), t.play() } pause() { let { resolved: e } = this; if (!e) return; let { animation: t } = e; t.pause() } stop() { if (this.resolver.cancel(), this.isStopped = !0, "idle" === this.state) return; this.resolveFinishedPromise(), this.updateFinishedPromise(); let { resolved: e } = this; if (!e) return; let { animation: t, keyframes: i, duration: r, type: s, ease: a, times: o } = e; if ("idle" === t.playState || "finished" === t.playState) return; if (this.time) { let { motionValue: e, onUpdate: t, onComplete: l, element: u, ...h } = this.options, c = new F({ ...h, keyframes: i, duration: r, type: s, ease: a, times: o, isGenerator: !0 }), d = (0, n.f)(this.time); e.setWithVelocity(c.sample(d - 10).value, c.sample(d).value, 10) } let { onStop: l } = this.options; l && l(), this.cancel() } complete() { let { resolved: e } = this; e && e.animation.finish() } cancel() { let { resolved: e } = this; e && e.animation.cancel() } static supports(e) { let { motionValue: t, name: i, repeatDelay: r, repeatType: n, damping: s, type: a } = e; return N() && i && U.has(i) && t && t.owner && t.owner.current instanceof HTMLElement && !t.owner.getProps().onUpdate && !r && "mirror" !== n && 0 !== s && "inertia" !== a } } var G = i(2443); let H = { type: "spring", stiffness: 500, damping: 25, restSpeed: 10 }, V = e => ({ type: "spring", stiffness: 550, damping: 0 === e ? 2 * Math.sqrt(550) : 30, restSpeed: 10 }), W = { type: "keyframes", duration: .8 }, j = { type: "keyframes", ease: [.25, .1, .35, 1], duration: .3 }, Y = (e, { keyframes: t }) => t.length > 2 ? W : G.f.has(e) ? e.startsWith("scale") ? V(t[1]) : H : j, X = (e, t, i, l = {}, u, h) => c => { let d = (0, r.rU)(l, e) || {}, f = d.delay || l.delay || 0, { elapsed: p = 0 } = l; p -= (0, n.f)(f); let m = { keyframes: Array.isArray(i) ? i : [null, i], ease: "easeOut", velocity: t.getVelocity(), ...d, delay: -p, onUpdate: e => { t.set(e), d.onUpdate && d.onUpdate(e) }, onComplete: () => { c(), d.onComplete && d.onComplete() }, name: e, motionValue: t, element: h ? void 0 : u }; !function ({ when: e, delay: t, delayChildren: i, staggerChildren: r, staggerDirection: n, repeat: s, repeatType: a, repeatDelay: o, from: l, elapsed: u, ...h }) { return !!Object.keys(h).length }(d) && (m = { ...m, ...Y(e, m) }), m.duration && (m.duration = (0, n.f)(m.duration)), m.repeatDelay && (m.repeatDelay = (0, n.f)(m.repeatDelay)), void 0 !== m.from && (m.keyframes[0] = m.from); let g = !1; if (!1 !== m.type && (0 !== m.duration || m.repeatDelay) || (m.duration = 0, 0 !== m.delay || (g = !0)), (o.current || a.W.skipAnimations) && (g = !0, m.duration = 0, m.delay = 0), g && !h && void 0 !== t.get()) { let e = x(m.keyframes, d); if (void 0 !== e) return s.Gt.update(() => { m.onUpdate(e), m.onComplete() }), new r.P6([]) } return !h && z.supports(m) ? new z(m) : new F(m) } }, 1388: (e, t, i) => { "use strict"; i.d(t, { $: () => d }); var r = i(3033), n = i(5972), s = i(7365), a = i(4785), o = i(4737), l = i(9194), u = i(4458), h = i(5807), c = i(104); function d(e, t, { delay: i = 0, transitionOverride: f, type: p } = {}) { var m; let { transition: g = e.getDefaultTransition(), transitionEnd: v, ...y } = t; f && (g = f); let x = [], S = p && e.animationState && e.animationState.getState()[p]; for (let t in y) { let s = e.getValue(t, null !== (m = e.latestValues[t]) && void 0 !== m ? m : null), a = y[t]; if (void 0 === a || S && function ({ protectedKeys: e, needsAnimating: t }, i) { let r = e.hasOwnProperty(i) && !0 !== t[i]; return t[i] = !1, r }(S, t)) continue; let o = { delay: i, ...(0, r.rU)(g || {}, t) }, d = !1; if (window.MotionHandoffAnimation) { let i = (0, u.P)(e); if (i) { let e = window.MotionHandoffAnimation(i, t, c.Gt); null !== e && (o.startTime = e, d = !0) } } (0, l.g)(e, t), s.start((0, h.f)(t, s, a, e.shouldReduceMotion && n.$.has(t) ? { type: !1 } : o, e, d)); let f = s.animation; f && x.push(f) } return v && Promise.all(x).then(() => { c.Gt.update(() => { v && function (e, t) { let { transitionEnd: i = {}, transition: r = {}, ...n } = (0, o.K)(e, t) || {}; for (let t in n = { ...n, ...i }) { let i = (0, s.K)(n[t]); e.hasValue(t) ? e.getValue(t).set(i) : e.addValue(t, (0, a.OQ)(i)) } }(e, v) }) }), x } }, 2392: (e, t, i) => { "use strict"; i.d(t, { n: () => r }); let r = "data-" + (0, i(8062).I)("framerAppearId") }, 4458: (e, t, i) => { "use strict"; i.d(t, { P: () => n }); var r = i(2392); function n(e) { return e.props[r.n] } }, 5490: (e, t, i) => { "use strict"; function r(e) { return null !== e && "object" == typeof e && "function" == typeof e.start } i.d(t, { N: () => r }) }, 1712: (e, t, i) => { "use strict"; i.d(t, { p: () => r }); let r = e => Array.isArray(e) }, 6297: (e, t, i) => {
    "use strict"; i.d(t, { N: () => v }); var r = i(4848), n = i(6540), s = i(9473), a = i(8601), o = i(6719), l = i(5446); class u extends n.Component { getSnapshotBeforeUpdate(e) { let t = this.props.childRef.current; if (t && e.isPresent && !this.props.isPresent) { let e = this.props.sizeRef.current; e.height = t.offsetHeight || 0, e.width = t.offsetWidth || 0, e.top = t.offsetTop, e.left = t.offsetLeft } return null } componentDidUpdate() { } render() { return this.props.children } } function h({ children: e, isPresent: t }) {
      let i = (0, n.useId)(), s = (0, n.useRef)(null), a = (0, n.useRef)({ width: 0, height: 0, top: 0, left: 0 }), { nonce: o } = (0, n.useContext)(l.Q); return (0, n.useInsertionEffect)(() => {
        let { width: e, height: r, top: n, left: l } = a.current; if (t || !s.current || !e || !r) return; s.current.dataset.motionPopId = i; let u = document.createElement("style"); return o && (u.nonce = o), document.head.appendChild(u), u.sheet && u.sheet.insertRule(`
          [data-motion-pop-id="${i}"] {
            position: absolute !important;
            width: ${e}px !important;
            height: ${r}px !important;
            top: ${n}px !important;
            left: ${l}px !important;
          }
        `), () => { document.head.removeChild(u) }
      }, [t]), (0, r.jsx)(u, { isPresent: t, childRef: s, sizeRef: a, children: n.cloneElement(e, { ref: s }) })
    } let c = ({ children: e, initial: t, isPresent: i, onExitComplete: s, custom: l, presenceAffectsLayout: u, mode: c }) => { let f = (0, a.M)(d), p = (0, n.useId)(), m = (0, n.useCallback)(e => { for (let t of (f.set(e, !0), f.values())) if (!t) return; s && s() }, [f, s]), g = (0, n.useMemo)(() => ({ id: p, initial: t, isPresent: i, custom: l, onExitComplete: m, register: e => (f.set(e, !1), () => f.delete(e)) }), u ? [Math.random(), m] : [i, m]); return (0, n.useMemo)(() => { f.forEach((e, t) => f.set(t, !1)) }, [i]), n.useEffect(() => { i || f.size || !s || s() }, [i]), "popLayout" === c && (e = (0, r.jsx)(h, { isPresent: i, children: e })), (0, r.jsx)(o.t.Provider, { value: g, children: e }) }; function d() { return new Map } var f = i(9120); let p = e => e.key || ""; function m(e) { let t = []; return n.Children.forEach(e, e => { (0, n.isValidElement)(e) && t.push(e) }), t } var g = i(5128); let v = ({ children: e, custom: t, initial: i = !0, onExitComplete: o, presenceAffectsLayout: l = !0, mode: u = "sync", propagate: h = !1 }) => { let [d, v] = (0, f.xQ)(h), y = (0, n.useMemo)(() => m(e), [e]), x = h && !d ? [] : y.map(p), S = (0, n.useRef)(!0), A = (0, n.useRef)(y), _ = (0, a.M)(() => new Map), [E, b] = (0, n.useState)(y), [T, w] = (0, n.useState)(y); (0, g.E)(() => { S.current = !1, A.current = y; for (let e = 0; e < T.length; e++) { let t = p(T[e]); x.includes(t) ? _.delete(t) : !0 !== _.get(t) && _.set(t, !1) } }, [T, x.length, x.join("-")]); let M = []; if (y !== E) { let e = [...y]; for (let t = 0; t < T.length; t++) { let i = T[t], r = p(i); x.includes(r) || (e.splice(t, 0, i), M.push(i)) } "wait" === u && M.length && (e = M), w(m(e)), b(y); return } let { forceRender: R } = (0, n.useContext)(s.L); return (0, r.jsx)(r.Fragment, { children: T.map(e => { let n = p(e), s = (!h || !!d) && (y === T || x.includes(n)); return (0, r.jsx)(c, { isPresent: s, initial: (!S.current || !!i) && void 0, custom: s ? void 0 : t, presenceAffectsLayout: l, mode: u, onExitComplete: s ? void 0 : () => { if (!_.has(n)) return; _.set(n, !0); let e = !0; _.forEach(t => { t || (e = !1) }), e && (null == R || R(), w(A.current), h && (null == v || v()), o && o()) }, children: e }, n) }) }) }
  }, 9120: (e, t, i) => { "use strict"; i.d(t, { xQ: () => s }); var r = i(6540), n = i(6719); function s(e = !0) { let t = (0, r.useContext)(n.t); if (null === t) return [!0, null]; let { isPresent: i, onExitComplete: a, register: o } = t, l = (0, r.useId)(); (0, r.useEffect)(() => { e && o(l) }, [e]); let u = (0, r.useCallback)(() => e && a && a(l), [l, a, e]); return !i && a ? [!1, u] : [!0] } }, 9473: (e, t, i) => { "use strict"; i.d(t, { L: () => r }); let r = (0, i(6540).createContext)({}) }, 5446: (e, t, i) => { "use strict"; i.d(t, { Q: () => r }); let r = (0, i(6540).createContext)({ transformPagePoint: e => e, isStatic: !1, reducedMotion: "never" }) }, 6719: (e, t, i) => { "use strict"; i.d(t, { t: () => r }); let r = (0, i(6540).createContext)(null) }, 309: (e, t, i) => { "use strict"; i.d(t, { b: () => n }); var r = i(4768); let n = e => (e *= 2) < 1 ? .5 * (0, r.dg)(e) : .5 * (2 - Math.pow(2, -10 * (e - 1))) }, 4768: (e, t, i) => { "use strict"; i.d(t, { Sz: () => a, ZZ: () => l, dg: () => o }); var r = i(4043), n = i(3041), s = i(2946); let a = (0, r.A)(.33, 1.53, .69, .99), o = (0, s.G)(a), l = (0, n.V)(o) }, 4868: (e, t, i) => { "use strict"; i.d(t, { po: () => s, tn: () => o, yT: () => a }); var r = i(3041), n = i(2946); let s = e => 1 - Math.sin(Math.acos(e)), a = (0, n.G)(s), o = (0, r.V)(s) }, 4043: (e, t, i) => { "use strict"; i.d(t, { A: () => s }); var r = i(1533); let n = (e, t, i) => (((1 - 3 * i + 3 * t) * e + (3 * i - 6 * t)) * e + 3 * t) * e; function s(e, t, i, s) { if (e === t && i === s) return r.l; let a = t => (function (e, t, i, r, s) { let a, o; let l = 0; do (a = n(o = t + (i - t) / 2, r, s) - e) > 0 ? i = o : t = o; while (Math.abs(a) > 1e-7 && ++l < 12); return o })(t, 0, 1, e, i); return e => 0 === e || 1 === e ? e : n(a(e), t, s) } }, 3771: (e, t, i) => { "use strict"; i.d(t, { a6: () => n, am: () => a, vT: () => s }); var r = i(4043); let n = (0, r.A)(.42, 0, 1, 1), s = (0, r.A)(0, 0, .58, 1), a = (0, r.A)(.42, 0, .58, 1) }, 3041: (e, t, i) => { "use strict"; i.d(t, { V: () => r }); let r = e => t => t <= .5 ? e(2 * t) / 2 : (2 - e(2 * (1 - t))) / 2 }, 2946: (e, t, i) => { "use strict"; i.d(t, { G: () => r }); let r = e => t => 1 - e(1 - t) }, 7795: (e, t, i) => { "use strict"; i.d(t, { h: () => r }); let r = e => Array.isArray(e) && "number" != typeof e[0] }, 983: (e, t, i) => { "use strict"; i.d(t, { K: () => d }); var r = i(3033), n = i(1533), s = i(8104), a = i(309), o = i(4768), l = i(4868), u = i(4043), h = i(3771); let c = { linear: n.l, easeIn: h.a6, easeInOut: h.am, easeOut: h.vT, circIn: l.po, circInOut: l.tn, circOut: l.yT, backIn: o.dg, backInOut: o.ZZ, backOut: o.Sz, anticipate: a.b }, d = e => { if ((0, r.DW)(e)) { (0, s.V)(4 === e.length, "Cubic bezier arrays must contain four numerical values."); let [t, i, r, n] = e; return (0, u.A)(t, i, r, n) } return "string" == typeof e ? ((0, s.V)(void 0 !== c[e], `Invalid easing type '${e}'`), c[e]) : e } }, 5489: (e, t, i) => { "use strict"; i.d(t, { I: () => s }); var r = i(4668); let n = ["read", "resolveKeyframes", "update", "preRender", "render", "postRender"]; function s(e, t) { let i = !1, s = !0, a = { delta: 0, timestamp: 0, isProcessing: !1 }, o = () => i = !0, l = n.reduce((e, t) => (e[t] = function (e) { let t = new Set, i = new Set, r = !1, n = !1, s = new WeakSet, a = { delta: 0, timestamp: 0, isProcessing: !1 }; function o(t) { s.has(t) && (l.schedule(t), e()), t(a) } let l = { schedule: (e, n = !1, a = !1) => { let o = a && r ? t : i; return n && s.add(e), o.has(e) || o.add(e), e }, cancel: e => { i.delete(e), s.delete(e) }, process: e => { if (a = e, r) { n = !0; return } r = !0, [t, i] = [i, t], t.forEach(o), t.clear(), r = !1, n && (n = !1, l.process(e)) } }; return l }(o), e), {}), { read: u, resolveKeyframes: h, update: c, preRender: d, render: f, postRender: p } = l, m = () => { let n = r.W.useManualTiming ? a.timestamp : performance.now(); i = !1, a.delta = s ? 1e3 / 60 : Math.max(Math.min(n - a.timestamp, 40), 1), a.timestamp = n, a.isProcessing = !0, u.process(a), h.process(a), c.process(a), d.process(a), f.process(a), p.process(a), a.isProcessing = !1, i && t && (s = !1, e(m)) }, g = () => { i = !0, s = !0, a.isProcessing || e(m) }; return { schedule: n.reduce((e, t) => { let r = l[t]; return e[t] = (e, t = !1, n = !1) => (i || g(), r.schedule(e, t, n)), e }, {}), cancel: e => { for (let t = 0; t < n.length; t++)l[n[t]].cancel(e) }, state: a, steps: l } } }, 104: (e, t, i) => { "use strict"; i.d(t, { Gt: () => n, PP: () => o, WG: () => s, uv: () => a }); var r = i(1533); let { schedule: n, cancel: s, state: a, steps: o } = (0, i(5489).I)("undefined" != typeof requestAnimationFrame ? requestAnimationFrame : r.l, !0) }, 4582: (e, t, i) => { "use strict"; let r; i.d(t, { k: () => o }); var n = i(4668), s = i(104); function a() { r = void 0 } let o = { now: () => (void 0 === r && o.set(s.uv.isProcessing || n.W.useManualTiming ? s.uv.timestamp : performance.now()), r), set: e => { r = e, queueMicrotask(a) } } }, 3996: (e, t, i) => { "use strict"; i.d(t, { B: () => n }); let r = { animation: ["animate", "variants", "whileHover", "whileTap", "exit", "whileInView", "whileFocus", "whileDrag"], exit: ["exit"], drag: ["drag", "dragControls"], focus: ["whileFocus"], hover: ["whileHover", "onHoverStart", "onHoverEnd"], tap: ["whileTap", "onTap", "onTapStart", "onTapCancel"], pan: ["onPan", "onPanStart", "onPanSessionStart", "onPanEnd"], inView: ["whileInView", "onViewportEnter", "onViewportLeave"], layout: ["layout", "layoutId"] }, n = {}; for (let e in r) n[e] = { isEnabled: t => r[e].some(e => !!t[e]) } }, 7549: (e, t, i) => { "use strict"; i.d(t, { z: () => s }); var r = i(8645), n = i(2443); function s(e, { layout: t, layoutId: i }) { return n.f.has(e) || e.startsWith("origin") || (t || void 0 !== i) && (!!r.H[e] || "opacity" === e) } }, 8448: (e, t, i) => { "use strict"; function r({ top: e, left: t, right: i, bottom: r }) { return { x: { min: t, max: i }, y: { min: e, max: r } } } function n({ x: e, y: t }) { return { top: t.min, right: e.max, bottom: t.max, left: e.min } } function s(e, t) { if (!t) return e; let i = t({ x: e.left, y: e.top }), r = t({ x: e.right, y: e.bottom }); return { top: i.y, left: i.x, bottom: r.y, right: r.x } } i.d(t, { FY: () => r, bS: () => s, pA: () => n }) }, 5673: (e, t, i) => { "use strict"; i.d(t, { OU: () => u, Ql: () => h, Ww: () => d, hq: () => s, o4: () => l }); var r = i(9713), n = i(1630); function s(e, t, i) { return i + t * (e - i) } function a(e, t, i, r, n) { return void 0 !== n && (e = r + n * (e - r)), r + i * (e - r) + t } function o(e, t = 0, i = 1, r, n) { e.min = a(e.min, t, i, r, n), e.max = a(e.max, t, i, r, n) } function l(e, { x: t, y: i }) { o(e.x, t.translate, t.scale, t.originPoint), o(e.y, i.translate, i.scale, i.originPoint) } function u(e, t, i, r = !1) { let s, a; let o = i.length; if (o) { t.x = t.y = 1; for (let u = 0; u < o; u++) { a = (s = i[u]).projectionDelta; let { visualElement: o } = s.options; (!o || !o.props.style || "contents" !== o.props.style.display) && (r && s.options.layoutScroll && s.scroll && s !== s.root && d(e, { x: -s.scroll.offset.x, y: -s.scroll.offset.y }), a && (t.x *= a.x.scale, t.y *= a.y.scale, l(e, a)), r && (0, n.HD)(s.latestValues) && d(e, s.latestValues)) } t.x < 1.0000000000001 && t.x > .999999999999 && (t.x = 1), t.y < 1.0000000000001 && t.y > .999999999999 && (t.y = 1) } } function h(e, t) { e.min = e.min + t, e.max = e.max + t } function c(e, t, i, n, s = .5) { let a = (0, r.k)(e.min, e.max, s); o(e, t, i, a, n) } function d(e, t) { c(e.x, t.x, t.scaleX, t.scale, t.originX), c(e.y, t.y, t.scaleY, t.scale, t.originY) } }, 4106: (e, t, i) => { "use strict"; i.d(t, { ge: () => a, xU: () => n }); let r = () => ({ translate: 0, scale: 1, origin: 0, originPoint: 0 }), n = () => ({ x: r(), y: r() }), s = () => ({ min: 0, max: 0 }), a = () => ({ x: s(), y: s() }) }, 8645: (e, t, i) => { "use strict"; i.d(t, { $: () => n, H: () => r }); let r = {}; function n(e) { Object.assign(r, e) } }, 1630: (e, t, i) => { "use strict"; function r(e) { return void 0 === e || 1 === e } function n({ scale: e, scaleX: t, scaleY: i }) { return !r(e) || !r(t) || !r(i) } function s(e) { return n(e) || a(e) || e.z || e.rotate || e.rotateX || e.rotateY || e.skewX || e.skewY } function a(e) { var t, i; return (t = e.x) && "0%" !== t || (i = e.y) && "0%" !== i } i.d(t, { HD: () => s, vF: () => a, vk: () => n }) }, 4805: (e, t, i) => { "use strict"; i.d(t, { L: () => a, m: () => s }); var r = i(8448), n = i(5673); function s(e, t) { return (0, r.FY)((0, r.bS)(e.getBoundingClientRect(), t)) } function a(e, t, i) { let r = s(e, i), { scroll: a } = t; return a && ((0, n.Ql)(r.x, a.offset.x), (0, n.Ql)(r.y, a.offset.y)), r } }, 2183: (e, t, i) => { "use strict"; i.d(t, { B: () => R }); var r = i(4582), n = i(3996), s = i(4106), a = i(9652), o = i(7312), l = i(8288); let u = { current: null }, h = { current: !1 }; var c = i(2606), d = i(4785), f = i(615), p = i(9896), m = i(5320), g = i(7739), v = i(5141), y = i(1969); let x = [...v.T, g.y, f.f], S = e => x.find((0, y.w)(e)); var A = i(2443), _ = i(3379), E = i(837), b = i(4835), T = i(3141), w = i(104); let M = ["AnimationStart", "AnimationComplete", "Update", "BeforeLayoutMeasure", "LayoutMeasure", "LayoutAnimationStart", "LayoutAnimationComplete"]; class R { scrapeMotionValuesFromProps(e, t, i) { return {} } constructor({ parent: e, props: t, presenceContext: i, reducedMotionConfig: n, blockInitialAnimation: s, visualState: a }, o = {}) { this.current = null, this.children = new Set, this.isVariantNode = !1, this.isControllingVariants = !1, this.shouldReduceMotion = null, this.values = new Map, this.KeyframeResolver = b.h, this.features = {}, this.valueSubscriptions = new Map, this.prevMotionValues = {}, this.events = {}, this.propEventSubscriptions = {}, this.notifyUpdate = () => this.notify("Update", this.latestValues), this.render = () => { this.current && (this.triggerBuild(), this.renderInstance(this.current, this.renderState, this.props.style, this.projection)) }, this.renderScheduledAt = 0, this.scheduleRender = () => { let e = r.k.now(); this.renderScheduledAt < e && (this.renderScheduledAt = e, w.Gt.render(this.render, !1, !0)) }; let { latestValues: l, renderState: u, onUpdate: h } = a; this.onUpdate = h, this.latestValues = l, this.baseTarget = { ...l }, this.initialValues = t.initial ? { ...l } : {}, this.renderState = u, this.parent = e, this.props = t, this.presenceContext = i, this.depth = e ? e.depth + 1 : 0, this.reducedMotionConfig = n, this.options = o, this.blockInitialAnimation = !!s, this.isControllingVariants = (0, E.e)(t), this.isVariantNode = (0, E.O)(t), this.isVariantNode && (this.variantChildren = new Set), this.manuallyAnimateOnMount = !!(e && e.current); let { willChange: c, ...d } = this.scrapeMotionValuesFromProps(t, {}, this); for (let e in d) { let t = d[e]; void 0 !== l[e] && (0, p.S)(t) && t.set(l[e], !1) } } mount(e) { this.current = e, _.C.set(e, this), this.projection && !this.projection.instance && this.projection.mount(e), this.parent && this.isVariantNode && !this.isControllingVariants && (this.removeFromVariantTree = this.parent.addVariantChild(this)), this.values.forEach((e, t) => this.bindToMotionValue(t, e)), h.current || function () { if (h.current = !0, l.B) { if (window.matchMedia) { let e = window.matchMedia("(prefers-reduced-motion)"), t = () => u.current = e.matches; e.addListener(t), t() } else u.current = !1 } }(), this.shouldReduceMotion = "never" !== this.reducedMotionConfig && ("always" === this.reducedMotionConfig || u.current), this.parent && this.parent.children.add(this), this.update(this.props, this.presenceContext) } unmount() { for (let e in _.C.delete(this.current), this.projection && this.projection.unmount(), (0, w.WG)(this.notifyUpdate), (0, w.WG)(this.render), this.valueSubscriptions.forEach(e => e()), this.valueSubscriptions.clear(), this.removeFromVariantTree && this.removeFromVariantTree(), this.parent && this.parent.children.delete(this), this.events) this.events[e].clear(); for (let e in this.features) { let t = this.features[e]; t && (t.unmount(), t.isMounted = !1) } this.current = null } bindToMotionValue(e, t) { let i; this.valueSubscriptions.has(e) && this.valueSubscriptions.get(e)(); let r = A.f.has(e), n = t.on("change", t => { this.latestValues[e] = t, this.props.onUpdate && w.Gt.preRender(this.notifyUpdate), r && this.projection && (this.projection.isTransformDirty = !0) }), s = t.on("renderRequest", this.scheduleRender); window.MotionCheckAppearSync && (i = window.MotionCheckAppearSync(this, e, t)), this.valueSubscriptions.set(e, () => { n(), s(), i && i(), t.owner && t.stop() }) } sortNodePosition(e) { return this.current && this.sortInstanceNodePosition && this.type === e.type ? this.sortInstanceNodePosition(this.current, e.current) : 0 } updateFeatures() { let e = "animation"; for (e in n.B) { let t = n.B[e]; if (!t) continue; let { isEnabled: i, Feature: r } = t; if (!this.features[e] && r && i(this.props) && (this.features[e] = new r(this)), this.features[e]) { let t = this.features[e]; t.isMounted ? t.update() : (t.mount(), t.isMounted = !0) } } } triggerBuild() { this.build(this.renderState, this.latestValues, this.props) } measureViewportBox() { return this.current ? this.measureInstanceViewportBox(this.current, this.props) : (0, s.ge)() } getStaticValue(e) { return this.latestValues[e] } setStaticValue(e, t) { this.latestValues[e] = t } update(e, t) { (e.transformTemplate || this.props.transformTemplate) && this.scheduleRender(), this.prevProps = this.props, this.props = e, this.prevPresenceContext = this.presenceContext, this.presenceContext = t; for (let t = 0; t < M.length; t++) { let i = M[t]; this.propEventSubscriptions[i] && (this.propEventSubscriptions[i](), delete this.propEventSubscriptions[i]); let r = e["on" + i]; r && (this.propEventSubscriptions[i] = this.on(i, r)) } this.prevMotionValues = function (e, t, i) { for (let r in t) { let n = t[r], s = i[r]; if ((0, p.S)(n)) e.addValue(r, n); else if ((0, p.S)(s)) e.addValue(r, (0, d.OQ)(n, { owner: e })); else if (s !== n) { if (e.hasValue(r)) { let t = e.getValue(r); !0 === t.liveStyle ? t.jump(n) : t.hasAnimated || t.set(n) } else { let t = e.getStaticValue(r); e.addValue(r, (0, d.OQ)(void 0 !== t ? t : n, { owner: e })) } } } for (let r in i) void 0 === t[r] && e.removeValue(r); return t }(this, this.scrapeMotionValuesFromProps(e, this.prevProps, this), this.prevMotionValues), this.handleChildMotionValue && this.handleChildMotionValue(), this.onUpdate && this.onUpdate(this) } getProps() { return this.props } getVariant(e) { return this.props.variants ? this.props.variants[e] : void 0 } getDefaultTransition() { return this.props.transition } getTransformPagePoint() { return this.props.transformPagePoint } getClosestVariantNode() { return this.isVariantNode ? this : this.parent ? this.parent.getClosestVariantNode() : void 0 } addVariantChild(e) { let t = this.getClosestVariantNode(); if (t) return t.variantChildren && t.variantChildren.add(e), () => t.variantChildren.delete(e) } addValue(e, t) { let i = this.values.get(e); t !== i && (i && this.removeValue(e), this.bindToMotionValue(e, t), this.values.set(e, t), this.latestValues[e] = t.get()) } removeValue(e) { this.values.delete(e); let t = this.valueSubscriptions.get(e); t && (t(), this.valueSubscriptions.delete(e)), delete this.latestValues[e], this.removeValueFromRenderState(e, this.renderState) } hasValue(e) { return this.values.has(e) } getValue(e, t) { if (this.props.values && this.props.values[e]) return this.props.values[e]; let i = this.values.get(e); return void 0 === i && void 0 !== t && (i = (0, d.OQ)(null === t ? void 0 : t, { owner: this }), this.addValue(e, i)), i } readValue(e, t) { var i; let r = void 0 === this.latestValues[e] && this.current ? null !== (i = this.getBaseTargetFromProps(this.props, e)) && void 0 !== i ? i : this.readValueFromInstance(this.current, e, this.options) : this.latestValues[e]; return null != r && ("string" == typeof r && ((0, a.i)(r) || (0, o.$)(r)) ? r = parseFloat(r) : !S(r) && f.f.test(t) && (r = (0, m.J)(e, t)), this.setBaseTarget(e, (0, p.S)(r) ? r.get() : r)), (0, p.S)(r) ? r.get() : r } setBaseTarget(e, t) { this.baseTarget[e] = t } getBaseTarget(e) { var t; let i; let { initial: r } = this.props; if ("string" == typeof r || "object" == typeof r) { let n = (0, T.a)(this.props, r, null === (t = this.presenceContext) || void 0 === t ? void 0 : t.custom); n && (i = n[e]) } if (r && void 0 !== i) return i; let n = this.getBaseTargetFromProps(this.props, e); return void 0 === n || (0, p.S)(n) ? void 0 !== this.initialValues[e] && void 0 === i ? void 0 : this.baseTarget[e] : n } on(e, t) { return this.events[e] || (this.events[e] = new c.v), this.events[e].add(t) } notify(e, ...t) { this.events[e] && this.events[e].notify(...t) } } }, 8343: (e, t, i) => { "use strict"; i.d(t, { P: () => iv }); var r, n, s = i(5490), a = i(1712); function o(e, t) { if (!Array.isArray(t)) return !1; let i = t.length; if (i !== e.length) return !1; for (let r = 0; r < i; r++)if (t[r] !== e[r]) return !1; return !0 } var l = i(6551), u = i(4737), h = i(5092), c = i(1388); function d(e, t, i = {}) { var r; let n = (0, u.K)(e, t, "exit" === i.type ? null === (r = e.presenceContext) || void 0 === r ? void 0 : r.custom : void 0), { transition: s = e.getDefaultTransition() || {} } = n || {}; i.transitionOverride && (s = i.transitionOverride); let a = n ? () => Promise.all((0, c.$)(e, n, i)) : () => Promise.resolve(), o = e.variantChildren && e.variantChildren.size ? (r = 0) => { let { delayChildren: n = 0, staggerChildren: a, staggerDirection: o } = s; return function (e, t, i = 0, r = 0, n = 1, s) { let a = [], o = (e.variantChildren.size - 1) * r, l = 1 === n ? (e = 0) => e * r : (e = 0) => o - e * r; return Array.from(e.variantChildren).sort(f).forEach((e, r) => { e.notify("AnimationStart", t), a.push(d(e, t, { ...s, delay: i + l(r) }).then(() => e.notify("AnimationComplete", t))) }), Promise.all(a) }(e, t, n + r, a, o, i) } : () => Promise.resolve(), { when: l } = s; if (!l) return Promise.all([a(), o(i.delay)]); { let [e, t] = "beforeChildren" === l ? [a, o] : [o, a]; return e().then(() => t()) } } function f(e, t) { return e.sortNodePosition(t) } let p = h._.length, m = [...h.U].reverse(), g = h.U.length; function v(e = !1) { return { isActive: e, protectedKeys: {}, needsAnimating: {}, prevResolvedValues: {} } } function y() { return { animate: v(!0), whileInView: v(), whileHover: v(), whileTap: v(), whileDrag: v(), whileFocus: v(), exit: v() } } class x { constructor(e) { this.isMounted = !1, this.node = e } update() { } } class S extends x { constructor(e) { super(e), e.animationState || (e.animationState = function (e) { let t = t => Promise.all(t.map(({ animation: t, options: i }) => (function (e, t, i = {}) { let r; if (e.notify("AnimationStart", t), Array.isArray(t)) r = Promise.all(t.map(t => d(e, t, i))); else if ("string" == typeof t) r = d(e, t, i); else { let n = "function" == typeof t ? (0, u.K)(e, t, i.custom) : t; r = Promise.all((0, c.$)(e, n, i)) } return r.then(() => { e.notify("AnimationComplete", t) }) })(e, t, i))), i = y(), r = !0, n = t => (i, r) => { var n; let s = (0, u.K)(e, r, "exit" === t ? null === (n = e.presenceContext) || void 0 === n ? void 0 : n.custom : void 0); if (s) { let { transition: e, transitionEnd: t, ...r } = s; i = { ...i, ...r, ...t } } return i }; function f(u) { let { props: c } = e, d = function e(t) { if (!t) return; if (!t.isControllingVariants) { let i = t.parent && e(t.parent) || {}; return void 0 !== t.props.initial && (i.initial = t.props.initial), i } let i = {}; for (let e = 0; e < p; e++) { let r = h._[e], n = t.props[r]; ((0, l.w)(n) || !1 === n) && (i[r] = n) } return i }(e.parent) || {}, f = [], v = new Set, y = {}, x = 1 / 0; for (let t = 0; t < g; t++) { var S; let h = m[t], p = i[h], g = void 0 !== c[h] ? c[h] : d[h], A = (0, l.w)(g), _ = h === u ? p.isActive : null; !1 === _ && (x = t); let E = g === d[h] && g !== c[h] && A; if (E && r && e.manuallyAnimateOnMount && (E = !1), p.protectedKeys = { ...y }, !p.isActive && null === _ || !g && !p.prevProp || (0, s.N)(g) || "boolean" == typeof g) continue; let b = (S = p.prevProp, "string" == typeof g ? g !== S : !!Array.isArray(g) && !o(g, S)), T = b || h === u && p.isActive && !E && A || t > x && A, w = !1, M = Array.isArray(g) ? g : [g], R = M.reduce(n(h), {}); !1 === _ && (R = {}); let { prevResolvedValues: C = {} } = p, I = { ...C, ...R }, L = t => { T = !0, v.has(t) && (w = !0, v.delete(t)), p.needsAnimating[t] = !0; let i = e.getValue(t); i && (i.liveStyle = !1) }; for (let e in I) { let t = R[e], i = C[e]; if (!y.hasOwnProperty(e)) ((0, a.p)(t) && (0, a.p)(i) ? o(t, i) : t === i) ? void 0 !== t && v.has(e) ? L(e) : p.protectedKeys[e] = !0 : null != t ? L(e) : v.add(e) } p.prevProp = g, p.prevResolvedValues = R, p.isActive && (y = { ...y, ...R }), r && e.blockInitialAnimation && (T = !1); let P = !(E && b) || w; T && P && f.push(...M.map(e => ({ animation: e, options: { type: h } }))) } if (v.size) { let t = {}; v.forEach(i => { let r = e.getBaseTarget(i), n = e.getValue(i); n && (n.liveStyle = !0), t[i] = null != r ? r : null }), f.push({ animation: t }) } let A = !!f.length; return r && (!1 === c.initial || c.initial === c.animate) && !e.manuallyAnimateOnMount && (A = !1), r = !1, A ? t(f) : Promise.resolve() } return { animateChanges: f, setActive: function (t, r) { var n; if (i[t].isActive === r) return Promise.resolve(); null === (n = e.variantChildren) || void 0 === n || n.forEach(e => { var i; return null === (i = e.animationState) || void 0 === i ? void 0 : i.setActive(t, r) }), i[t].isActive = r; let s = f(t); for (let e in i) i[e].protectedKeys = {}; return s }, setAnimateFunction: function (i) { t = i(e) }, getState: () => i, reset: () => { i = y(), r = !0 } } }(e)) } updateAnimationControlsSubscription() { let { animate: e } = this.node.getProps(); (0, s.N)(e) && (this.unmountControls = e.subscribe(this.node)) } mount() { this.updateAnimationControlsSubscription() } update() { let { animate: e } = this.node.getProps(), { animate: t } = this.node.prevProps || {}; e !== t && this.updateAnimationControlsSubscription() } unmount() { var e; this.node.animationState.reset(), null === (e = this.unmountControls) || void 0 === e || e.call(this) } } let A = 0; class _ extends x { constructor() { super(...arguments), this.id = A++ } update() { if (!this.node.presenceContext) return; let { isPresent: e, onExitComplete: t } = this.node.presenceContext, { isPresent: i } = this.node.prevPresenceContext || {}; if (!this.node.animationState || e === i) return; let r = this.node.animationState.setActive("exit", !e); t && !e && r.then(() => t(this.id)) } mount() { let { register: e } = this.node.presenceContext || {}; e && (this.unmount = e(this.id)) } unmount() { } } var E = i(1533), b = i(8104), T = i(3033), w = i(7331); function M(e, t, i, r = { passive: !0 }) { return e.addEventListener(t, i, r), () => e.removeEventListener(t, i) } function R(e) { return { point: { x: e.pageX, y: e.pageY } } } let C = e => t => (0, T.Mc)(t) && e(t, R(t)); function I(e, t, i, r) { return M(e, t, C(i), r) } let L = (e, t) => Math.abs(e - t); var P = i(1339), D = i(104); class O { constructor(e, t, { transformPagePoint: i, contextWindow: r, dragSnapToOrigin: n = !1 } = {}) { if (this.startEvent = null, this.lastMoveEvent = null, this.lastMoveEventInfo = null, this.handlers = {}, this.contextWindow = window, this.updatePoint = () => { if (!(this.lastMoveEvent && this.lastMoveEventInfo)) return; let e = U(this.lastMoveEventInfo, this.history), t = null !== this.startEvent, i = function (e, t) { return Math.sqrt(L(e.x, t.x) ** 2 + L(e.y, t.y) ** 2) }(e.offset, { x: 0, y: 0 }) >= 3; if (!t && !i) return; let { point: r } = e, { timestamp: n } = D.uv; this.history.push({ ...r, timestamp: n }); let { onStart: s, onMove: a } = this.handlers; t || (s && s(this.lastMoveEvent, e), this.startEvent = this.lastMoveEvent), a && a(this.lastMoveEvent, e) }, this.handlePointerMove = (e, t) => { this.lastMoveEvent = e, this.lastMoveEventInfo = k(t, this.transformPagePoint), D.Gt.update(this.updatePoint, !0) }, this.handlePointerUp = (e, t) => { this.end(); let { onEnd: i, onSessionEnd: r, resumeAnimation: n } = this.handlers; if (this.dragSnapToOrigin && n && n(), !(this.lastMoveEvent && this.lastMoveEventInfo)) return; let s = U("pointercancel" === e.type ? this.lastMoveEventInfo : k(t, this.transformPagePoint), this.history); this.startEvent && i && i(e, s), r && r(e, s) }, !(0, T.Mc)(e)) return; this.dragSnapToOrigin = n, this.handlers = t, this.transformPagePoint = i, this.contextWindow = r || window; let s = k(R(e), this.transformPagePoint), { point: a } = s, { timestamp: o } = D.uv; this.history = [{ ...a, timestamp: o }]; let { onSessionStart: l } = t; l && l(e, U(s, this.history)), this.removeListeners = (0, P.F)(I(this.contextWindow, "pointermove", this.handlePointerMove), I(this.contextWindow, "pointerup", this.handlePointerUp), I(this.contextWindow, "pointercancel", this.handlePointerUp)) } updateHandlers(e) { this.handlers = e } end() { this.removeListeners && this.removeListeners(), (0, D.WG)(this.updatePoint) } } function k(e, t) { return t ? { point: t(e.point) } : e } function F(e, t) { return { x: e.x - t.x, y: e.y - t.y } } function U({ point: e }, t) { return { point: e, delta: F(e, N(t)), offset: F(e, t[0]), velocity: function (e, t) { if (e.length < 2) return { x: 0, y: 0 }; let i = e.length - 1, r = null, n = N(e); for (; i >= 0 && (r = e[i], !(n.timestamp - r.timestamp > (0, w.f)(.1)));)i--; if (!r) return { x: 0, y: 0 }; let s = (0, w.X)(n.timestamp - r.timestamp); if (0 === s) return { x: 0, y: 0 }; let a = { x: (n.x - r.x) / s, y: (n.y - r.y) / s }; return a.x === 1 / 0 && (a.x = 0), a.y === 1 / 0 && (a.y = 0), a }(t, 0) } } function N(e) { return e[e.length - 1] } function B(e) { return e && "object" == typeof e && Object.prototype.hasOwnProperty.call(e, "current") } var z = i(6896), G = i(9713); function H(e) { return e.max - e.min } function V(e, t, i, r = .5) { e.origin = r, e.originPoint = (0, G.k)(t.min, t.max, e.origin), e.scale = H(i) / H(t), e.translate = (0, G.k)(i.min, i.max, e.origin) - e.originPoint, (e.scale >= .9999 && e.scale <= 1.0001 || isNaN(e.scale)) && (e.scale = 1), (e.translate >= -.01 && e.translate <= .01 || isNaN(e.translate)) && (e.translate = 0) } function W(e, t, i, r) { V(e.x, t.x, i.x, r ? r.originX : void 0), V(e.y, t.y, i.y, r ? r.originY : void 0) } function j(e, t, i) { e.min = i.min + t.min, e.max = e.min + H(t) } function Y(e, t, i) { e.min = t.min - i.min, e.max = e.min + H(t) } function X(e, t, i) { Y(e.x, t.x, i.x), Y(e.y, t.y, i.y) } var K = i(2464); function q(e, t, i) { return { min: void 0 !== t ? e.min + t : void 0, max: void 0 !== i ? e.max + i - (e.max - e.min) : void 0 } } function Q(e, t) { let i = t.min - e.min, r = t.max - e.max; return t.max - t.min < e.max - e.min && ([i, r] = [r, i]), { min: i, max: r } } function Z(e, t, i) { return { min: $(e, t), max: $(e, i) } } function $(e, t) { return "number" == typeof e ? e : e[t] || 0 } var J = i(4106); function ee(e) { return [e("x"), e("y")] } var et = i(4805), ei = i(8448), er = i(5269), en = i(5807); let es = ({ current: e }) => e ? e.ownerDocument.defaultView : null; var ea = i(9194); let eo = new WeakMap; class el { constructor(e) { this.openDragLock = null, this.isDragging = !1, this.currentDirection = null, this.originPoint = { x: 0, y: 0 }, this.constraints = !1, this.hasMutatedConstraints = !1, this.elastic = (0, J.ge)(), this.visualElement = e } start(e, { snapToCursor: t = !1 } = {}) { let { presenceContext: i } = this.visualElement; if (i && !1 === i.isPresent) return; let { dragSnapToOrigin: r } = this.getProps(); this.panSession = new O(e, { onSessionStart: e => { let { dragSnapToOrigin: i } = this.getProps(); i ? this.pauseAnimation() : this.stopAnimation(), t && this.snapToCursor(R(e).point) }, onStart: (e, t) => { let { drag: i, dragPropagation: r, onDragStart: n } = this.getProps(); if (i && !r && (this.openDragLock && this.openDragLock(), this.openDragLock = (0, T.Wp)(i), !this.openDragLock)) return; this.isDragging = !0, this.currentDirection = null, this.resolveConstraints(), this.visualElement.projection && (this.visualElement.projection.isAnimationBlocked = !0, this.visualElement.projection.target = void 0), ee(e => { let t = this.getAxisMotionValue(e).get() || 0; if (er.KN.test(t)) { let { projection: i } = this.visualElement; if (i && i.layout) { let r = i.layout.layoutBox[e]; r && (t = H(r) * (parseFloat(t) / 100)) } } this.originPoint[e] = t }), n && D.Gt.postRender(() => n(e, t)), (0, ea.g)(this.visualElement, "transform"); let { animationState: s } = this.visualElement; s && s.setActive("whileDrag", !0) }, onMove: (e, t) => { let { dragPropagation: i, dragDirectionLock: r, onDirectionLock: n, onDrag: s } = this.getProps(); if (!i && !this.openDragLock) return; let { offset: a } = t; if (r && null === this.currentDirection) { this.currentDirection = function (e, t = 10) { let i = null; return Math.abs(e.y) > t ? i = "y" : Math.abs(e.x) > t && (i = "x"), i }(a), null !== this.currentDirection && n && n(this.currentDirection); return } this.updateAxis("x", t.point, a), this.updateAxis("y", t.point, a), this.visualElement.render(), s && s(e, t) }, onSessionEnd: (e, t) => this.stop(e, t), resumeAnimation: () => ee(e => { var t; return "paused" === this.getAnimationState(e) && (null === (t = this.getAxisMotionValue(e).animation) || void 0 === t ? void 0 : t.play()) }) }, { transformPagePoint: this.visualElement.getTransformPagePoint(), dragSnapToOrigin: r, contextWindow: es(this.visualElement) }) } stop(e, t) { let i = this.isDragging; if (this.cancel(), !i) return; let { velocity: r } = t; this.startAnimation(r); let { onDragEnd: n } = this.getProps(); n && D.Gt.postRender(() => n(e, t)) } cancel() { this.isDragging = !1; let { projection: e, animationState: t } = this.visualElement; e && (e.isAnimationBlocked = !1), this.panSession && this.panSession.end(), this.panSession = void 0; let { dragPropagation: i } = this.getProps(); !i && this.openDragLock && (this.openDragLock(), this.openDragLock = null), t && t.setActive("whileDrag", !1) } updateAxis(e, t, i) { let { drag: r } = this.getProps(); if (!i || !eu(e, r, this.currentDirection)) return; let n = this.getAxisMotionValue(e), s = this.originPoint[e] + i[e]; this.constraints && this.constraints[e] && (s = function (e, { min: t, max: i }, r) { return void 0 !== t && e < t ? e = r ? (0, G.k)(t, e, r.min) : Math.max(e, t) : void 0 !== i && e > i && (e = r ? (0, G.k)(i, e, r.max) : Math.min(e, i)), e }(s, this.constraints[e], this.elastic[e])), n.set(s) } resolveConstraints() { var e; let { dragConstraints: t, dragElastic: i } = this.getProps(), r = this.visualElement.projection && !this.visualElement.projection.layout ? this.visualElement.projection.measure(!1) : null === (e = this.visualElement.projection) || void 0 === e ? void 0 : e.layout, n = this.constraints; t && B(t) ? this.constraints || (this.constraints = this.resolveRefConstraints()) : t && r ? this.constraints = function (e, { top: t, left: i, bottom: r, right: n }) { return { x: q(e.x, i, n), y: q(e.y, t, r) } }(r.layoutBox, t) : this.constraints = !1, this.elastic = function (e = .35) { return !1 === e ? e = 0 : !0 === e && (e = .35), { x: Z(e, "left", "right"), y: Z(e, "top", "bottom") } }(i), n !== this.constraints && r && this.constraints && !this.hasMutatedConstraints && ee(e => { !1 !== this.constraints && this.getAxisMotionValue(e) && (this.constraints[e] = function (e, t) { let i = {}; return void 0 !== t.min && (i.min = t.min - e.min), void 0 !== t.max && (i.max = t.max - e.min), i }(r.layoutBox[e], this.constraints[e])) }) } resolveRefConstraints() { var e; let { dragConstraints: t, onMeasureDragConstraints: i } = this.getProps(); if (!t || !B(t)) return !1; let r = t.current; (0, b.V)(null !== r, "If `dragConstraints` is set as a React ref, that ref must be passed to another component's `ref` prop."); let { projection: n } = this.visualElement; if (!n || !n.layout) return !1; let s = (0, et.L)(r, n.root, this.visualElement.getTransformPagePoint()), a = { x: Q((e = n.layout.layoutBox).x, s.x), y: Q(e.y, s.y) }; if (i) { let e = i((0, ei.pA)(a)); this.hasMutatedConstraints = !!e, e && (a = (0, ei.FY)(e)) } return a } startAnimation(e) { let { drag: t, dragMomentum: i, dragElastic: r, dragTransition: n, dragSnapToOrigin: s, onDragTransitionEnd: a } = this.getProps(), o = this.constraints || {}; return Promise.all(ee(a => { if (!eu(a, t, this.currentDirection)) return; let l = o && o[a] || {}; s && (l = { min: 0, max: 0 }); let u = { type: "inertia", velocity: i ? e[a] : 0, bounceStiffness: r ? 200 : 1e6, bounceDamping: r ? 40 : 1e7, timeConstant: 750, restDelta: 1, restSpeed: 10, ...n, ...l }; return this.startAxisValueAnimation(a, u) })).then(a) } startAxisValueAnimation(e, t) { let i = this.getAxisMotionValue(e); return (0, ea.g)(this.visualElement, e), i.start((0, en.f)(e, i, 0, t, this.visualElement, !1)) } stopAnimation() { ee(e => this.getAxisMotionValue(e).stop()) } pauseAnimation() { ee(e => { var t; return null === (t = this.getAxisMotionValue(e).animation) || void 0 === t ? void 0 : t.pause() }) } getAnimationState(e) { var t; return null === (t = this.getAxisMotionValue(e).animation) || void 0 === t ? void 0 : t.state } getAxisMotionValue(e) { let t = `_drag${e.toUpperCase()}`, i = this.visualElement.getProps(); return i[t] || this.visualElement.getValue(e, (i.initial ? i.initial[e] : void 0) || 0) } snapToCursor(e) { ee(t => { let { drag: i } = this.getProps(); if (!eu(t, i, this.currentDirection)) return; let { projection: r } = this.visualElement, n = this.getAxisMotionValue(t); if (r && r.layout) { let { min: i, max: s } = r.layout.layoutBox[t]; n.set(e[t] - (0, G.k)(i, s, .5)) } }) } scalePositionWithinConstraints() { if (!this.visualElement.current) return; let { drag: e, dragConstraints: t } = this.getProps(), { projection: i } = this.visualElement; if (!B(t) || !i || !this.constraints) return; this.stopAnimation(); let r = { x: 0, y: 0 }; ee(e => { let t = this.getAxisMotionValue(e); if (t && !1 !== this.constraints) { let i = t.get(); r[e] = function (e, t) { let i = .5, r = H(e), n = H(t); return n > r ? i = (0, z.q)(t.min, t.max - r, e.min) : r > n && (i = (0, z.q)(e.min, e.max - n, t.min)), (0, K.q)(0, 1, i) }({ min: i, max: i }, this.constraints[e]) } }); let { transformTemplate: n } = this.visualElement.getProps(); this.visualElement.current.style.transform = n ? n({}, "") : "none", i.root && i.root.updateScroll(), i.updateLayout(), this.resolveConstraints(), ee(t => { if (!eu(t, e, null)) return; let i = this.getAxisMotionValue(t), { min: n, max: s } = this.constraints[t]; i.set((0, G.k)(n, s, r[t])) }) } addListeners() { if (!this.visualElement.current) return; eo.set(this.visualElement, this); let e = I(this.visualElement.current, "pointerdown", e => { let { drag: t, dragListener: i = !0 } = this.getProps(); t && i && this.start(e) }), t = () => { let { dragConstraints: e } = this.getProps(); B(e) && e.current && (this.constraints = this.resolveRefConstraints()) }, { projection: i } = this.visualElement, r = i.addEventListener("measure", t); i && !i.layout && (i.root && i.root.updateScroll(), i.updateLayout()), D.Gt.read(t); let n = M(window, "resize", () => this.scalePositionWithinConstraints()), s = i.addEventListener("didUpdate", ({ delta: e, hasLayoutChanged: t }) => { this.isDragging && t && (ee(t => { let i = this.getAxisMotionValue(t); i && (this.originPoint[t] += e[t].translate, i.set(i.get() + e[t].translate)) }), this.visualElement.render()) }); return () => { n(), e(), r(), s && s() } } getProps() { let e = this.visualElement.getProps(), { drag: t = !1, dragDirectionLock: i = !1, dragPropagation: r = !1, dragConstraints: n = !1, dragElastic: s = .35, dragMomentum: a = !0 } = e; return { ...e, drag: t, dragDirectionLock: i, dragPropagation: r, dragConstraints: n, dragElastic: s, dragMomentum: a } } } function eu(e, t, i) { return (!0 === t || t === e) && (null === i || i === e) } class eh extends x { constructor(e) { super(e), this.removeGroupControls = E.l, this.removeListeners = E.l, this.controls = new el(e) } mount() { let { dragControls: e } = this.node.getProps(); e && (this.removeGroupControls = e.subscribe(this.controls)), this.removeListeners = this.controls.addListeners() || E.l } unmount() { this.removeGroupControls(), this.removeListeners() } } let ec = e => (t, i) => { e && D.Gt.postRender(() => e(t, i)) }; class ed extends x { constructor() { super(...arguments), this.removePointerDownListener = E.l } onPointerDown(e) { this.session = new O(e, this.createPanHandlers(), { transformPagePoint: this.node.getTransformPagePoint(), contextWindow: es(this.node) }) } createPanHandlers() { let { onPanSessionStart: e, onPanStart: t, onPan: i, onPanEnd: r } = this.node.getProps(); return { onSessionStart: ec(e), onStart: ec(t), onMove: i, onEnd: (e, t) => { delete this.session, r && D.Gt.postRender(() => r(e, t)) } } } mount() { this.removePointerDownListener = I(this.node.current, "pointerdown", e => this.onPointerDown(e)) } update() { this.session && this.session.updateHandlers(this.createPanHandlers()) } unmount() { this.removePointerDownListener(), this.session && this.session.end() } } var ef = i(4848), ep = i(6540), em = i(9120), eg = i(9473); let ev = (0, ep.createContext)({}), ey = { hasAnimatedSinceResize: !0, hasEverUpdated: !1 }; function ex(e, t) { return t.max === t.min ? 0 : e / (t.max - t.min) * 100 } let eS = { correct: (e, t) => { if (!t.target) return e; if ("string" == typeof e) { if (!er.px.test(e)) return e; e = parseFloat(e) } let i = ex(e, t.target.x), r = ex(e, t.target.y); return `${i}% ${r}%` } }; var eA = i(615), e_ = i(8645); let { schedule: eE, cancel: eb } = (0, i(5489).I)(queueMicrotask, !1); class eT extends ep.Component { componentDidMount() { let { visualElement: e, layoutGroup: t, switchLayoutGroup: i, layoutId: r } = this.props, { projection: n } = e; (0, e_.$)(eM), n && (t.group && t.group.add(n), i && i.register && r && i.register(n), n.root.didUpdate(), n.addEventListener("animationComplete", () => { this.safeToRemove() }), n.setOptions({ ...n.options, onExitComplete: () => this.safeToRemove() })), ey.hasEverUpdated = !0 } getSnapshotBeforeUpdate(e) { let { layoutDependency: t, visualElement: i, drag: r, isPresent: n } = this.props, s = i.projection; return s && (s.isPresent = n, r || e.layoutDependency !== t || void 0 === t ? s.willUpdate() : this.safeToRemove(), e.isPresent === n || (n ? s.promote() : s.relegate() || D.Gt.postRender(() => { let e = s.getStack(); e && e.members.length || this.safeToRemove() }))), null } componentDidUpdate() { let { projection: e } = this.props.visualElement; e && (e.root.didUpdate(), eE.postRender(() => { !e.currentAnimation && e.isLead() && this.safeToRemove() })) } componentWillUnmount() { let { visualElement: e, layoutGroup: t, switchLayoutGroup: i } = this.props, { projection: r } = e; r && (r.scheduleCheckAfterUnmount(), t && t.group && t.group.remove(r), i && i.deregister && i.deregister(r)) } safeToRemove() { let { safeToRemove: e } = this.props; e && e() } render() { return null } } function ew(e) { let [t, i] = (0, em.xQ)(), r = (0, ep.useContext)(eg.L); return (0, ef.jsx)(eT, { ...e, layoutGroup: r, switchLayoutGroup: (0, ep.useContext)(ev), isPresent: t, safeToRemove: i }) } let eM = { borderRadius: { ...eS, applyTo: ["borderTopLeftRadius", "borderTopRightRadius", "borderBottomLeftRadius", "borderBottomRightRadius"] }, borderTopLeftRadius: eS, borderTopRightRadius: eS, borderBottomLeftRadius: eS, borderBottomRightRadius: eS, boxShadow: { correct: (e, { treeScale: t, projectionDelta: i }) => { let r = eA.f.parse(e); if (r.length > 5) return e; let n = eA.f.createTransformer(e), s = "number" != typeof r[0] ? 1 : 0, a = i.x.scale * t.x, o = i.y.scale * t.y; r[0 + s] /= a, r[1 + s] /= o; let l = (0, G.k)(a, o, .5); return "number" == typeof r[2 + s] && (r[2 + s] /= l), "number" == typeof r[3 + s] && (r[3 + s] /= l), n(r) } } }; var eR = i(2956), eC = i(4458), eI = i(4582), eL = i(3628), eP = i(2358); let eD = (e, t) => e.depth - t.depth; class eO { constructor() { this.children = [], this.isDirty = !1 } add(e) { (0, eP.Kq)(this.children, e), this.isDirty = !0 } remove(e) { (0, eP.Ai)(this.children, e), this.isDirty = !0 } forEach(e) { this.isDirty && this.children.sort(eD), this.isDirty = !1, this.children.forEach(e) } } var ek = i(2606), eF = i(7365), eU = i(9896); function eN(e) { let t = (0, eU.S)(e) ? e.get() : e; return (0, eF.B)(t) ? t.toValue() : t } var eB = i(4868); let ez = ["TopLeft", "TopRight", "BottomLeft", "BottomRight"], eG = ez.length, eH = e => "string" == typeof e ? parseFloat(e) : e, eV = e => "number" == typeof e || er.px.test(e); function eW(e, t) { return void 0 !== e[t] ? e[t] : e.borderRadius } let ej = eX(0, .5, eB.yT), eY = eX(.5, .95, E.l); function eX(e, t, i) { return r => r < e ? 0 : r > t ? 1 : i((0, z.q)(e, t, r)) } function eK(e, t) { e.min = t.min, e.max = t.max } function eq(e, t) { eK(e.x, t.x), eK(e.y, t.y) } function eQ(e, t) { e.translate = t.translate, e.scale = t.scale, e.originPoint = t.originPoint, e.origin = t.origin } var eZ = i(5673); function e$(e, t, i, r, n) { return e -= t, e = (0, eZ.hq)(e, 1 / i, r), void 0 !== n && (e = (0, eZ.hq)(e, 1 / n, r)), e } function eJ(e, t, [i, r, n], s, a) { !function (e, t = 0, i = 1, r = .5, n, s = e, a = e) { if (er.KN.test(t) && (t = parseFloat(t), t = (0, G.k)(a.min, a.max, t / 100) - a.min), "number" != typeof t) return; let o = (0, G.k)(s.min, s.max, r); e === s && (o -= t), e.min = e$(e.min, t, i, o, n), e.max = e$(e.max, t, i, o, n) }(e, t[i], t[r], t[n], t.scale, s, a) } let e0 = ["x", "scaleX", "originX"], e1 = ["y", "scaleY", "originY"]; function e2(e, t, i, r) { eJ(e.x, t, e0, i ? i.x : void 0, r ? r.x : void 0), eJ(e.y, t, e1, i ? i.y : void 0, r ? r.y : void 0) } function e3(e) { return 0 === e.translate && 1 === e.scale } function e4(e) { return e3(e.x) && e3(e.y) } function e5(e, t) { return e.min === t.min && e.max === t.max } function e8(e, t) { return Math.round(e.min) === Math.round(t.min) && Math.round(e.max) === Math.round(t.max) } function e6(e, t) { return e8(e.x, t.x) && e8(e.y, t.y) } function e9(e) { return H(e.x) / H(e.y) } function e7(e, t) { return e.translate === t.translate && e.scale === t.scale && e.originPoint === t.originPoint } class te { constructor() { this.members = [] } add(e) { (0, eP.Kq)(this.members, e), e.scheduleRender() } remove(e) { if ((0, eP.Ai)(this.members, e), e === this.prevLead && (this.prevLead = void 0), e === this.lead) { let e = this.members[this.members.length - 1]; e && this.promote(e) } } relegate(e) { let t; let i = this.members.findIndex(t => e === t); if (0 === i) return !1; for (let e = i; e >= 0; e--) { let i = this.members[e]; if (!1 !== i.isPresent) { t = i; break } } return !!t && (this.promote(t), !0) } promote(e, t) { let i = this.lead; if (e !== i && (this.prevLead = i, this.lead = e, e.show(), i)) { i.instance && i.scheduleRender(), e.scheduleRender(), e.resumeFrom = i, t && (e.resumeFrom.preserveOpacity = !0), i.snapshot && (e.snapshot = i.snapshot, e.snapshot.latestValues = i.animationValues || i.latestValues), e.root && e.root.isUpdating && (e.isLayoutDirty = !0); let { crossfade: r } = e.options; !1 === r && i.hide() } } exitAnimationComplete() { this.members.forEach(e => { let { options: t, resumingFrom: i } = e; t.onExitComplete && t.onExitComplete(), i && i.options.onExitComplete && i.options.onExitComplete() }) } scheduleRender() { this.members.forEach(e => { e.instance && e.scheduleRender(!1) }) } removeLeadSnapshot() { this.lead && this.lead.snapshot && (this.lead.snapshot = void 0) } } var tt = i(1630); let ti = { type: "projectionFrame", totalNodes: 0, resolvedTargetDeltas: 0, recalculatedProjection: 0 }, tr = "undefined" != typeof window && void 0 !== window.MotionDebug, tn = ["", "X", "Y", "Z"], ts = { visibility: "hidden" }, ta = 0; function to(e, t, i, r) { let { latestValues: n } = t; n[e] && (i[e] = n[e], t.setStaticValue(e, 0), r && (r[e] = 0)) } function tl({ attachResizeListener: e, defaultParent: t, measureScroll: i, checkIsScrollRoot: r, resetTransform: n }) { return class { constructor(e = {}, i = null == t ? void 0 : t()) { this.id = ta++, this.animationId = 0, this.children = new Set, this.options = {}, this.isTreeAnimating = !1, this.isAnimationBlocked = !1, this.isLayoutDirty = !1, this.isProjectionDirty = !1, this.isSharedProjectionDirty = !1, this.isTransformDirty = !1, this.updateManuallyBlocked = !1, this.updateBlockedByResize = !1, this.isUpdating = !1, this.isSVG = !1, this.needsReset = !1, this.shouldResetTransform = !1, this.hasCheckedOptimisedAppear = !1, this.treeScale = { x: 1, y: 1 }, this.eventHandlers = new Map, this.hasTreeAnimated = !1, this.updateScheduled = !1, this.scheduleUpdate = () => this.update(), this.projectionUpdateScheduled = !1, this.checkUpdateFailed = () => { this.isUpdating && (this.isUpdating = !1, this.clearAllSnapshots()) }, this.updateProjection = () => { this.projectionUpdateScheduled = !1, tr && (ti.totalNodes = ti.resolvedTargetDeltas = ti.recalculatedProjection = 0), this.nodes.forEach(tc), this.nodes.forEach(ty), this.nodes.forEach(tx), this.nodes.forEach(td), tr && window.MotionDebug.record(ti) }, this.resolvedRelativeTargetAt = 0, this.hasProjected = !1, this.isVisible = !0, this.animationProgress = 0, this.sharedNodes = new Map, this.latestValues = e, this.root = i ? i.root || i : this, this.path = i ? [...i.path, i] : [], this.parent = i, this.depth = i ? i.depth + 1 : 0; for (let e = 0; e < this.path.length; e++)this.path[e].shouldResetTransform = !0; this.root === this && (this.nodes = new eO) } addEventListener(e, t) { return this.eventHandlers.has(e) || this.eventHandlers.set(e, new ek.v), this.eventHandlers.get(e).add(t) } notifyListeners(e, ...t) { let i = this.eventHandlers.get(e); i && i.notify(...t) } hasListeners(e) { return this.eventHandlers.has(e) } mount(t, i = this.root.hasTreeAnimated) { if (this.instance) return; this.isSVG = (0, eL.x)(t), this.instance = t; let { layoutId: r, layout: n, visualElement: s } = this.options; if (s && !s.current && s.mount(t), this.root.nodes.add(this), this.parent && this.parent.children.add(this), i && (n || r) && (this.isLayoutDirty = !0), e) { let i; let r = () => this.root.updateBlockedByResize = !1; e(t, () => { this.root.updateBlockedByResize = !0, i && i(), i = function (e, t) { let i = eI.k.now(), r = ({ timestamp: t }) => { let n = t - i; n >= 250 && ((0, D.WG)(r), e(n - 250)) }; return D.Gt.read(r, !0), () => (0, D.WG)(r) }(r, 250), ey.hasAnimatedSinceResize && (ey.hasAnimatedSinceResize = !1, this.nodes.forEach(tv)) }) } r && this.root.registerSharedNode(r, this), !1 !== this.options.animate && s && (r || n) && this.addEventListener("didUpdate", ({ delta: e, hasLayoutChanged: t, hasRelativeTargetChanged: i, layout: r }) => { if (this.isTreeAnimationBlocked()) { this.target = void 0, this.relativeTarget = void 0; return } let n = this.options.transition || s.getDefaultTransition() || tT, { onLayoutAnimationStart: a, onLayoutAnimationComplete: o } = s.getProps(), l = !this.targetLayout || !e6(this.targetLayout, r) || i, u = !t && i; if (this.options.layoutRoot || this.resumeFrom && this.resumeFrom.instance || u || t && (l || !this.currentAnimation)) { this.resumeFrom && (this.resumingFrom = this.resumeFrom, this.resumingFrom.resumingFrom = void 0), this.setAnimationOrigin(e, u); let t = { ...(0, T.rU)(n, "layout"), onPlay: a, onComplete: o }; (s.shouldReduceMotion || this.options.layoutRoot) && (t.delay = 0, t.type = !1), this.startAnimation(t) } else t || tv(this), this.isLead() && this.options.onExitComplete && this.options.onExitComplete(); this.targetLayout = r }) } unmount() { this.options.layoutId && this.willUpdate(), this.root.nodes.remove(this); let e = this.getStack(); e && e.remove(this), this.parent && this.parent.children.delete(this), this.instance = void 0, (0, D.WG)(this.updateProjection) } blockUpdate() { this.updateManuallyBlocked = !0 } unblockUpdate() { this.updateManuallyBlocked = !1 } isUpdateBlocked() { return this.updateManuallyBlocked || this.updateBlockedByResize } isTreeAnimationBlocked() { return this.isAnimationBlocked || this.parent && this.parent.isTreeAnimationBlocked() || !1 } startUpdate() { !this.isUpdateBlocked() && (this.isUpdating = !0, this.nodes && this.nodes.forEach(tS), this.animationId++) } getTransformTemplate() { let { visualElement: e } = this.options; return e && e.getProps().transformTemplate } willUpdate(e = !0) { if (this.root.hasTreeAnimated = !0, this.root.isUpdateBlocked()) { this.options.onExitComplete && this.options.onExitComplete(); return } if (window.MotionCancelOptimisedAnimation && !this.hasCheckedOptimisedAppear && function e(t) { if (t.hasCheckedOptimisedAppear = !0, t.root === t) return; let { visualElement: i } = t.options; if (!i) return; let r = (0, eC.P)(i); if (window.MotionHasOptimisedAnimation(r, "transform")) { let { layout: e, layoutId: i } = t.options; window.MotionCancelOptimisedAnimation(r, "transform", D.Gt, !(e || i)) } let { parent: n } = t; n && !n.hasCheckedOptimisedAppear && e(n) }(this), this.root.isUpdating || this.root.startUpdate(), this.isLayoutDirty) return; this.isLayoutDirty = !0; for (let e = 0; e < this.path.length; e++) { let t = this.path[e]; t.shouldResetTransform = !0, t.updateScroll("snapshot"), t.options.layoutRoot && t.willUpdate(!1) } let { layoutId: t, layout: i } = this.options; if (void 0 === t && !i) return; let r = this.getTransformTemplate(); this.prevTransformTemplateValue = r ? r(this.latestValues, "") : void 0, this.updateSnapshot(), e && this.notifyListeners("willUpdate") } update() { if (this.updateScheduled = !1, this.isUpdateBlocked()) { this.unblockUpdate(), this.clearAllSnapshots(), this.nodes.forEach(tp); return } this.isUpdating || this.nodes.forEach(tm), this.isUpdating = !1, this.nodes.forEach(tg), this.nodes.forEach(tu), this.nodes.forEach(th), this.clearAllSnapshots(); let e = eI.k.now(); D.uv.delta = (0, K.q)(0, 1e3 / 60, e - D.uv.timestamp), D.uv.timestamp = e, D.uv.isProcessing = !0, D.PP.update.process(D.uv), D.PP.preRender.process(D.uv), D.PP.render.process(D.uv), D.uv.isProcessing = !1 } didUpdate() { this.updateScheduled || (this.updateScheduled = !0, eE.read(this.scheduleUpdate)) } clearAllSnapshots() { this.nodes.forEach(tf), this.sharedNodes.forEach(tA) } scheduleUpdateProjection() { this.projectionUpdateScheduled || (this.projectionUpdateScheduled = !0, D.Gt.preRender(this.updateProjection, !1, !0)) } scheduleCheckAfterUnmount() { D.Gt.postRender(() => { this.isLayoutDirty ? this.root.didUpdate() : this.root.checkUpdateFailed() }) } updateSnapshot() { !this.snapshot && this.instance && (this.snapshot = this.measure()) } updateLayout() { if (!this.instance || (this.updateScroll(), !(this.options.alwaysMeasureLayout && this.isLead()) && !this.isLayoutDirty)) return; if (this.resumeFrom && !this.resumeFrom.instance) for (let e = 0; e < this.path.length; e++)this.path[e].updateScroll(); let e = this.layout; this.layout = this.measure(!1), this.layoutCorrected = (0, J.ge)(), this.isLayoutDirty = !1, this.projectionDelta = void 0, this.notifyListeners("measure", this.layout.layoutBox); let { visualElement: t } = this.options; t && t.notify("LayoutMeasure", this.layout.layoutBox, e ? e.layoutBox : void 0) } updateScroll(e = "measure") { let t = !!(this.options.layoutScroll && this.instance); if (this.scroll && this.scroll.animationId === this.root.animationId && this.scroll.phase === e && (t = !1), t) { let t = r(this.instance); this.scroll = { animationId: this.root.animationId, phase: e, isRoot: t, offset: i(this.instance), wasRoot: this.scroll ? this.scroll.isRoot : t } } } resetTransform() { if (!n) return; let e = this.isLayoutDirty || this.shouldResetTransform || this.options.alwaysMeasureLayout, t = this.projectionDelta && !e4(this.projectionDelta), i = this.getTransformTemplate(), r = i ? i(this.latestValues, "") : void 0, s = r !== this.prevTransformTemplateValue; e && (t || (0, tt.HD)(this.latestValues) || s) && (n(this.instance, r), this.shouldResetTransform = !1, this.scheduleRender()) } measure(e = !0) { var t; let i = this.measurePageBox(), r = this.removeElementScroll(i); return e && (r = this.removeTransform(r)), tR((t = r).x), tR(t.y), { animationId: this.root.animationId, measuredBox: i, layoutBox: r, latestValues: {}, source: this.id } } measurePageBox() { var e; let { visualElement: t } = this.options; if (!t) return (0, J.ge)(); let i = t.measureViewportBox(); if (!((null === (e = this.scroll) || void 0 === e ? void 0 : e.wasRoot) || this.path.some(tI))) { let { scroll: e } = this.root; e && ((0, eZ.Ql)(i.x, e.offset.x), (0, eZ.Ql)(i.y, e.offset.y)) } return i } removeElementScroll(e) { var t; let i = (0, J.ge)(); if (eq(i, e), null === (t = this.scroll) || void 0 === t ? void 0 : t.wasRoot) return i; for (let t = 0; t < this.path.length; t++) { let r = this.path[t], { scroll: n, options: s } = r; r !== this.root && n && s.layoutScroll && (n.wasRoot && eq(i, e), (0, eZ.Ql)(i.x, n.offset.x), (0, eZ.Ql)(i.y, n.offset.y)) } return i } applyTransform(e, t = !1) { let i = (0, J.ge)(); eq(i, e); for (let e = 0; e < this.path.length; e++) { let r = this.path[e]; !t && r.options.layoutScroll && r.scroll && r !== r.root && (0, eZ.Ww)(i, { x: -r.scroll.offset.x, y: -r.scroll.offset.y }), (0, tt.HD)(r.latestValues) && (0, eZ.Ww)(i, r.latestValues) } return (0, tt.HD)(this.latestValues) && (0, eZ.Ww)(i, this.latestValues), i } removeTransform(e) { let t = (0, J.ge)(); eq(t, e); for (let e = 0; e < this.path.length; e++) { let i = this.path[e]; if (!i.instance || !(0, tt.HD)(i.latestValues)) continue; (0, tt.vk)(i.latestValues) && i.updateSnapshot(); let r = (0, J.ge)(); eq(r, i.measurePageBox()), e2(t, i.latestValues, i.snapshot ? i.snapshot.layoutBox : void 0, r) } return (0, tt.HD)(this.latestValues) && e2(t, this.latestValues), t } setTargetDelta(e) { this.targetDelta = e, this.root.scheduleUpdateProjection(), this.isProjectionDirty = !0 } setOptions(e) { this.options = { ...this.options, ...e, crossfade: void 0 === e.crossfade || e.crossfade } } clearMeasurements() { this.scroll = void 0, this.layout = void 0, this.snapshot = void 0, this.prevTransformTemplateValue = void 0, this.targetDelta = void 0, this.target = void 0, this.isLayoutDirty = !1 } forceRelativeParentToResolveTarget() { this.relativeParent && this.relativeParent.resolvedRelativeTargetAt !== D.uv.timestamp && this.relativeParent.resolveTargetDelta(!0) } resolveTargetDelta(e = !1) { var t, i, r, n; let s = this.getLead(); this.isProjectionDirty || (this.isProjectionDirty = s.isProjectionDirty), this.isTransformDirty || (this.isTransformDirty = s.isTransformDirty), this.isSharedProjectionDirty || (this.isSharedProjectionDirty = s.isSharedProjectionDirty); let a = !!this.resumingFrom || this !== s; if (!(e || a && this.isSharedProjectionDirty || this.isProjectionDirty || (null === (t = this.parent) || void 0 === t ? void 0 : t.isProjectionDirty) || this.attemptToResolveRelativeTarget || this.root.updateBlockedByResize)) return; let { layout: o, layoutId: l } = this.options; if (this.layout && (o || l)) { if (this.resolvedRelativeTargetAt = D.uv.timestamp, !this.targetDelta && !this.relativeTarget) { let e = this.getClosestProjectingParent(); e && e.layout && 1 !== this.animationProgress ? (this.relativeParent = e, this.forceRelativeParentToResolveTarget(), this.relativeTarget = (0, J.ge)(), this.relativeTargetOrigin = (0, J.ge)(), X(this.relativeTargetOrigin, this.layout.layoutBox, e.layout.layoutBox), eq(this.relativeTarget, this.relativeTargetOrigin)) : this.relativeParent = this.relativeTarget = void 0 } if (this.relativeTarget || this.targetDelta) { if ((this.target || (this.target = (0, J.ge)(), this.targetWithTransforms = (0, J.ge)()), this.relativeTarget && this.relativeTargetOrigin && this.relativeParent && this.relativeParent.target) ? (this.forceRelativeParentToResolveTarget(), i = this.target, r = this.relativeTarget, n = this.relativeParent.target, j(i.x, r.x, n.x), j(i.y, r.y, n.y)) : this.targetDelta ? (this.resumingFrom ? this.target = this.applyTransform(this.layout.layoutBox) : eq(this.target, this.layout.layoutBox), (0, eZ.o4)(this.target, this.targetDelta)) : eq(this.target, this.layout.layoutBox), this.attemptToResolveRelativeTarget) { this.attemptToResolveRelativeTarget = !1; let e = this.getClosestProjectingParent(); e && !!e.resumingFrom == !!this.resumingFrom && !e.options.layoutScroll && e.target && 1 !== this.animationProgress ? (this.relativeParent = e, this.forceRelativeParentToResolveTarget(), this.relativeTarget = (0, J.ge)(), this.relativeTargetOrigin = (0, J.ge)(), X(this.relativeTargetOrigin, this.target, e.target), eq(this.relativeTarget, this.relativeTargetOrigin)) : this.relativeParent = this.relativeTarget = void 0 } tr && ti.resolvedTargetDeltas++ } } } getClosestProjectingParent() { return !this.parent || (0, tt.vk)(this.parent.latestValues) || (0, tt.vF)(this.parent.latestValues) ? void 0 : this.parent.isProjecting() ? this.parent : this.parent.getClosestProjectingParent() } isProjecting() { return !!((this.relativeTarget || this.targetDelta || this.options.layoutRoot) && this.layout) } calcProjection() { var e; let t = this.getLead(), i = !!this.resumingFrom || this !== t, r = !0; if ((this.isProjectionDirty || (null === (e = this.parent) || void 0 === e ? void 0 : e.isProjectionDirty)) && (r = !1), i && (this.isSharedProjectionDirty || this.isTransformDirty) && (r = !1), this.resolvedRelativeTargetAt === D.uv.timestamp && (r = !1), r) return; let { layout: n, layoutId: s } = this.options; if (this.isTreeAnimating = !!(this.parent && this.parent.isTreeAnimating || this.currentAnimation || this.pendingAnimation), this.isTreeAnimating || (this.targetDelta = this.relativeTarget = void 0), !this.layout || !(n || s)) return; eq(this.layoutCorrected, this.layout.layoutBox); let a = this.treeScale.x, o = this.treeScale.y; (0, eZ.OU)(this.layoutCorrected, this.treeScale, this.path, i), t.layout && !t.target && (1 !== this.treeScale.x || 1 !== this.treeScale.y) && (t.target = t.layout.layoutBox, t.targetWithTransforms = (0, J.ge)()); let { target: l } = t; if (!l) { this.prevProjectionDelta && (this.createProjectionDeltas(), this.scheduleRender()); return } this.projectionDelta && this.prevProjectionDelta ? (eQ(this.prevProjectionDelta.x, this.projectionDelta.x), eQ(this.prevProjectionDelta.y, this.projectionDelta.y)) : this.createProjectionDeltas(), W(this.projectionDelta, this.layoutCorrected, l, this.latestValues), this.treeScale.x === a && this.treeScale.y === o && e7(this.projectionDelta.x, this.prevProjectionDelta.x) && e7(this.projectionDelta.y, this.prevProjectionDelta.y) || (this.hasProjected = !0, this.scheduleRender(), this.notifyListeners("projectionUpdate", l)), tr && ti.recalculatedProjection++ } hide() { this.isVisible = !1 } show() { this.isVisible = !0 } scheduleRender(e = !0) { var t; if (null === (t = this.options.visualElement) || void 0 === t || t.scheduleRender(), e) { let e = this.getStack(); e && e.scheduleRender() } this.resumingFrom && !this.resumingFrom.instance && (this.resumingFrom = void 0) } createProjectionDeltas() { this.prevProjectionDelta = (0, J.xU)(), this.projectionDelta = (0, J.xU)(), this.projectionDeltaWithTransform = (0, J.xU)() } setAnimationOrigin(e, t = !1) { let i; let r = this.snapshot, n = r ? r.latestValues : {}, s = { ...this.latestValues }, a = (0, J.xU)(); this.relativeParent && this.relativeParent.options.layoutRoot || (this.relativeTarget = this.relativeTargetOrigin = void 0), this.attemptToResolveRelativeTarget = !t; let o = (0, J.ge)(), l = (r ? r.source : void 0) !== (this.layout ? this.layout.source : void 0), u = this.getStack(), h = !u || u.members.length <= 1, c = !!(l && !h && !0 === this.options.crossfade && !this.path.some(tb)); this.animationProgress = 0, this.mixTargetDelta = t => { let r = t / 1e3; if (t_(a.x, e.x, r), t_(a.y, e.y, r), this.setTargetDelta(a), this.relativeTarget && this.relativeTargetOrigin && this.layout && this.relativeParent && this.relativeParent.layout) { var u, d, f, p; X(o, this.layout.layoutBox, this.relativeParent.layout.layoutBox), f = this.relativeTarget, p = this.relativeTargetOrigin, tE(f.x, p.x, o.x, r), tE(f.y, p.y, o.y, r), i && (u = this.relativeTarget, d = i, e5(u.x, d.x) && e5(u.y, d.y)) && (this.isProjectionDirty = !1), i || (i = (0, J.ge)()), eq(i, this.relativeTarget) } l && (this.animationValues = s, function (e, t, i, r, n, s) { n ? (e.opacity = (0, G.k)(0, void 0 !== i.opacity ? i.opacity : 1, ej(r)), e.opacityExit = (0, G.k)(void 0 !== t.opacity ? t.opacity : 1, 0, eY(r))) : s && (e.opacity = (0, G.k)(void 0 !== t.opacity ? t.opacity : 1, void 0 !== i.opacity ? i.opacity : 1, r)); for (let n = 0; n < eG; n++) { let s = `border${ez[n]}Radius`, a = eW(t, s), o = eW(i, s); (void 0 !== a || void 0 !== o) && (a || (a = 0), o || (o = 0), 0 === a || 0 === o || eV(a) === eV(o) ? (e[s] = Math.max((0, G.k)(eH(a), eH(o), r), 0), (er.KN.test(o) || er.KN.test(a)) && (e[s] += "%")) : e[s] = o) } (t.rotate || i.rotate) && (e.rotate = (0, G.k)(t.rotate || 0, i.rotate || 0, r)) }(s, n, this.latestValues, r, c, h)), this.root.scheduleUpdateProjection(), this.scheduleRender(), this.animationProgress = r }, this.mixTargetDelta(this.options.layoutRoot ? 1e3 : 0) } startAnimation(e) { this.notifyListeners("animationStart"), this.currentAnimation && this.currentAnimation.stop(), this.resumingFrom && this.resumingFrom.currentAnimation && this.resumingFrom.currentAnimation.stop(), this.pendingAnimation && ((0, D.WG)(this.pendingAnimation), this.pendingAnimation = void 0), this.pendingAnimation = D.Gt.update(() => { ey.hasAnimatedSinceResize = !0, this.currentAnimation = (0, eR.z)(0, 1e3, { ...e, onUpdate: t => { this.mixTargetDelta(t), e.onUpdate && e.onUpdate(t) }, onComplete: () => { e.onComplete && e.onComplete(), this.completeAnimation() } }), this.resumingFrom && (this.resumingFrom.currentAnimation = this.currentAnimation), this.pendingAnimation = void 0 }) } completeAnimation() { this.resumingFrom && (this.resumingFrom.currentAnimation = void 0, this.resumingFrom.preserveOpacity = void 0); let e = this.getStack(); e && e.exitAnimationComplete(), this.resumingFrom = this.currentAnimation = this.animationValues = void 0, this.notifyListeners("animationComplete") } finishAnimation() { this.currentAnimation && (this.mixTargetDelta && this.mixTargetDelta(1e3), this.currentAnimation.stop()), this.completeAnimation() } applyTransformsToTarget() { let e = this.getLead(), { targetWithTransforms: t, target: i, layout: r, latestValues: n } = e; if (t && i && r) { if (this !== e && this.layout && r && tC(this.options.animationType, this.layout.layoutBox, r.layoutBox)) { i = this.target || (0, J.ge)(); let t = H(this.layout.layoutBox.x); i.x.min = e.target.x.min, i.x.max = i.x.min + t; let r = H(this.layout.layoutBox.y); i.y.min = e.target.y.min, i.y.max = i.y.min + r } eq(t, i), (0, eZ.Ww)(t, n), W(this.projectionDeltaWithTransform, this.layoutCorrected, t, n) } } registerSharedNode(e, t) { this.sharedNodes.has(e) || this.sharedNodes.set(e, new te), this.sharedNodes.get(e).add(t); let i = t.options.initialPromotionConfig; t.promote({ transition: i ? i.transition : void 0, preserveFollowOpacity: i && i.shouldPreserveFollowOpacity ? i.shouldPreserveFollowOpacity(t) : void 0 }) } isLead() { let e = this.getStack(); return !e || e.lead === this } getLead() { var e; let { layoutId: t } = this.options; return t && (null === (e = this.getStack()) || void 0 === e ? void 0 : e.lead) || this } getPrevLead() { var e; let { layoutId: t } = this.options; return t ? null === (e = this.getStack()) || void 0 === e ? void 0 : e.prevLead : void 0 } getStack() { let { layoutId: e } = this.options; if (e) return this.root.sharedNodes.get(e) } promote({ needsReset: e, transition: t, preserveFollowOpacity: i } = {}) { let r = this.getStack(); r && r.promote(this, i), e && (this.projectionDelta = void 0, this.needsReset = !0), t && this.setOptions({ transition: t }) } relegate() { let e = this.getStack(); return !!e && e.relegate(this) } resetSkewAndRotation() { let { visualElement: e } = this.options; if (!e) return; let t = !1, { latestValues: i } = e; if ((i.z || i.rotate || i.rotateX || i.rotateY || i.rotateZ || i.skewX || i.skewY) && (t = !0), !t) return; let r = {}; i.z && to("z", e, r, this.animationValues); for (let t = 0; t < tn.length; t++)to(`rotate${tn[t]}`, e, r, this.animationValues), to(`skew${tn[t]}`, e, r, this.animationValues); for (let t in e.render(), r) e.setStaticValue(t, r[t]), this.animationValues && (this.animationValues[t] = r[t]); e.scheduleRender() } getProjectionStyles(e) { var t, i; if (!this.instance || this.isSVG) return; if (!this.isVisible) return ts; let r = { visibility: "" }, n = this.getTransformTemplate(); if (this.needsReset) return this.needsReset = !1, r.opacity = "", r.pointerEvents = eN(null == e ? void 0 : e.pointerEvents) || "", r.transform = n ? n(this.latestValues, "") : "none", r; let s = this.getLead(); if (!this.projectionDelta || !this.layout || !s.target) { let t = {}; return this.options.layoutId && (t.opacity = void 0 !== this.latestValues.opacity ? this.latestValues.opacity : 1, t.pointerEvents = eN(null == e ? void 0 : e.pointerEvents) || ""), this.hasProjected && !(0, tt.HD)(this.latestValues) && (t.transform = n ? n({}, "") : "none", this.hasProjected = !1), t } let a = s.animationValues || s.latestValues; this.applyTransformsToTarget(), r.transform = function (e, t, i) { let r = "", n = e.x.translate / t.x, s = e.y.translate / t.y, a = (null == i ? void 0 : i.z) || 0; if ((n || s || a) && (r = `translate3d(${n}px, ${s}px, ${a}px) `), (1 !== t.x || 1 !== t.y) && (r += `scale(${1 / t.x}, ${1 / t.y}) `), i) { let { transformPerspective: e, rotate: t, rotateX: n, rotateY: s, skewX: a, skewY: o } = i; e && (r = `perspective(${e}px) ${r}`), t && (r += `rotate(${t}deg) `), n && (r += `rotateX(${n}deg) `), s && (r += `rotateY(${s}deg) `), a && (r += `skewX(${a}deg) `), o && (r += `skewY(${o}deg) `) } let o = e.x.scale * t.x, l = e.y.scale * t.y; return (1 !== o || 1 !== l) && (r += `scale(${o}, ${l})`), r || "none" }(this.projectionDeltaWithTransform, this.treeScale, a), n && (r.transform = n(a, r.transform)); let { x: o, y: l } = this.projectionDelta; for (let e in r.transformOrigin = `${100 * o.origin}% ${100 * l.origin}% 0`, s.animationValues ? r.opacity = s === this ? null !== (i = null !== (t = a.opacity) && void 0 !== t ? t : this.latestValues.opacity) && void 0 !== i ? i : 1 : this.preserveOpacity ? this.latestValues.opacity : a.opacityExit : r.opacity = s === this ? void 0 !== a.opacity ? a.opacity : "" : void 0 !== a.opacityExit ? a.opacityExit : 0, e_.H) { if (void 0 === a[e]) continue; let { correct: t, applyTo: i } = e_.H[e], n = "none" === r.transform ? a[e] : t(a[e], s); if (i) { let e = i.length; for (let t = 0; t < e; t++)r[i[t]] = n } else r[e] = n } return this.options.layoutId && (r.pointerEvents = s === this ? eN(null == e ? void 0 : e.pointerEvents) || "" : "none"), r } clearSnapshot() { this.resumeFrom = this.snapshot = void 0 } resetTree() { this.root.nodes.forEach(e => { var t; return null === (t = e.currentAnimation) || void 0 === t ? void 0 : t.stop() }), this.root.nodes.forEach(tp), this.root.sharedNodes.clear() } } } function tu(e) { e.updateLayout() } function th(e) { var t; let i = (null === (t = e.resumeFrom) || void 0 === t ? void 0 : t.snapshot) || e.snapshot; if (e.isLead() && e.layout && i && e.hasListeners("didUpdate")) { let { layoutBox: t, measuredBox: r } = e.layout, { animationType: n } = e.options, s = i.source !== e.layout.source; "size" === n ? ee(e => { let r = s ? i.measuredBox[e] : i.layoutBox[e], n = H(r); r.min = t[e].min, r.max = r.min + n }) : tC(n, i.layoutBox, t) && ee(r => { let n = s ? i.measuredBox[r] : i.layoutBox[r], a = H(t[r]); n.max = n.min + a, e.relativeTarget && !e.currentAnimation && (e.isProjectionDirty = !0, e.relativeTarget[r].max = e.relativeTarget[r].min + a) }); let a = (0, J.xU)(); W(a, t, i.layoutBox); let o = (0, J.xU)(); s ? W(o, e.applyTransform(r, !0), i.measuredBox) : W(o, t, i.layoutBox); let l = !e4(a), u = !1; if (!e.resumeFrom) { let r = e.getClosestProjectingParent(); if (r && !r.resumeFrom) { let { snapshot: n, layout: s } = r; if (n && s) { let a = (0, J.ge)(); X(a, i.layoutBox, n.layoutBox); let o = (0, J.ge)(); X(o, t, s.layoutBox), e6(a, o) || (u = !0), r.options.layoutRoot && (e.relativeTarget = o, e.relativeTargetOrigin = a, e.relativeParent = r) } } } e.notifyListeners("didUpdate", { layout: t, snapshot: i, delta: o, layoutDelta: a, hasLayoutChanged: l, hasRelativeTargetChanged: u }) } else if (e.isLead()) { let { onExitComplete: t } = e.options; t && t() } e.options.transition = void 0 } function tc(e) { tr && ti.totalNodes++, e.parent && (e.isProjecting() || (e.isProjectionDirty = e.parent.isProjectionDirty), e.isSharedProjectionDirty || (e.isSharedProjectionDirty = !!(e.isProjectionDirty || e.parent.isProjectionDirty || e.parent.isSharedProjectionDirty)), e.isTransformDirty || (e.isTransformDirty = e.parent.isTransformDirty)) } function td(e) { e.isProjectionDirty = e.isSharedProjectionDirty = e.isTransformDirty = !1 } function tf(e) { e.clearSnapshot() } function tp(e) { e.clearMeasurements() } function tm(e) { e.isLayoutDirty = !1 } function tg(e) { let { visualElement: t } = e.options; t && t.getProps().onBeforeLayoutMeasure && t.notify("BeforeLayoutMeasure"), e.resetTransform() } function tv(e) { e.finishAnimation(), e.targetDelta = e.relativeTarget = e.target = void 0, e.isProjectionDirty = !0 } function ty(e) { e.resolveTargetDelta() } function tx(e) { e.calcProjection() } function tS(e) { e.resetSkewAndRotation() } function tA(e) { e.removeLeadSnapshot() } function t_(e, t, i) { e.translate = (0, G.k)(t.translate, 0, i), e.scale = (0, G.k)(t.scale, 1, i), e.origin = t.origin, e.originPoint = t.originPoint } function tE(e, t, i, r) { e.min = (0, G.k)(t.min, i.min, r), e.max = (0, G.k)(t.max, i.max, r) } function tb(e) { return e.animationValues && void 0 !== e.animationValues.opacityExit } let tT = { duration: .45, ease: [.4, 0, .1, 1] }, tw = e => "undefined" != typeof navigator && navigator.userAgent && navigator.userAgent.toLowerCase().includes(e), tM = tw("applewebkit/") && !tw("chrome/") ? Math.round : E.l; function tR(e) { e.min = tM(e.min), e.max = tM(e.max) } function tC(e, t, i) { return "position" === e || "preserve-aspect" === e && !(.2 >= Math.abs(e9(t) - e9(i))) } function tI(e) { var t; return e !== e.root && (null === (t = e.scroll) || void 0 === t ? void 0 : t.wasRoot) } let tL = tl({ attachResizeListener: (e, t) => M(e, "resize", t), measureScroll: () => ({ x: document.documentElement.scrollLeft || document.body.scrollLeft, y: document.documentElement.scrollTop || document.body.scrollTop }), checkIsScrollRoot: () => !0 }), tP = { current: void 0 }, tD = tl({ measureScroll: e => ({ x: e.scrollLeft, y: e.scrollTop }), defaultParent: () => { if (!tP.current) { let e = new tL({}); e.mount(window), e.setOptions({ layoutScroll: !0 }), tP.current = e } return tP.current }, resetTransform: (e, t) => { e.style.transform = void 0 !== t ? t : "none" }, checkIsScrollRoot: e => "fixed" === window.getComputedStyle(e).position }); function tO(e, t, i) { let { props: r } = e; e.animationState && r.whileHover && e.animationState.setActive("whileHover", "Start" === i); let n = r["onHover" + i]; n && D.Gt.postRender(() => n(t, R(t))) } class tk extends x { mount() { let { current: e } = this.node; e && (this.unmount = (0, T.PT)(e, e => (tO(this.node, e, "Start"), e => tO(this.node, e, "End")))) } unmount() { } } class tF extends x { constructor() { super(...arguments), this.isActive = !1 } onFocus() { let e = !1; try { e = this.node.current.matches(":focus-visible") } catch (t) { e = !0 } e && this.node.animationState && (this.node.animationState.setActive("whileFocus", !0), this.isActive = !0) } onBlur() { this.isActive && this.node.animationState && (this.node.animationState.setActive("whileFocus", !1), this.isActive = !1) } mount() { this.unmount = (0, P.F)(M(this.node.current, "focus", () => this.onFocus()), M(this.node.current, "blur", () => this.onBlur())) } unmount() { } } function tU(e, t, i) { let { props: r } = e; e.animationState && r.whileTap && e.animationState.setActive("whileTap", "Start" === i); let n = r["onTap" + ("End" === i ? "" : i)]; n && D.Gt.postRender(() => n(t, R(t))) } class tN extends x { mount() { let { current: e } = this.node; e && (this.unmount = (0, T.c$)(e, e => (tU(this.node, e, "Start"), (e, { success: t }) => tU(this.node, e, t ? "End" : "Cancel")), { useGlobalTarget: this.node.props.globalTapTarget })) } unmount() { } } let tB = new WeakMap, tz = new WeakMap, tG = e => { let t = tB.get(e.target); t && t(e) }, tH = e => { e.forEach(tG) }, tV = { some: 0, all: 1 }; class tW extends x { constructor() { super(...arguments), this.hasEnteredView = !1, this.isInView = !1 } startObserver() { this.unmount(); let { viewport: e = {} } = this.node.getProps(), { root: t, margin: i, amount: r = "some", once: n } = e, s = { root: t ? t.current : void 0, rootMargin: i, threshold: "number" == typeof r ? r : tV[r] }; return function (e, t, i) { let r = function ({ root: e, ...t }) { let i = e || document; tz.has(i) || tz.set(i, {}); let r = tz.get(i), n = JSON.stringify(t); return r[n] || (r[n] = new IntersectionObserver(tH, { root: e, ...t })), r[n] }(t); return tB.set(e, i), r.observe(e), () => { tB.delete(e), r.unobserve(e) } }(this.node.current, s, e => { let { isIntersecting: t } = e; if (this.isInView === t || (this.isInView = t, n && !t && this.hasEnteredView)) return; t && (this.hasEnteredView = !0), this.node.animationState && this.node.animationState.setActive("whileInView", t); let { onViewportEnter: i, onViewportLeave: r } = this.node.getProps(), s = t ? i : r; s && s(e) }) } mount() { this.startObserver() } update() { if ("undefined" == typeof IntersectionObserver) return; let { props: e, prevProps: t } = this.node;["amount", "margin", "root"].some(function ({ viewport: e = {} }, { viewport: t = {} } = {}) { return i => e[i] !== t[i] }(e, t)) && this.startObserver() } unmount() { } } let tj = (0, ep.createContext)({ strict: !1 }); var tY = i(5446); let tX = (0, ep.createContext)({}); var tK = i(837); function tq(e) { return Array.isArray(e) ? e.join(" ") : e } var tQ = i(8288), tZ = i(3996); let t$ = Symbol.for("motionComponentSymbol"); var tJ = i(6719), t0 = i(5128), t1 = i(2392); let t2 = ["animate", "circle", "defs", "desc", "ellipse", "g", "image", "line", "filter", "marker", "mask", "metadata", "path", "pattern", "polygon", "polyline", "rect", "stop", "switch", "symbol", "svg", "text", "tspan", "use", "view"]; function t3(e) { if ("string" != typeof e || e.includes("-")); else if (t2.indexOf(e) > -1 || /[A-Z]/u.test(e)) return !0; return !1 } var t4 = i(3141), t5 = i(8601); let t8 = e => (t, i) => { let r = (0, ep.useContext)(tX), n = (0, ep.useContext)(tJ.t), a = () => (function ({ scrapeMotionValuesFromProps: e, createRenderState: t, onUpdate: i }, r, n, a) { let o = { latestValues: function (e, t, i, r) { let n = {}, a = r(e, {}); for (let e in a) n[e] = eN(a[e]); let { initial: o, animate: l } = e, u = (0, tK.e)(e), h = (0, tK.O)(e); t && h && !u && !1 !== e.inherit && (void 0 === o && (o = t.initial), void 0 === l && (l = t.animate)); let c = !!i && !1 === i.initial, d = (c = c || !1 === o) ? l : o; if (d && "boolean" != typeof d && !(0, s.N)(d)) { let t = Array.isArray(d) ? d : [d]; for (let i = 0; i < t.length; i++) { let r = (0, t4.a)(e, t[i]); if (r) { let { transitionEnd: e, transition: t, ...i } = r; for (let e in i) { let t = i[e]; if (Array.isArray(t)) { let e = c ? t.length - 1 : 0; t = t[e] } null !== t && (n[e] = t) } for (let t in e) n[t] = e[t] } } } return n }(r, n, a, e), renderState: t() }; return i && (o.onMount = e => i({ props: r, current: e, ...o }), o.onUpdate = e => i(e)), o })(e, t, r, n); return i ? a() : (0, t5.M)(a) }; var t6 = i(2443), t9 = i(164); let t7 = () => ({ style: {}, transform: {}, transformOrigin: {}, vars: {} }), ie = () => ({ ...t7(), attrs: {} }); var it = i(6793), ii = i(7415), ir = i(2777); let is = ["x", "y", "width", "height", "cx", "cy", "r"], ia = { useVisualState: t8({ scrapeMotionValuesFromProps: ir.x, createRenderState: ie, onUpdate: ({ props: e, prevProps: t, current: i, renderState: r, latestValues: n }) => { if (!i) return; let s = !!e.drag; if (!s) { for (let e in n) if (t6.f.has(e)) { s = !0; break } } if (!s) return; let a = !t; if (t) for (let i = 0; i < is.length; i++) { let r = is[i]; e[r] !== t[r] && (a = !0) } a && D.Gt.read(() => { !function (e, t) { try { t.dimensions = "function" == typeof e.getBBox ? e.getBBox() : e.getBoundingClientRect() } catch (e) { t.dimensions = { x: 0, y: 0, width: 0, height: 0 } } }(i, r), D.Gt.render(() => { (0, t9.B)(r, n, (0, it.n)(i.tagName), e.transformTemplate), (0, ii.d)(i, r) }) }) } }) }, io = { useVisualState: t8({ scrapeMotionValuesFromProps: i(4494).x, createRenderState: t7 }) }; var il = i(7549), iu = i(5756); function ih(e, t, i) { for (let r in t) (0, eU.S)(t[r]) || (0, il.z)(r, i) || (e[r] = t[r]) } let ic = new Set(["animate", "exit", "variants", "initial", "style", "values", "variants", "transition", "transformTemplate", "custom", "inherit", "onBeforeLayoutMeasure", "onAnimationStart", "onAnimationComplete", "onUpdate", "onDragStart", "onDrag", "onDragEnd", "onMeasureDragConstraints", "onDirectionLock", "onDragTransitionEnd", "_dragX", "_dragY", "onHoverStart", "onHoverEnd", "onViewportEnter", "onViewportLeave", "globalTapTarget", "ignoreStrict", "viewport"]); function id(e) { return e.startsWith("while") || e.startsWith("drag") && "draggable" !== e || e.startsWith("layout") || e.startsWith("onTap") || e.startsWith("onPan") || e.startsWith("onLayout") || ic.has(e) } let ip = e => !id(e); try { !function (e) { e && (ip = t => t.startsWith("on") ? !id(t) : e(t)) }(require("@emotion/is-prop-valid").default) } catch (e) { } var im = i(963), ig = i(2159); let iv = function (e) { if ("undefined" == typeof Proxy) return e; let t = new Map; return new Proxy((...t) => e(...t), { get: (i, r) => "create" === r ? e : (t.has(r) || t.set(r, e(r)), t.get(r)) }) }((r = { animation: { Feature: S }, exit: { Feature: _ }, inView: { Feature: tW }, tap: { Feature: tN }, focus: { Feature: tF }, hover: { Feature: tk }, pan: { Feature: ed }, drag: { Feature: eh, ProjectionNode: tD, MeasureLayout: ew }, layout: { ProjectionNode: tD, MeasureLayout: ew } }, n = (e, t) => t3(e) ? new ig.l(t) : new im.M(t, { allowProjection: e !== ep.Fragment }), function (e, { forwardMotionProps: t } = { forwardMotionProps: !1 }) { return function ({ preloadedFeatures: e, createVisualElement: t, useRender: i, useVisualState: r, Component: n }) { var s, a; function o(e, s) { var a; let o; let u = { ...(0, ep.useContext)(tY.Q), ...e, layoutId: function ({ layoutId: e }) { let t = (0, ep.useContext)(eg.L).id; return t && void 0 !== e ? t + "-" + e : e }(e) }, { isStatic: h } = u, c = function (e) { let { initial: t, animate: i } = function (e, t) { if ((0, tK.e)(e)) { let { initial: t, animate: i } = e; return { initial: !1 === t || (0, l.w)(t) ? t : void 0, animate: (0, l.w)(i) ? i : void 0 } } return !1 !== e.inherit ? t : {} }(e, (0, ep.useContext)(tX)); return (0, ep.useMemo)(() => ({ initial: t, animate: i }), [tq(t), tq(i)]) }(e), d = r(e, h); if (!h && tQ.B) { (0, ep.useContext)(tj).strict; let e = function (e) { let { drag: t, layout: i } = tZ.B; if (!t && !i) return {}; let r = { ...t, ...i }; return { MeasureLayout: (null == t ? void 0 : t.isEnabled(e)) || (null == i ? void 0 : i.isEnabled(e)) ? r.MeasureLayout : void 0, ProjectionNode: r.ProjectionNode } }(u); o = e.MeasureLayout, c.visualElement = function (e, t, i, r, n) { var s, a; let { visualElement: o } = (0, ep.useContext)(tX), l = (0, ep.useContext)(tj), u = (0, ep.useContext)(tJ.t), h = (0, ep.useContext)(tY.Q).reducedMotion, c = (0, ep.useRef)(null); r = r || l.renderer, !c.current && r && (c.current = r(e, { visualState: t, parent: o, props: i, presenceContext: u, blockInitialAnimation: !!u && !1 === u.initial, reducedMotionConfig: h })); let d = c.current, f = (0, ep.useContext)(ev); d && !d.projection && n && ("html" === d.type || "svg" === d.type) && function (e, t, i, r) { let { layoutId: n, layout: s, drag: a, dragConstraints: o, layoutScroll: l, layoutRoot: u } = t; e.projection = new i(e.latestValues, t["data-framer-portal-id"] ? void 0 : function e(t) { if (t) return !1 !== t.options.allowProjection ? t.projection : e(t.parent) }(e.parent)), e.projection.setOptions({ layoutId: n, layout: s, alwaysMeasureLayout: !!a || o && B(o), visualElement: e, animationType: "string" == typeof s ? s : "both", initialPromotionConfig: r, layoutScroll: l, layoutRoot: u }) }(c.current, i, n, f); let p = (0, ep.useRef)(!1); (0, ep.useInsertionEffect)(() => { d && p.current && d.update(i, u) }); let m = i[t1.n], g = (0, ep.useRef)(!!m && !(null === (s = window.MotionHandoffIsComplete) || void 0 === s ? void 0 : s.call(window, m)) && (null === (a = window.MotionHasOptimisedAnimation) || void 0 === a ? void 0 : a.call(window, m))); return (0, t0.E)(() => { d && (p.current = !0, window.MotionIsMounted = !0, d.updateFeatures(), eE.render(d.render), g.current && d.animationState && d.animationState.animateChanges()) }), (0, ep.useEffect)(() => { d && (!g.current && d.animationState && d.animationState.animateChanges(), g.current && (queueMicrotask(() => { var e; null === (e = window.MotionHandoffMarkAsComplete) || void 0 === e || e.call(window, m) }), g.current = !1)) }), d }(n, d, u, t, e.ProjectionNode) } return (0, ef.jsxs)(tX.Provider, { value: c, children: [o && c.visualElement ? (0, ef.jsx)(o, { visualElement: c.visualElement, ...u }) : null, i(n, e, (a = c.visualElement, (0, ep.useCallback)(e => { e && d.onMount && d.onMount(e), a && (e ? a.mount(e) : a.unmount()), s && ("function" == typeof s ? s(e) : B(s) && (s.current = e)) }, [a])), d, h, c.visualElement)] }) } e && function (e) { for (let t in e) tZ.B[t] = { ...tZ.B[t], ...e[t] } }(e), o.displayName = `motion.${"string" == typeof n ? n : `create(${null !== (a = null !== (s = n.displayName) && void 0 !== s ? s : n.name) && void 0 !== a ? a : ""})`}`; let u = (0, ep.forwardRef)(o); return u[t$] = n, u }({ ...t3(e) ? ia : io, preloadedFeatures: r, useRender: function (e = !1) { return (t, i, r, { latestValues: n }, s) => { let a = (t3(t) ? function (e, t, i, r) { let n = (0, ep.useMemo)(() => { let i = ie(); return (0, t9.B)(i, t, (0, it.n)(r), e.transformTemplate), { ...i.attrs, style: { ...i.style } } }, [t]); if (e.style) { let t = {}; ih(t, e.style, e), n.style = { ...t, ...n.style } } return n } : function (e, t) { let i = {}, r = function (e, t) { let i = e.style || {}, r = {}; return ih(r, i, e), Object.assign(r, function ({ transformTemplate: e }, t) { return (0, ep.useMemo)(() => { let i = t7(); return (0, iu.O)(i, t, e), Object.assign({}, i.vars, i.style) }, [t]) }(e, t)), r }(e, t); return e.drag && !1 !== e.dragListener && (i.draggable = !1, r.userSelect = r.WebkitUserSelect = r.WebkitTouchCallout = "none", r.touchAction = !0 === e.drag ? "none" : `pan-${"x" === e.drag ? "y" : "x"}`), void 0 === e.tabIndex && (e.onTap || e.onTapStart || e.whileTap) && (i.tabIndex = 0), i.style = r, i })(i, n, s, t), o = function (e, t, i) { let r = {}; for (let n in e) ("values" !== n || "object" != typeof e.values) && (ip(n) || !0 === i && id(n) || !t && !id(n) || e.draggable && n.startsWith("onDrag")) && (r[n] = e[n]); return r }(i, "string" == typeof t, e), l = t !== ep.Fragment ? { ...o, ...a, ref: r } : {}, { children: u } = i, h = (0, ep.useMemo)(() => (0, eU.S)(u) ? u.get() : u, [u]); return (0, ep.createElement)(t, { ...l, children: h }) } }(t), createVisualElement: n, Component: e }) })) }, 4721: (e, t, i) => { "use strict"; i.d(t, { K: () => m }); var r = i(7312), n = i(5972), s = i(615), a = i(5320); let o = new Set(["auto", "none", "0"]); var l = i(4835), u = i(8104), h = i(9652), c = i(568); let d = /^var\(--(?:([\w-]+)|([\w-]+), ?([a-zA-Z\d ()%#.,-]+))\)/u; var f = i(3420), p = i(5141); class m extends l.h { constructor(e, t, i, r, n) { super(e, t, i, r, n, !0) } readKeyframes() { let { unresolvedKeyframes: e, element: t, name: i } = this; if (!t || !t.current) return; super.readKeyframes(); for (let i = 0; i < e.length; i++) { let r = e[i]; if ("string" == typeof r && (r = r.trim(), (0, c.p)(r))) { let n = function e(t, i, r = 1) { (0, u.V)(r <= 4, `Max CSS variable fallback depth detected in property "${t}". This may indicate a circular fallback dependency.`); let [n, s] = function (e) { let t = d.exec(e); if (!t) return [,]; let [, i, r, n] = t; return [`--${null != i ? i : r}`, n] }(t); if (!n) return; let a = window.getComputedStyle(i).getPropertyValue(n); if (a) { let e = a.trim(); return (0, h.i)(e) ? parseFloat(e) : e } return (0, c.p)(s) ? e(s, i, r + 1) : s }(r, t.current); void 0 !== n && (e[i] = n), i === e.length - 1 && (this.finalKeyframe = r) } } if (this.resolveNoneKeyframes(), !n.$.has(i) || 2 !== e.length) return; let [r, s] = e, a = (0, p.n)(r), o = (0, p.n)(s); if (a !== o) { if ((0, f.E4)(a) && (0, f.E4)(o)) for (let t = 0; t < e.length; t++) { let i = e[t]; "string" == typeof i && (e[t] = parseFloat(i)) } else this.needsMeasurement = !0 } } resolveNoneKeyframes() { let { unresolvedKeyframes: e, name: t } = this, i = []; for (let t = 0; t < e.length; t++) { var n; ("number" == typeof (n = e[t]) ? 0 === n : null === n || "none" === n || "0" === n || (0, r.$)(n)) && i.push(t) } i.length && function (e, t, i) { let r, n = 0; for (; n < e.length && !r;) { let t = e[n]; "string" == typeof t && !o.has(t) && (0, s.V)(t).values.length && (r = e[n]), n++ } if (r && i) for (let n of t) e[n] = (0, a.J)(i, r) }(e, i, t) } measureInitialState() { let { element: e, unresolvedKeyframes: t, name: i } = this; if (!e || !e.current) return; "height" === i && (this.suspendedScrollY = window.pageYOffset), this.measuredOrigin = f.Hr[i](e.measureViewportBox(), window.getComputedStyle(e.current)), t[0] = this.measuredOrigin; let r = t[t.length - 1]; void 0 !== r && e.getValue(i, r).jump(r, !1) } measureEndState() { var e; let { element: t, name: i, unresolvedKeyframes: r } = this; if (!t || !t.current) return; let n = t.getValue(i); n && n.jump(this.measuredOrigin, !1); let s = r.length - 1, a = r[s]; r[s] = f.Hr[i](t.measureViewportBox(), window.getComputedStyle(t.current)), null !== a && void 0 === this.finalKeyframe && (this.finalKeyframe = a), (null === (e = this.removedTransforms) || void 0 === e ? void 0 : e.length) && this.removedTransforms.forEach(([e, i]) => { t.getValue(e).set(i) }), this.resolveNoneKeyframes() } } }, 1479: (e, t, i) => { "use strict"; i.d(t, { b: () => a }); var r = i(2183), n = i(4721), s = i(9896); class a extends r.B { constructor() { super(...arguments), this.KeyframeResolver = n.K } sortInstanceNodePosition(e, t) { return 2 & e.compareDocumentPosition(t) ? 1 : -1 } getBaseTargetFromProps(e, t) { return e.style ? e.style[t] : void 0 } removeValueFromRenderState(e, { vars: t, style: i }) { delete t[e], delete i[e] } handleChildMotionValue() { this.childSubscription && (this.childSubscription(), delete this.childSubscription); let { children: e } = this.props; (0, s.S)(e) && (this.childSubscription = e.on("change", e => { this.current && (this.current.textContent = `${e}`) })) } } }, 8062: (e, t, i) => { "use strict"; i.d(t, { I: () => r }); let r = e => e.replace(/([a-z])([A-Z])/gu, "$1-$2").toLowerCase() }, 568: (e, t, i) => { "use strict"; i.d(t, { j: () => n, p: () => a }); let r = e => t => "string" == typeof t && t.startsWith(e), n = r("--"), s = r("var(--"), a = e => !!s(e) && o.test(e.split("/*")[0].trim()), o = /var\(--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)$/iu }, 3628: (e, t, i) => { "use strict"; function r(e) { return e instanceof SVGElement && "svg" !== e.tagName } i.d(t, { x: () => r }) }, 3420: (e, t, i) => { "use strict"; i.d(t, { E4: () => a, Hr: () => d, W9: () => c }); var r = i(2944), n = i(5269), s = i(2443); let a = e => e === r.ai || e === n.px, o = (e, t) => parseFloat(e.split(", ")[t]), l = (e, t) => (i, { transform: r }) => { if ("none" === r || !r) return 0; let n = r.match(/^matrix3d\((.+)\)$/u); if (n) return o(n[1], t); { let t = r.match(/^matrix\((.+)\)$/u); return t ? o(t[1], e) : 0 } }, u = new Set(["x", "y", "z"]), h = s.U.filter(e => !u.has(e)); function c(e) { let t = []; return h.forEach(i => { let r = e.getValue(i); void 0 !== r && (t.push([i, r.get()]), r.set(i.startsWith("scale") ? 1 : 0)) }), t } let d = { width: ({ x: e }, { paddingLeft: t = "0", paddingRight: i = "0" }) => e.max - e.min - parseFloat(t) - parseFloat(i), height: ({ y: e }, { paddingTop: t = "0", paddingBottom: i = "0" }) => e.max - e.min - parseFloat(t) - parseFloat(i), top: (e, { top: t }) => parseFloat(t), left: (e, { left: t }) => parseFloat(t), bottom: ({ y: e }, { top: t }) => parseFloat(t) + (e.max - e.min), right: ({ x: e }, { left: t }) => parseFloat(t) + (e.max - e.min), x: l(4, 13), y: l(5, 14) }; d.translateX = d.x, d.translateY = d.y }, 5320: (e, t, i) => { "use strict"; i.d(t, { J: () => a }); var r = i(615), n = i(6044), s = i(1619); function a(e, t) { let i = (0, s.D)(e); return i !== n.p && (i = r.f), i.getAnimatableNone ? i.getAnimatableNone(t) : void 0 } }, 1619: (e, t, i) => { "use strict"; i.d(t, { D: () => a }); var r = i(7739), n = i(6044); let s = { ...i(6763).W, color: r.y, backgroundColor: r.y, outlineColor: r.y, fill: r.y, stroke: r.y, borderColor: r.y, borderTopColor: r.y, borderRightColor: r.y, borderBottomColor: r.y, borderLeftColor: r.y, filter: n.p, WebkitFilter: n.p }, a = e => s[e] }, 5141: (e, t, i) => { "use strict"; i.d(t, { T: () => a, n: () => o }); var r = i(2944), n = i(5269), s = i(1969); let a = [r.ai, n.px, n.KN, n.uj, n.vw, n.vh, { test: e => "auto" === e, parse: e => e }], o = e => a.find((0, s.w)(e)) }, 6763: (e, t, i) => { "use strict"; i.d(t, { W: () => l }); var r = i(2944), n = i(5269); let s = { borderWidth: n.px, borderTopWidth: n.px, borderRightWidth: n.px, borderBottomWidth: n.px, borderLeftWidth: n.px, borderRadius: n.px, radius: n.px, borderTopLeftRadius: n.px, borderTopRightRadius: n.px, borderBottomRightRadius: n.px, borderBottomLeftRadius: n.px, width: n.px, maxWidth: n.px, height: n.px, maxHeight: n.px, top: n.px, right: n.px, bottom: n.px, left: n.px, padding: n.px, paddingTop: n.px, paddingRight: n.px, paddingBottom: n.px, paddingLeft: n.px, margin: n.px, marginTop: n.px, marginRight: n.px, marginBottom: n.px, marginLeft: n.px, backgroundPositionX: n.px, backgroundPositionY: n.px }, a = { rotate: n.uj, rotateX: n.uj, rotateY: n.uj, rotateZ: n.uj, scale: r.hs, scaleX: r.hs, scaleY: r.hs, scaleZ: r.hs, skew: n.uj, skewX: n.uj, skewY: n.uj, distance: n.px, translateX: n.px, translateY: n.px, translateZ: n.px, x: n.px, y: n.px, z: n.px, perspective: n.px, transformPerspective: n.px, opacity: r.X4, originX: n.gQ, originY: n.gQ, originZ: n.px }, o = { ...r.ai, transform: Math.round }, l = { ...s, ...a, zIndex: o, size: n.px, fillOpacity: r.X4, strokeOpacity: r.X4, numOctaves: o } }, 1969: (e, t, i) => { "use strict"; i.d(t, { w: () => r }); let r = e => t => t.test(e) }, 963: (e, t, i) => { "use strict"; i.d(t, { M: () => c }); var r = i(4805), n = i(1479), s = i(568), a = i(1619), o = i(5756), l = i(2443), u = i(9836), h = i(4494); class c extends n.b { constructor() { super(...arguments), this.type = "html", this.renderInstance = u.e } readValueFromInstance(e, t) { if (l.f.has(t)) { let e = (0, a.D)(t); return e && e.default || 0 } { let i = window.getComputedStyle(e), r = ((0, s.j)(t) ? i.getPropertyValue(t) : i[t]) || 0; return "string" == typeof r ? r.trim() : r } } measureInstanceViewportBox(e, { transformPagePoint: t }) { return (0, r.m)(e, t) } build(e, t, i) { (0, o.O)(e, t, i.transformTemplate) } scrapeMotionValuesFromProps(e, t, i) { return (0, h.x)(e, t, i) } } }, 5756: (e, t, i) => { "use strict"; i.d(t, { O: () => u }); var r = i(568); let n = (e, t) => t && "number" == typeof e ? t.transform(e) : e; var s = i(6763), a = i(2443); let o = { x: "translateX", y: "translateY", z: "translateZ", transformPerspective: "perspective" }, l = a.U.length; function u(e, t, i) { let { style: u, vars: h, transformOrigin: c } = e, d = !1, f = !1; for (let e in t) { let i = t[e]; if (a.f.has(e)) { d = !0; continue } if ((0, r.j)(e)) { h[e] = i; continue } { let t = n(i, s.W[e]); e.startsWith("origin") ? (f = !0, c[e] = t) : u[e] = t } } if (!t.transform && (d || i ? u.transform = function (e, t, i) { let r = "", u = !0; for (let h = 0; h < l; h++) { let l = a.U[h], c = e[l]; if (void 0 === c) continue; let d = !0; if (!(d = "number" == typeof c ? c === (l.startsWith("scale") ? 1 : 0) : 0 === parseFloat(c)) || i) { let e = n(c, s.W[l]); if (!d) { u = !1; let t = o[l] || l; r += `${t}(${e}) ` } i && (t[l] = e) } } return r = r.trim(), i ? r = i(t, u ? "" : r) : u && (r = "none"), r }(t, e.transform, i) : u.transform && (u.transform = "none")), f) { let { originX: e = "50%", originY: t = "50%", originZ: i = 0 } = c; u.transformOrigin = `${e} ${t} ${i}` } } }, 5972: (e, t, i) => { "use strict"; i.d(t, { $: () => r }); let r = new Set(["width", "height", "top", "left", "right", "bottom", ...i(2443).U]) }, 2443: (e, t, i) => { "use strict"; i.d(t, { U: () => r, f: () => n }); let r = ["transformPerspective", "x", "y", "z", "translateX", "translateY", "translateZ", "scale", "scaleX", "scaleY", "rotate", "rotateX", "rotateY", "rotateZ", "skew", "skewX", "skewY"], n = new Set(r) }, 9836: (e, t, i) => { "use strict"; function r(e, { style: t, vars: i }, r, n) { for (let s in Object.assign(e.style, t, n && n.getProjectionStyles(r)), i) e.style.setProperty(s, i[s]) } i.d(t, { e: () => r }) }, 4494: (e, t, i) => { "use strict"; i.d(t, { x: () => s }); var r = i(7549), n = i(9896); function s(e, t, i) { var s; let { style: a } = e, o = {}; for (let l in a) ((0, n.S)(a[l]) || t.style && (0, n.S)(t.style[l]) || (0, r.z)(l, e) || (null === (s = null == i ? void 0 : i.getValue(l)) || void 0 === s ? void 0 : s.liveStyle) !== void 0) && (o[l] = a[l]); return o } }, 3379: (e, t, i) => { "use strict"; i.d(t, { C: () => r }); let r = new WeakMap }, 2159: (e, t, i) => { "use strict"; i.d(t, { l: () => f }); var r = i(4106), n = i(1479), s = i(8062), a = i(1619), o = i(2443), l = i(164), u = i(2311), h = i(6793), c = i(7415), d = i(2777); class f extends n.b { constructor() { super(...arguments), this.type = "svg", this.isSVGTag = !1, this.measureInstanceViewportBox = r.ge } getBaseTargetFromProps(e, t) { return e[t] } readValueFromInstance(e, t) { if (o.f.has(t)) { let e = (0, a.D)(t); return e && e.default || 0 } return t = u.e.has(t) ? t : (0, s.I)(t), e.getAttribute(t) } scrapeMotionValuesFromProps(e, t, i) { return (0, d.x)(e, t, i) } build(e, t, i) { (0, l.B)(e, t, this.isSVGTag, i.transformTemplate) } renderInstance(e, t, i, r) { (0, c.d)(e, t, i, r) } mount(e) { this.isSVGTag = (0, h.n)(e.tagName), super.mount(e) } } }, 164: (e, t, i) => { "use strict"; i.d(t, { B: () => l }); var r = i(5756), n = i(5269); let s = { offset: "stroke-dashoffset", array: "stroke-dasharray" }, a = { offset: "strokeDashoffset", array: "strokeDasharray" }; function o(e, t, i) { return "string" == typeof e ? e : n.px.transform(t + i * e) } function l(e, { attrX: t, attrY: i, attrScale: l, originX: u, originY: h, pathLength: c, pathSpacing: d = 1, pathOffset: f = 0, ...p }, m, g) { if ((0, r.O)(e, p, g), m) { e.style.viewBox && (e.attrs.viewBox = e.style.viewBox); return } e.attrs = e.style, e.style = {}; let { attrs: v, style: y, dimensions: x } = e; v.transform && (x && (y.transform = v.transform), delete v.transform), x && (void 0 !== u || void 0 !== h || y.transform) && (y.transformOrigin = function (e, t, i) { let r = o(t, e.x, e.width), n = o(i, e.y, e.height); return `${r} ${n}` }(x, void 0 !== u ? u : .5, void 0 !== h ? h : .5)), void 0 !== t && (v.x = t), void 0 !== i && (v.y = i), void 0 !== l && (v.scale = l), void 0 !== c && function (e, t, i = 1, r = 0, o = !0) { e.pathLength = 1; let l = o ? s : a; e[l.offset] = n.px.transform(-r); let u = n.px.transform(t), h = n.px.transform(i); e[l.array] = `${u} ${h}` }(v, c, d, f, !1) } }, 2311: (e, t, i) => { "use strict"; i.d(t, { e: () => r }); let r = new Set(["baseFrequency", "diffuseConstant", "kernelMatrix", "kernelUnitLength", "keySplines", "keyTimes", "limitingConeAngle", "markerHeight", "markerWidth", "numOctaves", "targetX", "targetY", "surfaceScale", "specularConstant", "specularExponent", "stdDeviation", "tableValues", "viewBox", "gradientTransform", "pathLength", "startOffset", "textLength", "lengthAdjust"]) }, 6793: (e, t, i) => { "use strict"; i.d(t, { n: () => r }); let r = e => "string" == typeof e && "svg" === e.toLowerCase() }, 7415: (e, t, i) => { "use strict"; i.d(t, { d: () => a }); var r = i(8062), n = i(9836), s = i(2311); function a(e, t, i, a) { for (let i in (0, n.e)(e, t, void 0, a), t.attrs) e.setAttribute(s.e.has(i) ? i : (0, r.I)(i), t.attrs[i]) } }, 2777: (e, t, i) => { "use strict"; i.d(t, { x: () => a }); var r = i(9896), n = i(2443), s = i(4494); function a(e, t, i) { let a = (0, s.x)(e, t, i); for (let i in e) ((0, r.S)(e[i]) || (0, r.S)(t[i])) && (a[-1 !== n.U.indexOf(i) ? "attr" + i.charAt(0).toUpperCase() + i.substring(1) : i] = e[i]); return a } }, 4835: (e, t, i) => { "use strict"; i.d(t, { h: () => c, q: () => h }); var r = i(3420), n = i(104); let s = new Set, a = !1, o = !1; function l() { if (o) { let e = Array.from(s).filter(e => e.needsMeasurement), t = new Set(e.map(e => e.element)), i = new Map; t.forEach(e => { let t = (0, r.W9)(e); t.length && (i.set(e, t), e.render()) }), e.forEach(e => e.measureInitialState()), t.forEach(e => { e.render(); let t = i.get(e); t && t.forEach(([t, i]) => { var r; null === (r = e.getValue(t)) || void 0 === r || r.set(i) }) }), e.forEach(e => e.measureEndState()), e.forEach(e => { void 0 !== e.suspendedScrollY && window.scrollTo(0, e.suspendedScrollY) }) } o = !1, a = !1, s.forEach(e => e.complete()), s.clear() } function u() { s.forEach(e => { e.readKeyframes(), e.needsMeasurement && (o = !0) }) } function h() { u(), l() } class c { constructor(e, t, i, r, n, s = !1) { this.isComplete = !1, this.isAsync = !1, this.needsMeasurement = !1, this.isScheduled = !1, this.unresolvedKeyframes = [...e], this.onComplete = t, this.name = i, this.motionValue = r, this.element = n, this.isAsync = s } scheduleResolve() { this.isScheduled = !0, this.isAsync ? (s.add(this), a || (a = !0, n.Gt.read(u), n.Gt.resolveKeyframes(l))) : (this.readKeyframes(), this.complete()) } readKeyframes() { let { unresolvedKeyframes: e, name: t, element: i, motionValue: r } = this; for (let n = 0; n < e.length; n++)if (null === e[n]) { if (0 === n) { let n = null == r ? void 0 : r.get(), s = e[e.length - 1]; if (void 0 !== n) e[0] = n; else if (i && t) { let r = i.readValue(t, s); null != r && (e[0] = r) } void 0 === e[0] && (e[0] = s), r && void 0 === n && r.set(e[0]) } else e[n] = e[n - 1] } } setFinalKeyframe() { } measureInitialState() { } renderEndStyles() { } measureEndState() { } complete() { this.isComplete = !0, this.onComplete(this.unresolvedKeyframes, this.finalKeyframe), s.delete(this) } cancel() { this.isComplete || (this.isScheduled = !1, s.delete(this)) } resume() { this.isComplete || this.scheduleResolve() } } }, 837: (e, t, i) => { "use strict"; i.d(t, { O: () => o, e: () => a }); var r = i(5490), n = i(6551), s = i(5092); function a(e) { return (0, r.N)(e.animate) || s._.some(t => (0, n.w)(e[t])) } function o(e) { return !!(a(e) || e.variants) } }, 6551: (e, t, i) => { "use strict"; function r(e) { return "string" == typeof e || Array.isArray(e) } i.d(t, { w: () => r }) }, 4737: (e, t, i) => { "use strict"; i.d(t, { K: () => n }); var r = i(3141); function n(e, t, i) { let n = e.getProps(); return (0, r.a)(n, t, void 0 !== i ? i : n.custom, e) } }, 3141: (e, t, i) => { "use strict"; function r(e, t, i, r) { if ("function" == typeof t || ("string" == typeof t && (t = e.variants && e.variants[t]), "function" == typeof t)) { let [n, s] = function (e) { let t = [{}, {}]; return null == e || e.values.forEach((e, i) => { t[0][i] = e.get(), t[1][i] = e.getVelocity() }), t }(r); t = t(void 0 !== i ? i : e.custom, n, s) } return t } i.d(t, { a: () => r }) }, 5092: (e, t, i) => { "use strict"; i.d(t, { U: () => r, _: () => n }); let r = ["animate", "whileInView", "whileFocus", "whileHover", "whileTap", "whileDrag", "exit"], n = ["initial", ...r] }, 4668: (e, t, i) => { "use strict"; i.d(t, { W: () => r }); let r = { skipAnimations: !1, useManualTiming: !1 } }, 2358: (e, t, i) => { "use strict"; function r(e, t) { -1 === e.indexOf(t) && e.push(t) } function n(e, t) { let i = e.indexOf(t); i > -1 && e.splice(i, 1) } i.d(t, { Ai: () => n, Kq: () => r }) }, 2464: (e, t, i) => { "use strict"; i.d(t, { q: () => r }); let r = (e, t, i) => i > t ? t : i < e ? e : i }, 8844: (e, t, i) => { "use strict"; i.d(t, { G: () => u }); var r = i(1533), n = i(8104), s = i(6896), a = i(2464), o = i(8955), l = i(1339); function u(e, t, { clamp: i = !0, ease: h, mixer: c } = {}) { let d = e.length; if ((0, n.V)(d === t.length, "Both input and output ranges must be the same length"), 1 === d) return () => t[0]; if (2 === d && t[0] === t[1]) return () => t[1]; let f = e[0] === e[1]; e[0] > e[d - 1] && (e = [...e].reverse(), t = [...t].reverse()); let p = function (e, t, i) { let n = [], s = i || o.j, a = e.length - 1; for (let i = 0; i < a; i++) { let a = s(e[i], e[i + 1]); if (t) { let e = Array.isArray(t) ? t[i] || r.l : t; a = (0, l.F)(e, a) } n.push(a) } return n }(t, h, c), m = p.length, g = i => { if (f && i < e[0]) return t[0]; let r = 0; if (m > 1) for (; r < e.length - 2 && !(i < e[r + 1]); r++); let n = (0, s.q)(e[r], e[r + 1], i); return p[r](n) }; return i ? t => g((0, a.q)(e[0], e[d - 1], t)) : g } }, 8288: (e, t, i) => { "use strict"; i.d(t, { B: () => r }); let r = "undefined" != typeof window }, 9652: (e, t, i) => { "use strict"; i.d(t, { i: () => r }); let r = e => /^-?(?:\d+(?:\.\d+)?|\.\d+)$/u.test(e) }, 7312: (e, t, i) => { "use strict"; i.d(t, { $: () => r }); let r = e => /^0[^.\s]+$/u.test(e) }, 8955: (e, t, i) => { "use strict"; i.d(t, { j: () => T }); var r = i(9713), n = i(8104); function s(e, t, i) { return (i < 0 && (i += 1), i > 1 && (i -= 1), i < 1 / 6) ? e + (t - e) * 6 * i : i < .5 ? t : i < 2 / 3 ? e + (t - e) * (2 / 3 - i) * 6 : e } var a = i(5252), o = i(3735), l = i(2027); function u(e, t) { return i => i > 0 ? t : e } let h = (e, t, i) => { let r = e * e, n = i * (t * t - r) + r; return n < 0 ? 0 : Math.sqrt(n) }, c = [a.u, o.B, l.V], d = e => c.find(t => t.test(e)); function f(e) { let t = d(e); if ((0, n.$)(!!t, `'${e}' is not an animatable color. Use the equivalent color code instead.`), !t) return !1; let i = t.parse(e); return t === l.V && (i = function ({ hue: e, saturation: t, lightness: i, alpha: r }) { e /= 360, i /= 100; let n = 0, a = 0, o = 0; if (t /= 100) { let r = i < .5 ? i * (1 + t) : i + t - i * t, l = 2 * i - r; n = s(l, r, e + 1 / 3), a = s(l, r, e), o = s(l, r, e - 1 / 3) } else n = a = o = i; return { red: Math.round(255 * n), green: Math.round(255 * a), blue: Math.round(255 * o), alpha: r } }(i)), i } let p = (e, t) => { let i = f(e), n = f(t); if (!i || !n) return u(e, t); let s = { ...i }; return e => (s.red = h(i.red, n.red, e), s.green = h(i.green, n.green, e), s.blue = h(i.blue, n.blue, e), s.alpha = (0, r.k)(i.alpha, n.alpha, e), o.B.transform(s)) }; var m = i(1339), g = i(7739), v = i(615), y = i(568); let x = new Set(["none", "hidden"]); function S(e, t) { return i => (0, r.k)(e, t, i) } function A(e) { return "number" == typeof e ? S : "string" == typeof e ? (0, y.p)(e) ? u : g.y.test(e) ? p : b : Array.isArray(e) ? _ : "object" == typeof e ? g.y.test(e) ? p : E : u } function _(e, t) { let i = [...e], r = i.length, n = e.map((e, i) => A(e)(e, t[i])); return e => { for (let t = 0; t < r; t++)i[t] = n[t](e); return i } } function E(e, t) { let i = { ...e, ...t }, r = {}; for (let n in i) void 0 !== e[n] && void 0 !== t[n] && (r[n] = A(e[n])(e[n], t[n])); return e => { for (let t in r) i[t] = r[t](e); return i } } let b = (e, t) => { let i = v.f.createTransformer(t), r = (0, v.V)(e), s = (0, v.V)(t); return r.indexes.var.length === s.indexes.var.length && r.indexes.color.length === s.indexes.color.length && r.indexes.number.length >= s.indexes.number.length ? x.has(e) && !s.values.length || x.has(t) && !r.values.length ? function (e, t) { return x.has(e) ? i => i <= 0 ? e : t : i => i >= 1 ? t : e }(e, t) : (0, m.F)(_(function (e, t) { var i; let r = [], n = { color: 0, var: 0, number: 0 }; for (let s = 0; s < t.values.length; s++) { let a = t.types[s], o = e.indexes[a][n[a]], l = null !== (i = e.values[o]) && void 0 !== i ? i : 0; r[s] = l, n[a]++ } return r }(r, s), s.values), i) : ((0, n.$)(!0, `Complex values '${e}' and '${t}' too different to mix. Ensure all colors are of the same type, and that each contains the same quantity of number and color values. Falling back to instant transition.`), u(e, t)) }; function T(e, t, i) { return "number" == typeof e && "number" == typeof t && "number" == typeof i ? (0, r.k)(e, t, i) : A(e)(e, t) } }, 9713: (e, t, i) => { "use strict"; i.d(t, { k: () => r }); let r = (e, t, i) => e + (t - e) * i }, 1899: (e, t, i) => { "use strict"; i.d(t, { Z: () => n }); var r = i(971); function n(e) { let t = [0]; return (0, r.f)(t, e.length - 1), t } }, 971: (e, t, i) => { "use strict"; i.d(t, { f: () => s }); var r = i(6896), n = i(9713); function s(e, t) { let i = e[e.length - 1]; for (let s = 1; s <= t; s++) { let a = (0, r.q)(0, t, s); e.push((0, n.k)(i, 1, a)) } } }, 1339: (e, t, i) => { "use strict"; i.d(t, { F: () => n }); let r = (e, t) => i => t(e(i)), n = (...e) => e.reduce(r) }, 7365: (e, t, i) => { "use strict"; i.d(t, { B: () => n, K: () => s }); var r = i(1712); let n = e => !!(e && "object" == typeof e && e.mix && e.toValue), s = e => (0, r.p)(e) ? e[e.length - 1] || 0 : e }, 2606: (e, t, i) => { "use strict"; i.d(t, { v: () => n }); var r = i(2358); class n { constructor() { this.subscriptions = [] } add(e) { return (0, r.Kq)(this.subscriptions, e), () => (0, r.Ai)(this.subscriptions, e) } notify(e, t, i) { let r = this.subscriptions.length; if (r) { if (1 === r) this.subscriptions[0](e, t, i); else for (let n = 0; n < r; n++) { let r = this.subscriptions[n]; r && r(e, t, i) } } } getSize() { return this.subscriptions.length } clear() { this.subscriptions.length = 0 } } }, 8601: (e, t, i) => { "use strict"; i.d(t, { M: () => n }); var r = i(6540); function n(e) { let t = (0, r.useRef)(null); return null === t.current && (t.current = e()), t.current } }, 5128: (e, t, i) => { "use strict"; i.d(t, { E: () => n }); var r = i(6540); let n = i(8288).B ? r.useLayoutEffect : r.useEffect }, 7177: (e, t, i) => { "use strict"; function r(e, t) { return t ? 1e3 / t * e : 0 } i.d(t, { f: () => r }) }, 1671: (e, t, i) => { "use strict"; i.d(t, { L: () => r }); let r = (e, t, i) => { let r = t - e; return ((i - e) % r + r) % r + e } }, 4785: (e, t, i) => { "use strict"; i.d(t, { OQ: () => h }); var r = i(4582), n = i(2606), s = i(7177), a = i(104); let o = e => !isNaN(parseFloat(e)), l = { current: void 0 }; class u { constructor(e, t = {}) { this.version = "11.18.1", this.canTrackVelocity = null, this.events = {}, this.updateAndNotify = (e, t = !0) => { let i = r.k.now(); this.updatedAt !== i && this.setPrevFrameValue(), this.prev = this.current, this.setCurrent(e), this.current !== this.prev && this.events.change && this.events.change.notify(this.current), t && this.events.renderRequest && this.events.renderRequest.notify(this.current) }, this.hasAnimated = !1, this.setCurrent(e), this.owner = t.owner } setCurrent(e) { this.current = e, this.updatedAt = r.k.now(), null === this.canTrackVelocity && void 0 !== e && (this.canTrackVelocity = o(this.current)) } setPrevFrameValue(e = this.current) { this.prevFrameValue = e, this.prevUpdatedAt = this.updatedAt } onChange(e) { return this.on("change", e) } on(e, t) { this.events[e] || (this.events[e] = new n.v); let i = this.events[e].add(t); return "change" === e ? () => { i(), a.Gt.read(() => { this.events.change.getSize() || this.stop() }) } : i } clearListeners() { for (let e in this.events) this.events[e].clear() } attach(e, t) { this.passiveEffect = e, this.stopPassiveEffect = t } set(e, t = !0) { t && this.passiveEffect ? this.passiveEffect(e, this.updateAndNotify) : this.updateAndNotify(e, t) } setWithVelocity(e, t, i) { this.set(t), this.prev = void 0, this.prevFrameValue = e, this.prevUpdatedAt = this.updatedAt - i } jump(e, t = !0) { this.updateAndNotify(e), this.prev = e, this.prevUpdatedAt = this.prevFrameValue = void 0, t && this.stop(), this.stopPassiveEffect && this.stopPassiveEffect() } get() { return l.current && l.current.push(this), this.current } getPrevious() { return this.prev } getVelocity() { let e = r.k.now(); if (!this.canTrackVelocity || void 0 === this.prevFrameValue || e - this.updatedAt > 30) return 0; let t = Math.min(this.updatedAt - this.prevUpdatedAt, 30); return (0, s.f)(parseFloat(this.current) - parseFloat(this.prevFrameValue), t) } start(e) { return this.stop(), new Promise(t => { this.hasAnimated = !0, this.animation = e(t), this.events.animationStart && this.events.animationStart.notify() }).then(() => { this.events.animationComplete && this.events.animationComplete.notify(), this.clearAnimation() }) } stop() { this.animation && (this.animation.stop(), this.events.animationCancel && this.events.animationCancel.notify()), this.clearAnimation() } isAnimating() { return !!this.animation } clearAnimation() { delete this.animation } destroy() { this.clearListeners(), this.stop(), this.stopPassiveEffect && this.stopPassiveEffect() } } function h(e, t) { return new u(e, t) } }, 5252: (e, t, i) => { "use strict"; i.d(t, { u: () => n }); var r = i(3735); let n = { test: (0, i(8521).$)("#"), parse: function (e) { let t = "", i = "", r = "", n = ""; return e.length > 5 ? (t = e.substring(1, 3), i = e.substring(3, 5), r = e.substring(5, 7), n = e.substring(7, 9)) : (t = e.substring(1, 2), i = e.substring(2, 3), r = e.substring(3, 4), n = e.substring(4, 5), t += t, i += i, r += r, n += n), { red: parseInt(t, 16), green: parseInt(i, 16), blue: parseInt(r, 16), alpha: n ? parseInt(n, 16) / 255 : 1 } }, transform: r.B.transform } }, 2027: (e, t, i) => { "use strict"; i.d(t, { V: () => o }); var r = i(2944), n = i(5269), s = i(6046), a = i(8521); let o = { test: (0, a.$)("hsl", "hue"), parse: (0, a.q)("hue", "saturation", "lightness"), transform: ({ hue: e, saturation: t, lightness: i, alpha: a = 1 }) => "hsla(" + Math.round(e) + ", " + n.KN.transform((0, s.a)(t)) + ", " + n.KN.transform((0, s.a)(i)) + ", " + (0, s.a)(r.X4.transform(a)) + ")" } }, 7739: (e, t, i) => { "use strict"; i.d(t, { y: () => a }); var r = i(5252), n = i(2027), s = i(3735); let a = { test: e => s.B.test(e) || r.u.test(e) || n.V.test(e), parse: e => s.B.test(e) ? s.B.parse(e) : n.V.test(e) ? n.V.parse(e) : r.u.parse(e), transform: e => "string" == typeof e ? e : e.hasOwnProperty("red") ? s.B.transform(e) : n.V.transform(e) } }, 3735: (e, t, i) => { "use strict"; i.d(t, { B: () => u }); var r = i(2464), n = i(2944), s = i(6046), a = i(8521); let o = e => (0, r.q)(0, 255, e), l = { ...n.ai, transform: e => Math.round(o(e)) }, u = { test: (0, a.$)("rgb", "red"), parse: (0, a.q)("red", "green", "blue"), transform: ({ red: e, green: t, blue: i, alpha: r = 1 }) => "rgba(" + l.transform(e) + ", " + l.transform(t) + ", " + l.transform(i) + ", " + (0, s.a)(n.X4.transform(r)) + ")" } }, 8521: (e, t, i) => { "use strict"; i.d(t, { $: () => s, q: () => a }); var r = i(849); let n = /^(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))$/iu, s = (e, t) => i => !!("string" == typeof i && n.test(i) && i.startsWith(e) || t && null != i && Object.prototype.hasOwnProperty.call(i, t)), a = (e, t, i) => n => { if ("string" != typeof n) return n; let [s, a, o, l] = n.match(r.S); return { [e]: parseFloat(s), [t]: parseFloat(a), [i]: parseFloat(o), alpha: void 0 !== l ? parseFloat(l) : 1 } } }, 6044: (e, t, i) => { "use strict"; i.d(t, { p: () => l }); var r = i(615), n = i(849); let s = new Set(["brightness", "contrast", "saturate", "opacity"]); function a(e) { let [t, i] = e.slice(0, -1).split("("); if ("drop-shadow" === t) return e; let [r] = i.match(n.S) || []; if (!r) return e; let a = i.replace(r, ""), o = s.has(t) ? 1 : 0; return r !== i && (o *= 100), t + "(" + o + a + ")" } let o = /\b([a-z-]*)\(.*?\)/gu, l = { ...r.f, getAnimatableNone: e => { let t = e.match(o); return t ? t.map(a).join(" ") : e } } }, 615: (e, t, i) => { "use strict"; i.d(t, { V: () => h, f: () => p }); var r = i(7739); let n = /(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))/giu; var s = i(849), a = i(6046); let o = "number", l = "color", u = /var\s*\(\s*--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)|#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\)|-?(?:\d+(?:\.\d+)?|\.\d+)/giu; function h(e) { let t = e.toString(), i = [], n = { color: [], number: [], var: [] }, s = [], a = 0, h = t.replace(u, e => (r.y.test(e) ? (n.color.push(a), s.push(l), i.push(r.y.parse(e))) : e.startsWith("var(") ? (n.var.push(a), s.push("var"), i.push(e)) : (n.number.push(a), s.push(o), i.push(parseFloat(e))), ++a, "${}")).split("${}"); return { values: i, split: h, indexes: n, types: s } } function c(e) { return h(e).values } function d(e) { let { split: t, types: i } = h(e), n = t.length; return e => { let s = ""; for (let u = 0; u < n; u++)if (s += t[u], void 0 !== e[u]) { let t = i[u]; t === o ? s += (0, a.a)(e[u]) : t === l ? s += r.y.transform(e[u]) : s += e[u] } return s } } let f = e => "number" == typeof e ? 0 : e, p = { test: function (e) { var t, i; return isNaN(e) && "string" == typeof e && ((null === (t = e.match(s.S)) || void 0 === t ? void 0 : t.length) || 0) + ((null === (i = e.match(n)) || void 0 === i ? void 0 : i.length) || 0) > 0 }, parse: c, createTransformer: d, getAnimatableNone: function (e) { let t = c(e); return d(e)(t.map(f)) } } }, 2944: (e, t, i) => { "use strict"; i.d(t, { X4: () => s, ai: () => n, hs: () => a }); var r = i(2464); let n = { test: e => "number" == typeof e, parse: parseFloat, transform: e => e }, s = { ...n, transform: e => (0, r.q)(0, 1, e) }, a = { ...n, default: 1 } }, 5269: (e, t, i) => { "use strict"; i.d(t, { KN: () => s, gQ: () => u, px: () => a, uj: () => n, vh: () => o, vw: () => l }); let r = e => ({ test: t => "string" == typeof t && t.endsWith(e) && 1 === t.split(" ").length, parse: parseFloat, transform: t => `${t}${e}` }), n = r("deg"), s = r("%"), a = r("px"), o = r("vh"), l = r("vw"), u = { ...s, parse: e => s.parse(e) / 100, transform: e => s.transform(100 * e) } }, 849: (e, t, i) => { "use strict"; i.d(t, { S: () => r }); let r = /-?(?:\d+(?:\.\d+)?|\.\d+)/gu }, 6046: (e, t, i) => { "use strict"; i.d(t, { a: () => r }); let r = e => Math.round(1e5 * e) / 1e5 }, 9194: (e, t, i) => { "use strict"; i.d(t, { g: () => n }); var r = i(9896); function n(e, t) { let i = e.getValue("willChange"); if ((0, r.S)(i) && i.add) return i.add(t) } }, 9896: (e, t, i) => { "use strict"; i.d(t, { S: () => r }); let r = e => !!(e && e.getVelocity) }, 4945: (e, t, i) => {
    "use strict"; let r, n, s; i.r(t), i.d(t, { AbrController: () => tW, AttrList: () => w, AudioStreamController: () => rt, AudioTrackController: () => rs, BasePlaylistController: () => tO, BaseSegment: () => I, BaseStreamController: () => is, BufferController: () => rc, CMCDController: () => ny, CapLevelController: () => r4, ChunkMetadata: () => t$, ContentSteeringController: () => nx, DateRange: () => M, EMEController: () => r6, ErrorActionFlags: () => tP, ErrorController: () => tD, ErrorDetails: () => x, ErrorTypes: () => y, Events: () => v, FPSController: () => r5, Fragment: () => L, Hls: () => nN, HlsSkip: () => tc, HlsUrlParameters: () => tf, KeySystemFormats: () => N, KeySystems: () => U, Level: () => tp, LevelDetails: () => D, LevelKey: () => eR, LoadStats: () => R, MetadataSchema: () => ti, NetworkErrorAction: () => tL, Part: () => P, PlaylistLevelType: () => e3, SubtitleStreamController: () => ra, SubtitleTrackController: () => rl, TimelineController: () => r0, default: () => nN, getMediaSource: () => eD, isMSESupported: () => nO, isSupported: () => nk }); var a, o, l, u = { exports: {} }; !function (e, t) { var i, r, n, s, a; i = /^(?=((?:[a-zA-Z0-9+\-.]+:)?))\1(?=((?:\/\/[^\/?#]*)?))\2(?=((?:(?:[^?#\/]*\/)*[^;?#\/]*)?))\3((?:;[^?#]*)?)(\?[^#]*)?(#[^]*)?$/, r = /^(?=([^\/?#]*))\1([^]*)$/, n = /(?:\/|^)\.(?=\/)/g, s = /(?:\/|^)\.\.\/(?!\.\.\/)[^\/]*(?=\/)/g, a = { buildAbsoluteURL: function (e, t, i) { if (i = i || {}, e = e.trim(), !(t = t.trim())) { if (!i.alwaysNormalize) return e; var n = a.parseURL(e); if (!n) throw Error("Error trying to parse base URL."); return n.path = a.normalizePath(n.path), a.buildURLFromParts(n) } var s = a.parseURL(t); if (!s) throw Error("Error trying to parse relative URL."); if (s.scheme) return i.alwaysNormalize ? (s.path = a.normalizePath(s.path), a.buildURLFromParts(s)) : t; var o = a.parseURL(e); if (!o) throw Error("Error trying to parse base URL."); if (!o.netLoc && o.path && "/" !== o.path[0]) { var l = r.exec(o.path); o.netLoc = l[1], o.path = l[2] } o.netLoc && !o.path && (o.path = "/"); var u = { scheme: o.scheme, netLoc: s.netLoc, path: null, params: s.params, query: s.query, fragment: s.fragment }; if (!s.netLoc && (u.netLoc = o.netLoc, "/" !== s.path[0])) { if (s.path) { var h = o.path, c = h.substring(0, h.lastIndexOf("/") + 1) + s.path; u.path = a.normalizePath(c) } else u.path = o.path, s.params || (u.params = o.params, s.query || (u.query = o.query)) } return null === u.path && (u.path = i.alwaysNormalize ? a.normalizePath(s.path) : s.path), a.buildURLFromParts(u) }, parseURL: function (e) { var t = i.exec(e); return t ? { scheme: t[1] || "", netLoc: t[2] || "", path: t[3] || "", params: t[4] || "", query: t[5] || "", fragment: t[6] || "" } : null }, normalizePath: function (e) { for (e = e.split("").reverse().join("").replace(n, ""); e.length !== (e = e.replace(s, "")).length;); return e.split("").reverse().join("") }, buildURLFromParts: function (e) { return e.scheme + e.netLoc + e.path + e.params + e.query + e.fragment } }, e.exports = a }(u); var h = u.exports; function c(e, t) { var i = Object.keys(e); if (Object.getOwnPropertySymbols) { var r = Object.getOwnPropertySymbols(e); t && (r = r.filter(function (t) { return Object.getOwnPropertyDescriptor(e, t).enumerable })), i.push.apply(i, r) } return i } function d(e) { for (var t = 1; t < arguments.length; t++) { var i = null != arguments[t] ? arguments[t] : {}; t % 2 ? c(Object(i), !0).forEach(function (t) { !function (e, t, i) { var r; (t = "symbol" == typeof (r = function (e, t) { if ("object" != typeof e || !e) return e; var i = e[Symbol.toPrimitive]; if (void 0 !== i) { var r = i.call(e, t || "default"); if ("object" != typeof r) return r; throw TypeError("@@toPrimitive must return a primitive value.") } return ("string" === t ? String : Number)(e) }(t, "string")) ? r : String(r)) in e ? Object.defineProperty(e, t, { value: i, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = i }(e, t, i[t]) }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(i)) : c(Object(i)).forEach(function (t) { Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(i, t)) }) } return e } function f() { return (f = Object.assign ? Object.assign.bind() : function (e) { for (var t = 1; t < arguments.length; t++) { var i = arguments[t]; for (var r in i) Object.prototype.hasOwnProperty.call(i, r) && (e[r] = i[r]) } return e }).apply(this, arguments) } let p = Number.isFinite || function (e) { return "number" == typeof e && isFinite(e) }, m = Number.isSafeInteger || function (e) { return "number" == typeof e && Math.abs(e) <= g }, g = Number.MAX_SAFE_INTEGER || 0x1fffffffffffff, v = function (e) { return e.MEDIA_ATTACHING = "hlsMediaAttaching", e.MEDIA_ATTACHED = "hlsMediaAttached", e.MEDIA_DETACHING = "hlsMediaDetaching", e.MEDIA_DETACHED = "hlsMediaDetached", e.BUFFER_RESET = "hlsBufferReset", e.BUFFER_CODECS = "hlsBufferCodecs", e.BUFFER_CREATED = "hlsBufferCreated", e.BUFFER_APPENDING = "hlsBufferAppending", e.BUFFER_APPENDED = "hlsBufferAppended", e.BUFFER_EOS = "hlsBufferEos", e.BUFFER_FLUSHING = "hlsBufferFlushing", e.BUFFER_FLUSHED = "hlsBufferFlushed", e.MANIFEST_LOADING = "hlsManifestLoading", e.MANIFEST_LOADED = "hlsManifestLoaded", e.MANIFEST_PARSED = "hlsManifestParsed", e.LEVEL_SWITCHING = "hlsLevelSwitching", e.LEVEL_SWITCHED = "hlsLevelSwitched", e.LEVEL_LOADING = "hlsLevelLoading", e.LEVEL_LOADED = "hlsLevelLoaded", e.LEVEL_UPDATED = "hlsLevelUpdated", e.LEVEL_PTS_UPDATED = "hlsLevelPtsUpdated", e.LEVELS_UPDATED = "hlsLevelsUpdated", e.AUDIO_TRACKS_UPDATED = "hlsAudioTracksUpdated", e.AUDIO_TRACK_SWITCHING = "hlsAudioTrackSwitching", e.AUDIO_TRACK_SWITCHED = "hlsAudioTrackSwitched", e.AUDIO_TRACK_LOADING = "hlsAudioTrackLoading", e.AUDIO_TRACK_LOADED = "hlsAudioTrackLoaded", e.SUBTITLE_TRACKS_UPDATED = "hlsSubtitleTracksUpdated", e.SUBTITLE_TRACKS_CLEARED = "hlsSubtitleTracksCleared", e.SUBTITLE_TRACK_SWITCH = "hlsSubtitleTrackSwitch", e.SUBTITLE_TRACK_LOADING = "hlsSubtitleTrackLoading", e.SUBTITLE_TRACK_LOADED = "hlsSubtitleTrackLoaded", e.SUBTITLE_FRAG_PROCESSED = "hlsSubtitleFragProcessed", e.CUES_PARSED = "hlsCuesParsed", e.NON_NATIVE_TEXT_TRACKS_FOUND = "hlsNonNativeTextTracksFound", e.INIT_PTS_FOUND = "hlsInitPtsFound", e.FRAG_LOADING = "hlsFragLoading", e.FRAG_LOAD_EMERGENCY_ABORTED = "hlsFragLoadEmergencyAborted", e.FRAG_LOADED = "hlsFragLoaded", e.FRAG_DECRYPTED = "hlsFragDecrypted", e.FRAG_PARSING_INIT_SEGMENT = "hlsFragParsingInitSegment", e.FRAG_PARSING_USERDATA = "hlsFragParsingUserdata", e.FRAG_PARSING_METADATA = "hlsFragParsingMetadata", e.FRAG_PARSED = "hlsFragParsed", e.FRAG_BUFFERED = "hlsFragBuffered", e.FRAG_CHANGED = "hlsFragChanged", e.FPS_DROP = "hlsFpsDrop", e.FPS_DROP_LEVEL_CAPPING = "hlsFpsDropLevelCapping", e.MAX_AUTO_LEVEL_UPDATED = "hlsMaxAutoLevelUpdated", e.ERROR = "hlsError", e.DESTROYING = "hlsDestroying", e.KEY_LOADING = "hlsKeyLoading", e.KEY_LOADED = "hlsKeyLoaded", e.LIVE_BACK_BUFFER_REACHED = "hlsLiveBackBufferReached", e.BACK_BUFFER_REACHED = "hlsBackBufferReached", e.STEERING_MANIFEST_LOADED = "hlsSteeringManifestLoaded", e }({}), y = function (e) { return e.NETWORK_ERROR = "networkError", e.MEDIA_ERROR = "mediaError", e.KEY_SYSTEM_ERROR = "keySystemError", e.MUX_ERROR = "muxError", e.OTHER_ERROR = "otherError", e }({}), x = function (e) { return e.KEY_SYSTEM_NO_KEYS = "keySystemNoKeys", e.KEY_SYSTEM_NO_ACCESS = "keySystemNoAccess", e.KEY_SYSTEM_NO_SESSION = "keySystemNoSession", e.KEY_SYSTEM_NO_CONFIGURED_LICENSE = "keySystemNoConfiguredLicense", e.KEY_SYSTEM_LICENSE_REQUEST_FAILED = "keySystemLicenseRequestFailed", e.KEY_SYSTEM_SERVER_CERTIFICATE_REQUEST_FAILED = "keySystemServerCertificateRequestFailed", e.KEY_SYSTEM_SERVER_CERTIFICATE_UPDATE_FAILED = "keySystemServerCertificateUpdateFailed", e.KEY_SYSTEM_SESSION_UPDATE_FAILED = "keySystemSessionUpdateFailed", e.KEY_SYSTEM_STATUS_OUTPUT_RESTRICTED = "keySystemStatusOutputRestricted", e.KEY_SYSTEM_STATUS_INTERNAL_ERROR = "keySystemStatusInternalError", e.MANIFEST_LOAD_ERROR = "manifestLoadError", e.MANIFEST_LOAD_TIMEOUT = "manifestLoadTimeOut", e.MANIFEST_PARSING_ERROR = "manifestParsingError", e.MANIFEST_INCOMPATIBLE_CODECS_ERROR = "manifestIncompatibleCodecsError", e.LEVEL_EMPTY_ERROR = "levelEmptyError", e.LEVEL_LOAD_ERROR = "levelLoadError", e.LEVEL_LOAD_TIMEOUT = "levelLoadTimeOut", e.LEVEL_PARSING_ERROR = "levelParsingError", e.LEVEL_SWITCH_ERROR = "levelSwitchError", e.AUDIO_TRACK_LOAD_ERROR = "audioTrackLoadError", e.AUDIO_TRACK_LOAD_TIMEOUT = "audioTrackLoadTimeOut", e.SUBTITLE_LOAD_ERROR = "subtitleTrackLoadError", e.SUBTITLE_TRACK_LOAD_TIMEOUT = "subtitleTrackLoadTimeOut", e.FRAG_LOAD_ERROR = "fragLoadError", e.FRAG_LOAD_TIMEOUT = "fragLoadTimeOut", e.FRAG_DECRYPT_ERROR = "fragDecryptError", e.FRAG_PARSING_ERROR = "fragParsingError", e.FRAG_GAP = "fragGap", e.REMUX_ALLOC_ERROR = "remuxAllocError", e.KEY_LOAD_ERROR = "keyLoadError", e.KEY_LOAD_TIMEOUT = "keyLoadTimeOut", e.BUFFER_ADD_CODEC_ERROR = "bufferAddCodecError", e.BUFFER_INCOMPATIBLE_CODECS_ERROR = "bufferIncompatibleCodecsError", e.BUFFER_APPEND_ERROR = "bufferAppendError", e.BUFFER_APPENDING_ERROR = "bufferAppendingError", e.BUFFER_STALLED_ERROR = "bufferStalledError", e.BUFFER_FULL_ERROR = "bufferFullError", e.BUFFER_SEEK_OVER_HOLE = "bufferSeekOverHole", e.BUFFER_NUDGE_ON_STALL = "bufferNudgeOnStall", e.INTERNAL_EXCEPTION = "internalException", e.INTERNAL_ABORTED = "aborted", e.UNKNOWN = "unknown", e }({}), S = function () { }, A = { trace: S, debug: S, log: S, warn: S, info: S, error: S }, _ = A, E = _, b = /^(\d+)x(\d+)$/, T = /(.+?)=(".*?"|.*?)(?:,|$)/g; class w { constructor(e) { "string" == typeof e && (e = w.parseAttrList(e)), f(this, e) } get clientAttrs() { return Object.keys(this).filter(e => "X-" === e.substring(0, 2)) } decimalInteger(e) { let t = parseInt(this[e], 10); return t > Number.MAX_SAFE_INTEGER ? 1 / 0 : t } hexadecimalInteger(e) { if (!this[e]) return null; { let t = (this[e] || "0x").slice(2), i = new Uint8Array((t = (1 & t.length ? "0" : "") + t).length / 2); for (let e = 0; e < t.length / 2; e++)i[e] = parseInt(t.slice(2 * e, 2 * e + 2), 16); return i } } hexadecimalIntegerAsNumber(e) { let t = parseInt(this[e], 16); return t > Number.MAX_SAFE_INTEGER ? 1 / 0 : t } decimalFloatingPoint(e) { return parseFloat(this[e]) } optionalFloat(e, t) { let i = this[e]; return i ? parseFloat(i) : t } enumeratedString(e) { return this[e] } bool(e) { return "YES" === this[e] } decimalResolution(e) { let t = b.exec(this[e]); if (null !== t) return { width: parseInt(t[1], 10), height: parseInt(t[2], 10) } } static parseAttrList(e) { let t; let i = {}; for (T.lastIndex = 0; null !== (t = T.exec(e));) { let e = t[2]; 0 === e.indexOf('"') && e.lastIndexOf('"') === e.length - 1 && (e = e.slice(1, -1)), i[t[1].trim()] = e } return i } } class M { constructor(e, t) { if (this.attr = void 0, this._startDate = void 0, this._endDate = void 0, this._badValueForSameId = void 0, t) { let i = t.attr; for (let t in i) if (Object.prototype.hasOwnProperty.call(e, t) && e[t] !== i[t]) { E.warn(`DATERANGE tag attribute: "${t}" does not match for tags with ID: "${e.ID}"`), this._badValueForSameId = t; break } e = f(new w({}), i, e) } if (this.attr = e, this._startDate = new Date(e["START-DATE"]), "END-DATE" in this.attr) { let e = new Date(this.attr["END-DATE"]); p(e.getTime()) && (this._endDate = e) } } get id() { return this.attr.ID } get class() { return this.attr.CLASS } get startDate() { return this._startDate } get endDate() { if (this._endDate) return this._endDate; let e = this.duration; return null !== e ? new Date(this._startDate.getTime() + 1e3 * e) : null } get duration() { if ("DURATION" in this.attr) { let e = this.attr.decimalFloatingPoint("DURATION"); if (p(e)) return e } else if (this._endDate) return (this._endDate.getTime() - this._startDate.getTime()) / 1e3; return null } get plannedDuration() { return "PLANNED-DURATION" in this.attr ? this.attr.decimalFloatingPoint("PLANNED-DURATION") : null } get endOnNext() { return this.attr.bool("END-ON-NEXT") } get isValid() { return !!this.id && !this._badValueForSameId && p(this.startDate.getTime()) && (null === this.duration || this.duration >= 0) && (!this.endOnNext || !!this.class) } } class R { constructor() { this.aborted = !1, this.loaded = 0, this.retry = 0, this.total = 0, this.chunkCount = 0, this.bwEstimate = 0, this.loading = { start: 0, first: 0, end: 0 }, this.parsing = { start: 0, end: 0 }, this.buffering = { start: 0, first: 0, end: 0 } } } var C = { AUDIO: "audio", VIDEO: "video", AUDIOVIDEO: "audiovideo" }; class I { constructor(e) { this._byteRange = null, this._url = null, this.baseurl = void 0, this.relurl = void 0, this.elementaryStreams = { [C.AUDIO]: null, [C.VIDEO]: null, [C.AUDIOVIDEO]: null }, this.baseurl = e } setByteRange(e, t) { let i; let r = e.split("@", 2); i = 1 === r.length ? (null == t ? void 0 : t.byteRangeEndOffset) || 0 : parseInt(r[1]), this._byteRange = [i, parseInt(r[0]) + i] } get byteRange() { return this._byteRange ? this._byteRange : [] } get byteRangeStartOffset() { return this.byteRange[0] } get byteRangeEndOffset() { return this.byteRange[1] } get url() { return !this._url && this.baseurl && this.relurl && (this._url = h.buildAbsoluteURL(this.baseurl, this.relurl, { alwaysNormalize: !0 })), this._url || "" } set url(e) { this._url = e } } class L extends I { constructor(e, t) { super(t), this._decryptdata = null, this.rawProgramDateTime = null, this.programDateTime = null, this.tagList = [], this.duration = 0, this.sn = 0, this.levelkeys = void 0, this.type = void 0, this.loader = null, this.keyLoader = null, this.level = -1, this.cc = 0, this.startPTS = void 0, this.endPTS = void 0, this.startDTS = void 0, this.endDTS = void 0, this.start = 0, this.deltaPTS = void 0, this.maxStartPTS = void 0, this.minEndPTS = void 0, this.stats = new R, this.data = void 0, this.bitrateTest = !1, this.title = null, this.initSegment = null, this.endList = void 0, this.gap = void 0, this.urlId = 0, this.type = e } get decryptdata() { let { levelkeys: e } = this; if (!e && !this._decryptdata) return null; if (!this._decryptdata && this.levelkeys && !this.levelkeys.NONE) { let e = this.levelkeys.identity; if (e) this._decryptdata = e.getDecryptData(this.sn); else { let e = Object.keys(this.levelkeys); if (1 === e.length) return this._decryptdata = this.levelkeys[e[0]].getDecryptData(this.sn) } } return this._decryptdata } get end() { return this.start + this.duration } get endProgramDateTime() { if (null === this.programDateTime || !p(this.programDateTime)) return null; let e = p(this.duration) ? this.duration : 0; return this.programDateTime + 1e3 * e } get encrypted() { var e; if (null != (e = this._decryptdata) && e.encrypted) return !0; if (this.levelkeys) { let e = Object.keys(this.levelkeys), t = e.length; if (t > 1 || 1 === t && this.levelkeys[e[0]].encrypted) return !0 } return !1 } setKeyFormat(e) { if (this.levelkeys) { let t = this.levelkeys[e]; t && !this._decryptdata && (this._decryptdata = t.getDecryptData(this.sn)) } } abortRequests() { var e, t; null == (e = this.loader) || e.abort(), null == (t = this.keyLoader) || t.abort() } setElementaryStreamInfo(e, t, i, r, n, s = !1) { let { elementaryStreams: a } = this, o = a[e]; if (!o) { a[e] = { startPTS: t, endPTS: i, startDTS: r, endDTS: n, partial: s }; return } o.startPTS = Math.min(o.startPTS, t), o.endPTS = Math.max(o.endPTS, i), o.startDTS = Math.min(o.startDTS, r), o.endDTS = Math.max(o.endDTS, n) } clearElementaryStreamInfo() { let { elementaryStreams: e } = this; e[C.AUDIO] = null, e[C.VIDEO] = null, e[C.AUDIOVIDEO] = null } } class P extends I { constructor(e, t, i, r, n) { super(i), this.fragOffset = 0, this.duration = 0, this.gap = !1, this.independent = !1, this.relurl = void 0, this.fragment = void 0, this.index = void 0, this.stats = new R, this.duration = e.decimalFloatingPoint("DURATION"), this.gap = e.bool("GAP"), this.independent = e.bool("INDEPENDENT"), this.relurl = e.enumeratedString("URI"), this.fragment = t, this.index = r; let s = e.enumeratedString("BYTERANGE"); s && this.setByteRange(s, n), n && (this.fragOffset = n.fragOffset + n.duration) } get start() { return this.fragment.start + this.fragOffset } get end() { return this.start + this.duration } get loaded() { let { elementaryStreams: e } = this; return !!(e.audio || e.video || e.audiovideo) } } class D { constructor(e) { this.PTSKnown = !1, this.alignedSliding = !1, this.averagetargetduration = void 0, this.endCC = 0, this.endSN = 0, this.fragments = void 0, this.fragmentHint = void 0, this.partList = null, this.dateRanges = void 0, this.live = !0, this.ageHeader = 0, this.advancedDateTime = void 0, this.updated = !0, this.advanced = !0, this.availabilityDelay = void 0, this.misses = 0, this.startCC = 0, this.startSN = 0, this.startTimeOffset = null, this.targetduration = 0, this.totalduration = 0, this.type = null, this.url = void 0, this.m3u8 = "", this.version = null, this.canBlockReload = !1, this.canSkipUntil = 0, this.canSkipDateRanges = !1, this.skippedSegments = 0, this.recentlyRemovedDateranges = void 0, this.partHoldBack = 0, this.holdBack = 0, this.partTarget = 0, this.preloadHint = void 0, this.renditionReports = void 0, this.tuneInGoal = 0, this.deltaUpdateFailed = void 0, this.driftStartTime = 0, this.driftEndTime = 0, this.driftStart = 0, this.driftEnd = 0, this.encryptedFragments = void 0, this.playlistParsingError = null, this.variableList = null, this.hasVariableRefs = !1, this.fragments = [], this.encryptedFragments = [], this.dateRanges = {}, this.url = e } reloaded(e) { if (!e) { this.advanced = !0, this.updated = !0; return } let t = this.lastPartSn - e.lastPartSn, i = this.lastPartIndex - e.lastPartIndex; this.updated = this.endSN !== e.endSN || !!i || !!t || !this.live, this.advanced = this.endSN > e.endSN || t > 0 || 0 === t && i > 0, this.updated || this.advanced ? this.misses = Math.floor(.6 * e.misses) : this.misses = e.misses + 1, this.availabilityDelay = e.availabilityDelay } get hasProgramDateTime() { return !!this.fragments.length && p(this.fragments[this.fragments.length - 1].programDateTime) } get levelTargetDuration() { return this.averagetargetduration || this.targetduration || 10 } get drift() { let e = this.driftEndTime - this.driftStartTime; return e > 0 ? 1e3 * (this.driftEnd - this.driftStart) / e : 1 } get edge() { return this.partEnd || this.fragmentEnd } get partEnd() { var e; return null != (e = this.partList) && e.length ? this.partList[this.partList.length - 1].end : this.fragmentEnd } get fragmentEnd() { var e; return null != (e = this.fragments) && e.length ? this.fragments[this.fragments.length - 1].end : 0 } get age() { return this.advancedDateTime ? Math.max(Date.now() - this.advancedDateTime, 0) / 1e3 : 0 } get lastPartIndex() { var e; return null != (e = this.partList) && e.length ? this.partList[this.partList.length - 1].index : -1 } get lastPartSn() { var e; return null != (e = this.partList) && e.length ? this.partList[this.partList.length - 1].fragment.sn : this.endSN } } function O(e) { return Uint8Array.from(atob(e), e => e.charCodeAt(0)) } function k(e) { return Uint8Array.from(unescape(encodeURIComponent(e)), e => e.charCodeAt(0)) } let F = "undefined" != typeof self ? self : void 0; var U = { CLEARKEY: "org.w3.clearkey", FAIRPLAY: "com.apple.fps", PLAYREADY: "com.microsoft.playready", WIDEVINE: "com.widevine.alpha" }, N = { CLEARKEY: "org.w3.clearkey", FAIRPLAY: "com.apple.streamingkeydelivery", PLAYREADY: "com.microsoft.playready", WIDEVINE: "urn:uuid:edef8ba9-79d6-4ace-a3c8-27dcd51d21ed" }; function B(e) { switch (e) { case N.FAIRPLAY: return U.FAIRPLAY; case N.PLAYREADY: return U.PLAYREADY; case N.WIDEVINE: return U.WIDEVINE; case N.CLEARKEY: return U.CLEARKEY } } var z = { CENC: "1077efecc0b24d02ace33c1e52e2fb4b", CLEARKEY: "e2719d58a985b3c9781ab030af78d30e", PLAYREADY: "9a04f07998404286ab92e65be0885f95", WIDEVINE: "edef8ba979d64acea3c827dcd51d21ed" }; function G(e) { return e === z.WIDEVINE ? U.WIDEVINE : e === z.PLAYREADY ? U.PLAYREADY : e === z.CENC || e === z.CLEARKEY ? U.CLEARKEY : void 0 } function H(e) { switch (e) { case U.FAIRPLAY: return N.FAIRPLAY; case U.PLAYREADY: return N.PLAYREADY; case U.WIDEVINE: return N.WIDEVINE; case U.CLEARKEY: return N.CLEARKEY } } function V(e) { let { drmSystems: t, widevineLicenseUrl: i } = e, r = t ? [U.FAIRPLAY, U.WIDEVINE, U.PLAYREADY, U.CLEARKEY].filter(e => !!t[e]) : []; return !r[U.WIDEVINE] && i && r.push(U.WIDEVINE), r } let W = function (e) { return null != F && null != (e = F.navigator) && e.requestMediaKeySystemAccess ? self.navigator.requestMediaKeySystemAccess.bind(self.navigator) : null }(); function j(e) { let t = new Uint16Array(e.buffer, e.byteOffset, e.byteLength / 2), i = String.fromCharCode.apply(null, Array.from(t)), r = i.substring(i.indexOf("<"), i.length), n = new DOMParser().parseFromString(r, "text/xml").getElementsByTagName("KID")[0]; if (n) { let e = n.childNodes[0] ? n.childNodes[0].nodeValue : n.getAttribute("VALUE"); if (e) { let t = O(e).subarray(0, 16); return !function (e) { let t = function (e, t, i) { let r = e[t]; e[t] = e[i], e[i] = r }; t(e, 0, 3), t(e, 1, 2), t(e, 4, 5), t(e, 6, 7) }(t), t } } return null } function Y(e, t, i) { return Uint8Array.prototype.slice ? e.slice(t, i) : new Uint8Array(Array.prototype.slice.call(e, t, i)) } let X = (e, t) => t + 10 <= e.length && 73 === e[t] && 68 === e[t + 1] && 51 === e[t + 2] && e[t + 3] < 255 && e[t + 4] < 255 && e[t + 6] < 128 && e[t + 7] < 128 && e[t + 8] < 128 && e[t + 9] < 128, K = (e, t) => t + 10 <= e.length && 51 === e[t] && 68 === e[t + 1] && 73 === e[t + 2] && e[t + 3] < 255 && e[t + 4] < 255 && e[t + 6] < 128 && e[t + 7] < 128 && e[t + 8] < 128 && e[t + 9] < 128, q = (e, t) => { let i = t, r = 0; for (; X(e, t);)r += 10, r += Q(e, t + 6), K(e, t + 10) && (r += 10), t += r; if (r > 0) return e.subarray(i, i + r) }, Q = (e, t) => (127 & e[t]) << 21 | (127 & e[t + 1]) << 14 | (127 & e[t + 2]) << 7 | 127 & e[t + 3], Z = (e, t) => X(e, t) && Q(e, t + 6) + 10 <= e.length - t, $ = e => { let t = et(e); for (let e = 0; e < t.length; e++) { let i = t[e]; if (J(i)) return ea(i) } }, J = e => e && "PRIV" === e.key && "com.apple.streaming.transportStreamTimestamp" === e.info, ee = e => { let t = String.fromCharCode(e[0], e[1], e[2], e[3]), i = Q(e, 4); return { type: t, size: i, data: e.subarray(10, 10 + i) } }, et = e => { let t = 0, i = []; for (; X(e, t);) { let r = Q(e, t + 6), n = (t += 10) + r; for (; t + 8 < n;) { let r = ee(e.subarray(t)), n = ei(r); n && i.push(n), t += r.size + 10 } K(e, t) && (t += 10) } return i }, ei = e => "PRIV" === e.type ? er(e) : "W" === e.type[0] ? es(e) : en(e), er = e => { if (e.size < 2) return; let t = eo(e.data, !0), i = new Uint8Array(e.data.subarray(t.length + 1)); return { key: e.type, info: t, data: i.buffer } }, en = e => { if (e.size < 2) return; if ("TXXX" === e.type) { let t = 1, i = eo(e.data.subarray(t), !0); t += i.length + 1; let r = eo(e.data.subarray(t)); return { key: e.type, info: i, data: r } } let t = eo(e.data.subarray(1)); return { key: e.type, data: t } }, es = e => { if ("WXXX" === e.type) { if (e.size < 2) return; let t = 1, i = eo(e.data.subarray(t), !0); t += i.length + 1; let r = eo(e.data.subarray(t)); return { key: e.type, info: i, data: r } } let t = eo(e.data); return { key: e.type, data: t } }, ea = e => { if (8 === e.data.byteLength) { let t = new Uint8Array(e.data), i = 1 & t[3], r = (t[4] << 23) + (t[5] << 15) + (t[6] << 7) + t[7]; return r /= 45, i && (r += 47721858.84), Math.round(r) } }, eo = (e, t = !1) => { let i, n; let s = function () { if (!navigator.userAgent.includes("PlayStation 4")) return r || void 0 === self.TextDecoder || (r = new self.TextDecoder("utf-8")), r }(); if (s) { let i = s.decode(e); if (t) { let e = i.indexOf("\0"); return -1 !== e ? i.substring(0, e) : i } return i.replace(/\0/g, "") } let a = e.length, o = "", l = 0; for (; l < a && (0 !== (i = e[l++]) || !t);)if (0 !== i && 3 !== i) switch (i >> 4) { case 0: case 1: case 2: case 3: case 4: case 5: case 6: case 7: o += String.fromCharCode(i); break; case 12: case 13: o += String.fromCharCode((31 & i) << 6 | 63 & e[l++]); break; case 14: o += String.fromCharCode((15 & i) << 12 | (63 & e[l++]) << 6 | (63 & e[l++]) << 0) }return o }, el = { hexDump: function (e) { let t = ""; for (let i = 0; i < e.length; i++) { let r = e[i].toString(16); r.length < 2 && (r = "0" + r), t += r } return t } }, eu = [].push, eh = { video: 1, audio: 2, id3: 3, text: 4 }; function ec(e) { return String.fromCharCode.apply(null, e) } function ed(e, t) { let i = e[t] << 8 | e[t + 1]; return i < 0 ? 65536 + i : i } function ef(e, t) { let i = em(e, t); return i < 0 ? 0x100000000 + i : i } function ep(e, t) { let i = ef(e, t); return i *= 0x100000000, i += ef(e, t + 4) } function em(e, t) { return e[t] << 24 | e[t + 1] << 16 | e[t + 2] << 8 | e[t + 3] } function eg(e, t, i) { e[t] = i >> 24, e[t + 1] = i >> 16 & 255, e[t + 2] = i >> 8 & 255, e[t + 3] = 255 & i } function ev(e, t) { let i = []; if (!t.length) return i; let r = e.byteLength; for (let n = 0; n < r;) { let s = ef(e, n), a = ec(e.subarray(n + 4, n + 8)), o = s > 1 ? n + s : r; if (a === t[0]) { if (1 === t.length) i.push(e.subarray(n + 8, o)); else { let r = ev(e.subarray(n + 8, o), t.slice(1)); r.length && eu.apply(i, r) } } n = o } return i } function ey(e) { let t = [], i = ev(e, ["moov", "trak"]); for (let e = 0; e < i.length; e++) { let r = i[e], n = ev(r, ["tkhd"])[0]; if (n) { let e = n[0], i = ef(n, 0 === e ? 12 : 20), s = ev(r, ["mdia", "mdhd"])[0]; if (s) { e = s[0]; let n = ef(s, 0 === e ? 12 : 20), a = ev(r, ["mdia", "hdlr"])[0]; if (a) { let e = ec(a.subarray(8, 12)), s = { soun: C.AUDIO, vide: C.VIDEO }[e]; if (s) { let e = function (e) { let t = e.subarray(8), i = t.subarray(86), r = ec(t.subarray(4, 8)), n = r, s = "enca" === r || "encv" === r; if (s) { let e = ev(t, [r])[0].subarray("enca" === r ? 28 : 78); ev(e, ["sinf"]).forEach(e => { let t = ev(e, ["schm"])[0]; if (t) { let i = ec(t.subarray(4, 8)); if ("cbcs" === i || "cenc" === i) { let t = ev(e, ["frma"])[0]; t && (n = ec(t)) } } }) } switch (n) { case "avc1": case "avc2": case "avc3": case "avc4": { let e = ev(i, ["avcC"])[0]; n += "." + eS(e[1]) + eS(e[2]) + eS(e[3]); break } case "mp4a": { let e = ev(t, [r])[0], i = ev(e.subarray(28), ["esds"])[0]; if (i && i.length > 12) { let e = 4; if (3 !== i[e++]) break; e = ex(i, e) + 2; let t = i[e++]; if (128 & t && (e += 2), 64 & t && (e += i[e++]), 4 !== i[e++]) break; e = ex(i, e); let r = i[e++]; if (64 === r) n += "." + eS(r); else break; if (e += 12, 5 !== i[e++]) break; e = ex(i, e); let s = i[e++], a = (248 & s) >> 3; 31 === a && (a += 1 + ((7 & s) << 3) + ((224 & i[e]) >> 5)), n += "." + a } break } case "hvc1": case "hev1": { let e = ev(i, ["hvcC"])[0], t = e[1], r = ["", "A", "B", "C"][t >> 6], s = ef(e, 2), a = e[12], o = e.subarray(6, 12); n += "." + r + (31 & t), n += "." + s.toString(16).toUpperCase(), n += "." + ((32 & t) >> 5 ? "H" : "L") + a; let l = ""; for (let e = o.length; e--;) { let t = o[e]; (t || l) && (l = "." + t.toString(16).toUpperCase() + l) } n += l; break } case "dvh1": case "dvhe": { let e = ev(i, ["dvcC"])[0], t = e[2] >> 1 & 127, r = e[2] << 5 & 32 | e[3] >> 3 & 31; n += "." + eA(t) + "." + eA(r); break } case "vp09": { let e = ev(i, ["vpcC"])[0], t = e[4], r = e[5], s = e[6] >> 4 & 15; n += "." + eA(t) + "." + eA(r) + "." + eA(s); break } case "av01": { let e = ev(i, ["av1C"])[0], t = e[1] >>> 5, r = 31 & e[1], s = e[2] >>> 7 ? "H" : "M", a = (64 & e[2]) >> 6, o = (32 & e[2]) >> 5, l = (16 & e[2]) >> 4, u = (8 & e[2]) >> 3, h = (4 & e[2]) >> 2, c = 3 & e[2]; n += "." + t + "." + eA(r) + s + "." + eA(2 === t && a ? o ? 12 : 10 : a ? 10 : 8) + "." + l + "." + u + h + c + "." + eA(1) + "." + eA(1) + "." + eA(1) + ".0" } }return { codec: n, encrypted: s } }(ev(r, ["mdia", "minf", "stbl", "stsd"])[0]); t[i] = { timescale: n, type: s }, t[s] = d({ timescale: n, id: i }, e) } } } } } return ev(e, ["moov", "mvex", "trex"]).forEach(e => { let i = t[ef(e, 4)]; i && (i.default = { duration: ef(e, 12), flags: ef(e, 20) }) }), t } function ex(e, t) { let i = t + 5; for (; 128 & e[t++] && t < i;); return t } function eS(e) { return ("0" + e.toString(16).toUpperCase()).slice(-2) } function eA(e) { return (e < 10 ? "0" : "") + e } function e_(e) { let t = ev(e, ["schm"])[0]; if (t) { let i = ec(t.subarray(4, 8)); if ("cbcs" === i || "cenc" === i) return ev(e, ["schi", "tenc"])[0] } return null } function eE(e, t) { let i = new Uint8Array(e.length + t.length); return i.set(e), i.set(t, e.length), i } function eb(e, t) { let i = [], r = t.samples, n = t.timescale, s = t.id, a = !1; return ev(r, ["moof"]).map(o => { let l = o.byteOffset - 8; ev(o, ["traf"]).map(o => { let u = ev(o, ["tfdt"]).map(e => { let t = e[0], i = ef(e, 4); return 1 === t && (i *= 0x100000000, i += ef(e, 8)), i / n })[0]; return void 0 !== u && (e = u), ev(o, ["tfhd"]).map(u => { let h = ef(u, 4), c = 0xffffff & ef(u, 0), d = 0, f = 0, p = 8; h === s && ((1 & c) != 0 && (p += 8), (2 & c) != 0 && (p += 4), (8 & c) != 0 && (d = ef(u, p), p += 4), (16 & c) != 0 && (f = ef(u, p), p += 4), (32 & c) != 0 && (p += 4), "video" === t.type && (a = function (e) { if (!e) return !1; let t = e.indexOf("."), i = t < 0 ? e : e.substring(0, t); return "hvc1" === i || "hev1" === i || "dvh1" === i || "dvhe" === i }(t.codec)), ev(o, ["trun"]).map(s => { let o = s[0], u = 0xffffff & ef(s, 0), h = 0, c = (256 & u) != 0, p = 0, m = (512 & u) != 0, g = 0, v = (1024 & u) != 0, y = (2048 & u) != 0, x = 0, S = ef(s, 4), A = 8; (1 & u) != 0 && (h = ef(s, A), A += 4), (4 & u) != 0 && (A += 4); let _ = h + l; for (let l = 0; l < S; l++) { if (c ? (p = ef(s, A), A += 4) : p = d, m ? (g = ef(s, A), A += 4) : g = f, v && (A += 4), y && (x = 0 === o ? ef(s, A) : em(s, A), A += 4), t.type === C.VIDEO) { let t = 0; for (; t < g;) { let s = ef(r, _); _ += 4, function (e, t) { if (!e) return 6 == (31 & t); { let e = t >> 1 & 63; return 39 === e || 40 === e } }(a, r[_]) && eT(r.subarray(_, _ + s), a ? 2 : 1, e + x / n, i), _ += s, t += s + 4 } } e += p / n } })) }) }) }), i } function eT(e, t, i, r) { let n; let s = ew(e); n = 0 + t; let a = 0, o = 0, l = 0; for (; n < s.length;) { a = 0; do { if (n >= s.length) break; a += l = s[n++] } while (255 === l); o = 0; do { if (n >= s.length) break; o += l = s[n++] } while (255 === l); let e = s.length - n, t = n; if (o < e) n += o; else if (o > e) { E.error(`Malformed SEI payload. ${o} is too small, only ${e} bytes left to parse.`); break } if (4 === a) { if (181 === s[t++]) { let e = ed(s, t); if (t += 2, 49 === e) { let e = ef(s, t); if (t += 4, 0x47413934 === e) { let e = s[t++]; if (3 === e) { let n = s[t++], o = 31 & n, l = 64 & n, u = l ? 2 + 3 * o : 0, h = new Uint8Array(u); if (l) { h[0] = n; for (let e = 1; e < u; e++)h[e] = s[t++] } r.push({ type: e, payloadType: a, pts: i, bytes: h }) } } } } } else if (5 === a && o > 16) { let e = []; for (let i = 0; i < 16; i++) { let r = s[t++].toString(16); e.push(1 == r.length ? "0" + r : r), (3 === i || 5 === i || 7 === i || 9 === i) && e.push("-") } let n = o - 16, l = new Uint8Array(n); for (let e = 0; e < n; e++)l[e] = s[t++]; r.push({ payloadType: a, pts: i, uuid: e.join(""), userData: eo(l), userDataBytes: l }) } } } function ew(e) { let t = e.byteLength, i = [], r = 1; for (; r < t - 2;)0 === e[r] && 0 === e[r + 1] && 3 === e[r + 2] ? (i.push(r + 2), r += 2) : r++; if (0 === i.length) return e; let n = t - i.length, s = new Uint8Array(n), a = 0; for (r = 0; r < n; a++, r++)a === i[0] && (a++, i.shift()), s[r] = e[a]; return s } let eM = {}; class eR { static clearKeyUriToKeyIdMap() { eM = {} } constructor(e, t, i, r = [1], n = null) { this.uri = void 0, this.method = void 0, this.keyFormat = void 0, this.keyFormatVersions = void 0, this.encrypted = void 0, this.isCommonEncryption = void 0, this.iv = null, this.key = null, this.keyId = null, this.pssh = null, this.method = e, this.uri = t, this.keyFormat = i, this.keyFormatVersions = r, this.iv = n, this.encrypted = !!e && "NONE" !== e, this.isCommonEncryption = this.encrypted && "AES-128" !== e } isSupported() { if (this.method) { if ("AES-128" === this.method || "NONE" === this.method) return !0; if ("identity" === this.keyFormat) return "SAMPLE-AES" === this.method; switch (this.keyFormat) { case N.FAIRPLAY: case N.WIDEVINE: case N.PLAYREADY: case N.CLEARKEY: return -1 !== ["ISO-23001-7", "SAMPLE-AES", "SAMPLE-AES-CENC", "SAMPLE-AES-CTR"].indexOf(this.method) } } return !1 } getDecryptData(e) { if (!this.encrypted || !this.uri) return null; if ("AES-128" === this.method && this.uri && !this.iv) { "number" != typeof e && ("AES-128" !== this.method || this.iv || E.warn(`missing IV for initialization segment with method="${this.method}" - compliance issue`), e = 0); let t = function (e) { let t = new Uint8Array(16); for (let i = 12; i < 16; i++)t[i] = e >> 8 * (15 - i) & 255; return t }(e); return new eR(this.method, this.uri, "identity", this.keyFormatVersions, t) } let t = function (e) { let t = e.split(":"), i = null; if ("data" === t[0] && 2 === t.length) { let e = t[1].split(";"), r = e[e.length - 1].split(","); if (2 === r.length) { let t = "base64" === r[0], n = r[1]; t ? (e.splice(-1, 1), i = O(n)) : i = function (e) { let t = k(e).subarray(0, 16), i = new Uint8Array(16); return i.set(t, 16 - t.length), i }(n) } } return i }(this.uri); if (t) switch (this.keyFormat) { case N.WIDEVINE: this.pssh = t, t.length >= 22 && (this.keyId = t.subarray(t.length - 22, t.length - 6)); break; case N.PLAYREADY: { let e = new Uint8Array([154, 4, 240, 121, 152, 64, 66, 134, 171, 146, 230, 91, 224, 136, 95, 149]); this.pssh = function (e, t, i) { let r, n; if (16 !== e.byteLength) throw RangeError("Invalid system id"); r = new Uint8Array, n = new Uint8Array; let s = new Uint8Array(4); return i && i.byteLength > 0 && new DataView(s.buffer).setUint32(0, i.byteLength, !1), function (e, ...t) { let i = t.length, r = 8, n = i; for (; n--;)r += t[n].byteLength; let s = new Uint8Array(r); for (s[0] = r >> 24 & 255, s[1] = r >> 16 & 255, s[2] = r >> 8 & 255, s[3] = 255 & r, s.set(e, 4), n = 0, r = 8; n < i; n++)s.set(t[n], r), r += t[n].byteLength; return s }([112, 115, 115, 104], new Uint8Array([0, 0, 0, 0]), e, n, r, s, i || new Uint8Array) }(e, 0, t), this.keyId = j(t); break } default: { let e = t.subarray(0, 16); if (16 !== e.length) { let t = new Uint8Array(16); t.set(e, 16 - e.length), e = t } this.keyId = e } }if (!this.keyId || 16 !== this.keyId.byteLength) { let e = eM[this.uri]; if (!e) { let t = Object.keys(eM).length % Number.MAX_SAFE_INTEGER; new DataView((e = new Uint8Array(16)).buffer, 12, 4).setUint32(0, t), eM[this.uri] = e } this.keyId = e } return this } } let eC = /\{\$([a-zA-Z0-9-_]+)\}/g; function eI(e, t, i) { if (null !== e.variableList || e.hasVariableRefs) for (let r = i.length; r--;) { let n = i[r], s = t[n]; s && (t[n] = eL(e, s)) } } function eL(e, t) { if (null !== e.variableList || e.hasVariableRefs) { let i = e.variableList; return t.replace(eC, t => { let r = t.substring(2, t.length - 1), n = null == i ? void 0 : i[r]; return void 0 === n ? (e.playlistParsingError || (e.playlistParsingError = Error(`Missing preceding EXT-X-DEFINE tag for Variable Reference: "${r}"`)), t) : n }) } return t } function eP(e, t, i) { let r, n, s = e.variableList; if (s || (e.variableList = s = {}), "QUERYPARAM" in t) { r = t.QUERYPARAM; try { let e = new self.URL(i).searchParams; if (e.has(r)) n = e.get(r); else throw Error(`"${r}" does not match any query parameter in URI: "${i}"`) } catch (t) { e.playlistParsingError || (e.playlistParsingError = Error(`EXT-X-DEFINE QUERYPARAM: ${t.message}`)) } } else r = t.NAME, n = t.VALUE; r in s ? e.playlistParsingError || (e.playlistParsingError = Error(`EXT-X-DEFINE duplicate Variable Name declarations: "${r}"`)) : s[r] = n || "" } function eD(e = !0) { if ("undefined" != typeof self) return (e || !self.MediaSource) && self.ManagedMediaSource || self.MediaSource || self.WebKitMediaSource } let eO = { audio: { a3ds: 1, "ac-3": .95, "ac-4": 1, alac: .9, alaw: 1, dra1: 1, "dts+": 1, "dts-": 1, dtsc: 1, dtse: 1, dtsh: 1, "ec-3": .9, enca: 1, fLaC: .9, flac: .9, FLAC: .9, g719: 1, g726: 1, m4ae: 1, mha1: 1, mha2: 1, mhm1: 1, mhm2: 1, mlpa: 1, mp4a: 1, "raw ": 1, Opus: 1, opus: 1, samr: 1, sawb: 1, sawp: 1, sevc: 1, sqcp: 1, ssmv: 1, twos: 1, ulaw: 1 }, video: { avc1: 1, avc2: 1, avc3: 1, avc4: 1, avcp: 1, av01: .8, drac: 1, dva1: 1, dvav: 1, dvh1: .7, dvhe: .7, encv: 1, hev1: .75, hvc1: .75, mjp2: 1, mp4v: 1, mvc1: 1, mvc2: 1, mvc3: 1, mvc4: 1, resv: 1, rv60: 1, s263: 1, svc1: 1, svc2: 1, "vc-1": 1, vp08: 1, vp09: .9 }, text: { stpp: 1, wvtt: 1 } }; function ek(e, t, i = !0) { return !e.split(",").some(e => !eF(e, t, i)) } function eF(e, t, i = !0) { var r; let n = eD(i); return null != (r = null == n ? void 0 : n.isTypeSupported(eU(e, t))) && r } function eU(e, t) { return `${t}/mp4;codecs="${e}"` } function eN(e) { if (e) { let t = e.substring(0, 4); return eO.video[t] } return 2 } function eB(e) { return e.split(",").reduce((e, t) => { let i = eO.video[t]; return i ? (2 * i + e) / (e ? 3 : 2) : (eO.audio[t] + e) / (e ? 2 : 1) }, 0) } let ez = {}, eG = /flac|opus/i; function eH(e, t = !0) { return e.replace(eG, e => (function (e, t = !0) { if (ez[e]) return ez[e]; let i = { flac: ["flac", "fLaC", "FLAC"], opus: ["opus", "Opus"] }[e]; for (let r = 0; r < i.length; r++)if (eF(i[r], "audio", t)) return ez[e] = i[r], i[r]; return e })(e.toLowerCase(), t)) } function eV(e, t) { return e && "mp4a" !== e ? e : t ? t.split(",")[0] : t } let eW = /#EXT-X-STREAM-INF:([^\r\n]*)(?:[\r\n](?:#[^\r\n]*)?)*([^\r\n]+)|#EXT-X-(SESSION-DATA|SESSION-KEY|DEFINE|CONTENT-STEERING|START):([^\r\n]*)[\r\n]+/g, ej = /#EXT-X-MEDIA:(.*)/g, eY = /^#EXT(?:INF|-X-TARGETDURATION):/m, eX = RegExp([/#EXTINF:\s*(\d*(?:\.\d+)?)(?:,(.*)\s+)?/.source, /(?!#) *(\S[^\r\n]*)/.source, /#EXT-X-BYTERANGE:*(.+)/.source, /#EXT-X-PROGRAM-DATE-TIME:(.+)/.source, /#.*/.source].join("|"), "g"), eK = new RegExp([/#(EXTM3U)/.source, /#EXT-X-(DATERANGE|DEFINE|KEY|MAP|PART|PART-INF|PLAYLIST-TYPE|PRELOAD-HINT|RENDITION-REPORT|SERVER-CONTROL|SKIP|START):(.+)/.source, /#EXT-X-(BITRATE|DISCONTINUITY-SEQUENCE|MEDIA-SEQUENCE|TARGETDURATION|VERSION): *(\d+)/.source, /#EXT-X-(DISCONTINUITY|ENDLIST|GAP|INDEPENDENT-SEGMENTS)/.source, /(#)([^:]*):(.*)/.source, /(#)(.*)(?:.*)\r?\n?/.source].join("|")); class eq { static findGroup(e, t) { for (let i = 0; i < e.length; i++) { let r = e[i]; if (r.id === t) return r } } static resolve(e, t) { return h.buildAbsoluteURL(t, e, { alwaysNormalize: !0 }) } static isMediaPlaylist(e) { return eY.test(e) } static parseMasterPlaylist(e, t) { var i; let r; let n = { contentSteering: null, levels: [], playlistParsingError: null, sessionData: null, sessionKeys: null, startTimeOffset: null, variableList: null, hasVariableRefs: eC.test(e) }, s = []; for (eW.lastIndex = 0; null != (r = eW.exec(e));)if (r[1]) { let e = new w(r[1]); eI(n, e, ["CODECS", "SUPPLEMENTAL-CODECS", "ALLOWED-CPC", "PATHWAY-ID", "STABLE-VARIANT-ID", "AUDIO", "VIDEO", "SUBTITLES", "CLOSED-CAPTIONS", "NAME"]); let a = eL(n, r[2]), o = { attrs: e, bitrate: e.decimalInteger("BANDWIDTH") || e.decimalInteger("AVERAGE-BANDWIDTH"), name: e.NAME, url: eq.resolve(a, t) }, l = e.decimalResolution("RESOLUTION"); l && (o.width = l.width, o.height = l.height), function (e, t) { let i = (e || "").split(/[ ,]+/).filter(e => e);["video", "audio", "text"].forEach(e => { let r = i.filter(t => (function (e, t) { let i = eO[t]; return !!i && !!i[e.slice(0, 4)] })(t, e)); r.length && (t[`${e}Codec`] = r.join(","), i = i.filter(e => -1 === r.indexOf(e))) }), t.unknownCodecs = i }(e.CODECS, o), null != (i = o.unknownCodecs) && i.length || s.push(o), n.levels.push(o) } else if (r[3]) { let e = r[3], i = r[4]; switch (e) { case "SESSION-DATA": { let e = new w(i); eI(n, e, ["DATA-ID", "LANGUAGE", "VALUE", "URI"]); let t = e["DATA-ID"]; t && (null === n.sessionData && (n.sessionData = {}), n.sessionData[t] = e); break } case "SESSION-KEY": { let e = eQ(i, t, n); e.encrypted && e.isSupported() ? (null === n.sessionKeys && (n.sessionKeys = []), n.sessionKeys.push(e)) : E.warn(`[Keys] Ignoring invalid EXT-X-SESSION-KEY tag: "${i}"`); break } case "DEFINE": { let e = new w(i); eI(n, e, ["NAME", "VALUE", "QUERYPARAM"]), eP(n, e, t) } break; case "CONTENT-STEERING": { let e = new w(i); eI(n, e, ["SERVER-URI", "PATHWAY-ID"]), n.contentSteering = { uri: eq.resolve(e["SERVER-URI"], t), pathwayId: e["PATHWAY-ID"] || "." }; break } case "START": n.startTimeOffset = eZ(i) } } let a = s.length > 0 && s.length < n.levels.length; return n.levels = a ? s : n.levels, 0 === n.levels.length && (n.playlistParsingError = Error("no levels found in manifest")), n } static parseMasterPlaylistMedia(e, t, i) { let r; let n = {}, s = i.levels, a = { AUDIO: s.map(e => ({ id: e.attrs.AUDIO, audioCodec: e.audioCodec })), SUBTITLES: s.map(e => ({ id: e.attrs.SUBTITLES, textCodec: e.textCodec })), "CLOSED-CAPTIONS": [] }, o = 0; for (ej.lastIndex = 0; null !== (r = ej.exec(e));) { let e = new w(r[1]), s = e.TYPE; if (s) { let r = a[s], l = n[s] || []; n[s] = l, eI(i, e, ["URI", "GROUP-ID", "LANGUAGE", "ASSOC-LANGUAGE", "STABLE-RENDITION-ID", "NAME", "INSTREAM-ID", "CHARACTERISTICS", "CHANNELS"]); let u = e.LANGUAGE, h = e["ASSOC-LANGUAGE"], c = e.CHANNELS, d = e.CHARACTERISTICS, f = e["INSTREAM-ID"], p = { attrs: e, bitrate: 0, id: o++, groupId: e["GROUP-ID"] || "", name: e.NAME || u || "", type: s, default: e.bool("DEFAULT"), autoselect: e.bool("AUTOSELECT"), forced: e.bool("FORCED"), lang: u, url: e.URI ? eq.resolve(e.URI, t) : "" }; if (h && (p.assocLang = h), c && (p.channels = c), d && (p.characteristics = d), f && (p.instreamId = f), null != r && r.length) { let e = eq.findGroup(r, p.groupId) || r[0]; e$(p, e, "audioCodec"), e$(p, e, "textCodec") } l.push(p) } } return n } static parseLevelPlaylist(e, t, i, r, n, s) { let a, o, l; let u = new D(t), h = u.fragments, c = null, d = 0, m = 0, g = 0, v = 0, y = null, x = new L(r, t), S = -1, A = !1, _ = null; for (eX.lastIndex = 0, u.m3u8 = e, u.hasVariableRefs = eC.test(e); null !== (a = eX.exec(e));) { A && (A = !1, (x = new L(r, t)).start = g, x.sn = d, x.cc = v, x.level = i, c && (x.initSegment = c, x.rawProgramDateTime = c.rawProgramDateTime, c.rawProgramDateTime = null, _ && (x.setByteRange(_), _ = null))); let e = a[1]; if (e) { x.duration = parseFloat(e); let t = (" " + a[2]).slice(1); x.title = t || null, x.tagList.push(t ? ["INF", e, t] : ["INF", e]) } else if (a[3]) { if (p(x.duration)) { x.start = g, l && e1(x, l, u), x.sn = d, x.level = i, x.cc = v, h.push(x); let e = (" " + a[3]).slice(1); x.relurl = eL(u, e), eJ(x, y), y = x, g += x.duration, d++, m = 0, A = !0 } } else if (a[4]) { let e = (" " + a[4]).slice(1); y ? x.setByteRange(e, y) : x.setByteRange(e) } else if (a[5]) x.rawProgramDateTime = (" " + a[5]).slice(1), x.tagList.push(["PROGRAM-DATE-TIME", x.rawProgramDateTime]), -1 === S && (S = h.length); else { if (!(a = a[0].match(eK))) { E.warn("No matches on slow regex match for level playlist!"); continue } for (o = 1; o < a.length && void 0 === a[o]; o++); let e = (" " + a[o]).slice(1), n = (" " + a[o + 1]).slice(1), g = a[o + 2] ? (" " + a[o + 2]).slice(1) : ""; switch (e) { case "PLAYLIST-TYPE": u.type = n.toUpperCase(); break; case "MEDIA-SEQUENCE": d = u.startSN = parseInt(n); break; case "SKIP": { let e = new w(n); eI(u, e, ["RECENTLY-REMOVED-DATERANGES"]); let t = e.decimalInteger("SKIPPED-SEGMENTS"); if (p(t)) { u.skippedSegments = t; for (let e = t; e--;)h.unshift(null); d += t } let i = e.enumeratedString("RECENTLY-REMOVED-DATERANGES"); i && (u.recentlyRemovedDateranges = i.split("	")); break } case "TARGETDURATION": u.targetduration = Math.max(parseInt(n), 1); break; case "VERSION": u.version = parseInt(n); break; case "INDEPENDENT-SEGMENTS": case "EXTM3U": break; case "ENDLIST": u.live = !1; break; case "#": (n || g) && x.tagList.push(g ? [n, g] : [n]); break; case "DISCONTINUITY": v++, x.tagList.push(["DIS"]); break; case "GAP": x.gap = !0, x.tagList.push([e]); break; case "BITRATE": x.tagList.push([e, n]); break; case "DATERANGE": { let e = new w(n); eI(u, e, ["ID", "CLASS", "START-DATE", "END-DATE", "SCTE35-CMD", "SCTE35-OUT", "SCTE35-IN"]), eI(u, e, e.clientAttrs); let t = new M(e, u.dateRanges[e.ID]); t.isValid || u.skippedSegments ? u.dateRanges[t.id] = t : E.warn(`Ignoring invalid DATERANGE tag: "${n}"`), x.tagList.push(["EXT-X-DATERANGE", n]); break } case "DEFINE": { let e = new w(n); eI(u, e, ["NAME", "VALUE", "IMPORT", "QUERYPARAM"]), "IMPORT" in e ? function (e, t, i) { let r = t.IMPORT; if (i && r in i) { let t = e.variableList; t || (e.variableList = t = {}), t[r] = i[r] } else e.playlistParsingError || (e.playlistParsingError = Error(`EXT-X-DEFINE IMPORT attribute not found in Multivariant Playlist: "${r}"`)) }(u, e, s) : eP(u, e, t) } break; case "DISCONTINUITY-SEQUENCE": v = parseInt(n); break; case "KEY": { let e = eQ(n, t, u); if (e.isSupported()) { if ("NONE" === e.method) { l = void 0; break } l || (l = {}), l[e.keyFormat] && (l = f({}, l)), l[e.keyFormat] = e } else E.warn(`[Keys] Ignoring invalid EXT-X-KEY tag: "${n}"`); break } case "START": u.startTimeOffset = eZ(n); break; case "MAP": { let e = new w(n); if (eI(u, e, ["BYTERANGE", "URI"]), x.duration) { let n = new L(r, t); e0(n, e, i, l), c = n, x.initSegment = c, c.rawProgramDateTime && !x.rawProgramDateTime && (x.rawProgramDateTime = c.rawProgramDateTime) } else { let t = x.byteRangeEndOffset; if (t) { let e = x.byteRangeStartOffset; _ = `${t - e}@${e}` } else _ = null; e0(x, e, i, l), c = x, A = !0 } break } case "SERVER-CONTROL": { let e = new w(n); u.canBlockReload = e.bool("CAN-BLOCK-RELOAD"), u.canSkipUntil = e.optionalFloat("CAN-SKIP-UNTIL", 0), u.canSkipDateRanges = u.canSkipUntil > 0 && e.bool("CAN-SKIP-DATERANGES"), u.partHoldBack = e.optionalFloat("PART-HOLD-BACK", 0), u.holdBack = e.optionalFloat("HOLD-BACK", 0); break } case "PART-INF": { let e = new w(n); u.partTarget = e.decimalFloatingPoint("PART-TARGET"); break } case "PART": { let e = u.partList; e || (e = u.partList = []); let i = m > 0 ? e[e.length - 1] : void 0, r = m++, s = new w(n); eI(u, s, ["BYTERANGE", "URI"]); let a = new P(s, x, t, r, i); e.push(a), x.duration += a.duration; break } case "PRELOAD-HINT": { let e = new w(n); eI(u, e, ["URI"]), u.preloadHint = e; break } case "RENDITION-REPORT": { let e = new w(n); eI(u, e, ["URI"]), u.renditionReports = u.renditionReports || [], u.renditionReports.push(e); break } default: E.warn(`line parsed but not handled: ${a}`) } } } y && !y.relurl ? (h.pop(), g -= y.duration, u.partList && (u.fragmentHint = y)) : u.partList && (eJ(x, y), x.cc = v, u.fragmentHint = x, l && e1(x, l, u)); let b = h.length, T = h[0], R = h[b - 1]; if ((g += u.skippedSegments * u.targetduration) > 0 && b && R) { u.averagetargetduration = g / b; let e = R.sn; u.endSN = "initSegment" !== e ? e : 0, u.live || (R.endList = !0), T && (u.startCC = T.cc) } else u.endSN = 0, u.startCC = 0; return u.fragmentHint && (g += u.fragmentHint.duration), u.totalduration = g, u.endCC = v, S > 0 && function (e, t) { let i = e[t]; for (let r = t; r--;) { let t = e[r]; if (!t) return; t.programDateTime = i.programDateTime - 1e3 * t.duration, i = t } }(h, S), u } } function eQ(e, t, i) { var r, n; let s = new w(e); eI(i, s, ["KEYFORMAT", "KEYFORMATVERSIONS", "URI", "IV", "URI"]); let a = null != (r = s.METHOD) ? r : "", o = s.URI, l = s.hexadecimalInteger("IV"), u = s.KEYFORMATVERSIONS, h = null != (n = s.KEYFORMAT) ? n : "identity"; return o && s.IV && !l && E.error(`Invalid IV: ${s.IV}`), new eR(a, o ? eq.resolve(o, t) : "", h, (u || "1").split("/").map(Number).filter(Number.isFinite), l) } function eZ(e) { let t = new w(e).decimalFloatingPoint("TIME-OFFSET"); return p(t) ? t : null } function e$(e, t, i) { let r = t[i]; r && (e[i] = r) } function eJ(e, t) { e.rawProgramDateTime ? e.programDateTime = Date.parse(e.rawProgramDateTime) : null != t && t.programDateTime && (e.programDateTime = t.endProgramDateTime), p(e.programDateTime) || (e.programDateTime = null, e.rawProgramDateTime = null) } function e0(e, t, i, r) { e.relurl = t.URI, t.BYTERANGE && e.setByteRange(t.BYTERANGE), e.level = i, e.sn = "initSegment", r && (e.levelkeys = r), e.initSegment = null } function e1(e, t, i) { e.levelkeys = t; let { encryptedFragments: r } = i; (!r.length || r[r.length - 1].levelkeys !== t) && Object.keys(t).some(e => t[e].isCommonEncryption) && r.push(e) } var e2 = { MANIFEST: "manifest", LEVEL: "level", AUDIO_TRACK: "audioTrack", SUBTITLE_TRACK: "subtitleTrack" }, e3 = { MAIN: "main", AUDIO: "audio", SUBTITLE: "subtitle" }; function e4(e) { let { type: t } = e; switch (t) { case e2.AUDIO_TRACK: return e3.AUDIO; case e2.SUBTITLE_TRACK: return e3.SUBTITLE; default: return e3.MAIN } } function e5(e, t) { let i = e.url; return (void 0 === i || 0 === i.indexOf("data:")) && (i = t.url), i } class e8 { constructor(e) { this.hls = void 0, this.loaders = Object.create(null), this.variableList = null, this.hls = e, this.registerListeners() } startLoad(e) { } stopLoad() { this.destroyInternalLoaders() } registerListeners() { let { hls: e } = this; e.on(v.MANIFEST_LOADING, this.onManifestLoading, this), e.on(v.LEVEL_LOADING, this.onLevelLoading, this), e.on(v.AUDIO_TRACK_LOADING, this.onAudioTrackLoading, this), e.on(v.SUBTITLE_TRACK_LOADING, this.onSubtitleTrackLoading, this) } unregisterListeners() { let { hls: e } = this; e.off(v.MANIFEST_LOADING, this.onManifestLoading, this), e.off(v.LEVEL_LOADING, this.onLevelLoading, this), e.off(v.AUDIO_TRACK_LOADING, this.onAudioTrackLoading, this), e.off(v.SUBTITLE_TRACK_LOADING, this.onSubtitleTrackLoading, this) } createInternalLoader(e) { let t = this.hls.config, i = t.pLoader, r = t.loader, n = new (i || r)(t); return this.loaders[e.type] = n, n } getInternalLoader(e) { return this.loaders[e.type] } resetInternalLoader(e) { this.loaders[e] && delete this.loaders[e] } destroyInternalLoaders() { for (let e in this.loaders) { let t = this.loaders[e]; t && t.destroy(), this.resetInternalLoader(e) } } destroy() { this.variableList = null, this.unregisterListeners(), this.destroyInternalLoaders() } onManifestLoading(e, t) { let { url: i } = t; this.variableList = null, this.load({ id: null, level: 0, responseType: "text", type: e2.MANIFEST, url: i, deliveryDirectives: null }) } onLevelLoading(e, t) { let { id: i, level: r, pathwayId: n, url: s, deliveryDirectives: a } = t; this.load({ id: i, level: r, pathwayId: n, responseType: "text", type: e2.LEVEL, url: s, deliveryDirectives: a }) } onAudioTrackLoading(e, t) { let { id: i, groupId: r, url: n, deliveryDirectives: s } = t; this.load({ id: i, groupId: r, level: null, responseType: "text", type: e2.AUDIO_TRACK, url: n, deliveryDirectives: s }) } onSubtitleTrackLoading(e, t) { let { id: i, groupId: r, url: n, deliveryDirectives: s } = t; this.load({ id: i, groupId: r, level: null, responseType: "text", type: e2.SUBTITLE_TRACK, url: n, deliveryDirectives: s }) } load(e) { var t; let i; let r = this.hls.config, n = this.getInternalLoader(e); if (n) { let t = n.context; if (t && t.url === e.url && t.level === e.level) { E.trace("[playlist-loader]: playlist request ongoing"); return } E.log(`[playlist-loader]: aborting previous loader for type: ${e.type}`), n.abort() } if (i = e.type === e2.MANIFEST ? r.manifestLoadPolicy.default : f({}, r.playlistLoadPolicy.default, { timeoutRetry: null, errorRetry: null }), n = this.createInternalLoader(e), p(null == (t = e.deliveryDirectives) ? void 0 : t.part)) { let t; if (e.type === e2.LEVEL && null !== e.level ? t = this.hls.levels[e.level].details : e.type === e2.AUDIO_TRACK && null !== e.id ? t = this.hls.audioTracks[e.id].details : e.type === e2.SUBTITLE_TRACK && null !== e.id && (t = this.hls.subtitleTracks[e.id].details), t) { let e = t.partTarget, r = t.targetduration; if (e && r) { let t = 1e3 * Math.max(3 * e, .8 * r); i = f({}, i, { maxTimeToFirstByteMs: Math.min(t, i.maxTimeToFirstByteMs), maxLoadTimeMs: Math.min(t, i.maxTimeToFirstByteMs) }) } } } let s = i.errorRetry || i.timeoutRetry || {}, a = { loadPolicy: i, timeout: i.maxLoadTimeMs, maxRetry: s.maxNumRetry || 0, retryDelay: s.retryDelayMs || 0, maxRetryDelay: s.maxRetryDelayMs || 0 }; n.load(e, a, { onSuccess: (e, t, i, r) => { let n = this.getInternalLoader(i); this.resetInternalLoader(i.type); let s = e.data; if (0 !== s.indexOf("#EXTM3U")) { this.handleManifestParsingError(e, i, Error("no EXTM3U delimiter"), r || null, t); return } t.parsing.start = performance.now(), eq.isMediaPlaylist(s) ? this.handleTrackOrLevelPlaylist(e, t, i, r || null, n) : this.handleMasterPlaylist(e, t, i, r) }, onError: (e, t, i, r) => { this.handleNetworkError(t, i, !1, e, r) }, onTimeout: (e, t, i) => { this.handleNetworkError(t, i, !0, void 0, e) } }) } handleMasterPlaylist(e, t, i, r) { let n = this.hls, s = e.data, a = e5(e, i), o = eq.parseMasterPlaylist(s, a); if (o.playlistParsingError) { this.handleManifestParsingError(e, i, o.playlistParsingError, r, t); return } let { contentSteering: l, levels: u, sessionData: h, sessionKeys: c, startTimeOffset: d, variableList: f } = o; this.variableList = f; let { AUDIO: p = [], SUBTITLES: m, "CLOSED-CAPTIONS": g } = eq.parseMasterPlaylistMedia(s, a, o); p.length && !p.some(e => !e.url) && u[0].audioCodec && !u[0].attrs.AUDIO && (E.log("[playlist-loader]: audio codec signaled in quality level, but no embedded audio track signaled, create one"), p.unshift({ type: "main", name: "main", groupId: "main", default: !1, autoselect: !1, forced: !1, id: -1, attrs: new w({}), bitrate: 0, url: "" })), n.trigger(v.MANIFEST_LOADED, { levels: u, audioTracks: p, subtitles: m, captions: g, contentSteering: l, url: a, stats: t, networkDetails: r, sessionData: h, sessionKeys: c, startTimeOffset: d, variableList: f }) } handleTrackOrLevelPlaylist(e, t, i, r, n) { let s = this.hls, { id: a, level: o, type: l } = i, u = e5(e, i), h = p(o) ? o : p(a) ? a : 0, c = e4(i), d = eq.parseLevelPlaylist(e.data, u, h, c, 0, this.variableList); if (l === e2.MANIFEST) { let e = { attrs: new w({}), bitrate: 0, details: d, name: "", url: u }; s.trigger(v.MANIFEST_LOADED, { levels: [e], audioTracks: [], url: u, stats: t, networkDetails: r, sessionData: null, sessionKeys: null, contentSteering: null, startTimeOffset: null, variableList: null }) } t.parsing.end = performance.now(), i.levelDetails = d, this.handlePlaylistLoaded(d, e, t, i, r, n) } handleManifestParsingError(e, t, i, r, n) { this.hls.trigger(v.ERROR, { type: y.NETWORK_ERROR, details: x.MANIFEST_PARSING_ERROR, fatal: t.type === e2.MANIFEST, url: e.url, err: i, error: i, reason: i.message, response: e, context: t, networkDetails: r, stats: n }) } handleNetworkError(e, t, i = !1, r, n) { let s = `A network ${i ? "timeout" : "error" + (r ? " (status " + r.code + ")" : "")} occurred while loading ${e.type}`; e.type === e2.LEVEL ? s += `: ${e.level} id: ${e.id}` : (e.type === e2.AUDIO_TRACK || e.type === e2.SUBTITLE_TRACK) && (s += ` id: ${e.id} group-id: "${e.groupId}"`); let a = Error(s); E.warn(`[playlist-loader]: ${s}`); let o = x.UNKNOWN, l = !1, u = this.getInternalLoader(e); switch (e.type) { case e2.MANIFEST: o = i ? x.MANIFEST_LOAD_TIMEOUT : x.MANIFEST_LOAD_ERROR, l = !0; break; case e2.LEVEL: o = i ? x.LEVEL_LOAD_TIMEOUT : x.LEVEL_LOAD_ERROR, l = !1; break; case e2.AUDIO_TRACK: o = i ? x.AUDIO_TRACK_LOAD_TIMEOUT : x.AUDIO_TRACK_LOAD_ERROR, l = !1; break; case e2.SUBTITLE_TRACK: o = i ? x.SUBTITLE_TRACK_LOAD_TIMEOUT : x.SUBTITLE_LOAD_ERROR, l = !1 }u && this.resetInternalLoader(e.type); let h = { type: y.NETWORK_ERROR, details: o, fatal: l, url: e.url, loader: u, context: e, error: a, networkDetails: t, stats: n }; if (r) { let i = (null == t ? void 0 : t.url) || e.url; h.response = d({ url: i, data: void 0 }, r) } this.hls.trigger(v.ERROR, h) } handlePlaylistLoaded(e, t, i, r, n, s) { let a = this.hls, { type: o, level: l, id: u, groupId: h, deliveryDirectives: c } = r, d = e5(t, r), f = e4(r), p = "number" == typeof r.level && f === e3.MAIN ? l : void 0; if (!e.fragments.length) { let e = Error("No Segments found in Playlist"); a.trigger(v.ERROR, { type: y.NETWORK_ERROR, details: x.LEVEL_EMPTY_ERROR, fatal: !1, url: d, error: e, reason: e.message, response: t, context: r, level: p, parent: f, networkDetails: n, stats: i }); return } e.targetduration || (e.playlistParsingError = Error("Missing Target Duration")); let m = e.playlistParsingError; if (m) { a.trigger(v.ERROR, { type: y.NETWORK_ERROR, details: x.LEVEL_PARSING_ERROR, fatal: !1, url: d, error: m, reason: m.message, response: t, context: r, level: p, parent: f, networkDetails: n, stats: i }); return } switch (e.live && s && (s.getCacheAge && (e.ageHeader = s.getCacheAge() || 0), (!s.getCacheAge || isNaN(e.ageHeader)) && (e.ageHeader = 0)), o) { case e2.MANIFEST: case e2.LEVEL: a.trigger(v.LEVEL_LOADED, { details: e, level: p || 0, id: u || 0, stats: i, networkDetails: n, deliveryDirectives: c }); break; case e2.AUDIO_TRACK: a.trigger(v.AUDIO_TRACK_LOADED, { details: e, id: u || 0, groupId: h || "", stats: i, networkDetails: n, deliveryDirectives: c }); break; case e2.SUBTITLE_TRACK: a.trigger(v.SUBTITLE_TRACK_LOADED, { details: e, id: u || 0, groupId: h || "", stats: i, networkDetails: n, deliveryDirectives: c }) } } } function e6(e, t) { let i; try { i = new Event("addtrack") } catch (e) { (i = document.createEvent("Event")).initEvent("addtrack", !1, !1) } i.track = e, t.dispatchEvent(i) } function e9(e, t) { let i = e.mode; if ("disabled" === i && (e.mode = "hidden"), e.cues && !e.cues.getCueById(t.id)) try { if (e.addCue(t), !e.cues.getCueById(t.id)) throw Error(`addCue is failed for: ${t}`) } catch (i) { E.debug(`[texttrack-utils]: ${i}`); try { let i = new self.TextTrackCue(t.startTime, t.endTime, t.text); i.id = t.id, e.addCue(i) } catch (e) { E.debug(`[texttrack-utils]: Legacy TextTrackCue fallback failed: ${e}`) } } "disabled" === i && (e.mode = i) } function e7(e) { let t = e.mode; if ("disabled" === t && (e.mode = "hidden"), e.cues) for (let t = e.cues.length; t--;)e.removeCue(e.cues[t]); "disabled" === t && (e.mode = t) } function te(e, t, i, r) { let n = e.mode; if ("disabled" === n && (e.mode = "hidden"), e.cues && e.cues.length > 0) { let n = function (e, t, i) { let r = [], n = function (e, t) { if (t < e[0].startTime) return 0; let i = e.length - 1; if (t > e[i].endTime) return -1; let r = 0, n = i; for (; r <= n;) { let s = Math.floor((n + r) / 2); if (t < e[s].startTime) n = s - 1; else { if (!(t > e[s].startTime) || !(r < i)) return s; r = s + 1 } } return e[r].startTime - t < t - e[n].startTime ? r : n }(e, t); if (n > -1) for (let s = n, a = e.length; s < a; s++) { let n = e[s]; if (n.startTime >= t && n.endTime <= i) r.push(n); else if (n.startTime > i) break } return r }(e.cues, t, i); for (let t = 0; t < n.length; t++)(!r || r(n[t])) && e.removeCue(n[t]) } "disabled" === n && (e.mode = n) } function tt(e) { let t = []; for (let i = 0; i < e.length; i++) { let r = e[i]; ("subtitles" === r.kind || "captions" === r.kind) && r.label && t.push(e[i]) } return t } var ti = { audioId3: "org.id3", dateRange: "com.apple.quicktime.HLS", emsg: "https://aomedia.org/emsg/ID3" }; function tr() { if ("undefined" != typeof self) return self.VTTCue || self.TextTrackCue } function tn(e, t, i, r, n) { let s = new e(t, i, ""); try { s.value = r, n && (s.type = n) } catch (a) { s = new e(t, i, JSON.stringify(n ? d({ type: n }, r) : r)) } return s } let ts = (() => { let e = tr(); try { e && new e(0, Number.POSITIVE_INFINITY, "") } catch (e) { return Number.MAX_VALUE } return Number.POSITIVE_INFINITY })(); function ta(e, t) { return e.getTime() / 1e3 - t } class to { constructor(e) { this.hls = void 0, this.id3Track = null, this.media = null, this.dateRangeCuesAppended = {}, this.hls = e, this._registerListeners() } destroy() { this._unregisterListeners(), this.id3Track = null, this.media = null, this.dateRangeCuesAppended = {}, this.hls = null } _registerListeners() { let { hls: e } = this; e.on(v.MEDIA_ATTACHED, this.onMediaAttached, this), e.on(v.MEDIA_DETACHING, this.onMediaDetaching, this), e.on(v.MANIFEST_LOADING, this.onManifestLoading, this), e.on(v.FRAG_PARSING_METADATA, this.onFragParsingMetadata, this), e.on(v.BUFFER_FLUSHING, this.onBufferFlushing, this), e.on(v.LEVEL_UPDATED, this.onLevelUpdated, this) } _unregisterListeners() { let { hls: e } = this; e.off(v.MEDIA_ATTACHED, this.onMediaAttached, this), e.off(v.MEDIA_DETACHING, this.onMediaDetaching, this), e.off(v.MANIFEST_LOADING, this.onManifestLoading, this), e.off(v.FRAG_PARSING_METADATA, this.onFragParsingMetadata, this), e.off(v.BUFFER_FLUSHING, this.onBufferFlushing, this), e.off(v.LEVEL_UPDATED, this.onLevelUpdated, this) } onMediaAttached(e, t) { this.media = t.media } onMediaDetaching() { this.id3Track && (e7(this.id3Track), this.id3Track = null, this.media = null, this.dateRangeCuesAppended = {}) } onManifestLoading() { this.dateRangeCuesAppended = {} } createTrack(e) { let t = this.getID3Track(e.textTracks); return t.mode = "hidden", t } getID3Track(e) { if (this.media) { for (let t = 0; t < e.length; t++) { let i = e[t]; if ("metadata" === i.kind && "id3" === i.label) return e6(i, this.media), i } return this.media.addTextTrack("metadata", "id3") } } onFragParsingMetadata(e, t) { if (!this.media) return; let { hls: { config: { enableEmsgMetadataCues: i, enableID3MetadataCues: r } } } = this; if (!i && !r) return; let { samples: n } = t; this.id3Track || (this.id3Track = this.createTrack(this.media)); let s = tr(); if (s) for (let e = 0; e < n.length; e++) { let t = n[e].type; if (t === ti.emsg && !i || !r) continue; let a = et(n[e].data); if (a) { let i = n[e].pts, r = i + n[e].duration; r > ts && (r = ts), r - i <= 0 && (r = i + .25); for (let e = 0; e < a.length; e++) { let n = a[e]; if (!J(n)) { this.updateId3CueEnds(i, t); let e = tn(s, i, r, n, t); e && this.id3Track.addCue(e) } } } } } updateId3CueEnds(e, t) { var i; let r = null == (i = this.id3Track) ? void 0 : i.cues; if (r) for (let i = r.length; i--;) { let n = r[i]; n.type === t && n.startTime < e && n.endTime === ts && (n.endTime = e) } } onBufferFlushing(e, { startOffset: t, endOffset: i, type: r }) { let { id3Track: n, hls: s } = this; if (!s) return; let { config: { enableEmsgMetadataCues: a, enableID3MetadataCues: o } } = s; n && (a || o) && te(n, t, i, "audio" === r ? e => e.type === ti.audioId3 && o : "video" === r ? e => e.type === ti.emsg && a : e => e.type === ti.audioId3 && o || e.type === ti.emsg && a) } onLevelUpdated(e, { details: t }) { if (!this.media || !t.hasProgramDateTime || !this.hls.config.enableDateRangeMetadataCues) return; let { dateRangeCuesAppended: i, id3Track: r } = this, { dateRanges: n } = t, s = Object.keys(n); if (r) { let e = Object.keys(i).filter(e => !s.includes(e)); for (let t = e.length; t--;) { let n = e[t]; Object.keys(i[n].cues).forEach(e => { r.removeCue(i[n].cues[e]) }), delete i[n] } } let a = t.fragments[t.fragments.length - 1]; if (0 === s.length || !p(null == a ? void 0 : a.programDateTime)) return; this.id3Track || (this.id3Track = this.createTrack(this.media)); let o = a.programDateTime / 1e3 - a.start, l = tr(); for (let e = 0; e < s.length; e++) { let t = s[e], r = n[t], a = ta(r.startDate, o), h = i[t], c = (null == h ? void 0 : h.cues) || {}, d = (null == h ? void 0 : h.durationKnown) || !1, f = ts, p = r.endDate; if (p) f = ta(p, o), d = !0; else if (r.endOnNext && !d) { let e = s.reduce((e, t) => { if (t !== r.id) { let i = n[t]; if (i.class === r.class && i.startDate > r.startDate && (!e || r.startDate < e.startDate)) return i } return e }, null); e && (f = ta(e.startDate, o), d = !0) } let m = Object.keys(r.attr); for (let e = 0; e < m.length; e++) { var u; let i = m[e]; if (!("ID" !== i && "CLASS" !== i && "START-DATE" !== i && "DURATION" !== i && "END-DATE" !== i && "END-ON-NEXT" !== i)) continue; let n = c[i]; if (n) d && !h.durationKnown && (n.endTime = f); else if (l) { let e = r.attr[i]; ("SCTE35-OUT" === i || "SCTE35-IN" === i) && (u = e, e = Uint8Array.from(u.replace(/^0x/, "").replace(/([\da-fA-F]{2}) ?/g, "0x$1 ").replace(/ +$/, "").split(" ")).buffer); let n = tn(l, a, f, { key: i, data: e }, ti.dateRange); n && (n.id = t, this.id3Track.addCue(n), c[i] = n) } } i[t] = { cues: c, dateRange: r, durationKnown: d } } } } class tl { constructor(e) { this.hls = void 0, this.config = void 0, this.media = null, this.levelDetails = null, this.currentTime = 0, this.stallCount = 0, this._latency = null, this.timeupdateHandler = () => this.timeupdate(), this.hls = e, this.config = e.config, this.registerListeners() } get latency() { return this._latency || 0 } get maxLatency() { let { config: e, levelDetails: t } = this; return void 0 !== e.liveMaxLatencyDuration ? e.liveMaxLatencyDuration : t ? e.liveMaxLatencyDurationCount * t.targetduration : 0 } get targetLatency() { let { levelDetails: e } = this; if (null === e) return null; let { holdBack: t, partHoldBack: i, targetduration: r } = e, { liveSyncDuration: n, liveSyncDurationCount: s, lowLatencyMode: a } = this.config, o = this.hls.userConfig, l = a && i || t; return (o.liveSyncDuration || o.liveSyncDurationCount || 0 === l) && (l = void 0 !== n ? n : s * r), l + Math.min(1 * this.stallCount, r) } get liveSyncPosition() { let e = this.estimateLiveEdge(), t = this.targetLatency, i = this.levelDetails; if (null === e || null === t || null === i) return null; let r = i.edge, n = e - t - this.edgeStalled; return Math.min(Math.max(r - i.totalduration, n), r - (this.config.lowLatencyMode && i.partTarget || i.targetduration)) } get drift() { let { levelDetails: e } = this; return null === e ? 1 : e.drift } get edgeStalled() { let { levelDetails: e } = this; if (null === e) return 0; let t = 3 * (this.config.lowLatencyMode && e.partTarget || e.targetduration); return Math.max(e.age - t, 0) } get forwardBufferLength() { let { media: e, levelDetails: t } = this; if (!e || !t) return 0; let i = e.buffered.length; return (i ? e.buffered.end(i - 1) : t.edge) - this.currentTime } destroy() { this.unregisterListeners(), this.onMediaDetaching(), this.levelDetails = null, this.hls = this.timeupdateHandler = null } registerListeners() { this.hls.on(v.MEDIA_ATTACHED, this.onMediaAttached, this), this.hls.on(v.MEDIA_DETACHING, this.onMediaDetaching, this), this.hls.on(v.MANIFEST_LOADING, this.onManifestLoading, this), this.hls.on(v.LEVEL_UPDATED, this.onLevelUpdated, this), this.hls.on(v.ERROR, this.onError, this) } unregisterListeners() { this.hls.off(v.MEDIA_ATTACHED, this.onMediaAttached, this), this.hls.off(v.MEDIA_DETACHING, this.onMediaDetaching, this), this.hls.off(v.MANIFEST_LOADING, this.onManifestLoading, this), this.hls.off(v.LEVEL_UPDATED, this.onLevelUpdated, this), this.hls.off(v.ERROR, this.onError, this) } onMediaAttached(e, t) { this.media = t.media, this.media.addEventListener("timeupdate", this.timeupdateHandler) } onMediaDetaching() { this.media && (this.media.removeEventListener("timeupdate", this.timeupdateHandler), this.media = null) } onManifestLoading() { this.levelDetails = null, this._latency = null, this.stallCount = 0 } onLevelUpdated(e, { details: t }) { this.levelDetails = t, t.advanced && this.timeupdate(), !t.live && this.media && this.media.removeEventListener("timeupdate", this.timeupdateHandler) } onError(e, t) { var i; t.details === x.BUFFER_STALLED_ERROR && (this.stallCount++, null != (i = this.levelDetails) && i.live && E.warn("[playback-rate-controller]: Stall detected, adjusting target latency")) } timeupdate() { let { media: e, levelDetails: t } = this; if (!e || !t) return; this.currentTime = e.currentTime; let i = this.computeLatency(); if (null === i) return; this._latency = i; let { lowLatencyMode: r, maxLiveSyncPlaybackRate: n } = this.config; if (!r || 1 === n || !t.live) return; let s = this.targetLatency; if (null === s) return; let a = i - s; if (a < Math.min(this.maxLatency, s + t.targetduration) && a > .05 && this.forwardBufferLength > 1) { let t = Math.min(2, Math.max(1, n)), i = Math.round(2 / (1 + Math.exp(-.75 * a - this.edgeStalled)) * 20) / 20; e.playbackRate = Math.min(t, Math.max(1, i)) } else 1 !== e.playbackRate && 0 !== e.playbackRate && (e.playbackRate = 1) } estimateLiveEdge() { let { levelDetails: e } = this; return null === e ? null : e.edge + e.age } computeLatency() { let e = this.estimateLiveEdge(); return null === e ? null : e - this.currentTime } } let tu = ["NONE", "TYPE-0", "TYPE-1", null], th = ["SDR", "PQ", "HLG"]; var tc = { No: "", Yes: "YES", v2: "v2" }; function td(e) { let { canSkipUntil: t, canSkipDateRanges: i, age: r } = e; return t && r < t / 2 ? i ? tc.v2 : tc.Yes : tc.No } class tf { constructor(e, t, i) { this.msn = void 0, this.part = void 0, this.skip = void 0, this.msn = e, this.part = t, this.skip = i } addDirectives(e) { let t = new self.URL(e); return void 0 !== this.msn && t.searchParams.set("_HLS_msn", this.msn.toString()), void 0 !== this.part && t.searchParams.set("_HLS_part", this.part.toString()), this.skip && t.searchParams.set("_HLS_skip", this.skip), t.href } } class tp { constructor(e) { this._attrs = void 0, this.audioCodec = void 0, this.bitrate = void 0, this.codecSet = void 0, this.url = void 0, this.frameRate = void 0, this.height = void 0, this.id = void 0, this.name = void 0, this.videoCodec = void 0, this.width = void 0, this.details = void 0, this.fragmentError = 0, this.loadError = 0, this.loaded = void 0, this.realBitrate = 0, this.supportedPromise = void 0, this.supportedResult = void 0, this._avgBitrate = 0, this._audioGroups = void 0, this._subtitleGroups = void 0, this._urlId = 0, this.url = [e.url], this._attrs = [e.attrs], this.bitrate = e.bitrate, e.details && (this.details = e.details), this.id = e.id || 0, this.name = e.name, this.width = e.width || 0, this.height = e.height || 0, this.frameRate = e.attrs.optionalFloat("FRAME-RATE", 0), this._avgBitrate = e.attrs.decimalInteger("AVERAGE-BANDWIDTH"), this.audioCodec = e.audioCodec, this.videoCodec = e.videoCodec, this.codecSet = [e.videoCodec, e.audioCodec].filter(e => !!e).map(e => e.substring(0, 4)).join(","), this.addGroupId("audio", e.attrs.AUDIO), this.addGroupId("text", e.attrs.SUBTITLES) } get maxBitrate() { return Math.max(this.realBitrate, this.bitrate) } get averageBitrate() { return this._avgBitrate || this.realBitrate || this.bitrate } get attrs() { return this._attrs[0] } get codecs() { return this.attrs.CODECS || "" } get pathwayId() { return this.attrs["PATHWAY-ID"] || "." } get videoRange() { return this.attrs["VIDEO-RANGE"] || "SDR" } get score() { return this.attrs.optionalFloat("SCORE", 0) } get uri() { return this.url[0] || "" } hasAudioGroup(e) { return tm(this._audioGroups, e) } hasSubtitleGroup(e) { return tm(this._subtitleGroups, e) } get audioGroups() { return this._audioGroups } get subtitleGroups() { return this._subtitleGroups } addGroupId(e, t) { if (t) { if ("audio" === e) { let e = this._audioGroups; e || (e = this._audioGroups = []), -1 === e.indexOf(t) && e.push(t) } else if ("text" === e) { let e = this._subtitleGroups; e || (e = this._subtitleGroups = []), -1 === e.indexOf(t) && e.push(t) } } } get urlId() { return 0 } set urlId(e) { } get audioGroupIds() { return this.audioGroups ? [this.audioGroupId] : void 0 } get textGroupIds() { return this.subtitleGroups ? [this.textGroupId] : void 0 } get audioGroupId() { var e; return null == (e = this.audioGroups) ? void 0 : e[0] } get textGroupId() { var e; return null == (e = this.subtitleGroups) ? void 0 : e[0] } addFallback() { } } function tm(e, t) { return !!t && !!e && -1 !== e.indexOf(t) } function tg(e, t) { let i = t.startPTS; if (p(i)) { let r, n = 0; t.sn > e.sn ? (n = i - e.start, r = e) : (n = e.start - i, r = t), r.duration !== n && (r.duration = n) } else t.sn > e.sn ? e.cc === t.cc && e.minEndPTS ? t.start = e.start + (e.minEndPTS - e.start) : t.start = e.start + e.duration : t.start = Math.max(e.start - t.duration, 0) } function tv(e, t, i, r, n, s) { let a; r - i <= 0 && (E.warn("Fragment should have a positive duration", t), r = i + t.duration, s = n + t.duration); let o = i, l = r, u = t.startPTS, h = t.endPTS; if (p(u)) { let e = Math.abs(u - i); p(t.deltaPTS) ? t.deltaPTS = Math.max(e, t.deltaPTS) : t.deltaPTS = e, o = Math.max(i, u), i = Math.min(i, u), n = Math.min(n, t.startDTS), l = Math.min(r, h), r = Math.max(r, h), s = Math.max(s, t.endDTS) } let c = i - t.start; 0 !== t.start && (t.start = i), t.duration = r - t.start, t.startPTS = i, t.maxStartPTS = o, t.startDTS = n, t.endPTS = r, t.minEndPTS = l, t.endDTS = s; let d = t.sn; if (!e || d < e.startSN || d > e.endSN) return 0; let f = d - e.startSN, m = e.fragments; for (m[f] = t, a = f; a > 0; a--)tg(m[a], m[a - 1]); for (a = f; a < m.length - 1; a++)tg(m[a], m[a + 1]); return e.fragmentHint && tg(m[m.length - 1], e.fragmentHint), e.PTSKnown = e.alignedSliding = !0, c } function ty(e, t) { let i = t.startSN + t.skippedSegments - e.startSN, r = e.fragments; i < 0 || i >= r.length || tx(t, r[i].start) } function tx(e, t) { if (t) { let i = e.fragments; for (let r = e.skippedSegments; r < i.length; r++)i[r].start += t; e.fragmentHint && (e.fragmentHint.start += t) } } function tS(e, t, i) { var r; return null != e && e.details ? tA(null == (r = e.details) ? void 0 : r.partList, t, i) : null } function tA(e, t, i) { if (e) for (let r = e.length; r--;) { let n = e[r]; if (n.index === i && n.fragment.sn === t) return n } return null } function t_(e) { e.forEach((e, t) => { let { details: i } = e; null != i && i.fragments && i.fragments.forEach(e => { e.level = t }) }) } function tE(e) { switch (e.details) { case x.FRAG_LOAD_TIMEOUT: case x.KEY_LOAD_TIMEOUT: case x.LEVEL_LOAD_TIMEOUT: case x.MANIFEST_LOAD_TIMEOUT: return !0 }return !1 } function tb(e, t) { let i = tE(t); return e.default[`${i ? "timeout" : "error"}Retry`] } function tT(e, t) { return Math.min(("linear" === e.backoff ? 1 : Math.pow(2, t)) * e.retryDelayMs, e.maxRetryDelayMs) } function tw(e) { return d(d({}, e), { errorRetry: null, timeoutRetry: null }) } function tM(e, t, i, r) { if (!e) return !1; let n = null == r ? void 0 : r.code, s = t < e.maxNumRetry && (0 === n && !1 === navigator.onLine || !!n && (n < 400 || n > 499) || !!i); return e.shouldRetry ? e.shouldRetry(e, t, i, r, s) : s } let tR = { search: function (e, t) { let i = 0, r = e.length - 1, n = null, s = null; for (; i <= r;) { let a = t(s = e[n = (i + r) / 2 | 0]); if (a > 0) i = n + 1; else { if (!(a < 0)) return s; r = n - 1 } } return null } }; function tC(e, t, i = 0, r = 0, n = .005) { let s = null; if (e) { s = t[e.sn - t[0].sn + 1] || null; let r = e.endDTS - i; r > 0 && r < 15e-7 && (i += 15e-7) } else 0 === i && 0 === t[0].start && (s = t[0]); if (s && ((!e || e.level === s.level) && 0 === tI(i, r, s) || function (e, t, i) { if (t && 0 === t.start && t.level < e.level && (t.endPTS || 0) > 0) { let r = t.tagList.reduce((e, t) => ("INF" === t[0] && (e += parseFloat(t[1])), e), i); return e.start <= r } return !1 }(s, e, Math.min(n, r)))) return s; let a = tR.search(t, tI.bind(null, i, r)); return a && (a !== e || !s) ? a : s } function tI(e = 0, t = 0, i) { if (i.start <= e && i.start + i.duration > e) return 0; let r = Math.min(t, i.duration + (i.deltaPTS ? i.deltaPTS : 0)); return i.start + i.duration - r <= e ? 1 : i.start - r > e && i.start ? -1 : 0 } var tL = { DoNothing: 0, SendEndCallback: 1, SendAlternateToPenaltyBox: 2, RemoveAlternatePermanently: 3, InsertDiscontinuity: 4, RetryRequest: 5 }, tP = { None: 0, MoveAllAlternatesMatchingHost: 1, MoveAllAlternatesMatchingHDCP: 2, SwitchToSDR: 4 }; class tD { constructor(e) { this.hls = void 0, this.playlistError = 0, this.penalizedRenditions = {}, this.log = void 0, this.warn = void 0, this.error = void 0, this.hls = e, this.log = E.log.bind(E, "[info]:"), this.warn = E.warn.bind(E, "[warning]:"), this.error = E.error.bind(E, "[error]:"), this.registerListeners() } registerListeners() { let e = this.hls; e.on(v.ERROR, this.onError, this), e.on(v.MANIFEST_LOADING, this.onManifestLoading, this), e.on(v.LEVEL_UPDATED, this.onLevelUpdated, this) } unregisterListeners() { let e = this.hls; e && (e.off(v.ERROR, this.onError, this), e.off(v.ERROR, this.onErrorOut, this), e.off(v.MANIFEST_LOADING, this.onManifestLoading, this), e.off(v.LEVEL_UPDATED, this.onLevelUpdated, this)) } destroy() { this.unregisterListeners(), this.hls = null, this.penalizedRenditions = {} } startLoad(e) { } stopLoad() { this.playlistError = 0 } getVariantLevelIndex(e) { return (null == e ? void 0 : e.type) === e3.MAIN ? e.level : this.hls.loadLevel } onManifestLoading() { this.playlistError = 0, this.penalizedRenditions = {} } onLevelUpdated() { this.playlistError = 0 } onError(e, t) { var i, r, n, s; if (t.fatal) return; let a = this.hls, o = t.context; switch (t.details) { case x.FRAG_LOAD_ERROR: case x.FRAG_LOAD_TIMEOUT: case x.KEY_LOAD_ERROR: case x.KEY_LOAD_TIMEOUT: t.errorAction = this.getFragRetryOrSwitchAction(t); return; case x.FRAG_PARSING_ERROR: if (null != (i = t.frag) && i.gap) { t.errorAction = { action: tL.DoNothing, flags: tP.None }; return } case x.FRAG_GAP: case x.FRAG_DECRYPT_ERROR: t.errorAction = this.getFragRetryOrSwitchAction(t), t.errorAction.action = tL.SendAlternateToPenaltyBox; return; case x.LEVEL_EMPTY_ERROR: case x.LEVEL_PARSING_ERROR: { let e = t.parent === e3.MAIN ? t.level : a.loadLevel; t.details === x.LEVEL_EMPTY_ERROR && null != (n = t.context) && null != (s = n.levelDetails) && s.live ? t.errorAction = this.getPlaylistRetryOrSwitchAction(t, e) : (t.levelRetry = !1, t.errorAction = this.getLevelSwitchAction(t, e)) } return; case x.LEVEL_LOAD_ERROR: case x.LEVEL_LOAD_TIMEOUT: "number" == typeof (null == o ? void 0 : o.level) && (t.errorAction = this.getPlaylistRetryOrSwitchAction(t, o.level)); return; case x.AUDIO_TRACK_LOAD_ERROR: case x.AUDIO_TRACK_LOAD_TIMEOUT: case x.SUBTITLE_LOAD_ERROR: case x.SUBTITLE_TRACK_LOAD_TIMEOUT: if (o) { let e = a.levels[a.loadLevel]; e && (o.type === e2.AUDIO_TRACK && e.hasAudioGroup(o.groupId) || o.type === e2.SUBTITLE_TRACK && e.hasSubtitleGroup(o.groupId)) && (t.errorAction = this.getPlaylistRetryOrSwitchAction(t, a.loadLevel), t.errorAction.action = tL.SendAlternateToPenaltyBox, t.errorAction.flags = tP.MoveAllAlternatesMatchingHost) } return; case x.KEY_SYSTEM_STATUS_OUTPUT_RESTRICTED: { let e = a.levels[a.loadLevel], i = null == e ? void 0 : e.attrs["HDCP-LEVEL"]; i ? t.errorAction = { action: tL.SendAlternateToPenaltyBox, flags: tP.MoveAllAlternatesMatchingHDCP, hdcpLevel: i } : this.keySystemError(t) } return; case x.BUFFER_ADD_CODEC_ERROR: case x.REMUX_ALLOC_ERROR: case x.BUFFER_APPEND_ERROR: t.errorAction = this.getLevelSwitchAction(t, null != (r = t.level) ? r : a.loadLevel); return; case x.INTERNAL_EXCEPTION: case x.BUFFER_APPENDING_ERROR: case x.BUFFER_FULL_ERROR: case x.LEVEL_SWITCH_ERROR: case x.BUFFER_STALLED_ERROR: case x.BUFFER_SEEK_OVER_HOLE: case x.BUFFER_NUDGE_ON_STALL: t.errorAction = { action: tL.DoNothing, flags: tP.None }; return }t.type === y.KEY_SYSTEM_ERROR && this.keySystemError(t) } keySystemError(e) { let t = this.getVariantLevelIndex(e.frag); e.levelRetry = !1, e.errorAction = this.getLevelSwitchAction(e, t) } getPlaylistRetryOrSwitchAction(e, t) { let i = tb(this.hls.config.playlistLoadPolicy, e), r = this.playlistError++; if (tM(i, r, tE(e), e.response)) return { action: tL.RetryRequest, flags: tP.None, retryConfig: i, retryCount: r }; let n = this.getLevelSwitchAction(e, t); return i && (n.retryConfig = i, n.retryCount = r), n } getFragRetryOrSwitchAction(e) { let t = this.hls, i = this.getVariantLevelIndex(e.frag), r = t.levels[i], { fragLoadPolicy: n, keyLoadPolicy: s } = t.config, a = tb(e.details.startsWith("key") ? s : n, e), o = t.levels.reduce((e, t) => e + t.fragmentError, 0); if (r && (e.details !== x.FRAG_GAP && r.fragmentError++, tM(a, o, tE(e), e.response))) return { action: tL.RetryRequest, flags: tP.None, retryConfig: a, retryCount: o }; let l = this.getLevelSwitchAction(e, i); return a && (l.retryConfig = a, l.retryCount = o), l } getLevelSwitchAction(e, t) { let i = this.hls; null == t && (t = i.loadLevel); let r = this.hls.levels[t]; if (r) { var n, s, a, o; let t = e.details; r.loadError++, t === x.BUFFER_APPEND_ERROR && r.fragmentError++; let l = -1, { levels: u, loadLevel: h, minAutoLevel: c, maxAutoLevel: d } = i; i.autoLevelEnabled || (i.loadLevel = -1); let f = null == (n = e.frag) ? void 0 : n.type, p = (f === e3.AUDIO && t === x.FRAG_PARSING_ERROR || "audio" === e.sourceBufferName && (t === x.BUFFER_ADD_CODEC_ERROR || t === x.BUFFER_APPEND_ERROR)) && u.some(({ audioCodec: e }) => r.audioCodec !== e), m = "video" === e.sourceBufferName && (t === x.BUFFER_ADD_CODEC_ERROR || t === x.BUFFER_APPEND_ERROR) && u.some(({ codecSet: e, audioCodec: t }) => r.codecSet !== e && r.audioCodec === t), { type: g, groupId: v } = null != (s = e.context) ? s : {}; for (let i = u.length; i--;) { let n = (i + h) % u.length; if (n !== h && n >= c && n <= d && 0 === u[n].loadError) { let i = u[n]; if (t === x.FRAG_GAP && f === e3.MAIN && e.frag) { let t = u[n].details; if (t) { let i = tC(e.frag, t.fragments, e.frag.start); if (null != i && i.gap) continue } } else if (g === e2.AUDIO_TRACK && i.hasAudioGroup(v) || g === e2.SUBTITLE_TRACK && i.hasSubtitleGroup(v)) continue; else if (f === e3.AUDIO && null != (a = r.audioGroups) && a.some(e => i.hasAudioGroup(e)) || f === e3.SUBTITLE && null != (o = r.subtitleGroups) && o.some(e => i.hasSubtitleGroup(e)) || p && r.audioCodec === i.audioCodec || !p && r.audioCodec !== i.audioCodec || m && r.codecSet === i.codecSet) continue; l = n; break } } if (l > -1 && i.loadLevel !== l) return e.levelRetry = !0, this.playlistError = 0, { action: tL.SendAlternateToPenaltyBox, flags: tP.None, nextAutoLevel: l } } return { action: tL.SendAlternateToPenaltyBox, flags: tP.MoveAllAlternatesMatchingHost } } onErrorOut(e, t) { var i; switch (null == (i = t.errorAction) ? void 0 : i.action) { case tL.DoNothing: break; case tL.SendAlternateToPenaltyBox: this.sendAlternateToPenaltyBox(t), t.errorAction.resolved || t.details === x.FRAG_GAP ? /MediaSource readyState: ended/.test(t.error.message) && (this.warn(`MediaSource ended after "${t.sourceBufferName}" sourceBuffer append error. Attempting to recover from media error.`), this.hls.recoverMediaError()) : t.fatal = !0; case tL.RetryRequest: }if (t.fatal) { this.hls.stopLoad(); return } } sendAlternateToPenaltyBox(e) { let t = this.hls, i = e.errorAction; if (!i) return; let { flags: r, hdcpLevel: n, nextAutoLevel: s } = i; switch (r) { case tP.None: this.switchLevel(e, s); break; case tP.MoveAllAlternatesMatchingHDCP: n && (t.maxHdcpLevel = tu[tu.indexOf(n) - 1], i.resolved = !0), this.warn(`Restricting playback to HDCP-LEVEL of "${t.maxHdcpLevel}" or lower`) }i.resolved || this.switchLevel(e, s) } switchLevel(e, t) { void 0 !== t && e.errorAction && (this.warn(`switching to level ${t} after ${e.details}`), this.hls.nextAutoLevel = t, e.errorAction.resolved = !0, this.hls.nextLoadLevel = this.hls.nextAutoLevel) } } class tO { constructor(e, t) { this.hls = void 0, this.timer = -1, this.requestScheduled = -1, this.canLoad = !1, this.log = void 0, this.warn = void 0, this.log = E.log.bind(E, `${t}:`), this.warn = E.warn.bind(E, `${t}:`), this.hls = e } destroy() { this.clearTimer(), this.hls = this.log = this.warn = null } clearTimer() { -1 !== this.timer && (self.clearTimeout(this.timer), this.timer = -1) } startLoad() { this.canLoad = !0, this.requestScheduled = -1, this.loadPlaylist() } stopLoad() { this.canLoad = !1, this.clearTimer() } switchParams(e, t, i) { let r = null == t ? void 0 : t.renditionReports; if (r) { let n = -1; for (let i = 0; i < r.length; i++) { let s; let a = r[i]; try { s = new self.URL(a.URI, t.url).href } catch (e) { E.warn(`Could not construct new URL for Rendition Report: ${e}`), s = a.URI || "" } if (s === e) { n = i; break } s === e.substring(0, s.length) && (n = i) } if (-1 !== n) { let e = r[n], s = parseInt(e["LAST-MSN"]) || (null == t ? void 0 : t.lastPartSn), a = parseInt(e["LAST-PART"]) || (null == t ? void 0 : t.lastPartIndex); if (this.hls.config.lowLatencyMode) { let e = Math.min(t.age - t.partTarget, t.targetduration); a >= 0 && e > t.partTarget && (a += 1) } return new tf(s, a >= 0 ? a : void 0, i && td(i)) } } } loadPlaylist(e) { -1 === this.requestScheduled && (this.requestScheduled = self.performance.now()) } shouldLoadPlaylist(e) { return this.canLoad && !!e && !!e.url && (!e.details || e.details.live) } shouldReloadPlaylist(e) { return -1 === this.timer && -1 === this.requestScheduled && this.shouldLoadPlaylist(e) } playlistLoaded(e, t, i) { let { details: r, stats: n } = t, s = self.performance.now(), a = n.loading.first ? Math.max(0, s - n.loading.first) : 0; if (r.advancedDateTime = Date.now() - a, r.live || null != i && i.live) { let a, o, l; if (r.reloaded(i), i && this.log(`live playlist ${e} ${r.advanced ? "REFRESHED " + r.lastPartSn + "-" + r.lastPartIndex : r.updated ? "UPDATED" : "MISSED"}`), i && r.fragments.length > 0 && function (e, t) { let i, r = null, n = e.fragments; for (let e = n.length - 1; e >= 0; e--) { let t = n[e].initSegment; if (t) { r = t; break } } e.fragmentHint && delete e.fragmentHint.endPTS, function (e, t, i) { let r = t.skippedSegments, n = Math.max(e.startSN, t.startSN) - t.startSN, s = (e.fragmentHint ? 1 : 0) + (r ? t.endSN : Math.min(e.endSN, t.endSN)) - t.startSN, a = t.startSN - e.startSN, o = t.fragmentHint ? t.fragments.concat(t.fragmentHint) : t.fragments, l = e.fragmentHint ? e.fragments.concat(e.fragmentHint) : e.fragments; for (let e = n; e <= s; e++) { let n = l[a + e], s = o[e]; r && !s && e < r && (s = t.fragments[e] = n), n && s && i(n, s, e, o) } }(e, t, (e, n, s, a) => { if (t.skippedSegments && n.cc !== e.cc) { let t = e.cc - n.cc; for (let e = s; e < a.length; e++)a[e].cc += t } p(e.startPTS) && p(e.endPTS) && (n.start = n.startPTS = e.startPTS, n.startDTS = e.startDTS, n.maxStartPTS = e.maxStartPTS, n.endPTS = e.endPTS, n.endDTS = e.endDTS, n.minEndPTS = e.minEndPTS, n.duration = e.endPTS - e.startPTS, n.duration && (i = n), t.PTSKnown = t.alignedSliding = !0), n.elementaryStreams = e.elementaryStreams, n.loader = e.loader, n.stats = e.stats, e.initSegment && (n.initSegment = e.initSegment, r = e.initSegment) }); let s = t.fragments; if (r && (t.fragmentHint ? s.concat(t.fragmentHint) : s).forEach(e => { var t; e && (!e.initSegment || e.initSegment.relurl === (null == (t = r) ? void 0 : t.relurl)) && (e.initSegment = r) }), t.skippedSegments) { if (t.deltaUpdateFailed = s.some(e => !e), t.deltaUpdateFailed) { E.warn("[level-helper] Previous playlist missing segments skipped in delta playlist"); for (let e = t.skippedSegments; e--;)s.shift(); t.startSN = s[0].sn } else t.canSkipDateRanges && (t.dateRanges = function (e, t, i) { let r = f({}, e); return i && i.forEach(e => { delete r[e] }), Object.keys(t).forEach(e => { let i = new M(t[e].attr, r[e]); i.isValid ? r[e] = i : E.warn(`Ignoring invalid Playlist Delta Update DATERANGE tag: "${JSON.stringify(t[e].attr)}"`) }), r }(e.dateRanges, t.dateRanges, t.recentlyRemovedDateranges)); t.startCC = t.fragments[0].cc, t.endCC = s[s.length - 1].cc } (function (e, t, i) { if (e && t) { let r = 0; for (let n = 0, s = e.length; n <= s; n++) { let s = e[n], a = t[n + r]; s && a && s.index === a.index && s.fragment.sn === a.fragment.sn ? i(s, a) : r-- } } })(e.partList, t.partList, (e, t) => { t.elementaryStreams = e.elementaryStreams, t.stats = e.stats }), i ? tv(t, i, i.startPTS, i.endPTS, i.startDTS, i.endDTS) : ty(e, t), s.length && (t.totalduration = t.edge - s[0].start), t.driftStartTime = e.driftStartTime, t.driftStart = e.driftStart; let a = t.advancedDateTime; if (t.advanced && a) { let e = t.edge; t.driftStart || (t.driftStartTime = a, t.driftStart = e), t.driftEndTime = a, t.driftEnd = e } else t.driftEndTime = e.driftEndTime, t.driftEnd = e.driftEnd, t.advancedDateTime = e.advancedDateTime }(i, r), !this.canLoad || !r.live) return; if (r.canBlockReload && r.endSN && r.advanced) { let e = this.hls.config.lowLatencyMode, n = r.lastPartSn, s = r.endSN, u = r.lastPartIndex, h = n === s; -1 !== u ? (o = h ? s + 1 : n, l = h ? e ? 0 : u : u + 1) : o = s + 1; let c = r.age, d = Math.min(c + r.ageHeader - r.partTarget, 1.5 * r.targetduration); if (d > 0) { if (i && d > i.tuneInGoal) this.warn(`CDN Tune-in goal increased from: ${i.tuneInGoal} to: ${d} with playlist age: ${r.age}`), d = 0; else { let e = Math.floor(d / r.targetduration); o += e, void 0 !== l && (l += Math.round(d % r.targetduration / r.partTarget)), this.log(`CDN Tune-in age: ${r.ageHeader}s last advanced ${c.toFixed(2)}s goal: ${d} skip sn ${e} to part ${l}`) } r.tuneInGoal = d } if (a = this.getDeliveryDirectives(r, t.deliveryDirectives, o, l), e || !h) { this.loadPlaylist(a); return } } else (r.canBlockReload || r.canSkipUntil) && (a = this.getDeliveryDirectives(r, t.deliveryDirectives, o, l)); let u = this.hls.mainForwardBufferInfo, h = u ? u.end - u.len : 0, c = (r.edge - h) * 1e3, d = function (e, t = 1 / 0) { let i = 1e3 * e.targetduration; if (e.updated) { let r = e.fragments; if (r.length && 4 * i > t) { let e = 1e3 * r[r.length - 1].duration; e < i && (i = e) } } else i /= 2; return Math.round(i) }(r, c); r.updated && s > this.requestScheduled + d && (this.requestScheduled = n.loading.start), void 0 !== o && r.canBlockReload ? this.requestScheduled = n.loading.first + d - (1e3 * r.partTarget || 1e3) : -1 === this.requestScheduled || this.requestScheduled + d < s ? this.requestScheduled = s : this.requestScheduled - s <= 0 && (this.requestScheduled += d); let m = this.requestScheduled - s; m = Math.max(0, m), this.log(`reload live playlist ${e} in ${Math.round(m)} ms`), this.timer = self.setTimeout(() => this.loadPlaylist(a), m) } else this.clearTimer() } getDeliveryDirectives(e, t, i, r) { let n = td(e); return null != t && t.skip && e.deltaUpdateFailed && (i = t.msn, r = t.part, n = tc.No), new tf(i, r, n) } checkRetry(e) { let t = e.details, i = tE(e), r = e.errorAction, { action: n, retryCount: s = 0, retryConfig: a } = r || {}, o = !!r && !!a && (n === tL.RetryRequest || !r.resolved && n === tL.SendAlternateToPenaltyBox); if (o) { var l; if (this.requestScheduled = -1, s >= a.maxNumRetry) return !1; if (i && null != (l = e.context) && l.deliveryDirectives) this.warn(`Retrying playlist loading ${s + 1}/${a.maxNumRetry} after "${t}" without delivery-directives`), this.loadPlaylist(); else { let e = tT(a, s); this.timer = self.setTimeout(() => this.loadPlaylist(), e), this.warn(`Retrying playlist loading ${s + 1}/${a.maxNumRetry} after "${t}" in ${e}ms`) } e.levelRetry = !0, r.resolved = !0 } return o } } class tk { constructor(e, t = 0, i = 0) { this.halfLife = void 0, this.alpha_ = void 0, this.estimate_ = void 0, this.totalWeight_ = void 0, this.halfLife = e, this.alpha_ = e ? Math.exp(Math.log(.5) / e) : 0, this.estimate_ = t, this.totalWeight_ = i } sample(e, t) { let i = Math.pow(this.alpha_, e); this.estimate_ = t * (1 - i) + i * this.estimate_, this.totalWeight_ += e } getTotalWeight() { return this.totalWeight_ } getEstimate() { if (this.alpha_) { let e = 1 - Math.pow(this.alpha_, this.totalWeight_); if (e) return this.estimate_ / e } return this.estimate_ } } class tF { constructor(e, t, i, r = 100) { this.defaultEstimate_ = void 0, this.minWeight_ = void 0, this.minDelayMs_ = void 0, this.slow_ = void 0, this.fast_ = void 0, this.defaultTTFB_ = void 0, this.ttfb_ = void 0, this.defaultEstimate_ = i, this.minWeight_ = .001, this.minDelayMs_ = 50, this.slow_ = new tk(e), this.fast_ = new tk(t), this.defaultTTFB_ = r, this.ttfb_ = new tk(e) } update(e, t) { let { slow_: i, fast_: r, ttfb_: n } = this; i.halfLife !== e && (this.slow_ = new tk(e, i.getEstimate(), i.getTotalWeight())), r.halfLife !== t && (this.fast_ = new tk(t, r.getEstimate(), r.getTotalWeight())), n.halfLife !== e && (this.ttfb_ = new tk(e, n.getEstimate(), n.getTotalWeight())) } sample(e, t) { let i = (e = Math.max(e, this.minDelayMs_)) / 1e3, r = 8 * t / i; this.fast_.sample(i, r), this.slow_.sample(i, r) } sampleTTFB(e) { let t = Math.sqrt(2) * Math.exp(-Math.pow(e / 1e3, 2) / 2); this.ttfb_.sample(t, Math.max(e, 5)) } canEstimate() { return this.fast_.getTotalWeight() >= this.minWeight_ } getEstimate() { return this.canEstimate() ? Math.min(this.fast_.getEstimate(), this.slow_.getEstimate()) : this.defaultEstimate_ } getEstimateTTFB() { return this.ttfb_.getTotalWeight() >= this.minWeight_ ? this.ttfb_.getEstimate() : this.defaultTTFB_ } destroy() { } } let tU = { supported: !0, configurations: [], decodingInfoResults: [{ supported: !0, powerEfficient: !0, smooth: !0 }] }, tN = {}; function tB(e, t) { E.log(`[abr] start candidates with "${e}" ignored because ${t}`) } function tz(e, t, i) { if ("attrs" in e) { let i = t.indexOf(e); if (-1 !== i) return i } for (let r = 0; r < t.length; r++)if (tG(e, t[r], i)) return r; return -1 } function tG(e, t, i) { let { groupId: r, name: n, lang: s, assocLang: a, default: o } = e, l = e.forced; return (void 0 === r || t.groupId === r) && (void 0 === n || t.name === n) && (void 0 === s || t.lang === s) && (void 0 === s || t.assocLang === a) && (void 0 === o || t.default === o) && (void 0 === l || t.forced === l) && (!("characteristics" in e) || function (e, t = "") { let i = e.split(","), r = t.split(","); return i.length === r.length && !i.some(e => -1 === r.indexOf(e)) }(e.characteristics || "", t.characteristics)) && (void 0 === i || i(e, t)) } function tH(e, t) { let { audioCodec: i, channels: r } = e; return (void 0 === i || (t.audioCodec || "").substring(0, 4) === i.substring(0, 4)) && (void 0 === r || r === (t.channels || "2")) } function tV(e, t, i) { for (let r = t; r > -1; r--)if (i(e[r])) return r; for (let r = t + 1; r < e.length; r++)if (i(e[r])) return r; return -1 } class tW {
      constructor(e) {
        this.hls = void 0, this.lastLevelLoadSec = 0, this.lastLoadedFragLevel = -1, this.firstSelection = -1, this._nextAutoLevel = -1, this.nextAutoLevelKey = "", this.audioTracksByGroup = null, this.codecTiers = null, this.timer = -1, this.fragCurrent = null, this.partCurrent = null, this.bitrateTestDelay = 0, this.bwEstimator = void 0, this._abandonRulesCheck = () => {
          let e; let { fragCurrent: t, partCurrent: i, hls: r } = this, { autoLevelEnabled: n, media: s } = r; if (!t || !s) return; let a = performance.now(), o = i ? i.stats : t.stats, l = i ? i.duration : t.duration, u = a - o.loading.start, h = r.minAutoLevel; if (o.aborted || o.loaded && o.loaded === o.total || t.level <= h) { this.clearTimer(), this._nextAutoLevel = -1; return } if (!n || s.paused || !s.playbackRate || !s.readyState) return; let c = r.mainForwardBufferInfo; if (null === c) return; let d = this.bwEstimator.getEstimateTTFB(), f = Math.abs(s.playbackRate); if (u <= Math.max(d, l / (2 * f) * 1e3)) return; let m = c.len / f, g = o.loading.first ? o.loading.first - o.loading.start : -1, y = o.loaded && g > -1, x = this.getBwEstimate(), S = r.levels, A = S[t.level], _ = o.total || Math.max(o.loaded, Math.round(l * A.averageBitrate / 8)), b = y ? u - g : u; b < 1 && y && (b = Math.min(u, 8 * o.loaded / x)); let T = y ? 1e3 * o.loaded / b : 0, w = T ? (_ - o.loaded) / T : 8 * _ / x + d / 1e3; if (w <= m) return; let M = T ? 8 * T : x, R = Number.POSITIVE_INFINITY; for (e = t.level - 1; e > h; e--) { let t = S[e].maxBitrate; if ((R = this.getTimeToLoadFrag(d / 1e3, M, l * t, !S[e].details)) < m) break } if (R >= w || R > 10 * l) return; r.nextLoadLevel = r.nextAutoLevel = e, y ? this.bwEstimator.sample(u - Math.min(d, g), o.loaded) : this.bwEstimator.sampleTTFB(u); let C = S[e].maxBitrate; this.getBwEstimate() * this.hls.config.abrBandWidthUpFactor > C && this.resetEstimator(C), this.clearTimer(), E.warn(`[abr] Fragment ${t.sn}${i ? " part " + i.index : ""} of level ${t.level} is loading too slowly;
      Time to underbuffer: ${m.toFixed(3)} s
      Estimated load time for current fragment: ${w.toFixed(3)} s
      Estimated load time for down switch fragment: ${R.toFixed(3)} s
      TTFB estimate: ${0 | g} ms
      Current BW estimate: ${p(x) ? 0 | x : "Unknown"} bps
      New BW estimate: ${0 | this.getBwEstimate()} bps
      Switching to level ${e} @ ${0 | C} bps`), r.trigger(v.FRAG_LOAD_EMERGENCY_ABORTED, { frag: t, part: i, stats: o })
        }, this.hls = e, this.bwEstimator = this.initEstimator(), this.registerListeners()
      } resetEstimator(e) { e && (E.log(`setting initial bwe to ${e}`), this.hls.config.abrEwmaDefaultEstimate = e), this.firstSelection = -1, this.bwEstimator = this.initEstimator() } initEstimator() { let e = this.hls.config; return new tF(e.abrEwmaSlowVoD, e.abrEwmaFastVoD, e.abrEwmaDefaultEstimate) } registerListeners() { let { hls: e } = this; e.on(v.MANIFEST_LOADING, this.onManifestLoading, this), e.on(v.FRAG_LOADING, this.onFragLoading, this), e.on(v.FRAG_LOADED, this.onFragLoaded, this), e.on(v.FRAG_BUFFERED, this.onFragBuffered, this), e.on(v.LEVEL_SWITCHING, this.onLevelSwitching, this), e.on(v.LEVEL_LOADED, this.onLevelLoaded, this), e.on(v.LEVELS_UPDATED, this.onLevelsUpdated, this), e.on(v.MAX_AUTO_LEVEL_UPDATED, this.onMaxAutoLevelUpdated, this), e.on(v.ERROR, this.onError, this) } unregisterListeners() { let { hls: e } = this; e && (e.off(v.MANIFEST_LOADING, this.onManifestLoading, this), e.off(v.FRAG_LOADING, this.onFragLoading, this), e.off(v.FRAG_LOADED, this.onFragLoaded, this), e.off(v.FRAG_BUFFERED, this.onFragBuffered, this), e.off(v.LEVEL_SWITCHING, this.onLevelSwitching, this), e.off(v.LEVEL_LOADED, this.onLevelLoaded, this), e.off(v.LEVELS_UPDATED, this.onLevelsUpdated, this), e.off(v.MAX_AUTO_LEVEL_UPDATED, this.onMaxAutoLevelUpdated, this), e.off(v.ERROR, this.onError, this)) } destroy() { this.unregisterListeners(), this.clearTimer(), this.hls = this._abandonRulesCheck = null, this.fragCurrent = this.partCurrent = null } onManifestLoading(e, t) { this.lastLoadedFragLevel = -1, this.firstSelection = -1, this.lastLevelLoadSec = 0, this.fragCurrent = this.partCurrent = null, this.onLevelsUpdated(), this.clearTimer() } onLevelsUpdated() { this.lastLoadedFragLevel > -1 && this.fragCurrent && (this.lastLoadedFragLevel = this.fragCurrent.level), this._nextAutoLevel = -1, this.onMaxAutoLevelUpdated(), this.codecTiers = null, this.audioTracksByGroup = null } onMaxAutoLevelUpdated() { this.firstSelection = -1, this.nextAutoLevelKey = "" } onFragLoading(e, t) { let i = t.frag; if (!this.ignoreFragment(i)) { if (!i.bitrateTest) { var r; this.fragCurrent = i, this.partCurrent = null != (r = t.part) ? r : null } this.clearTimer(), this.timer = self.setInterval(this._abandonRulesCheck, 100) } } onLevelSwitching(e, t) { this.clearTimer() } onError(e, t) { if (!t.fatal) switch (t.details) { case x.BUFFER_ADD_CODEC_ERROR: case x.BUFFER_APPEND_ERROR: this.lastLoadedFragLevel = -1, this.firstSelection = -1; break; case x.FRAG_LOAD_TIMEOUT: { let e = t.frag, { fragCurrent: i, partCurrent: r } = this; if (e && i && e.sn === i.sn && e.level === i.level) { let t = performance.now(), i = r ? r.stats : e.stats, n = t - i.loading.start, s = i.loading.first ? i.loading.first - i.loading.start : -1; if (i.loaded && s > -1) { let e = this.bwEstimator.getEstimateTTFB(); this.bwEstimator.sample(n - Math.min(e, s), i.loaded) } else this.bwEstimator.sampleTTFB(n) } } } } getTimeToLoadFrag(e, t, i, r) { return e + i / t + (r ? this.lastLevelLoadSec : 0) } onLevelLoaded(e, t) { let i = this.hls.config, { loading: r } = t.stats, n = r.end - r.start; p(n) && (this.lastLevelLoadSec = n / 1e3), t.details.live ? this.bwEstimator.update(i.abrEwmaSlowLive, i.abrEwmaFastLive) : this.bwEstimator.update(i.abrEwmaSlowVoD, i.abrEwmaFastVoD) } onFragLoaded(e, { frag: t, part: i }) { let r = i ? i.stats : t.stats; if (t.type === e3.MAIN && this.bwEstimator.sampleTTFB(r.loading.first - r.loading.start), !this.ignoreFragment(t)) { if (this.clearTimer(), t.level === this._nextAutoLevel && (this._nextAutoLevel = -1), this.firstSelection = -1, this.hls.config.abrMaxWithRealBitrate) { let e = i ? i.duration : t.duration, n = this.hls.levels[t.level], s = (n.loaded ? n.loaded.bytes : 0) + r.loaded, a = (n.loaded ? n.loaded.duration : 0) + e; n.loaded = { bytes: s, duration: a }, n.realBitrate = Math.round(8 * s / a) } if (t.bitrateTest) { let e = { stats: r, frag: t, part: i, id: t.type }; this.onFragBuffered(v.FRAG_BUFFERED, e), t.bitrateTest = !1 } else this.lastLoadedFragLevel = t.level } } onFragBuffered(e, t) { let { frag: i, part: r } = t, n = null != r && r.stats.loaded ? r.stats : i.stats; if (n.aborted || this.ignoreFragment(i)) return; let s = n.parsing.end - n.loading.start - Math.min(n.loading.first - n.loading.start, this.bwEstimator.getEstimateTTFB()); this.bwEstimator.sample(s, n.loaded), n.bwEstimate = this.getBwEstimate(), i.bitrateTest ? this.bitrateTestDelay = s / 1e3 : this.bitrateTestDelay = 0 } ignoreFragment(e) { return e.type !== e3.MAIN || "initSegment" === e.sn } clearTimer() { this.timer > -1 && (self.clearInterval(this.timer), this.timer = -1) } get firstAutoLevel() { let { maxAutoLevel: e, minAutoLevel: t } = this.hls, i = this.getBwEstimate(), r = this.hls.config.maxStarvationDelay, n = this.findBestLevel(i, t, e, 0, r, 1, 1); if (n > -1) return n; let s = this.hls.firstLevel, a = Math.min(Math.max(s, t), e); return E.warn(`[abr] Could not find best starting auto level. Defaulting to first in playlist ${s} clamped to ${a}`), a } get forcedAutoLevel() { return this.nextAutoLevelKey ? -1 : this._nextAutoLevel } get nextAutoLevel() { let e = this.forcedAutoLevel, t = this.bwEstimator.canEstimate(), i = this.lastLoadedFragLevel > -1; if (-1 !== e && (!t || !i || this.nextAutoLevelKey === this.getAutoLevelKey())) return e; let r = t && i ? this.getNextABRAutoLevel() : this.firstAutoLevel; if (-1 !== e) { let t = this.hls.levels; if (t.length > Math.max(e, r) && t[e].loadError <= t[r].loadError) return e } return this._nextAutoLevel = r, this.nextAutoLevelKey = this.getAutoLevelKey(), r } getAutoLevelKey() { return `${this.getBwEstimate()}_${this.getStarvationDelay().toFixed(2)}` } getNextABRAutoLevel() { let { fragCurrent: e, partCurrent: t, hls: i } = this, { maxAutoLevel: r, config: n, minAutoLevel: s } = i, a = t ? t.duration : e ? e.duration : 0, o = this.getBwEstimate(), l = this.getStarvationDelay(), u = n.abrBandWidthFactor, h = n.abrBandWidthUpFactor; if (l) { let e = this.findBestLevel(o, s, r, l, 0, u, h); if (e >= 0) return e } let c = a ? Math.min(a, n.maxStarvationDelay) : n.maxStarvationDelay; if (!l) { let e = this.bitrateTestDelay; e && (c = (a ? Math.min(a, n.maxLoadingDelay) : n.maxLoadingDelay) - e, E.info(`[abr] bitrate test took ${Math.round(1e3 * e)}ms, set first fragment max fetchDuration to ${Math.round(1e3 * c)} ms`), u = h = 1) } let d = this.findBestLevel(o, s, r, l, c, u, h); if (E.info(`[abr] ${l ? "rebuffering expected" : "buffer is empty"}, optimal quality level ${d}`), d > -1) return d; let f = i.levels[s], p = i.levels[i.loadLevel]; return (null == f ? void 0 : f.bitrate) < (null == p ? void 0 : p.bitrate) ? s : i.loadLevel } getStarvationDelay() { let e = this.hls, t = e.media; if (!t) return 1 / 0; let i = t && 0 !== t.playbackRate ? Math.abs(t.playbackRate) : 1, r = e.mainForwardBufferInfo; return (r ? r.len : 0) / i } getBwEstimate() { return this.bwEstimator.canEstimate() ? this.bwEstimator.getEstimate() : this.hls.config.abrEwmaDefaultEstimate } findBestLevel(e, t, i, r, n, s, a) { var o, l; let u; let h = r + n, c = this.lastLoadedFragLevel, f = -1 === c ? this.hls.firstLevel : c, { fragCurrent: m, partCurrent: g } = this, { levels: v, allAudioTracks: y, loadLevel: x, config: S } = this.hls; if (1 === v.length) return 0; let A = v[f], _ = !!(null != A && null != (o = A.details) && o.live), b = -1 === x || -1 === c, T = "SDR", w = (null == A ? void 0 : A.frameRate) || 0, { audioPreference: M, videoPreference: R } = S, C = this.audioTracksByGroup || (this.audioTracksByGroup = y.reduce((e, t) => { let i = e.groups[t.groupId]; i || (i = e.groups[t.groupId] = { tracks: [], channels: { 2: 0 }, hasDefault: !1, hasAutoSelect: !1 }), i.tracks.push(t); let r = t.channels || "2"; return i.channels[r] = (i.channels[r] || 0) + 1, i.hasDefault = i.hasDefault || t.default, i.hasAutoSelect = i.hasAutoSelect || t.autoselect, i.hasDefault && (e.hasDefaultAudio = !0), i.hasAutoSelect && (e.hasAutoSelectAudio = !0), e }, { hasDefaultAudio: !1, hasAutoSelectAudio: !1, groups: {} })); if (b) { if (-1 !== this.firstSelection) return this.firstSelection; let r = function (e, t, i, r, n) { var s; let a, o; let l = Object.keys(e), u = null == r ? void 0 : r.channels, h = null == r ? void 0 : r.audioCodec, c = u && 2 === parseInt(u), d = !0, f = !1, m = 1 / 0, g = 1 / 0, v = 1 / 0, y = 0, x = [], { preferHDR: S, allowedVideoRanges: A } = (a = !1, o = [], (s = t) && (a = "SDR" !== s, o = [s]), n && (o = n.allowedVideoRanges || th.slice(0), o = (a = void 0 !== n.preferHDR ? n.preferHDR : function () { if ("function" == typeof matchMedia) { let e = matchMedia("(dynamic-range: high)"), t = matchMedia("bad query"); if (e.media !== t.media) return !0 === e.matches } return !1 }()) ? o.filter(e => "SDR" !== e) : ["SDR"]), { preferHDR: a, allowedVideoRanges: o }); for (let t = l.length; t--;) { let i = e[l[t]]; d = i.channels[2] > 0, m = Math.min(m, i.minHeight), g = Math.min(g, i.minFramerate), v = Math.min(v, i.minBitrate); let r = A.filter(e => i.videoRanges[e] > 0); r.length > 0 && (f = !0, x = r) } m = p(m) ? m : 0, g = p(g) ? g : 0; let _ = Math.max(1080, m), E = Math.max(30, g); return i = Math.max(v = p(v) ? v : i, i), f || (t = void 0, x = []), { codecSet: l.reduce((t, r) => { let n = e[r]; if (r === t) return t; if (n.minBitrate > i) return tB(r, `min bitrate of ${n.minBitrate} > current estimate of ${i}`), t; if (!n.hasDefaultAudio) return tB(r, "no renditions with default or auto-select sound found"), t; if (h && r.indexOf(h.substring(0, 4)) % 5 != 0) return tB(r, `audio codec preference "${h}" not found`), t; if (u && !c) { if (!n.channels[u]) return tB(r, `no renditions with ${u} channel sound found (channels options: ${Object.keys(n.channels)})`), t } else if ((!h || c) && d && 0 === n.channels["2"]) return tB(r, "no renditions with stereo sound found"), t; return n.minHeight > _ ? (tB(r, `min resolution of ${n.minHeight} > maximum of ${_}`), t) : n.minFramerate > E ? (tB(r, `min framerate of ${n.minFramerate} > maximum of ${E}`), t) : x.some(e => n.videoRanges[e] > 0) ? n.maxScore < y ? (tB(r, `max score of ${n.maxScore} < selected max of ${y}`), t) : t && (eB(r) >= eB(t) || n.fragmentError > e[t].fragmentError) ? t : (y = n.maxScore, r) : (tB(r, `no variants with VIDEO-RANGE of ${JSON.stringify(x)} found`), t) }, void 0), videoRanges: x, preferHDR: S, minFramerate: g, minBitrate: v } }(this.codecTiers || (this.codecTiers = v.slice(t, i + 1).reduce((e, t) => { if (!t.codecSet) return e; let i = t.audioGroups, r = e[t.codecSet]; r || (e[t.codecSet] = r = { minBitrate: 1 / 0, minHeight: 1 / 0, minFramerate: 1 / 0, maxScore: 0, videoRanges: { SDR: 0 }, channels: { 2: 0 }, hasDefaultAudio: !i, fragmentError: 0 }), r.minBitrate = Math.min(r.minBitrate, t.bitrate); let n = Math.min(t.height, t.width); return r.minHeight = Math.min(r.minHeight, n), r.minFramerate = Math.min(r.minFramerate, t.frameRate), r.maxScore = Math.max(r.maxScore, t.score), r.fragmentError += t.fragmentError, r.videoRanges[t.videoRange] = (r.videoRanges[t.videoRange] || 0) + 1, i && i.forEach(e => { if (!e) return; let t = C.groups[e]; t && (r.hasDefaultAudio = r.hasDefaultAudio || C.hasDefaultAudio ? t.hasDefault : t.hasAutoSelect || !C.hasDefaultAudio && !C.hasAutoSelectAudio, Object.keys(t.channels).forEach(e => { r.channels[e] = (r.channels[e] || 0) + t.channels[e] })) }), e }, {})), T, e, M, R), { codecSet: n, videoRanges: s, minFramerate: a, minBitrate: o, preferHDR: l } = r; u = n, T = l ? s[s.length - 1] : s[0], w = a, e = Math.max(e, o), E.log(`[abr] picked start tier ${JSON.stringify(r)}`) } else u = null == A ? void 0 : A.codecSet, T = null == A ? void 0 : A.videoRange; let I = g ? g.duration : m ? m.duration : 0, L = this.bwEstimator.getEstimateTTFB() / 1e3, P = []; for (let o = i; o >= t; o--) { let t; let m = v[o], y = o > f; if (!m) continue; if (S.useMediaCapabilities && !m.supportedResult && !m.supportedPromise) { let t = navigator.mediaCapabilities; "function" == typeof (null == t ? void 0 : t.decodingInfo) && function (e, t, i, r, n, s) { let a = e.audioCodec ? e.audioGroups : null, o = null == s ? void 0 : s.audioCodec, l = null == s ? void 0 : s.channels, u = l ? parseInt(l) : o ? 1 / 0 : 2, h = null; if (null != a && a.length) try { h = 1 === a.length && a[0] ? t.groups[a[0]].channels : a.reduce((e, i) => { if (i) { let r = t.groups[i]; if (!r) throw Error(`Audio track group ${i} not found`); Object.keys(r.channels).forEach(t => { e[t] = (e[t] || 0) + r.channels[t] }) } return e }, { 2: 0 }) } catch (e) { return !0 } return void 0 !== e.videoCodec && (e.width > 1920 && e.height > 1088 || e.height > 1920 && e.width > 1088 || e.frameRate > Math.max(r, 30) || "SDR" !== e.videoRange && e.videoRange !== i || e.bitrate > Math.max(n, 8e6)) || !!h && p(u) && Object.keys(h).some(e => parseInt(e) > u) }(m, C, T, w, e, M) ? (m.supportedPromise = function (e, t, i) { let r = e.videoCodec, n = e.audioCodec; if (!r || !n || !i) return Promise.resolve(tU); let s = { width: e.width, height: e.height, bitrate: Math.ceil(Math.max(.9 * e.bitrate, e.averageBitrate)), framerate: e.frameRate || 30 }, a = e.videoRange; "SDR" !== a && (s.transferFunction = a.toLowerCase()); let o = r.split(",").map(e => ({ type: "media-source", video: d(d({}, s), {}, { contentType: eU(e, "video") }) })); return n && e.audioGroups && e.audioGroups.forEach(e => { var i; e && (null == (i = t.groups[e]) || i.tracks.forEach(t => { if (t.groupId === e) { let e = parseFloat(t.channels || ""); p(e) && e > 2 && o.push.apply(o, n.split(",").map(t => ({ type: "media-source", audio: { contentType: eU(t, "audio"), channels: "" + e } }))) } })) }), Promise.all(o.map(e => { let t = function (e) { let { audio: t, video: i } = e, r = i || t; if (r) { let e = r.contentType.split('"')[1]; if (i) return `r${i.height}x${i.width}f${Math.ceil(i.framerate)}${i.transferFunction || "sd"}_${e}_${Math.ceil(i.bitrate / 1e5)}`; if (t) return `c${t.channels}${t.spatialRendering ? "s" : "n"}_${e}` } return "" }(e); return tN[t] || (tN[t] = i.decodingInfo(e)) })).then(e => ({ supported: !e.some(e => !e.supported), configurations: o, decodingInfoResults: e })).catch(e => ({ supported: !1, configurations: o, decodingInfoResults: [], error: e })) }(m, C, t), m.supportedPromise.then(e => { if (!this.hls) return; m.supportedResult = e; let t = this.hls.levels, i = t.indexOf(m); e.error ? E.warn(`[abr] MediaCapabilities decodingInfo error: "${e.error}" for level ${i} ${JSON.stringify(e)}`) : !e.supported && (E.warn(`[abr] Unsupported MediaCapabilities decodingInfo result for level ${i} ${JSON.stringify(e)}`), i > -1 && t.length > 1 && (E.log(`[abr] Removing unsupported level ${i}`), this.hls.removeLevel(i))) })) : m.supportedResult = tU } if (u && m.codecSet !== u || T && m.videoRange !== T || y && w > m.frameRate || !y && w > 0 && w < m.frameRate || m.supportedResult && !(null != (l = m.supportedResult.decodingInfoResults) && l[0].smooth)) { P.push(o); continue } let R = m.details, D = (g ? null == R ? void 0 : R.partTarget : null == R ? void 0 : R.averagetargetduration) || I; t = y ? a * e : s * e; let O = I && r >= 2 * I && 0 === n ? v[o].averageBitrate : v[o].maxBitrate, k = this.getTimeToLoadFrag(L, t, O * D, void 0 === R); if (t >= O && (o === c || 0 === m.loadError && 0 === m.fragmentError) && (k <= L || !p(k) || _ && !this.bitrateTestDelay || k < h)) { let e = this.forcedAutoLevel; return o !== x && (-1 === e || e !== x) && (P.length && E.trace(`[abr] Skipped level(s) ${P.join(",")} of ${i} max with CODECS and VIDEO-RANGE:"${v[P[0]].codecs}" ${v[P[0]].videoRange}; not compatible with "${A.codecs}" ${T}`), E.info(`[abr] switch candidate:${f}->${o} adjustedbw(${Math.round(t)})-bitrate=${Math.round(t - O)} ttfb:${L.toFixed(1)} avgDuration:${D.toFixed(1)} maxFetchDuration:${h.toFixed(1)} fetchDuration:${k.toFixed(1)} firstSelection:${b} codecSet:${u} videoRange:${T} hls.loadLevel:${x}`)), b && (this.firstSelection = o), o } } return -1 } set nextAutoLevel(e) { let { maxAutoLevel: t, minAutoLevel: i } = this.hls, r = Math.min(Math.max(e, i), t); this._nextAutoLevel !== r && (this.nextAutoLevelKey = "", this._nextAutoLevel = r) }
    } class tj { constructor() { this._boundTick = void 0, this._tickTimer = null, this._tickInterval = null, this._tickCallCount = 0, this._boundTick = this.tick.bind(this) } destroy() { this.onHandlerDestroying(), this.onHandlerDestroyed() } onHandlerDestroying() { this.clearNextTick(), this.clearInterval() } onHandlerDestroyed() { } hasInterval() { return !!this._tickInterval } hasNextTick() { return !!this._tickTimer } setInterval(e) { return !this._tickInterval && (this._tickCallCount = 0, this._tickInterval = self.setInterval(this._boundTick, e), !0) } clearInterval() { return !!this._tickInterval && (self.clearInterval(this._tickInterval), this._tickInterval = null, !0) } clearNextTick() { return !!this._tickTimer && (self.clearTimeout(this._tickTimer), this._tickTimer = null, !0) } tick() { this._tickCallCount++, 1 === this._tickCallCount && (this.doTick(), this._tickCallCount > 1 && this.tickImmediate(), this._tickCallCount = 0) } tickImmediate() { this.clearNextTick(), this._tickTimer = self.setTimeout(this._boundTick, 0) } doTick() { } } var tY = { NOT_LOADED: "NOT_LOADED", APPENDING: "APPENDING", PARTIAL: "PARTIAL", OK: "OK" }; class tX { constructor(e) { this.activePartLists = Object.create(null), this.endListFragments = Object.create(null), this.fragments = Object.create(null), this.timeRanges = Object.create(null), this.bufferPadding = .2, this.hls = void 0, this.hasGaps = !1, this.hls = e, this._registerListeners() } _registerListeners() { let { hls: e } = this; e.on(v.BUFFER_APPENDED, this.onBufferAppended, this), e.on(v.FRAG_BUFFERED, this.onFragBuffered, this), e.on(v.FRAG_LOADED, this.onFragLoaded, this) } _unregisterListeners() { let { hls: e } = this; e.off(v.BUFFER_APPENDED, this.onBufferAppended, this), e.off(v.FRAG_BUFFERED, this.onFragBuffered, this), e.off(v.FRAG_LOADED, this.onFragLoaded, this) } destroy() { this._unregisterListeners(), this.fragments = this.activePartLists = this.endListFragments = this.timeRanges = null } getAppendedFrag(e, t) { let i = this.activePartLists[t]; if (i) for (let t = i.length; t--;) { let r = i[t]; if (!r) break; let n = r.end; if (r.start <= e && null !== n && e <= n) return r } return this.getBufferedFrag(e, t) } getBufferedFrag(e, t) { let { fragments: i } = this, r = Object.keys(i); for (let n = r.length; n--;) { let s = i[r[n]]; if ((null == s ? void 0 : s.body.type) === t && s.buffered) { let t = s.body; if (t.start <= e && e <= t.end) return t } } return null } detectEvictedFragments(e, t, i, r) { this.timeRanges && (this.timeRanges[e] = t); let n = (null == r ? void 0 : r.fragment.sn) || -1; Object.keys(this.fragments).forEach(r => { let s = this.fragments[r]; if (!s || n >= s.body.sn) return; if (!s.buffered && !s.loaded) { s.body.type === i && this.removeFragment(s.body); return } let a = s.range[e]; a && a.time.some(e => { let i = !this.isTimeBuffered(e.startPTS, e.endPTS, t); return i && this.removeFragment(s.body), i }) }) } detectPartialFragments(e) { let t = this.timeRanges, { frag: i, part: r } = e; if (!t || "initSegment" === i.sn) return; let n = tq(i), s = this.fragments[n]; if (!s || s.buffered && i.gap) return; let a = !i.relurl; Object.keys(t).forEach(e => { let n = i.elementaryStreams[e]; if (!n) return; let o = t[e], l = a || !0 === n.partial; s.range[e] = this.getBufferedTimes(i, r, l, o) }), s.loaded = null, Object.keys(s.range).length ? (s.buffered = !0, (s.body.endList = i.endList || s.body.endList) && (this.endListFragments[s.body.type] = s), tK(s) || this.removeParts(i.sn - 1, i.type)) : this.removeFragment(s.body) } removeParts(e, t) { let i = this.activePartLists[t]; i && (this.activePartLists[t] = i.filter(t => t.fragment.sn >= e)) } fragBuffered(e, t) { let i = tq(e), r = this.fragments[i]; !r && t && (r = this.fragments[i] = { body: e, appendedPTS: null, loaded: null, buffered: !1, range: Object.create(null) }, e.gap && (this.hasGaps = !0)), r && (r.loaded = null, r.buffered = !0) } getBufferedTimes(e, t, i, r) { let n = { time: [], partial: i }, s = e.start, a = e.end, o = e.minEndPTS || a, l = e.maxStartPTS || s; for (let e = 0; e < r.length; e++) { let t = r.start(e) - this.bufferPadding, i = r.end(e) + this.bufferPadding; if (l >= t && o <= i) { n.time.push({ startPTS: Math.max(s, r.start(e)), endPTS: Math.min(a, r.end(e)) }); break } if (s < i && a > t) { let t = Math.max(s, r.start(e)), i = Math.min(a, r.end(e)); i > t && (n.partial = !0, n.time.push({ startPTS: t, endPTS: i })) } else if (a <= t) break } return n } getPartialFragment(e) { let t, i, r, n = null, s = 0, { bufferPadding: a, fragments: o } = this; return Object.keys(o).forEach(l => { let u = o[l]; u && tK(u) && (i = u.body.start - a, r = u.body.end + a, e >= i && e <= r && s <= (t = Math.min(e - i, r - e)) && (n = u.body, s = t)) }), n } isEndListAppended(e) { let t = this.endListFragments[e]; return void 0 !== t && (t.buffered || tK(t)) } getState(e) { let t = tq(e), i = this.fragments[t]; return i ? i.buffered ? tK(i) ? tY.PARTIAL : tY.OK : tY.APPENDING : tY.NOT_LOADED } isTimeBuffered(e, t, i) { let r, n; for (let s = 0; s < i.length; s++) { if (r = i.start(s) - this.bufferPadding, n = i.end(s) + this.bufferPadding, e >= r && t <= n) return !0; if (t <= r) break } return !1 } onFragLoaded(e, t) { let { frag: i, part: r } = t; if ("initSegment" === i.sn || i.bitrateTest) return; let n = tq(i); this.fragments[n] = { body: i, appendedPTS: null, loaded: r ? null : t, buffered: !1, range: Object.create(null) } } onBufferAppended(e, t) { let { frag: i, part: r, timeRanges: n } = t; if ("initSegment" === i.sn) return; let s = i.type; if (r) { let e = this.activePartLists[s]; e || (this.activePartLists[s] = e = []), e.push(r) } this.timeRanges = n, Object.keys(n).forEach(e => { let t = n[e]; this.detectEvictedFragments(e, t, s, r) }) } onFragBuffered(e, t) { this.detectPartialFragments(t) } hasFragment(e) { let t = tq(e); return !!this.fragments[t] } hasParts(e) { var t; return !!(null != (t = this.activePartLists[e]) && t.length) } removeFragmentsInRange(e, t, i, r, n) { (!r || this.hasGaps) && Object.keys(this.fragments).forEach(s => { let a = this.fragments[s]; if (!a) return; let o = a.body; o.type === i && (!r || o.gap) && o.start < t && o.end > e && (a.buffered || n) && this.removeFragment(o) }) } removeFragment(e) { let t = tq(e); e.stats.loaded = 0, e.clearElementaryStreamInfo(); let i = this.activePartLists[e.type]; if (i) { let t = e.sn; this.activePartLists[e.type] = i.filter(e => e.fragment.sn !== t) } delete this.fragments[t], e.endList && delete this.endListFragments[e.type] } removeAllFragments() { this.fragments = Object.create(null), this.endListFragments = Object.create(null), this.activePartLists = Object.create(null), this.hasGaps = !1 } } function tK(e) { var t, i, r; return e.buffered && (e.body.gap || (null == (t = e.range.video) ? void 0 : t.partial) || (null == (i = e.range.audio) ? void 0 : i.partial) || (null == (r = e.range.audiovideo) ? void 0 : r.partial)) } function tq(e) { return `${e.type}_${e.level}_${e.sn}` } let tQ = { length: 0, start: () => 0, end: () => 0 }; class tZ { static isBuffered(e, t) { try { if (e) { let i = tZ.getBuffered(e); for (let e = 0; e < i.length; e++)if (t >= i.start(e) && t <= i.end(e)) return !0 } } catch (e) { } return !1 } static bufferInfo(e, t, i) { try { if (e) { let r; let n = tZ.getBuffered(e), s = []; for (r = 0; r < n.length; r++)s.push({ start: n.start(r), end: n.end(r) }); return this.bufferedInfo(s, t, i) } } catch (e) { } return { len: 0, start: t, end: t, nextStart: void 0 } } static bufferedInfo(e, t, i) { let r; t = Math.max(0, t), e.sort(function (e, t) { return e.start - t.start || t.end - e.end }); let n = []; if (i) for (let t = 0; t < e.length; t++) { let r = n.length; if (r) { let s = n[r - 1].end; e[t].start - s < i ? e[t].end > s && (n[r - 1].end = e[t].end) : n.push(e[t]) } else n.push(e[t]) } else n = e; let s = 0, a = t, o = t; for (let e = 0; e < n.length; e++) { let l = n[e].start, u = n[e].end; if (t + i >= l && t < u) a = l, s = (o = u) - t; else if (t + i < l) { r = l; break } } return { len: s, start: a || 0, end: o || 0, nextStart: r } } static getBuffered(e) { try { return e.buffered } catch (e) { return E.log("failed to get media.buffered", e), tQ } } } class t$ { constructor(e, t, i, r = 0, n = -1, s = !1) { this.level = void 0, this.sn = void 0, this.part = void 0, this.id = void 0, this.size = void 0, this.partial = void 0, this.transmuxing = tJ(), this.buffering = { audio: tJ(), video: tJ(), audiovideo: tJ() }, this.level = e, this.sn = t, this.id = i, this.size = r, this.part = n, this.partial = s } } function tJ() { return { start: 0, executeStart: 0, executeEnd: 0, end: 0 } } function t0(e, t) { for (let r = 0, n = e.length; r < n; r++) { var i; if ((null == (i = e[r]) ? void 0 : i.cc) === t) return e[r] } return null } function t1(e, t) { if (e) { let i = e.start + t; e.start = e.startPTS = i, e.endPTS = i + e.duration } } function t2(e, t) { let i = t.fragments; for (let t = 0, r = i.length; t < r; t++)t1(i[t], e); t.fragmentHint && t1(t.fragmentHint, e), t.alignedSliding = !0 } function t3(e, t) { let i, r; if (!e.hasProgramDateTime || !t.hasProgramDateTime) return; let n = e.fragments, s = t.fragments; if (!n.length || !s.length) return; let a = Math.min(t.endCC, e.endCC); t.startCC < a && e.startCC < a && (i = t0(s, a), r = t0(n, a)), i && r || (r = t0(n, (i = s[Math.floor(s.length / 2)]).cc) || n[Math.floor(n.length / 2)]); let o = i.programDateTime, l = r.programDateTime; o && l && t2((l - o) / 1e3 - (r.start - i.start), e) } class t4 { constructor(e) { this.config = void 0, this.loader = null, this.partLoadTimeout = -1, this.config = e } destroy() { this.loader && (this.loader.destroy(), this.loader = null) } abort() { this.loader && this.loader.abort() } load(e, t) { let i = e.url; if (!i) return Promise.reject(new t6({ type: y.NETWORK_ERROR, details: x.FRAG_LOAD_ERROR, fatal: !1, frag: e, error: Error(`Fragment does not have a ${i ? "part list" : "url"}`), networkDetails: null })); this.abort(); let r = this.config, n = r.fLoader, s = r.loader; return new Promise((a, o) => { if (this.loader && this.loader.destroy(), e.gap) { if (e.tagList.some(e => "GAP" === e[0])) { o(t8(e)); return } e.gap = !1 } let l = this.loader = e.loader = n ? new n(r) : new s(r), u = t5(e), h = tw(r.fragLoadPolicy.default), c = { loadPolicy: h, timeout: h.maxLoadTimeMs, maxRetry: 0, retryDelay: 0, maxRetryDelay: 0, highWaterMark: "initSegment" === e.sn ? 1 / 0 : 131072 }; e.stats = l.stats, l.load(u, c, { onSuccess: (t, i, r, n) => { this.resetLoader(e, l); let s = t.data; r.resetIV && e.decryptdata && (e.decryptdata.iv = new Uint8Array(s.slice(0, 16)), s = s.slice(16)), a({ frag: e, part: null, payload: s, networkDetails: n }) }, onError: (t, r, n, s) => { this.resetLoader(e, l), o(new t6({ type: y.NETWORK_ERROR, details: x.FRAG_LOAD_ERROR, fatal: !1, frag: e, response: d({ url: i, data: void 0 }, t), error: Error(`HTTP Error ${t.code} ${t.text}`), networkDetails: n, stats: s })) }, onAbort: (t, i, r) => { this.resetLoader(e, l), o(new t6({ type: y.NETWORK_ERROR, details: x.INTERNAL_ABORTED, fatal: !1, frag: e, error: Error("Aborted"), networkDetails: r, stats: t })) }, onTimeout: (t, i, r) => { this.resetLoader(e, l), o(new t6({ type: y.NETWORK_ERROR, details: x.FRAG_LOAD_TIMEOUT, fatal: !1, frag: e, error: Error(`Timeout after ${c.timeout}ms`), networkDetails: r, stats: t })) }, onProgress: (i, r, n, s) => { t && t({ frag: e, part: null, payload: n, networkDetails: s }) } }) }) } loadPart(e, t, i) { this.abort(); let r = this.config, n = r.fLoader, s = r.loader; return new Promise((a, o) => { if (this.loader && this.loader.destroy(), e.gap || t.gap) { o(t8(e, t)); return } let l = this.loader = e.loader = n ? new n(r) : new s(r), u = t5(e, t), h = tw(r.fragLoadPolicy.default), c = { loadPolicy: h, timeout: h.maxLoadTimeMs, maxRetry: 0, retryDelay: 0, maxRetryDelay: 0, highWaterMark: 131072 }; t.stats = l.stats, l.load(u, c, { onSuccess: (r, n, s, o) => { this.resetLoader(e, l), this.updateStatsFromPart(e, t); let u = { frag: e, part: t, payload: r.data, networkDetails: o }; i(u), a(u) }, onError: (i, r, n, s) => { this.resetLoader(e, l), o(new t6({ type: y.NETWORK_ERROR, details: x.FRAG_LOAD_ERROR, fatal: !1, frag: e, part: t, response: d({ url: u.url, data: void 0 }, i), error: Error(`HTTP Error ${i.code} ${i.text}`), networkDetails: n, stats: s })) }, onAbort: (i, r, n) => { e.stats.aborted = t.stats.aborted, this.resetLoader(e, l), o(new t6({ type: y.NETWORK_ERROR, details: x.INTERNAL_ABORTED, fatal: !1, frag: e, part: t, error: Error("Aborted"), networkDetails: n, stats: i })) }, onTimeout: (i, r, n) => { this.resetLoader(e, l), o(new t6({ type: y.NETWORK_ERROR, details: x.FRAG_LOAD_TIMEOUT, fatal: !1, frag: e, part: t, error: Error(`Timeout after ${c.timeout}ms`), networkDetails: n, stats: i })) } }) }) } updateStatsFromPart(e, t) { let i = e.stats, r = t.stats, n = r.total; if (i.loaded += r.loaded, n) { let r = Math.round(e.duration / t.duration), s = Math.min(Math.round(i.loaded / n), r), a = (r - s) * Math.round(i.loaded / s); i.total = i.loaded + a } else i.total = Math.max(i.loaded, i.total); let s = i.loading, a = r.loading; s.start ? s.first += a.first - a.start : (s.start = a.start, s.first = a.first), s.end = a.end } resetLoader(e, t) { e.loader = null, this.loader === t && (self.clearTimeout(this.partLoadTimeout), this.loader = null), t.destroy() } } function t5(e, t = null) { let i = t || e, r = { frag: e, part: t, responseType: "arraybuffer", url: i.url, headers: {}, rangeStart: 0, rangeEnd: 0 }, n = i.byteRangeStartOffset, s = i.byteRangeEndOffset; if (p(n) && p(s)) { var a; let t = n, i = s; if ("initSegment" === e.sn && (null == (a = e.decryptdata) ? void 0 : a.method) === "AES-128") { let e = s - n; e % 16 && (i = s + (16 - e % 16)), 0 !== n && (r.resetIV = !0, t = n - 16) } r.rangeStart = t, r.rangeEnd = i } return r } function t8(e, t) { let i = Error(`GAP ${e.gap ? "tag" : "attribute"} found`), r = { type: y.MEDIA_ERROR, details: x.FRAG_GAP, fatal: !1, frag: e, error: i, networkDetails: null }; return t && (r.part = t), (t || e).stats.aborted = !0, new t6(r) } class t6 extends Error { constructor(e) { super(e.error.message), this.data = void 0, this.data = e } } class t9 { constructor(e, t) { this.subtle = void 0, this.aesIV = void 0, this.subtle = e, this.aesIV = t } decrypt(e, t) { return this.subtle.decrypt({ name: "AES-CBC", iv: this.aesIV }, t, e) } } class t7 { constructor(e, t) { this.subtle = void 0, this.key = void 0, this.subtle = e, this.key = t } expandKey() { return this.subtle.importKey("raw", this.key, { name: "AES-CBC" }, !1, ["encrypt", "decrypt"]) } } class ie { constructor() { this.rcon = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54], this.subMix = [new Uint32Array(256), new Uint32Array(256), new Uint32Array(256), new Uint32Array(256)], this.invSubMix = [new Uint32Array(256), new Uint32Array(256), new Uint32Array(256), new Uint32Array(256)], this.sBox = new Uint32Array(256), this.invSBox = new Uint32Array(256), this.key = new Uint32Array(0), this.ksRows = 0, this.keySize = 0, this.keySchedule = void 0, this.invKeySchedule = void 0, this.initTable() } uint8ArrayToUint32Array_(e) { let t = new DataView(e), i = new Uint32Array(4); for (let e = 0; e < 4; e++)i[e] = t.getUint32(4 * e); return i } initTable() { let e = this.sBox, t = this.invSBox, i = this.subMix, r = i[0], n = i[1], s = i[2], a = i[3], o = this.invSubMix, l = o[0], u = o[1], h = o[2], c = o[3], d = new Uint32Array(256), f = 0, p = 0, m = 0; for (m = 0; m < 256; m++)m < 128 ? d[m] = m << 1 : d[m] = m << 1 ^ 283; for (m = 0; m < 256; m++) { let i = p ^ p << 1 ^ p << 2 ^ p << 3 ^ p << 4; i = i >>> 8 ^ 255 & i ^ 99, e[f] = i, t[i] = f; let o = d[f], m = d[o], g = d[m], v = 257 * d[i] ^ 0x1010100 * i; r[f] = v << 24 | v >>> 8, n[f] = v << 16 | v >>> 16, s[f] = v << 8 | v >>> 24, a[f] = v, v = 0x1010101 * g ^ 65537 * m ^ 257 * o ^ 0x1010100 * f, l[i] = v << 24 | v >>> 8, u[i] = v << 16 | v >>> 16, h[i] = v << 8 | v >>> 24, c[i] = v, f ? (f = o ^ d[d[d[g ^ o]]], p ^= d[d[p]]) : f = p = 1 } } expandKey(e) { let t, i, r, n; let s = this.uint8ArrayToUint32Array_(e), a = !0, o = 0; for (; o < s.length && a;)a = s[o] === this.key[o], o++; if (a) return; this.key = s; let l = this.keySize = s.length; if (4 !== l && 6 !== l && 8 !== l) throw Error("Invalid aes key size=" + l); let u = this.ksRows = (l + 6 + 1) * 4, h = this.keySchedule = new Uint32Array(u), c = this.invKeySchedule = new Uint32Array(u), d = this.sBox, f = this.rcon, p = this.invSubMix, m = p[0], g = p[1], v = p[2], y = p[3]; for (t = 0; t < u; t++) { if (t < l) { r = h[t] = s[t]; continue } n = r, t % l == 0 ? n = (d[(n = n << 8 | n >>> 24) >>> 24] << 24 | d[n >>> 16 & 255] << 16 | d[n >>> 8 & 255] << 8 | d[255 & n]) ^ f[t / l | 0] << 24 : l > 6 && t % l == 4 && (n = d[n >>> 24] << 24 | d[n >>> 16 & 255] << 16 | d[n >>> 8 & 255] << 8 | d[255 & n]), h[t] = r = (h[t - l] ^ n) >>> 0 } for (i = 0; i < u; i++)t = u - i, n = 3 & i ? h[t] : h[t - 4], i < 4 || t <= 4 ? c[i] = n : c[i] = m[d[n >>> 24]] ^ g[d[n >>> 16 & 255]] ^ v[d[n >>> 8 & 255]] ^ y[d[255 & n]], c[i] = c[i] >>> 0 } networkToHostOrderSwap(e) { return e << 24 | (65280 & e) << 8 | (0xff0000 & e) >> 8 | e >>> 24 } decrypt(e, t, i) { let r, n, s, a, o, l, u, h, c, d, f, p, m, g; let v = this.keySize + 6, y = this.invKeySchedule, x = this.invSBox, S = this.invSubMix, A = S[0], _ = S[1], E = S[2], b = S[3], T = this.uint8ArrayToUint32Array_(i), w = T[0], M = T[1], R = T[2], C = T[3], I = new Int32Array(e), L = new Int32Array(I.length), P = this.networkToHostOrderSwap; for (; t < I.length;) { for (g = 1, c = P(I[t]), d = P(I[t + 1]), f = P(I[t + 2]), p = P(I[t + 3]), o = c ^ y[0], l = p ^ y[1], u = f ^ y[2], h = d ^ y[3], m = 4; g < v; g++)r = A[o >>> 24] ^ _[l >> 16 & 255] ^ E[u >> 8 & 255] ^ b[255 & h] ^ y[m], n = A[l >>> 24] ^ _[u >> 16 & 255] ^ E[h >> 8 & 255] ^ b[255 & o] ^ y[m + 1], s = A[u >>> 24] ^ _[h >> 16 & 255] ^ E[o >> 8 & 255] ^ b[255 & l] ^ y[m + 2], a = A[h >>> 24] ^ _[o >> 16 & 255] ^ E[l >> 8 & 255] ^ b[255 & u] ^ y[m + 3], o = r, l = n, u = s, h = a, m += 4; r = x[o >>> 24] << 24 ^ x[l >> 16 & 255] << 16 ^ x[u >> 8 & 255] << 8 ^ x[255 & h] ^ y[m], n = x[l >>> 24] << 24 ^ x[u >> 16 & 255] << 16 ^ x[h >> 8 & 255] << 8 ^ x[255 & o] ^ y[m + 1], s = x[u >>> 24] << 24 ^ x[h >> 16 & 255] << 16 ^ x[o >> 8 & 255] << 8 ^ x[255 & l] ^ y[m + 2], a = x[h >>> 24] << 24 ^ x[o >> 16 & 255] << 16 ^ x[l >> 8 & 255] << 8 ^ x[255 & u] ^ y[m + 3], L[t] = P(r ^ w), L[t + 1] = P(a ^ M), L[t + 2] = P(s ^ R), L[t + 3] = P(n ^ C), w = c, M = d, R = f, C = p, t += 4 } return L.buffer } } class it { constructor(e, { removePKCS7Padding: t = !0 } = {}) { if (this.logEnabled = !0, this.removePKCS7Padding = void 0, this.subtle = null, this.softwareDecrypter = null, this.key = null, this.fastAesKey = null, this.remainderData = null, this.currentIV = null, this.currentResult = null, this.useSoftware = void 0, this.useSoftware = e.enableSoftwareAES, this.removePKCS7Padding = t, t) try { let e = self.crypto; e && (this.subtle = e.subtle || e.webkitSubtle) } catch (e) { } this.useSoftware = !this.subtle } destroy() { this.subtle = null, this.softwareDecrypter = null, this.key = null, this.fastAesKey = null, this.remainderData = null, this.currentIV = null, this.currentResult = null } isSync() { return this.useSoftware } flush() { let { currentResult: e, remainderData: t } = this; if (!e || t) return this.reset(), null; let i = new Uint8Array(e); return (this.reset(), this.removePKCS7Padding) ? function (e) { let t = e.byteLength, i = t && new DataView(e.buffer).getUint8(t - 1); return i ? Y(e, 0, t - i) : e }(i) : i } reset() { this.currentResult = null, this.currentIV = null, this.remainderData = null, this.softwareDecrypter && (this.softwareDecrypter = null) } decrypt(e, t, i) { return this.useSoftware ? new Promise((r, n) => { this.softwareDecrypt(new Uint8Array(e), t, i); let s = this.flush(); s ? r(s.buffer) : n(Error("[softwareDecrypt] Failed to decrypt data")) }) : this.webCryptoDecrypt(new Uint8Array(e), t, i) } softwareDecrypt(e, t, i) { let { currentIV: r, currentResult: n, remainderData: s } = this; this.logOnce("JS AES decrypt"), s && (e = eE(s, e), this.remainderData = null); let a = this.getValidChunk(e); if (!a.length) return null; r && (i = r); let o = this.softwareDecrypter; return (o || (o = this.softwareDecrypter = new ie), o.expandKey(t), this.currentResult = o.decrypt(a.buffer, 0, i), this.currentIV = Y(a, -16).buffer, n) ? n : null } webCryptoDecrypt(e, t, i) { if (this.key !== t || !this.fastAesKey) { if (!this.subtle) return Promise.resolve(this.onWebCryptoError(e, t, i)); this.key = t, this.fastAesKey = new t7(this.subtle, t) } return this.fastAesKey.expandKey().then(t => this.subtle ? (this.logOnce("WebCrypto AES decrypt"), new t9(this.subtle, new Uint8Array(i)).decrypt(e.buffer, t)) : Promise.reject(Error("web crypto not initialized"))).catch(r => (E.warn(`[decrypter]: WebCrypto Error, disable WebCrypto API, ${r.name}: ${r.message}`), this.onWebCryptoError(e, t, i))) } onWebCryptoError(e, t, i) { this.useSoftware = !0, this.logEnabled = !0, this.softwareDecrypt(e, t, i); let r = this.flush(); if (r) return r.buffer; throw Error("WebCrypto and softwareDecrypt: failed to decrypt data") } getValidChunk(e) { let t = e, i = e.length - e.length % 16; return i !== e.length && (t = Y(e, 0, i), this.remainderData = Y(e, i)), t } logOnce(e) { this.logEnabled && (E.log(`[decrypter]: ${e}`), this.logEnabled = !1) } } let ii = { toString: function (e) { let t = "", i = e.length; for (let r = 0; r < i; r++)t += `[${e.start(r).toFixed(3)}-${e.end(r).toFixed(3)}]`; return t } }, ir = { STOPPED: "STOPPED", IDLE: "IDLE", KEY_LOADING: "KEY_LOADING", FRAG_LOADING: "FRAG_LOADING", FRAG_LOADING_WAITING_RETRY: "FRAG_LOADING_WAITING_RETRY", WAITING_TRACK: "WAITING_TRACK", PARSING: "PARSING", PARSED: "PARSED", ENDED: "ENDED", ERROR: "ERROR", WAITING_INIT_PTS: "WAITING_INIT_PTS", WAITING_LEVEL: "WAITING_LEVEL" }; class is extends tj { constructor(e, t, i, r, n) { super(), this.hls = void 0, this.fragPrevious = null, this.fragCurrent = null, this.fragmentTracker = void 0, this.transmuxer = null, this._state = ir.STOPPED, this.playlistType = void 0, this.media = null, this.mediaBuffer = null, this.config = void 0, this.bitrateTest = !1, this.lastCurrentTime = 0, this.nextLoadPosition = 0, this.startPosition = 0, this.startTimeOffset = null, this.loadedmetadata = !1, this.retryDate = 0, this.levels = null, this.fragmentLoader = void 0, this.keyLoader = void 0, this.levelLastLoaded = null, this.startFragRequested = !1, this.decrypter = void 0, this.initPTS = [], this.buffering = !0, this.onvseeking = null, this.onvended = null, this.logPrefix = "", this.log = void 0, this.warn = void 0, this.playlistType = n, this.logPrefix = r, this.log = E.log.bind(E, `${r}:`), this.warn = E.warn.bind(E, `${r}:`), this.hls = e, this.fragmentLoader = new t4(e.config), this.keyLoader = i, this.fragmentTracker = t, this.config = e.config, this.decrypter = new it(e.config), e.on(v.MANIFEST_LOADED, this.onManifestLoaded, this) } doTick() { this.onTickEnd() } onTickEnd() { } startLoad(e) { } stopLoad() { this.fragmentLoader.abort(), this.keyLoader.abort(this.playlistType); let e = this.fragCurrent; null != e && e.loader && (e.abortRequests(), this.fragmentTracker.removeFragment(e)), this.resetTransmuxer(), this.fragCurrent = null, this.fragPrevious = null, this.clearInterval(), this.clearNextTick(), this.state = ir.STOPPED } pauseBuffering() { this.buffering = !1 } resumeBuffering() { this.buffering = !0 } _streamEnded(e, t) { if (t.live || e.nextStart || !e.end || !this.media) return !1; let i = t.partList; if (null != i && i.length) { let e = i[i.length - 1]; return tZ.isBuffered(this.media, e.start + e.duration / 2) } let r = t.fragments[t.fragments.length - 1].type; return this.fragmentTracker.isEndListAppended(r) } getLevelDetails() { if (this.levels && null !== this.levelLastLoaded) { var e; return null == (e = this.levelLastLoaded) ? void 0 : e.details } } onMediaAttached(e, t) { let i = this.media = this.mediaBuffer = t.media; this.onvseeking = this.onMediaSeeking.bind(this), this.onvended = this.onMediaEnded.bind(this), i.addEventListener("seeking", this.onvseeking), i.addEventListener("ended", this.onvended); let r = this.config; this.levels && r.autoStartLoad && this.state === ir.STOPPED && this.startLoad(r.startPosition) } onMediaDetaching() { let e = this.media; null != e && e.ended && (this.log("MSE detaching and video ended, reset startPosition"), this.startPosition = this.lastCurrentTime = 0), e && this.onvseeking && this.onvended && (e.removeEventListener("seeking", this.onvseeking), e.removeEventListener("ended", this.onvended), this.onvseeking = this.onvended = null), this.keyLoader && this.keyLoader.detach(), this.media = this.mediaBuffer = null, this.loadedmetadata = !1, this.fragmentTracker.removeAllFragments(), this.stopLoad() } onMediaSeeking() { let { config: e, fragCurrent: t, media: i, mediaBuffer: r, state: n } = this, s = i ? i.currentTime : 0, a = tZ.bufferInfo(r || i, s, e.maxBufferHole); if (this.log(`media seeking to ${p(s) ? s.toFixed(3) : s}, state: ${n}`), this.state === ir.ENDED) this.resetLoadingState(); else if (t) { let i = e.maxFragLookUpTolerance, r = t.start - i, n = t.start + t.duration + i; if (!a.len || n < a.start || r > a.end) { let e = s > n; (s < r || e) && (e && t.loader && (this.log("seeking outside of buffer while fragment load in progress, cancel fragment load"), t.abortRequests(), this.resetLoadingState()), this.fragPrevious = null) } } i && (this.fragmentTracker.removeFragmentsInRange(s, 1 / 0, this.playlistType, !0), this.lastCurrentTime = s), this.loadedmetadata || a.len || (this.nextLoadPosition = this.startPosition = s), this.tickImmediate() } onMediaEnded() { this.startPosition = this.lastCurrentTime = 0 } onManifestLoaded(e, t) { this.startTimeOffset = t.startTimeOffset, this.initPTS = [] } onHandlerDestroying() { this.hls.off(v.MANIFEST_LOADED, this.onManifestLoaded, this), this.stopLoad(), super.onHandlerDestroying(), this.hls = null } onHandlerDestroyed() { this.state = ir.STOPPED, this.fragmentLoader && this.fragmentLoader.destroy(), this.keyLoader && this.keyLoader.destroy(), this.decrypter && this.decrypter.destroy(), this.hls = this.log = this.warn = this.decrypter = this.keyLoader = this.fragmentLoader = this.fragmentTracker = null, super.onHandlerDestroyed() } loadFragment(e, t, i) { this._loadFragForPlayback(e, t, i) } _loadFragForPlayback(e, t, i) { this._doFragLoad(e, t, i, t => { if (this.fragContextChanged(e)) { this.warn(`Fragment ${e.sn}${t.part ? " p: " + t.part.index : ""} of level ${e.level} was dropped during download.`), this.fragmentTracker.removeFragment(e); return } e.stats.chunkCount++, this._handleFragmentLoadProgress(t) }).then(t => { if (!t) return; let i = this.state; if (this.fragContextChanged(e)) { i !== ir.FRAG_LOADING && (this.fragCurrent || i !== ir.PARSING) || (this.fragmentTracker.removeFragment(e), this.state = ir.IDLE); return } "payload" in t && (this.log(`Loaded fragment ${e.sn} of level ${e.level}`), this.hls.trigger(v.FRAG_LOADED, t)), this._handleFragmentLoadComplete(t) }).catch(t => { this.state !== ir.STOPPED && this.state !== ir.ERROR && (this.warn(`Frag error: ${(null == t ? void 0 : t.message) || t}`), this.resetFragmentLoading(e)) }) } clearTrackerIfNeeded(e) { var t; let { fragmentTracker: i } = this; if (i.getState(e) === tY.APPENDING) { let t = e.type, r = this.getFwdBufferInfo(this.mediaBuffer, t), n = Math.max(e.duration, r ? r.len : this.config.maxBufferLength), s = this.backtrackFragment; (1 == (s ? e.sn - s.sn : 0) || this.reduceMaxBufferLength(n, e.duration)) && i.removeFragment(e) } else (null == (t = this.mediaBuffer) ? void 0 : t.buffered.length) === 0 ? i.removeAllFragments() : i.hasParts(e.type) && (i.detectPartialFragments({ frag: e, part: null, stats: e.stats, id: e.type }), i.getState(e) === tY.PARTIAL && i.removeFragment(e)) } checkLiveUpdate(e) { if (e.updated && !e.live) { let t = e.fragments[e.fragments.length - 1]; this.fragmentTracker.detectPartialFragments({ frag: t, part: null, stats: t.stats, id: t.type }) } e.fragments[0] || (e.deltaUpdateFailed = !0) } flushMainBuffer(e, t, i = null) { e - t && this.hls.trigger(v.BUFFER_FLUSHING, { startOffset: e, endOffset: t, type: i }) } _loadInitSegment(e, t) { this._doFragLoad(e, t).then(t => { if (!t || this.fragContextChanged(e) || !this.levels) throw Error("init load aborted"); return t }).then(t => { let { hls: i } = this, { payload: r } = t, n = e.decryptdata; if (r && r.byteLength > 0 && null != n && n.key && n.iv && "AES-128" === n.method) { let s = self.performance.now(); return this.decrypter.decrypt(new Uint8Array(r), n.key.buffer, n.iv.buffer).catch(t => { throw i.trigger(v.ERROR, { type: y.MEDIA_ERROR, details: x.FRAG_DECRYPT_ERROR, fatal: !1, error: t, reason: t.message, frag: e }), t }).then(r => { let n = self.performance.now(); return i.trigger(v.FRAG_DECRYPTED, { frag: e, payload: r, stats: { tstart: s, tdecrypt: n } }), t.payload = r, this.completeInitSegmentLoad(t) }) } return this.completeInitSegmentLoad(t) }).catch(t => { this.state !== ir.STOPPED && this.state !== ir.ERROR && (this.warn(t), this.resetFragmentLoading(e)) }) } completeInitSegmentLoad(e) { let { levels: t } = this; if (!t) throw Error("init load aborted, missing levels"); let i = e.frag.stats; this.state = ir.IDLE, e.frag.data = new Uint8Array(e.payload), i.parsing.start = i.buffering.start = self.performance.now(), i.parsing.end = i.buffering.end = self.performance.now(), this.tick() } fragContextChanged(e) { let { fragCurrent: t } = this; return !e || !t || e.sn !== t.sn || e.level !== t.level } fragBufferedComplete(e, t) { var i, r, n, s, a; let o = this.mediaBuffer ? this.mediaBuffer : this.media; if (this.log(`Buffered ${e.type} sn: ${e.sn}${t ? " part: " + t.index : ""} of ${this.playlistType === e3.MAIN ? "level" : "track"} ${e.level} (frag:[${(null != (i = e.startPTS) ? i : NaN).toFixed(3)}-${(null != (r = e.endPTS) ? r : NaN).toFixed(3)}] > buffer:${o ? ii.toString(tZ.getBuffered(o)) : "(detached)"})`), "initSegment" !== e.sn) { if (e.type !== e3.SUBTITLE) { let t = e.elementaryStreams; if (!Object.keys(t).some(e => !!t[e])) { this.state = ir.IDLE; return } } let t = null == (a = this.levels) ? void 0 : a[e.level]; null != t && t.fragmentError && (this.log(`Resetting level fragment error count of ${t.fragmentError} on frag buffered`), t.fragmentError = 0) } this.state = ir.IDLE, o && (!this.loadedmetadata && e.type == e3.MAIN && o.buffered.length && (null == (n = this.fragCurrent) ? void 0 : n.sn) === (null == (s = this.fragPrevious) ? void 0 : s.sn) && (this.loadedmetadata = !0, this.seekToStartPos()), this.tick()) } seekToStartPos() { } _handleFragmentLoadComplete(e) { let { transmuxer: t } = this; if (!t) return; let { frag: i, part: r, partsLoaded: n } = e, s = !n || 0 === n.length || n.some(e => !e), a = new t$(i.level, i.sn, i.stats.chunkCount + 1, 0, r ? r.index : -1, !s); t.flush(a) } _handleFragmentLoadProgress(e) { } _doFragLoad(e, t, i = null, r) { var n; let s; let a = null == t ? void 0 : t.details; if (!this.levels || !a) throw Error(`frag load aborted, missing level${a ? "" : " detail"}s`); let o = null; if (e.encrypted && !(null != (n = e.decryptdata) && n.key) ? (this.log(`Loading key for ${e.sn} of [${a.startSN}-${a.endSN}], ${"[stream-controller]" === this.logPrefix ? "level" : "track"} ${e.level}`), this.state = ir.KEY_LOADING, this.fragCurrent = e, o = this.keyLoader.load(e).then(e => { if (!this.fragContextChanged(e.frag)) return this.hls.trigger(v.KEY_LOADED, e), this.state === ir.KEY_LOADING && (this.state = ir.IDLE), e }), this.hls.trigger(v.KEY_LOADING, { frag: e }), null === this.fragCurrent && (o = Promise.reject(Error("frag load aborted, context changed in KEY_LOADING")))) : !e.encrypted && a.encryptedFragments.length && this.keyLoader.loadClear(e, a.encryptedFragments), i = Math.max(e.start, i || 0), this.config.lowLatencyMode && "initSegment" !== e.sn) { let n = a.partList; if (n && r) { i > e.end && a.fragmentHint && (e = a.fragmentHint); let s = this.getNextPart(n, e, i); if (s > -1) { let l; let u = n[s]; return (this.log(`Loading part sn: ${e.sn} p: ${u.index} cc: ${e.cc} of playlist [${a.startSN}-${a.endSN}] parts [0-${s}-${n.length - 1}] ${"[stream-controller]" === this.logPrefix ? "level" : "track"}: ${e.level}, target: ${parseFloat(i.toFixed(3))}`), this.nextLoadPosition = u.start + u.duration, this.state = ir.FRAG_LOADING, l = o ? o.then(i => !i || this.fragContextChanged(i.frag) ? null : this.doFragPartsLoad(e, u, t, r)).catch(e => this.handleFragLoadError(e)) : this.doFragPartsLoad(e, u, t, r).catch(e => this.handleFragLoadError(e)), this.hls.trigger(v.FRAG_LOADING, { frag: e, part: u, targetBufferTime: i }), null === this.fragCurrent) ? Promise.reject(Error("frag load aborted, context changed in FRAG_LOADING parts")) : l } if (!e.url || this.loadedEndOfParts(n, i)) return Promise.resolve(null) } } this.log(`Loading fragment ${e.sn} cc: ${e.cc} ${a ? "of [" + a.startSN + "-" + a.endSN + "] " : ""}${"[stream-controller]" === this.logPrefix ? "level" : "track"}: ${e.level}, target: ${parseFloat(i.toFixed(3))}`), p(e.sn) && !this.bitrateTest && (this.nextLoadPosition = e.start + e.duration), this.state = ir.FRAG_LOADING; let l = this.config.progressive; return (s = l && o ? o.then(t => !t || this.fragContextChanged(null == t ? void 0 : t.frag) ? null : this.fragmentLoader.load(e, r)).catch(e => this.handleFragLoadError(e)) : Promise.all([this.fragmentLoader.load(e, l ? r : void 0), o]).then(([e]) => (!l && e && r && r(e), e)).catch(e => this.handleFragLoadError(e)), this.hls.trigger(v.FRAG_LOADING, { frag: e, targetBufferTime: i }), null === this.fragCurrent) ? Promise.reject(Error("frag load aborted, context changed in FRAG_LOADING")) : s } doFragPartsLoad(e, t, i, r) { return new Promise((n, s) => { var a; let o = [], l = null == (a = i.details) ? void 0 : a.partList, u = t => { this.fragmentLoader.loadPart(e, t, r).then(r => { o[t.index] = r; let s = r.part; this.hls.trigger(v.FRAG_LOADED, r); let a = tS(i, e.sn, t.index + 1) || tA(l, e.sn, t.index + 1); if (!a) return n({ frag: e, part: s, partsLoaded: o }); u(a) }).catch(s) }; u(t) }) } handleFragLoadError(e) { if ("data" in e) { let t = e.data; e.data && t.details === x.INTERNAL_ABORTED ? this.handleFragLoadAborted(t.frag, t.part) : this.hls.trigger(v.ERROR, t) } else this.hls.trigger(v.ERROR, { type: y.OTHER_ERROR, details: x.INTERNAL_EXCEPTION, err: e, error: e, fatal: !0 }); return null } _handleTransmuxerFlush(e) { let t = this.getCurrentContext(e); if (!t || this.state !== ir.PARSING) { this.fragCurrent || this.state === ir.STOPPED || this.state === ir.ERROR || (this.state = ir.IDLE); return } let { frag: i, part: r, level: n } = t, s = self.performance.now(); i.stats.parsing.end = s, r && (r.stats.parsing.end = s), this.updateLevelTiming(i, r, n, e.partial) } getCurrentContext(e) { let { levels: t, fragCurrent: i } = this, { level: r, sn: n, part: s } = e; if (!(null != t && t[r])) return this.warn(`Levels object was unset while buffering fragment ${n} of level ${r}. The current chunk will not be buffered.`), null; let a = t[r], o = s > -1 ? tS(a, n, s) : null, l = o ? o.fragment : function (e, t, i) { if (!(null != e && e.details)) return null; let r = e.details, n = r.fragments[t - r.startSN]; return n || (n = r.fragmentHint) && n.sn === t ? n : t < r.startSN && i && i.sn === t ? i : null }(a, n, i); return l ? (i && i !== l && (l.stats = i.stats), { frag: l, part: o, level: a }) : null } bufferFragmentData(e, t, i, r, n) { var s; if (!e || this.state !== ir.PARSING) return; let { data1: a, data2: o } = e, l = a; if (a && o && (l = eE(a, o)), !(null != (s = l) && s.length)) return; let u = { type: e.type, frag: t, part: i, chunkMeta: r, parent: t.type, data: l }; if (this.hls.trigger(v.BUFFER_APPENDING, u), e.dropped && e.independent && !i) { if (n) return; this.flushBufferGap(t) } } flushBufferGap(e) { let t = this.media; if (!t) return; if (!tZ.isBuffered(t, t.currentTime)) { this.flushMainBuffer(0, e.start); return } let i = t.currentTime, r = tZ.bufferInfo(t, i, 0), n = e.duration, s = Math.min(2 * this.config.maxFragLookUpTolerance, .25 * n), a = Math.max(Math.min(e.start - s, r.end - s), i + s); e.start - a > s && this.flushMainBuffer(a, e.start) } getFwdBufferInfo(e, t) { let i = this.getLoadPosition(); return p(i) ? this.getFwdBufferInfoAtPos(e, i, t) : null } getFwdBufferInfoAtPos(e, t, i) { let { config: { maxBufferHole: r } } = this, n = tZ.bufferInfo(e, t, r); if (0 === n.len && void 0 !== n.nextStart) { let s = this.fragmentTracker.getBufferedFrag(t, i); if (s && n.nextStart < s.end) return tZ.bufferInfo(e, t, Math.max(n.nextStart, r)) } return n } getMaxBufferLength(e) { let { config: t } = this; return Math.min(e ? Math.max(8 * t.maxBufferSize / e, t.maxBufferLength) : t.maxBufferLength, t.maxMaxBufferLength) } reduceMaxBufferLength(e, t) { let i = this.config, r = Math.max(Math.min(e - t, i.maxBufferLength), t), n = Math.max(e - 3 * t, i.maxMaxBufferLength / 2, r); return n >= r && (i.maxMaxBufferLength = n, this.warn(`Reduce max buffer length to ${n}s`), !0) } getAppendedFrag(e, t = e3.MAIN) { let i = this.fragmentTracker.getAppendedFrag(e, e3.MAIN); return i && "fragment" in i ? i.fragment : i } getNextFragment(e, t) { let i; let r = t.fragments, n = r.length; if (!n) return null; let { config: s } = this, a = r[0].start; if (t.live) { let o = s.initialLiveManifestSize; if (n < o) return this.warn(`Not enough fragments to start playback (have: ${n}, need: ${o})`), null; (t.PTSKnown || this.startFragRequested || -1 !== this.startPosition) && !(e < a) || (i = this.getInitialLiveFragment(t, r), this.startPosition = this.nextLoadPosition = i ? this.hls.liveSyncPosition || i.start : e) } else e <= a && (i = r[0]); if (!i) { let r = s.lowLatencyMode ? t.partEnd : t.fragmentEnd; i = this.getFragmentAtPosition(e, r, t) } return this.mapToInitFragWhenRequired(i) } isLoopLoading(e, t) { let i = this.fragmentTracker.getState(e); return (i === tY.OK || i === tY.PARTIAL && !!e.gap) && this.nextLoadPosition > t } getNextFragmentLoopLoading(e, t, i, r, n) { let s = e.gap, a = this.getNextFragment(this.nextLoadPosition, t); if (null === a) return a; if (e = a, s && e && !e.gap && i.nextStart) { let t = this.getFwdBufferInfoAtPos(this.mediaBuffer ? this.mediaBuffer : this.media, i.nextStart, r); if (null !== t && i.len + t.len >= n) return this.log(`buffer full after gaps in "${r}" playlist starting at sn: ${e.sn}`), null } return e } mapToInitFragWhenRequired(e) { return null == e || !e.initSegment || null != e && e.initSegment.data || this.bitrateTest ? e : e.initSegment } getNextPart(e, t, i) { let r = -1, n = !1, s = !0; for (let a = 0, o = e.length; a < o; a++) { let o = e[a]; if (s = s && !o.independent, r > -1 && i < o.start) break; let l = o.loaded; l ? r = -1 : (n || o.independent || s) && o.fragment === t && (r = a), n = l } return r } loadedEndOfParts(e, t) { let i = e[e.length - 1]; return i && t > i.start && i.loaded } getInitialLiveFragment(e, t) { let i = this.fragPrevious, r = null; if (i) { if (e.hasProgramDateTime && (this.log(`Live playlist, switching playlist, load frag with same PDT: ${i.programDateTime}`), r = function (e, t, i) { if (null === t || !Array.isArray(e) || !e.length || !p(t) || t < (e[0].programDateTime || 0) || t >= (e[e.length - 1].endProgramDateTime || 0)) return null; i = i || 0; for (let r = 0; r < e.length; ++r) { let n = e[r]; if (function (e, t, i) { let r = 1e3 * Math.min(t, i.duration + (i.deltaPTS ? i.deltaPTS : 0)); return (i.endProgramDateTime || 0) - r > e }(t, i, n)) return n } return null }(t, i.endProgramDateTime, this.config.maxFragLookUpTolerance)), !r) { let s = i.sn + 1; if (s >= e.startSN && s <= e.endSN) { let n = t[s - e.startSN]; i.cc === n.cc && (r = n, this.log(`Live playlist, switching playlist, load frag with next SN: ${r.sn}`)) } if (!r) { var n; n = i.cc, (r = tR.search(t, e => e.cc < n ? 1 : e.cc > n ? -1 : 0)) && this.log(`Live playlist, switching playlist, load frag with same CC: ${r.sn}`) } } } else { let t = this.hls.liveSyncPosition; null !== t && (r = this.getFragmentAtPosition(t, this.bitrateTest ? e.fragmentEnd : e.edge, e)) } return r } getFragmentAtPosition(e, t, i) { let r; let { config: n } = this, { fragPrevious: s } = this, { fragments: a, endSN: o } = i, { fragmentHint: l } = i, { maxFragLookUpTolerance: u } = n, h = i.partList, c = !!(n.lowLatencyMode && null != h && h.length && l); if (c && l && !this.bitrateTest && (a = a.concat(l), o = l.sn), r = e < t ? tC(s, a, e, e > t - u ? 0 : u) : a[a.length - 1]) { let e = r.sn - i.startSN, t = this.fragmentTracker.getState(r); if ((t === tY.OK || t === tY.PARTIAL && r.gap) && (s = r), s && r.sn === s.sn && (!c || h[0].fragment.sn > r.sn) && s && r.level === s.level) { let t = a[e + 1]; r = r.sn < o && this.fragmentTracker.getState(t) !== tY.OK ? t : null } } return r } synchronizeToLiveEdge(e) { let { config: t, media: i } = this; if (!i) return; let r = this.hls.liveSyncPosition, n = i.currentTime, s = e.fragments[0].start, a = e.edge, o = n >= s - t.maxFragLookUpTolerance && n <= a; if (null !== r && i.duration > r && (n < r || !o)) { let s = void 0 !== t.liveMaxLatencyDuration ? t.liveMaxLatencyDuration : t.liveMaxLatencyDurationCount * e.targetduration; (!o && i.readyState < 4 || n < a - s) && (this.loadedmetadata || (this.nextLoadPosition = r), i.readyState && (this.warn(`Playback: ${n.toFixed(3)} is located too far from the end of live sliding playlist: ${a}, reset currentTime to : ${r.toFixed(3)}`), i.currentTime = r)) } } alignPlaylists(e, t, i) { let r = e.fragments.length; if (!r) return this.warn("No fragments in live playlist"), 0; let n = e.fragments[0].start, s = !t, a = e.alignedSliding && p(n); if (s || !a && !n) { let { fragPrevious: n } = this; i && (function (e, t, i) { if (i && (t.endCC > t.startCC || e && e.cc < t.startCC)) { let e = function (e, t) { let i = e.fragments, r = t.fragments; if (!r.length || !i.length) { E.log("No fragments to align"); return } let n = t0(i, r[0].cc); if (!n || n && !n.startPTS) { E.log("No frag in previous level to align on"); return } return n }(i, t); e && p(e.start) && (E.log(`Adjusting PTS using last level due to CC increase within current level ${t.url}`), t2(e.start, t)) } }(n, e, i), !e.alignedSliding && i && t3(e, i), e.alignedSliding || !i || e.skippedSegments || ty(i, e)); let s = e.fragments[0].start; return this.log(`Live playlist sliding: ${s.toFixed(2)} start-sn: ${t ? t.startSN : "na"}->${e.startSN} prev-sn: ${n ? n.sn : "na"} fragments: ${r}`), s } return n } waitForCdnTuneIn(e) { return e.live && e.canBlockReload && e.partTarget && e.tuneInGoal > Math.max(e.partHoldBack, 3 * e.partTarget) } setStartPosition(e, t) { let i = this.startPosition; if (i < t && (i = -1), -1 === i || -1 === this.lastCurrentTime) { let r = null !== this.startTimeOffset, n = r ? this.startTimeOffset : e.startTimeOffset; null !== n && p(n) ? (i = t + n, n < 0 && (i += e.totalduration), i = Math.min(Math.max(t, i), t + e.totalduration), this.log(`Start time offset ${n} found in ${r ? "multivariant" : "media"} playlist, adjust startPosition to ${i}`), this.startPosition = i) : e.live ? i = this.hls.liveSyncPosition || t : this.startPosition = i = 0, this.lastCurrentTime = i } this.nextLoadPosition = i } getLoadPosition() { let { media: e } = this, t = 0; return this.loadedmetadata && e ? t = e.currentTime : this.nextLoadPosition && (t = this.nextLoadPosition), t } handleFragLoadAborted(e, t) { this.transmuxer && "initSegment" !== e.sn && e.stats.aborted && (this.warn(`Fragment ${e.sn}${t ? " part " + t.index : ""} of level ${e.level} was aborted`), this.resetFragmentLoading(e)) } resetFragmentLoading(e) { this.fragCurrent && (this.fragContextChanged(e) || this.state === ir.FRAG_LOADING_WAITING_RETRY) || (this.state = ir.IDLE) } onFragmentOrKeyLoadError(e, t) { if (t.chunkMeta && !t.frag) { let e = this.getCurrentContext(t.chunkMeta); e && (t.frag = e.frag) } let i = t.frag; if (!i || i.type !== e || !this.levels) return; if (this.fragContextChanged(i)) { var r; this.warn(`Frag load error must match current frag to retry ${i.url} > ${null == (r = this.fragCurrent) ? void 0 : r.url}`); return } let n = t.details === x.FRAG_GAP; n && this.fragmentTracker.fragBuffered(i, !0); let s = t.errorAction, { action: a, retryCount: o = 0, retryConfig: l } = s || {}; if (s && a === tL.RetryRequest && l) { this.resetStartWhenNotLoaded(this.levelLastLoaded); let r = tT(l, o); this.warn(`Fragment ${i.sn} of ${e} ${i.level} errored with ${t.details}, retrying loading ${o + 1}/${l.maxNumRetry} in ${r}ms`), s.resolved = !0, this.retryDate = self.performance.now() + r, this.state = ir.FRAG_LOADING_WAITING_RETRY } else if (l && s) { if (this.resetFragmentErrors(e), o < l.maxNumRetry) n || a === tL.RemoveAlternatePermanently || (s.resolved = !0); else { E.warn(`${t.details} reached or exceeded max retry (${o})`); return } } else (null == s ? void 0 : s.action) === tL.SendAlternateToPenaltyBox ? this.state = ir.WAITING_LEVEL : this.state = ir.ERROR; this.tickImmediate() } reduceLengthAndFlushBuffer(e) { if (this.state === ir.PARSING || this.state === ir.PARSED) { let t = e.frag, i = e.parent, r = this.getFwdBufferInfo(this.mediaBuffer, i), n = r && r.len > .5; n && this.reduceMaxBufferLength(r.len, (null == t ? void 0 : t.duration) || 10); let s = !n; return s && this.warn(`Buffer full error while media.currentTime is not buffered, flush ${i} buffer`), t && (this.fragmentTracker.removeFragment(t), this.nextLoadPosition = t.start), this.resetLoadingState(), s } return !1 } resetFragmentErrors(e) { e === e3.AUDIO && (this.fragCurrent = null), this.loadedmetadata || (this.startFragRequested = !1), this.state !== ir.STOPPED && (this.state = ir.IDLE) } afterBufferFlushed(e, t, i) { if (!e) return; let r = tZ.getBuffered(e); this.fragmentTracker.detectEvictedFragments(t, r, i), this.state === ir.ENDED && this.resetLoadingState() } resetLoadingState() { this.log("Reset loading state"), this.fragCurrent = null, this.fragPrevious = null, this.state = ir.IDLE } resetStartWhenNotLoaded(e) { if (!this.loadedmetadata) { this.startFragRequested = !1; let t = e ? e.details : null; null != t && t.live ? (this.startPosition = -1, this.setStartPosition(t, 0), this.resetLoadingState()) : this.nextLoadPosition = this.startPosition } } resetWhenMissingContext(e) { this.warn(`The loading context changed while buffering fragment ${e.sn} of level ${e.level}. This chunk will not be buffered.`), this.removeUnbufferedFrags(), this.resetStartWhenNotLoaded(this.levelLastLoaded), this.resetLoadingState() } removeUnbufferedFrags(e = 0) { this.fragmentTracker.removeFragmentsInRange(e, 1 / 0, this.playlistType, !1, !0) } updateLevelTiming(e, t, i, r) { var n; let s = i.details; if (!s) { this.warn("level.details undefined"); return } if (!Object.keys(e.elementaryStreams).reduce((t, n) => { let a = e.elementaryStreams[n]; if (a) { let o = a.endPTS - a.startPTS; if (o <= 0) return this.warn(`Could not parse fragment ${e.sn} ${n} duration reliably (${o})`), t || !1; let l = r ? 0 : tv(s, e, a.startPTS, a.endPTS, a.startDTS, a.endDTS); return this.hls.trigger(v.LEVEL_PTS_UPDATED, { details: s, level: i, drift: l, type: n, frag: e, start: a.startPTS, end: a.endPTS }), !0 } return t }, !1) && (null == (n = this.transmuxer) ? void 0 : n.error) === null) { let t = Error(`Found no media in fragment ${e.sn} of level ${e.level} resetting transmuxer to fallback to playlist timing`); if (0 === i.fragmentError && (i.fragmentError++, e.gap = !0, this.fragmentTracker.removeFragment(e), this.fragmentTracker.fragBuffered(e, !0)), this.warn(t.message), this.hls.trigger(v.ERROR, { type: y.MEDIA_ERROR, details: x.FRAG_PARSING_ERROR, fatal: !1, error: t, frag: e, reason: `Found no media in msn ${e.sn} of level "${i.url}"` }), !this.hls) return; this.resetTransmuxer() } this.state = ir.PARSED, this.hls.trigger(v.FRAG_PARSED, { frag: e, part: t }) } resetTransmuxer() { this.transmuxer && (this.transmuxer.destroy(), this.transmuxer = null) } recoverWorkerError(e) { "demuxerWorker" === e.event && (this.fragmentTracker.removeAllFragments(), this.resetTransmuxer(), this.resetStartWhenNotLoaded(this.levelLastLoaded), this.resetLoadingState()) } set state(e) { let t = this._state; t !== e && (this._state = e, this.log(`${t}->${e}`)) } get state() { return this._state } } class ia { constructor() { this.chunks = [], this.dataLength = 0 } push(e) { this.chunks.push(e), this.dataLength += e.length } flush() { let e; let { chunks: t, dataLength: i } = this; return t.length ? (e = 1 === t.length ? t[0] : function (e, t) { let i = new Uint8Array(t), r = 0; for (let t = 0; t < e.length; t++) { let n = e[t]; i.set(n, r), r += n.length } return i }(t, i), this.reset(), e) : new Uint8Array(0) } reset() { this.chunks.length = 0, this.dataLength = 0 } } function io(e = "", t = 9e4) { return { type: e, id: -1, pid: -1, inputTimeScale: t, sequenceNumber: -1, samples: [], dropped: 0 } } class il { constructor() { this._audioTrack = void 0, this._id3Track = void 0, this.frameIndex = 0, this.cachedData = null, this.basePTS = null, this.initPTS = null, this.lastPTS = null } resetInitSegment(e, t, i, r) { this._id3Track = { type: "id3", id: 3, pid: -1, inputTimeScale: 9e4, sequenceNumber: 0, samples: [], dropped: 0 } } resetTimeStamp(e) { this.initPTS = e, this.resetContiguity() } resetContiguity() { this.basePTS = null, this.lastPTS = null, this.frameIndex = 0 } canParse(e, t) { return !1 } appendFrame(e, t, i) { } demux(e, t) { let i; this.cachedData && (e = eE(this.cachedData, e), this.cachedData = null); let r = q(e, 0), n = r ? r.length : 0, s = this._audioTrack, a = this._id3Track, o = r ? $(r) : void 0, l = e.length; for ((null === this.basePTS || 0 === this.frameIndex && p(o)) && (this.basePTS = iu(o, t, this.initPTS), this.lastPTS = this.basePTS), null === this.lastPTS && (this.lastPTS = this.basePTS), r && r.length > 0 && a.samples.push({ pts: this.lastPTS, dts: this.lastPTS, data: r, type: ti.audioId3, duration: Number.POSITIVE_INFINITY }); n < l;) { if (this.canParse(e, n)) { let t = this.appendFrame(s, e, n); t ? (this.frameIndex++, this.lastPTS = t.sample.pts, n += t.length, i = n) : n = l } else Z(e, n) ? (r = q(e, n), a.samples.push({ pts: this.lastPTS, dts: this.lastPTS, data: r, type: ti.audioId3, duration: Number.POSITIVE_INFINITY }), n += r.length, i = n) : n++; if (n === l && i !== l) { let t = Y(e, i); this.cachedData ? this.cachedData = eE(this.cachedData, t) : this.cachedData = t } } return { audioTrack: s, videoTrack: io(), id3Track: a, textTrack: io() } } demuxSampleAes(e, t, i) { return Promise.reject(Error(`[${this}] This demuxer does not support Sample-AES decryption`)) } flush(e) { let t = this.cachedData; return t && (this.cachedData = null, this.demux(t, 0)), { audioTrack: this._audioTrack, videoTrack: io(), id3Track: this._id3Track, textTrack: io() } } destroy() { } } let iu = (e, t, i) => p(e) ? 90 * e : 9e4 * t + (i ? 9e4 * i.baseTime / i.timescale : 0); function ih(e, t) { return 255 === e[t] && (246 & e[t + 1]) == 240 } function ic(e, t) { return 1 & e[t + 1] ? 7 : 9 } function id(e, t) { return (3 & e[t + 3]) << 11 | e[t + 4] << 3 | (224 & e[t + 5]) >>> 5 } function ip(e, t) { return t + 1 < e.length && ih(e, t) } function im(e, t, i, r, n) { if (!e.samplerate) { let s = function (e, t, i, r) { let n, s, a, o; let l = navigator.userAgent.toLowerCase(), u = [96e3, 88200, 64e3, 48e3, 44100, 32e3, 24e3, 22050, 16e3, 12e3, 11025, 8e3, 7350]; n = ((192 & t[i + 2]) >>> 6) + 1; let h = (60 & t[i + 2]) >>> 2; if (h > u.length - 1) { let t = Error(`invalid ADTS sampling index:${h}`); e.emit(v.ERROR, v.ERROR, { type: y.MEDIA_ERROR, details: x.FRAG_PARSING_ERROR, fatal: !0, error: t, reason: t.message }); return } return a = (1 & t[i + 2]) << 2 | (192 & t[i + 3]) >>> 6, E.log(`manifest codec:${r}, ADTS type:${n}, samplingIndex:${h}`), /firefox/i.test(l) ? h >= 6 ? (n = 5, o = [, , , ,], s = h - 3) : (n = 2, o = [, ,], s = h) : -1 !== l.indexOf("android") ? (n = 2, o = [, ,], s = h) : (n = 5, o = [, , , ,], r && (-1 !== r.indexOf("mp4a.40.29") || -1 !== r.indexOf("mp4a.40.5")) || !r && h >= 6 ? s = h - 3 : ((r && -1 !== r.indexOf("mp4a.40.2") && (h >= 6 && 1 === a || /vivaldi/i.test(l)) || !r && 1 === a) && (n = 2, o = [, ,]), s = h)), o[0] = n << 3, o[0] |= (14 & h) >> 1, o[1] |= (1 & h) << 7, o[1] |= a << 3, 5 === n && (o[1] |= (14 & s) >> 1, o[2] = (1 & s) << 7, o[2] |= 8, o[3] = 0), { config: o, samplerate: u[h], channelCount: a, codec: "mp4a.40." + n, manifestCodec: r } }(t, i, r, n); s && (e.config = s.config, e.samplerate = s.samplerate, e.channelCount = s.channelCount, e.codec = s.codec, e.manifestCodec = s.manifestCodec, E.log(`parsed codec:${e.codec}, rate:${s.samplerate}, channels:${s.channelCount}`)) } } function ig(e, t, i, r, n) { let s; let a = r + n * (9216e4 / e.samplerate), o = function (e, t) { let i = ic(e, t); if (t + i <= e.length) { let r = id(e, t) - i; if (r > 0) return { headerLength: i, frameLength: r } } }(t, i); if (o) { let { frameLength: r, headerLength: n } = o, l = n + r, u = Math.max(0, i + l - t.length); u ? (s = new Uint8Array(l - n)).set(t.subarray(i + n, t.length), 0) : s = t.subarray(i + n, i + l); let h = { unit: s, pts: a }; return u || e.samples.push(h), { sample: h, length: l, missing: u } } let l = t.length - i; return (s = new Uint8Array(l)).set(t.subarray(i, t.length), 0), { sample: { unit: s, pts: a }, length: l, missing: -1 } } let iv = null, iy = [32, 64, 96, 128, 160, 192, 224, 256, 288, 320, 352, 384, 416, 448, 32, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320, 384, 32, 40, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320, 32, 48, 56, 64, 80, 96, 112, 128, 144, 160, 176, 192, 224, 256, 8, 16, 24, 32, 40, 48, 56, 64, 80, 96, 112, 128, 144, 160], ix = [44100, 48e3, 32e3, 22050, 24e3, 16e3, 11025, 12e3, 8e3], iS = [[0, 72, 144, 12], [0, 0, 0, 0], [0, 72, 144, 12], [0, 144, 144, 12]], iA = [0, 1, 1, 4]; function i_(e, t, i, r, n) { if (i + 24 > t.length) return; let s = iE(t, i); if (s && i + s.frameLength <= t.length) { let a = r + n * (9e4 * s.samplesPerFrame / s.sampleRate), o = { unit: t.subarray(i, i + s.frameLength), pts: a, dts: a }; return e.config = [], e.channelCount = s.channelCount, e.samplerate = s.sampleRate, e.samples.push(o), { sample: o, length: s.frameLength, missing: 0 } } } function iE(e, t) { let i = e[t + 1] >> 3 & 3, r = e[t + 1] >> 1 & 3, n = e[t + 2] >> 4 & 15, s = e[t + 2] >> 2 & 3; if (1 !== i && 0 !== n && 15 !== n && 3 !== s) { let a = e[t + 2] >> 1 & 1, o = e[t + 3] >> 6, l = 1e3 * iy[14 * (3 === i ? 3 - r : 3 === r ? 3 : 4) + n - 1], u = ix[3 * (3 === i ? 0 : 2 === i ? 1 : 2) + s], h = iS[i][r], c = iA[r], d = Math.floor(h * l / u + a) * c; if (null === iv) { let e = (navigator.userAgent || "").match(/Chrome\/(\d+)/i); iv = e ? parseInt(e[1]) : 0 } return iv && iv <= 87 && 2 === r && l >= 224e3 && 0 === o && (e[t + 3] = 128 | e[t + 3]), { sampleRate: u, channelCount: 3 === o ? 1 : 2, frameLength: d, samplesPerFrame: 8 * h * c } } } function ib(e, t) { return 255 === e[t] && (224 & e[t + 1]) == 224 && (6 & e[t + 1]) != 0 } function iT(e, t) { return t + 1 < e.length && ib(e, t) } function iw(e, t) { if (t + 1 < e.length && ib(e, t)) { let i = iE(e, t), r = 4; null != i && i.frameLength && (r = i.frameLength); let n = t + r; return n === e.length || iT(e, n) } return !1 } class iM extends il { constructor(e, t) { super(), this.observer = void 0, this.config = void 0, this.observer = e, this.config = t } resetInitSegment(e, t, i, r) { super.resetInitSegment(e, t, i, r), this._audioTrack = { container: "audio/adts", type: "audio", id: 2, pid: -1, sequenceNumber: 0, segmentCodec: "aac", samples: [], manifestCodec: t, duration: r, inputTimeScale: 9e4, dropped: 0 } } static probe(e) { if (!e) return !1; let t = q(e, 0), i = (null == t ? void 0 : t.length) || 0; if (iw(e, i)) return !1; for (let t = e.length; i < t; i++)if (function (e, t) { if (ip(e, t)) { let i = ic(e, t); if (t + i >= e.length) return !1; let r = id(e, t); if (r <= i) return !1; let n = t + r; return n === e.length || ip(e, n) } return !1 }(e, i)) return E.log("ADTS sync word found !"), !0; return !1 } canParse(e, t) { return t + 5 < e.length && ih(e, t) && id(e, t) <= e.length - t } appendFrame(e, t, i) { im(e, this.observer, t, i, e.manifestCodec); let r = ig(e, t, i, this.basePTS, this.frameIndex); if (r && 0 === r.missing) return r } } let iR = /\/emsg[-/]ID3/i; class iC { constructor(e, t) { this.remainderData = null, this.timeOffset = 0, this.config = void 0, this.videoTrack = void 0, this.audioTrack = void 0, this.id3Track = void 0, this.txtTrack = void 0, this.config = t } resetTimeStamp() { } resetInitSegment(e, t, i, r) { let n = this.videoTrack = io("video", 1), s = this.audioTrack = io("audio", 1), a = this.txtTrack = io("text", 1); if (this.id3Track = io("id3", 1), this.timeOffset = 0, !(null != e && e.byteLength)) return; let o = ey(e); if (o.video) { let { id: e, timescale: t, codec: i } = o.video; n.id = e, n.timescale = a.timescale = t, n.codec = i } if (o.audio) { let { id: e, timescale: t, codec: i } = o.audio; s.id = e, s.timescale = t, s.codec = i } a.id = eh.text, n.sampleDuration = 0, n.duration = s.duration = r } resetContiguity() { this.remainderData = null } static probe(e) { return function (e) { let t = e.byteLength; for (let i = 0; i < t;) { let r = ef(e, i); if (r > 8 && 109 === e[i + 4] && 111 === e[i + 5] && 111 === e[i + 6] && 102 === e[i + 7]) return !0; i = r > 1 ? i + r : t } return !1 }(e) } demux(e, t) { this.timeOffset = t; let i = e, r = this.videoTrack, n = this.txtTrack; if (this.config.progressive) { this.remainderData && (i = eE(this.remainderData, e)); let t = function (e) { let t = { valid: null, remainder: null }, i = ev(e, ["moof"]); if (i.length < 2) return t.remainder = e, t; let r = i[i.length - 1]; return t.valid = Y(e, 0, r.byteOffset - 8), t.remainder = Y(e, r.byteOffset - 8), t }(i); this.remainderData = t.remainder, r.samples = t.valid || new Uint8Array } else r.samples = i; let s = this.extractID3Track(r, t); return n.samples = eb(t, r), { videoTrack: r, audioTrack: this.audioTrack, id3Track: s, textTrack: this.txtTrack } } flush() { let e = this.timeOffset, t = this.videoTrack, i = this.txtTrack; t.samples = this.remainderData || new Uint8Array, this.remainderData = null; let r = this.extractID3Track(t, this.timeOffset); return i.samples = eb(e, t), { videoTrack: t, audioTrack: io(), id3Track: r, textTrack: io() } } extractID3Track(e, t) { let i = this.id3Track; if (e.samples.length) { let r = ev(e.samples, ["emsg"]); r && r.forEach(e => { let r = function (e) { let t = e[0], i = "", r = "", n = 0, s = 0, a = 0, o = 0, l = 0, u = 0; if (0 === t) { for (; "\0" !== ec(e.subarray(u, u + 1));)i += ec(e.subarray(u, u + 1)), u += 1; for (i += ec(e.subarray(u, u + 1)), u += 1; "\0" !== ec(e.subarray(u, u + 1));)r += ec(e.subarray(u, u + 1)), u += 1; r += ec(e.subarray(u, u + 1)), u += 1, n = ef(e, 12), s = ef(e, 16), o = ef(e, 20), l = ef(e, 24), u = 28 } else if (1 === t) { u += 4, n = ef(e, u); let t = ef(e, u += 4), s = ef(e, u += 4); for (u += 4, m(a = 0x100000000 * t + s) || (a = Number.MAX_SAFE_INTEGER, E.warn("Presentation time exceeds safe integer limit and wrapped to max safe integer in parsing emsg box")), o = ef(e, u), u += 4, l = ef(e, u), u += 4; "\0" !== ec(e.subarray(u, u + 1));)i += ec(e.subarray(u, u + 1)), u += 1; for (i += ec(e.subarray(u, u + 1)), u += 1; "\0" !== ec(e.subarray(u, u + 1));)r += ec(e.subarray(u, u + 1)), u += 1; r += ec(e.subarray(u, u + 1)), u += 1 } return { schemeIdUri: i, value: r, timeScale: n, presentationTime: a, presentationTimeDelta: s, eventDuration: o, id: l, payload: e.subarray(u, e.byteLength) } }(e); if (iR.test(r.schemeIdUri)) { let e = p(r.presentationTime) ? r.presentationTime / r.timeScale : t + r.presentationTimeDelta / r.timeScale, n = 0xffffffff === r.eventDuration ? Number.POSITIVE_INFINITY : r.eventDuration / r.timeScale; n <= .001 && (n = Number.POSITIVE_INFINITY); let s = r.payload; i.samples.push({ data: s, len: s.byteLength, dts: e, pts: e, type: ti.emsg, duration: n }) } }) } return i } demuxSampleAes(e, t, i) { return Promise.reject(Error("The MP4 demuxer does not support SAMPLE-AES decryption")) } destroy() { } } let iI = (e, t) => { let i = 0, r = 5; t += 5; let n = new Uint32Array(1), s = new Uint32Array(1), a = new Uint8Array(1); for (; r > 0;) { a[0] = e[t]; let o = Math.min(r, 8), l = 8 - o; s[0] = 0xff000000 >>> 24 + l << l, n[0] = (a[0] & s[0]) >> l, i = i ? i << o | n[0] : n[0], t += 1, r -= o } return i }; class iL extends il { constructor(e) { super(), this.observer = void 0, this.observer = e } resetInitSegment(e, t, i, r) { super.resetInitSegment(e, t, i, r), this._audioTrack = { container: "audio/ac-3", type: "audio", id: 2, pid: -1, sequenceNumber: 0, segmentCodec: "ac3", samples: [], manifestCodec: t, duration: r, inputTimeScale: 9e4, dropped: 0 } } canParse(e, t) { return t + 64 < e.length } appendFrame(e, t, i) { let r = iP(e, t, i, this.basePTS, this.frameIndex); if (-1 !== r) return { sample: e.samples[e.samples.length - 1], length: r, missing: 0 } } static probe(e) { if (!e) return !1; let t = q(e, 0); if (!t) return !1; let i = t.length; return !!(11 === e[i] && 119 === e[i + 1] && void 0 !== $(t) && 16 > iI(e, i)) } } function iP(e, t, i, r, n) { if (i + 8 > t.length || 11 !== t[i] || 119 !== t[i + 1]) return -1; let s = t[i + 4] >> 6; if (s >= 3) return -1; let a = [48e3, 44100, 32e3][s], o = 63 & t[i + 4], l = 2 * [64, 69, 96, 64, 70, 96, 80, 87, 120, 80, 88, 120, 96, 104, 144, 96, 105, 144, 112, 121, 168, 112, 122, 168, 128, 139, 192, 128, 140, 192, 160, 174, 240, 160, 175, 240, 192, 208, 288, 192, 209, 288, 224, 243, 336, 224, 244, 336, 256, 278, 384, 256, 279, 384, 320, 348, 480, 320, 349, 480, 384, 417, 576, 384, 418, 576, 448, 487, 672, 448, 488, 672, 512, 557, 768, 512, 558, 768, 640, 696, 960, 640, 697, 960, 768, 835, 1152, 768, 836, 1152, 896, 975, 1344, 896, 976, 1344, 1024, 1114, 1536, 1024, 1115, 1536, 1152, 1253, 1728, 1152, 1254, 1728, 1280, 1393, 1920, 1280, 1394, 1920][3 * o + s]; if (i + l > t.length) return -1; let u = t[i + 6] >> 5, h = 0; 2 === u ? h += 2 : (1 & u && 1 !== u && (h += 2), 4 & u && (h += 2)); let c = (t[i + 6] << 8 | t[i + 7]) >> 12 - h & 1, d = [2, 1, 2, 3, 3, 4, 4, 5][u] + c, f = t[i + 5] >> 3, p = 7 & t[i + 5], m = new Uint8Array([s << 6 | f << 1 | p >> 2, (3 & p) << 6 | u << 3 | c << 2 | o >> 4, o << 4 & 224]), g = t.subarray(i, i + l); return e.config = m, e.channelCount = d, e.samplerate = a, e.samples.push({ unit: g, pts: r + 1536 / a * 9e4 * n }), l } class iD { constructor() { this.VideoSample = null } createVideoSample(e, t, i, r) { return { key: e, frame: !1, pts: t, dts: i, units: [], debug: r, length: 0 } } getLastNalUnit(e) { var t; let i; let r = this.VideoSample; if (r && 0 !== r.units.length || (r = e[e.length - 1]), null != (t = r) && t.units) { let e = r.units; i = e[e.length - 1] } return i } pushAccessUnit(e, t) { if (e.units.length && e.frame) { if (void 0 === e.pts) { let i = t.samples, r = i.length; if (r) { let t = i[r - 1]; e.pts = t.pts, e.dts = t.dts } else { t.dropped++; return } } t.samples.push(e) } e.debug.length && E.log(e.pts + "/" + e.dts + ":" + e.debug) } } class iO { constructor(e) { this.data = void 0, this.bytesAvailable = void 0, this.word = void 0, this.bitsAvailable = void 0, this.data = e, this.bytesAvailable = e.byteLength, this.word = 0, this.bitsAvailable = 0 } loadWord() { let e = this.data, t = this.bytesAvailable, i = e.byteLength - t, r = new Uint8Array(4), n = Math.min(4, t); if (0 === n) throw Error("no bytes available"); r.set(e.subarray(i, i + n)), this.word = new DataView(r.buffer).getUint32(0), this.bitsAvailable = 8 * n, this.bytesAvailable -= n } skipBits(e) { let t; e = Math.min(e, 8 * this.bytesAvailable + this.bitsAvailable), this.bitsAvailable > e || (e -= this.bitsAvailable, t = e >> 3, e -= t << 3, this.bytesAvailable -= t, this.loadWord()), this.word <<= e, this.bitsAvailable -= e } readBits(e) { let t = Math.min(this.bitsAvailable, e), i = this.word >>> 32 - t; if (e > 32 && E.error("Cannot read more than 32 bits at a time"), this.bitsAvailable -= t, this.bitsAvailable > 0) this.word <<= t; else if (this.bytesAvailable > 0) this.loadWord(); else throw Error("no bits available"); return (t = e - t) > 0 && this.bitsAvailable ? i << t | this.readBits(t) : i } skipLZ() { let e; for (e = 0; e < this.bitsAvailable; ++e)if ((this.word & 0x80000000 >>> e) != 0) return this.word <<= e, this.bitsAvailable -= e, e; return this.loadWord(), e + this.skipLZ() } skipUEG() { this.skipBits(1 + this.skipLZ()) } skipEG() { this.skipBits(1 + this.skipLZ()) } readUEG() { let e = this.skipLZ(); return this.readBits(e + 1) - 1 } readEG() { let e = this.readUEG(); return 1 & e ? 1 + e >>> 1 : -1 * (e >>> 1) } readBoolean() { return 1 === this.readBits(1) } readUByte() { return this.readBits(8) } readUShort() { return this.readBits(16) } readUInt() { return this.readBits(32) } skipScalingList(e) { let t = 8, i = 8; for (let r = 0; r < e; r++)0 !== i && (i = (t + this.readEG() + 256) % 256), t = 0 === i ? t : i } readSPS() { let e, t, i, r = 0, n = 0, s = 0, a = 0, o = this.readUByte.bind(this), l = this.readBits.bind(this), u = this.readUEG.bind(this), h = this.readBoolean.bind(this), c = this.skipBits.bind(this), d = this.skipEG.bind(this), f = this.skipUEG.bind(this), p = this.skipScalingList.bind(this); o(); let m = o(); if (l(5), c(3), o(), f(), 100 === m || 110 === m || 122 === m || 244 === m || 44 === m || 83 === m || 86 === m || 118 === m || 128 === m) { let e = u(); if (3 === e && c(1), f(), f(), c(1), h()) for (i = 0, t = 3 !== e ? 8 : 12; i < t; i++)h() && p(i < 6 ? 16 : 64) } f(); let g = u(); if (0 === g) u(); else if (1 === g) for (c(1), d(), d(), e = u(), i = 0; i < e; i++)d(); f(), c(1); let v = u(), y = u(), x = l(1); 0 === x && c(1), c(1), h() && (r = u(), n = u(), s = u(), a = u()); let S = [1, 1]; if (h() && h()) switch (o()) { case 1: S = [1, 1]; break; case 2: S = [12, 11]; break; case 3: S = [10, 11]; break; case 4: S = [16, 11]; break; case 5: S = [40, 33]; break; case 6: S = [24, 11]; break; case 7: S = [20, 11]; break; case 8: S = [32, 11]; break; case 9: S = [80, 33]; break; case 10: S = [18, 11]; break; case 11: S = [15, 11]; break; case 12: S = [64, 33]; break; case 13: S = [160, 99]; break; case 14: S = [4, 3]; break; case 15: S = [3, 2]; break; case 16: S = [2, 1]; break; case 255: S = [o() << 8 | o(), o() << 8 | o()] }return { width: Math.ceil((v + 1) * 16 - 2 * r - 2 * n), height: (2 - x) * (y + 1) * 16 - (x ? 2 : 4) * (s + a), pixelRatio: S } } readSliceType() { return this.readUByte(), this.readUEG(), this.readUEG() } } class ik extends iD { parseAVCPES(e, t, i, r, n) { let s; let a = this.parseAVCNALu(e, i.data), o = this.VideoSample, l = !1; i.data = null, o && a.length && !e.audFound && (this.pushAccessUnit(o, e), o = this.VideoSample = this.createVideoSample(!1, i.pts, i.dts, "")), a.forEach(r => { var a, u, h, c; switch (r.type) { case 1: { let t = !1; s = !0; let n = r.data; if (l && n.length > 4) { let e = new iO(n).readSliceType(); (2 === e || 4 === e || 7 === e || 9 === e) && (t = !0) } t && null != (u = o) && u.frame && !o.key && (this.pushAccessUnit(o, e), o = this.VideoSample = null), o || (o = this.VideoSample = this.createVideoSample(!0, i.pts, i.dts, "")), o.frame = !0, o.key = t; break } case 5: s = !0, null != (a = o) && a.frame && !o.key && (this.pushAccessUnit(o, e), o = this.VideoSample = null), o || (o = this.VideoSample = this.createVideoSample(!0, i.pts, i.dts, "")), o.key = !0, o.frame = !0; break; case 6: s = !0, eT(r.data, 1, i.pts, t.samples); break; case 7: { s = !0, l = !0; let t = r.data, i = new iO(t).readSPS(); if (!e.sps || e.width !== i.width || e.height !== i.height || (null == (h = e.pixelRatio) ? void 0 : h[0]) !== i.pixelRatio[0] || (null == (c = e.pixelRatio) ? void 0 : c[1]) !== i.pixelRatio[1]) { e.width = i.width, e.height = i.height, e.pixelRatio = i.pixelRatio, e.sps = [t], e.duration = n; let r = t.subarray(1, 4), s = "avc1."; for (let e = 0; e < 3; e++) { let t = r[e].toString(16); t.length < 2 && (t = "0" + t), s += t } e.codec = s } break } case 8: s = !0, e.pps = [r.data]; break; case 9: s = !0, e.audFound = !0, o && this.pushAccessUnit(o, e), o = this.VideoSample = this.createVideoSample(!1, i.pts, i.dts, ""); break; case 12: s = !0; break; default: s = !1, o && (o.debug += "unknown NAL " + r.type + " ") }o && s && o.units.push(r) }), r && o && (this.pushAccessUnit(o, e), this.VideoSample = null) } parseAVCNALu(e, t) { let i, r, n; let s = t.byteLength, a = e.naluState || 0, o = a, l = [], u = 0, h = -1, c = 0; for (-1 === a && (h = 0, c = 31 & t[0], a = 0, u = 1); u < s;) { if (i = t[u++], !a) { a = i ? 0 : 1; continue } if (1 === a) { a = i ? 0 : 2; continue } if (i) { if (1 === i) { if (r = u - a - 1, h >= 0) { let e = { data: t.subarray(h, r), type: c }; l.push(e) } else { let i = this.getLastNalUnit(e.samples); i && (o && u <= 4 - o && i.state && (i.data = i.data.subarray(0, i.data.byteLength - o)), r > 0 && (i.data = eE(i.data, t.subarray(0, r)), i.state = 0)) } u < s ? (n = 31 & t[u], h = u, c = n, a = 0) : a = -1 } else a = 0 } else a = 3 } if (h >= 0 && a >= 0) { let e = { data: t.subarray(h, s), type: c, state: a }; l.push(e) } if (0 === l.length) { let i = this.getLastNalUnit(e.samples); i && (i.data = eE(i.data, t)) } return e.naluState = a, l } } class iF { constructor(e, t, i) { this.keyData = void 0, this.decrypter = void 0, this.keyData = i, this.decrypter = new it(t, { removePKCS7Padding: !1 }) } decryptBuffer(e) { return this.decrypter.decrypt(e, this.keyData.key.buffer, this.keyData.iv.buffer) } decryptAacSample(e, t, i) { let r = e[t].unit; if (r.length <= 16) return; let n = r.subarray(16, r.length - r.length % 16), s = n.buffer.slice(n.byteOffset, n.byteOffset + n.length); this.decryptBuffer(s).then(n => { let s = new Uint8Array(n); r.set(s, 16), this.decrypter.isSync() || this.decryptAacSamples(e, t + 1, i) }) } decryptAacSamples(e, t, i) { for (; ; t++) { if (t >= e.length) { i(); return } if (!(e[t].unit.length < 32) && (this.decryptAacSample(e, t, i), !this.decrypter.isSync())) return } } getAvcEncryptedData(e) { let t = new Int8Array(16 * Math.floor((e.length - 48) / 160) + 16), i = 0; for (let r = 32; r < e.length - 16; r += 160, i += 16)t.set(e.subarray(r, r + 16), i); return t } getAvcDecryptedUnit(e, t) { let i = new Uint8Array(t), r = 0; for (let t = 32; t < e.length - 16; t += 160, r += 16)e.set(i.subarray(r, r + 16), t); return e } decryptAvcSample(e, t, i, r, n) { let s = ew(n.data), a = this.getAvcEncryptedData(s); this.decryptBuffer(a.buffer).then(a => { n.data = this.getAvcDecryptedUnit(s, a), this.decrypter.isSync() || this.decryptAvcSamples(e, t, i + 1, r) }) } decryptAvcSamples(e, t, i, r) { if (e instanceof Uint8Array) throw Error("Cannot decrypt samples of type Uint8Array"); for (; ; t++, i = 0) { if (t >= e.length) { r(); return } let n = e[t].units; for (; !(i >= n.length); i++) { let s = n[i]; if (!(s.data.length <= 48) && (1 === s.type || 5 === s.type) && (this.decryptAvcSample(e, t, i, r, s), !this.decrypter.isSync())) return } } } } class iU { constructor(e, t, i) { this.observer = void 0, this.config = void 0, this.typeSupported = void 0, this.sampleAes = null, this.pmtParsed = !1, this.audioCodec = void 0, this.videoCodec = void 0, this._duration = 0, this._pmtId = -1, this._videoTrack = void 0, this._audioTrack = void 0, this._id3Track = void 0, this._txtTrack = void 0, this.aacOverFlow = null, this.remainderData = null, this.videoParser = void 0, this.observer = e, this.config = t, this.typeSupported = i, this.videoParser = new ik } static probe(e) { let t = iU.syncOffset(e); return t > 0 && E.warn(`MPEG2-TS detected but first sync word found @ offset ${t}`), -1 !== t } static syncOffset(e) { let t = e.length, i = Math.min(940, t - 188) + 1, r = 0; for (; r < i;) { let n = !1, s = -1, a = 0; for (let o = r; o < t; o += 188)if (71 === e[o] && (t - o == 188 || 71 === e[o + 188])) { if (a++, -1 === s && 0 !== (s = o) && (i = Math.min(s + 18612, e.length - 188) + 1), n || (n = 0 === iN(e, o)), n && a > 1 && (0 === s && a > 2 || o + 188 > i)) return s } else if (a) return -1; else break; r++ } return -1 } static createTrack(e, t) { return { container: "video" === e || "audio" === e ? "video/mp2t" : void 0, type: e, id: eh[e], pid: -1, inputTimeScale: 9e4, sequenceNumber: 0, samples: [], dropped: 0, duration: "audio" === e ? t : void 0 } } resetInitSegment(e, t, i, r) { this.pmtParsed = !1, this._pmtId = -1, this._videoTrack = iU.createTrack("video"), this._audioTrack = iU.createTrack("audio", r), this._id3Track = iU.createTrack("id3"), this._txtTrack = iU.createTrack("text"), this._audioTrack.segmentCodec = "aac", this.aacOverFlow = null, this.remainderData = null, this.audioCodec = t, this.videoCodec = i, this._duration = r } resetTimeStamp() { } resetContiguity() { let { _audioTrack: e, _videoTrack: t, _id3Track: i } = this; e && (e.pesData = null), t && (t.pesData = null), i && (i.pesData = null), this.aacOverFlow = null, this.remainderData = null } demux(e, t, i = !1, r = !1) { let n; i || (this.sampleAes = null); let s = this._videoTrack, a = this._audioTrack, o = this._id3Track, l = this._txtTrack, u = s.pid, h = s.pesData, c = a.pid, d = o.pid, f = a.pesData, p = o.pesData, m = null, g = this.pmtParsed, v = this._pmtId, y = e.length; if (this.remainderData && (y = (e = eE(this.remainderData, e)).length, this.remainderData = null), y < 188 && !r) return this.remainderData = e, { audioTrack: a, videoTrack: s, id3Track: o, textTrack: l }; let x = Math.max(0, iU.syncOffset(e)); (y -= (y - x) % 188) < e.byteLength && !r && (this.remainderData = new Uint8Array(e.buffer, y, e.buffer.byteLength - y)); let S = 0; for (let t = x; t < y; t += 188)if (71 === e[t]) { let r; let y = !!(64 & e[t + 1]), S = iN(e, t); if ((48 & e[t + 3]) >> 4 > 1) { if ((r = t + 5 + e[t + 4]) === t + 188) continue } else r = t + 4; switch (S) { case u: y && (h && (n = iG(h)) && this.videoParser.parseAVCPES(s, l, n, !1, this._duration), h = { data: [], size: 0 }), h && (h.data.push(e.subarray(r, t + 188)), h.size += t + 188 - r); break; case c: if (y) { if (f && (n = iG(f))) switch (a.segmentCodec) { case "aac": this.parseAACPES(a, n); break; case "mp3": this.parseMPEGPES(a, n); break; case "ac3": this.parseAC3PES(a, n) }f = { data: [], size: 0 } } f && (f.data.push(e.subarray(r, t + 188)), f.size += t + 188 - r); break; case d: y && (p && (n = iG(p)) && this.parseID3PES(o, n), p = { data: [], size: 0 }), p && (p.data.push(e.subarray(r, t + 188)), p.size += t + 188 - r); break; case 0: var A, _; y && (r += e[r] + 1), v = this._pmtId = (31 & (A = e)[(_ = r) + 10]) << 8 | A[_ + 11]; break; case v: { y && (r += e[r] + 1); let n = function (e, t, i, r, n) { let s = { audioPid: -1, videoPid: -1, id3Pid: -1, segmentVideoCodec: "avc", segmentAudioCodec: "aac" }, a = (15 & e[t + 1]) << 8 | e[t + 2], o = t + 3 + a - 4, l = (15 & e[t + 10]) << 8 | e[t + 11]; for (t += 12 + l; t < o;) { let a = iN(e, t), o = (15 & e[t + 3]) << 8 | e[t + 4]; switch (e[t]) { case 207: if (!r) { iz("ADTS AAC"); break } case 15: -1 === s.audioPid && (s.audioPid = a); break; case 21: -1 === s.id3Pid && (s.id3Pid = a); break; case 219: if (!r) { iz("H.264"); break } case 27: -1 === s.videoPid && (s.videoPid = a, s.segmentVideoCodec = "avc"); break; case 3: case 4: i.mpeg || i.mp3 ? -1 === s.audioPid && (s.audioPid = a, s.segmentAudioCodec = "mp3") : E.log("MPEG audio found, not supported in this browser"); break; case 193: if (!r) { iz("AC-3"); break } case 129: i.ac3 ? -1 === s.audioPid && (s.audioPid = a, s.segmentAudioCodec = "ac3") : E.log("AC-3 audio found, not supported in this browser"); break; case 6: if (-1 === s.audioPid && o > 0) { let r = t + 5, n = o; for (; n > 2;) { 106 === e[r] && (!0 !== i.ac3 ? E.log("AC-3 audio found, not supported in this browser for now") : (s.audioPid = a, s.segmentAudioCodec = "ac3")); let t = e[r + 1] + 2; r += t, n -= t } } break; case 194: case 135: return iB(n, Error("Unsupported EC-3 in M2TS found")), s; case 36: return iB(n, Error("Unsupported HEVC in M2TS found")), s }t += o + 5 } return s }(e, r, this.typeSupported, i, this.observer); (u = n.videoPid) > 0 && (s.pid = u, s.segmentCodec = n.segmentVideoCodec), (c = n.audioPid) > 0 && (a.pid = c, a.segmentCodec = n.segmentAudioCodec), (d = n.id3Pid) > 0 && (o.pid = d), null === m || g || (E.warn(`MPEG-TS PMT found at ${t} after unknown PID '${m}'. Backtracking to sync byte @${x} to parse all TS packets.`), m = null, t = x - 188), g = this.pmtParsed = !0; break } case 17: case 8191: break; default: m = S } } else S++; S > 0 && iB(this.observer, Error(`Found ${S} TS packet/s that do not start with 0x47`)), s.pesData = h, a.pesData = f, o.pesData = p; let b = { audioTrack: a, videoTrack: s, id3Track: o, textTrack: l }; return r && this.extractRemainingSamples(b), b } flush() { let e; let { remainderData: t } = this; return (this.remainderData = null, e = t ? this.demux(t, -1, !1, !0) : { videoTrack: this._videoTrack, audioTrack: this._audioTrack, id3Track: this._id3Track, textTrack: this._txtTrack }, this.extractRemainingSamples(e), this.sampleAes) ? this.decrypt(e, this.sampleAes) : e } extractRemainingSamples(e) { let t; let { audioTrack: i, videoTrack: r, id3Track: n, textTrack: s } = e, a = r.pesData, o = i.pesData, l = n.pesData; if (a && (t = iG(a)) ? (this.videoParser.parseAVCPES(r, s, t, !0, this._duration), r.pesData = null) : r.pesData = a, o && (t = iG(o))) { switch (i.segmentCodec) { case "aac": this.parseAACPES(i, t); break; case "mp3": this.parseMPEGPES(i, t); break; case "ac3": this.parseAC3PES(i, t) }i.pesData = null } else null != o && o.size && E.log("last AAC PES packet truncated,might overlap between fragments"), i.pesData = o; l && (t = iG(l)) ? (this.parseID3PES(n, t), n.pesData = null) : n.pesData = l } demuxSampleAes(e, t, i) { let r = this.demux(e, i, !0, !this.config.progressive), n = this.sampleAes = new iF(this.observer, this.config, t); return this.decrypt(r, n) } decrypt(e, t) { return new Promise(i => { let { audioTrack: r, videoTrack: n } = e; r.samples && "aac" === r.segmentCodec ? t.decryptAacSamples(r.samples, 0, () => { n.samples ? t.decryptAvcSamples(n.samples, 0, 0, () => { i(e) }) : i(e) }) : n.samples && t.decryptAvcSamples(n.samples, 0, 0, () => { i(e) }) }) } destroy() { this._duration = 0 } parseAACPES(e, t) { let i, r, n, s, a = 0, o = this.aacOverFlow, l = t.data; if (o) { this.aacOverFlow = null; let t = o.missing, i = o.sample.unit.byteLength; -1 === t ? l = eE(o.sample.unit, l) : (o.sample.unit.set(l.subarray(0, t), i - t), e.samples.push(o.sample), a = o.missing) } for (i = a, r = l.length; i < r - 1 && !ip(l, i); i++); if (i !== a) { let e; let t = i < r - 1; if (e = t ? `AAC PES did not start with ADTS header,offset:${i}` : "No ADTS header found in AAC PES", iB(this.observer, Error(e), t), !t) return } if (im(e, this.observer, l, i, this.audioCodec), void 0 !== t.pts) n = t.pts; else if (o) { let t = 9216e4 / e.samplerate; n = o.sample.pts + t } else { E.warn("[tsdemuxer]: AAC PES unknown PTS"); return } let u = 0; for (; i < r;) { if (s = ig(e, l, i, n, u), i += s.length, s.missing) { this.aacOverFlow = s; break } for (u++; i < r - 1 && !ip(l, i); i++); } } parseMPEGPES(e, t) { let i = t.data, r = i.length, n = 0, s = 0, a = t.pts; if (void 0 === a) { E.warn("[tsdemuxer]: MPEG PES unknown PTS"); return } for (; s < r;)if (iT(i, s)) { let t = i_(e, i, s, a, n); if (t) s += t.length, n++; else break } else s++ } parseAC3PES(e, t) { { let i; let r = t.data, n = t.pts; if (void 0 === n) { E.warn("[tsdemuxer]: AC3 PES unknown PTS"); return } let s = r.length, a = 0, o = 0; for (; o < s && (i = iP(e, r, o, n, a++)) > 0;)o += i } } parseID3PES(e, t) { if (void 0 === t.pts) { E.warn("[tsdemuxer]: ID3 PES unknown PTS"); return } let i = f({}, t, { type: this._videoTrack ? ti.emsg : ti.audioId3, duration: Number.POSITIVE_INFINITY }); e.samples.push(i) } } function iN(e, t) { return ((31 & e[t + 1]) << 8) + e[t + 2] } function iB(e, t, i) { E.warn(`parsing error: ${t.message}`), e.emit(v.ERROR, v.ERROR, { type: y.MEDIA_ERROR, details: x.FRAG_PARSING_ERROR, fatal: !1, levelRetry: i, error: t, reason: t.message }) } function iz(e) { E.log(`${e} with AES-128-CBC encryption found in unencrypted stream`) } function iG(e) { let t, i, r, n, s, a = 0, o = e.data; if (!e || 0 === e.size) return null; for (; o[0].length < 19 && o.length > 1;)o[0] = eE(o[0], o[1]), o.splice(1, 1); if (1 === ((t = o[0])[0] << 16) + (t[1] << 8) + t[2]) { if ((i = (t[4] << 8) + t[5]) && i > e.size - 6) return null; let l = t[7]; 192 & l && (n = (14 & t[9]) * 0x20000000 + (255 & t[10]) * 4194304 + (254 & t[11]) * 16384 + (255 & t[12]) * 128 + (254 & t[13]) / 2, 64 & l ? n - (s = (14 & t[14]) * 0x20000000 + (255 & t[15]) * 4194304 + (254 & t[16]) * 16384 + (255 & t[17]) * 128 + (254 & t[18]) / 2) > 54e5 && (E.warn(`${Math.round((n - s) / 9e4)}s delta between PTS and DTS, align them`), n = s) : s = n); let u = (r = t[8]) + 9; if (e.size <= u) return null; e.size -= u; let h = new Uint8Array(e.size); for (let e = 0, i = o.length; e < i; e++) { let i = (t = o[e]).byteLength; if (u) { if (u > i) { u -= i; continue } t = t.subarray(u), i -= u, u = 0 } h.set(t, a), a += i } return i && (i -= r + 3), { data: h, pts: n, dts: s, len: i } } return null } class iH extends il { resetInitSegment(e, t, i, r) { super.resetInitSegment(e, t, i, r), this._audioTrack = { container: "audio/mpeg", type: "audio", id: 2, pid: -1, sequenceNumber: 0, segmentCodec: "mp3", samples: [], manifestCodec: t, duration: r, inputTimeScale: 9e4, dropped: 0 } } static probe(e) { if (!e) return !1; let t = q(e, 0), i = (null == t ? void 0 : t.length) || 0; if (t && 11 === e[i] && 119 === e[i + 1] && void 0 !== $(t) && 16 >= iI(e, i)) return !1; for (let t = e.length; i < t; i++)if (iw(e, i)) return E.log("MPEG Audio sync word found !"), !0; return !1 } canParse(e, t) { return ib(e, t) && 4 <= e.length - t } appendFrame(e, t, i) { if (null !== this.basePTS) return i_(e, t, i, this.basePTS, this.frameIndex) } } class iV { static getSilentFrame(e, t) { if ("mp4a.40.2" === e) { if (1 === t) return new Uint8Array([0, 200, 0, 128, 35, 128]); if (2 === t) return new Uint8Array([33, 0, 73, 144, 2, 25, 0, 35, 128]); if (3 === t) return new Uint8Array([0, 200, 0, 128, 32, 132, 1, 38, 64, 8, 100, 0, 142]); if (4 === t) return new Uint8Array([0, 200, 0, 128, 32, 132, 1, 38, 64, 8, 100, 0, 128, 44, 128, 8, 2, 56]); else if (5 === t) return new Uint8Array([0, 200, 0, 128, 32, 132, 1, 38, 64, 8, 100, 0, 130, 48, 4, 153, 0, 33, 144, 2, 56]); else if (6 === t) return new Uint8Array([0, 200, 0, 128, 32, 132, 1, 38, 64, 8, 100, 0, 130, 48, 4, 153, 0, 33, 144, 2, 0, 178, 0, 32, 8, 224]) } else { if (1 === t) return new Uint8Array([1, 64, 34, 128, 163, 78, 230, 128, 186, 8, 0, 0, 0, 28, 6, 241, 193, 10, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 94]); if (2 === t || 3 === t) return new Uint8Array([1, 64, 34, 128, 163, 94, 230, 128, 186, 8, 0, 0, 0, 0, 149, 0, 6, 241, 161, 10, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 94]) } } } class iW { static init() { let e; for (e in iW.types = { avc1: [], avcC: [], btrt: [], dinf: [], dref: [], esds: [], ftyp: [], hdlr: [], mdat: [], mdhd: [], mdia: [], mfhd: [], minf: [], moof: [], moov: [], mp4a: [], ".mp3": [], dac3: [], "ac-3": [], mvex: [], mvhd: [], pasp: [], sdtp: [], stbl: [], stco: [], stsc: [], stsd: [], stsz: [], stts: [], tfdt: [], tfhd: [], traf: [], trak: [], trun: [], trex: [], tkhd: [], vmhd: [], smhd: [] }, iW.types) iW.types.hasOwnProperty(e) && (iW.types[e] = [e.charCodeAt(0), e.charCodeAt(1), e.charCodeAt(2), e.charCodeAt(3)]); let t = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 118, 105, 100, 101, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 86, 105, 100, 101, 111, 72, 97, 110, 100, 108, 101, 114, 0]), i = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 115, 111, 117, 110, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 83, 111, 117, 110, 100, 72, 97, 110, 100, 108, 101, 114, 0]); iW.HDLR_TYPES = { video: t, audio: i }; let r = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 12, 117, 114, 108, 32, 0, 0, 0, 1]), n = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0]); iW.STTS = iW.STSC = iW.STCO = n, iW.STSZ = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]), iW.VMHD = new Uint8Array([0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0]), iW.SMHD = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0]), iW.STSD = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 1]); let s = new Uint8Array([105, 115, 111, 109]), a = new Uint8Array([97, 118, 99, 49]), o = new Uint8Array([0, 0, 0, 1]); iW.FTYP = iW.box(iW.types.ftyp, s, o, s, a), iW.DINF = iW.box(iW.types.dinf, iW.box(iW.types.dref, r)) } static box(e, ...t) { let i = 8, r = t.length, n = r; for (; r--;)i += t[r].byteLength; let s = new Uint8Array(i); for (s[0] = i >> 24 & 255, s[1] = i >> 16 & 255, s[2] = i >> 8 & 255, s[3] = 255 & i, s.set(e, 4), r = 0, i = 8; r < n; r++)s.set(t[r], i), i += t[r].byteLength; return s } static hdlr(e) { return iW.box(iW.types.hdlr, iW.HDLR_TYPES[e]) } static mdat(e) { return iW.box(iW.types.mdat, e) } static mdhd(e, t) { let i = Math.floor((t *= e) / 0x100000000), r = Math.floor(t % 0x100000000); return iW.box(iW.types.mdhd, new Uint8Array([1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 3, e >> 24 & 255, e >> 16 & 255, e >> 8 & 255, 255 & e, i >> 24, i >> 16 & 255, i >> 8 & 255, 255 & i, r >> 24, r >> 16 & 255, r >> 8 & 255, 255 & r, 85, 196, 0, 0])) } static mdia(e) { return iW.box(iW.types.mdia, iW.mdhd(e.timescale, e.duration), iW.hdlr(e.type), iW.minf(e)) } static mfhd(e) { return iW.box(iW.types.mfhd, new Uint8Array([0, 0, 0, 0, e >> 24, e >> 16 & 255, e >> 8 & 255, 255 & e])) } static minf(e) { return "audio" === e.type ? iW.box(iW.types.minf, iW.box(iW.types.smhd, iW.SMHD), iW.DINF, iW.stbl(e)) : iW.box(iW.types.minf, iW.box(iW.types.vmhd, iW.VMHD), iW.DINF, iW.stbl(e)) } static moof(e, t, i) { return iW.box(iW.types.moof, iW.mfhd(e), iW.traf(i, t)) } static moov(e) { let t = e.length, i = []; for (; t--;)i[t] = iW.trak(e[t]); return iW.box.apply(null, [iW.types.moov, iW.mvhd(e[0].timescale, e[0].duration)].concat(i).concat(iW.mvex(e))) } static mvex(e) { let t = e.length, i = []; for (; t--;)i[t] = iW.trex(e[t]); return iW.box.apply(null, [iW.types.mvex, ...i]) } static mvhd(e, t) { let i = Math.floor((t *= e) / 0x100000000), r = Math.floor(t % 0x100000000), n = new Uint8Array([1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 3, e >> 24 & 255, e >> 16 & 255, e >> 8 & 255, 255 & e, i >> 24, i >> 16 & 255, i >> 8 & 255, 255 & i, r >> 24, r >> 16 & 255, r >> 8 & 255, 255 & r, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 64, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 255, 255, 255, 255]); return iW.box(iW.types.mvhd, n) } static sdtp(e) { let t, i; let r = e.samples || [], n = new Uint8Array(4 + r.length); for (t = 0; t < r.length; t++)i = r[t].flags, n[t + 4] = i.dependsOn << 4 | i.isDependedOn << 2 | i.hasRedundancy; return iW.box(iW.types.sdtp, n) } static stbl(e) { return iW.box(iW.types.stbl, iW.stsd(e), iW.box(iW.types.stts, iW.STTS), iW.box(iW.types.stsc, iW.STSC), iW.box(iW.types.stsz, iW.STSZ), iW.box(iW.types.stco, iW.STCO)) } static avc1(e) { let t, i, r, n = [], s = []; for (t = 0; t < e.sps.length; t++)r = (i = e.sps[t]).byteLength, n.push(r >>> 8 & 255), n.push(255 & r), n = n.concat(Array.prototype.slice.call(i)); for (t = 0; t < e.pps.length; t++)r = (i = e.pps[t]).byteLength, s.push(r >>> 8 & 255), s.push(255 & r), s = s.concat(Array.prototype.slice.call(i)); let a = iW.box(iW.types.avcC, new Uint8Array([1, n[3], n[4], n[5], 255, 224 | e.sps.length].concat(n).concat([e.pps.length]).concat(s))), o = e.width, l = e.height, u = e.pixelRatio[0], h = e.pixelRatio[1]; return iW.box(iW.types.avc1, new Uint8Array([0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, o >> 8 & 255, 255 & o, l >> 8 & 255, 255 & l, 0, 72, 0, 0, 0, 72, 0, 0, 0, 0, 0, 0, 0, 1, 18, 100, 97, 105, 108, 121, 109, 111, 116, 105, 111, 110, 47, 104, 108, 115, 46, 106, 115, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 24, 17, 17]), a, iW.box(iW.types.btrt, new Uint8Array([0, 28, 156, 128, 0, 45, 198, 192, 0, 45, 198, 192])), iW.box(iW.types.pasp, new Uint8Array([u >> 24, u >> 16 & 255, u >> 8 & 255, 255 & u, h >> 24, h >> 16 & 255, h >> 8 & 255, 255 & h]))) } static esds(e) { let t = e.config.length; return new Uint8Array([0, 0, 0, 0, 3, 23 + t, 0, 1, 0, 4, 15 + t, 64, 21, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5].concat([t]).concat(e.config).concat([6, 1, 2])) } static audioStsd(e) { let t = e.samplerate; return new Uint8Array([0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, e.channelCount, 0, 16, 0, 0, 0, 0, t >> 8 & 255, 255 & t, 0, 0]) } static mp4a(e) { return iW.box(iW.types.mp4a, iW.audioStsd(e), iW.box(iW.types.esds, iW.esds(e))) } static mp3(e) { return iW.box(iW.types[".mp3"], iW.audioStsd(e)) } static ac3(e) { return iW.box(iW.types["ac-3"], iW.audioStsd(e), iW.box(iW.types.dac3, e.config)) } static stsd(e) { return "audio" !== e.type ? iW.box(iW.types.stsd, iW.STSD, iW.avc1(e)) : "mp3" === e.segmentCodec && "mp3" === e.codec ? iW.box(iW.types.stsd, iW.STSD, iW.mp3(e)) : "ac3" === e.segmentCodec ? iW.box(iW.types.stsd, iW.STSD, iW.ac3(e)) : iW.box(iW.types.stsd, iW.STSD, iW.mp4a(e)) } static tkhd(e) { let t = e.id, i = e.duration * e.timescale, r = e.width, n = e.height, s = Math.floor(i / 0x100000000), a = Math.floor(i % 0x100000000); return iW.box(iW.types.tkhd, new Uint8Array([1, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 3, t >> 24 & 255, t >> 16 & 255, t >> 8 & 255, 255 & t, 0, 0, 0, 0, s >> 24, s >> 16 & 255, s >> 8 & 255, 255 & s, a >> 24, a >> 16 & 255, a >> 8 & 255, 255 & a, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 64, 0, 0, 0, r >> 8 & 255, 255 & r, 0, 0, n >> 8 & 255, 255 & n, 0, 0])) } static traf(e, t) { let i = iW.sdtp(e), r = e.id, n = Math.floor(t / 0x100000000), s = Math.floor(t % 0x100000000); return iW.box(iW.types.traf, iW.box(iW.types.tfhd, new Uint8Array([0, 0, 0, 0, r >> 24, r >> 16 & 255, r >> 8 & 255, 255 & r])), iW.box(iW.types.tfdt, new Uint8Array([1, 0, 0, 0, n >> 24, n >> 16 & 255, n >> 8 & 255, 255 & n, s >> 24, s >> 16 & 255, s >> 8 & 255, 255 & s])), iW.trun(e, i.length + 16 + 20 + 8 + 16 + 8 + 8), i) } static trak(e) { return e.duration = e.duration || 0xffffffff, iW.box(iW.types.trak, iW.tkhd(e), iW.mdia(e)) } static trex(e) { let t = e.id; return iW.box(iW.types.trex, new Uint8Array([0, 0, 0, 0, t >> 24, t >> 16 & 255, t >> 8 & 255, 255 & t, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1])) } static trun(e, t) { let i, r, n, s, a, o; let l = e.samples || [], u = l.length, h = 12 + 16 * u, c = new Uint8Array(h); for (t += 8 + h, c.set(["video" === e.type ? 1 : 0, 0, 15, 1, u >>> 24 & 255, u >>> 16 & 255, u >>> 8 & 255, 255 & u, t >>> 24 & 255, t >>> 16 & 255, t >>> 8 & 255, 255 & t], 0), i = 0; i < u; i++)n = (r = l[i]).duration, s = r.size, a = r.flags, o = r.cts, c.set([n >>> 24 & 255, n >>> 16 & 255, n >>> 8 & 255, 255 & n, s >>> 24 & 255, s >>> 16 & 255, s >>> 8 & 255, 255 & s, a.isLeading << 2 | a.dependsOn, a.isDependedOn << 6 | a.hasRedundancy << 4 | a.paddingValue << 1 | a.isNonSync, 61440 & a.degradPrio, 15 & a.degradPrio, o >>> 24 & 255, o >>> 16 & 255, o >>> 8 & 255, 255 & o], 12 + 16 * i); return iW.box(iW.types.trun, c) } static initSegment(e) { iW.types || iW.init(); let t = iW.moov(e); return eE(iW.FTYP, t) } } function ij(e, t, i = 1, r = !1) { let n = e * t * i; return r ? Math.round(n) : n } function iY(e, t = !1) { return ij(e, 1e3, 11111111111111112e-21, t) } iW.types = void 0, iW.HDLR_TYPES = void 0, iW.STTS = void 0, iW.STSC = void 0, iW.STCO = void 0, iW.STSZ = void 0, iW.VMHD = void 0, iW.SMHD = void 0, iW.STSD = void 0, iW.FTYP = void 0, iW.DINF = void 0; let iX = null, iK = null; class iq { constructor(e, t, i, r = "") { if (this.observer = void 0, this.config = void 0, this.typeSupported = void 0, this.ISGenerated = !1, this._initPTS = null, this._initDTS = null, this.nextAvcDts = null, this.nextAudioPts = null, this.videoSampleDuration = null, this.isAudioContiguous = !1, this.isVideoContiguous = !1, this.videoTrackConfig = void 0, this.observer = e, this.config = t, this.typeSupported = i, this.ISGenerated = !1, null === iX) { let e = (navigator.userAgent || "").match(/Chrome\/(\d+)/i); iX = e ? parseInt(e[1]) : 0 } if (null === iK) { let e = navigator.userAgent.match(/Safari\/(\d+)/i); iK = e ? parseInt(e[1]) : 0 } } destroy() { this.config = this.videoTrackConfig = this._initPTS = this._initDTS = null } resetTimeStamp(e) { E.log("[mp4-remuxer]: initPTS & initDTS reset"), this._initPTS = this._initDTS = e } resetNextTimestamp() { E.log("[mp4-remuxer]: reset next timestamp"), this.isVideoContiguous = !1, this.isAudioContiguous = !1 } resetInitSegment() { E.log("[mp4-remuxer]: ISGenerated flag reset"), this.ISGenerated = !1, this.videoTrackConfig = void 0 } getVideoStartPts(e) { let t = !1, i = e[0].pts, r = e.reduce((e, r) => { let n = r.pts, s = n - e; return (s < -0x100000000 && (t = !0, s = (n = iQ(n, i)) - e), s > 0) ? e : n }, i); return t && E.debug("PTS rollover detected"), r } remux(e, t, i, r, n, s, a, o) { let l, u, h, c, d, f; let p = n, m = n, g = e.pid > -1, v = t.pid > -1, y = t.samples.length, x = e.samples.length > 0, S = a && y > 0 || y > 1; if ((!g || x) && (!v || S) || this.ISGenerated || a) { let i; if (this.ISGenerated) { var A, _, b, T; let e = this.videoTrackConfig; e && (t.width !== e.width || t.height !== e.height || (null == (A = t.pixelRatio) ? void 0 : A[0]) !== (null == (_ = e.pixelRatio) ? void 0 : _[0]) || (null == (b = t.pixelRatio) ? void 0 : b[1]) !== (null == (T = e.pixelRatio) ? void 0 : T[1])) && this.resetInitSegment() } else h = this.generateIS(e, t, n, s); let r = this.isVideoContiguous, a = -1; if (S && (a = function (e) { for (let t = 0; t < e.length; t++)if (e[t].key) return t; return -1 }(t.samples), !r && this.config.forceKeyFrameOnDiscontinuity)) { if (f = !0, a > 0) { E.warn(`[mp4-remuxer]: Dropped ${a} out of ${y} video samples due to a missing keyframe`); let e = this.getVideoStartPts(t.samples); t.samples = t.samples.slice(a), t.dropped += a, m += (t.samples[0].pts - e) / t.inputTimeScale, i = m } else -1 === a && (E.warn(`[mp4-remuxer]: No keyframe found out of ${y} video samples`), f = !1) } if (this.ISGenerated) { if (x && S) { let i = this.getVideoStartPts(t.samples), r = (iQ(e.samples[0].pts, i) - i) / t.inputTimeScale; p += Math.max(0, r), m += Math.max(0, -r) } if (x) { if (e.samplerate || (E.warn("[mp4-remuxer]: regenerate InitSegment as audio detected"), h = this.generateIS(e, t, n, s)), u = this.remuxAudio(e, p, this.isAudioContiguous, s, v || S || o === e3.AUDIO ? m : void 0), S) { let i = u ? u.endPTS - u.startPTS : 0; t.inputTimeScale || (E.warn("[mp4-remuxer]: regenerate InitSegment as video detected"), h = this.generateIS(e, t, n, s)), l = this.remuxVideo(t, m, r, i) } } else S && (l = this.remuxVideo(t, m, r, 0)); l && (l.firstKeyFrame = a, l.independent = -1 !== a, l.firstKeyFramePTS = i) } } return this.ISGenerated && this._initPTS && this._initDTS && (i.samples.length && (d = iZ(i, n, this._initPTS, this._initDTS)), r.samples.length && (c = i$(r, n, this._initPTS))), { audio: u, video: l, initSegment: h, independent: f, text: c, id3: d } } generateIS(e, t, i, r) { let n, s, a; let o = e.samples, l = t.samples, u = this.typeSupported, h = {}, c = this._initPTS, d = !c || r, f = "audio/mp4"; if (d && (n = s = 1 / 0), e.config && o.length) { switch (e.timescale = e.samplerate, e.segmentCodec) { case "mp3": u.mpeg ? (f = "audio/mpeg", e.codec = "") : u.mp3 && (e.codec = "mp3"); break; case "ac3": e.codec = "ac-3" }h.audio = { id: "audio", container: f, codec: e.codec, initSegment: "mp3" === e.segmentCodec && u.mpeg ? new Uint8Array(0) : iW.initSegment([e]), metadata: { channelCount: e.channelCount } }, d && (a = e.inputTimeScale, c && a === c.timescale ? d = !1 : n = s = o[0].pts - Math.round(a * i)) } if (t.sps && t.pps && l.length) { if (t.timescale = t.inputTimeScale, h.video = { id: "main", container: "video/mp4", codec: t.codec, initSegment: iW.initSegment([t]), metadata: { width: t.width, height: t.height } }, d) { if (a = t.inputTimeScale, c && a === c.timescale) d = !1; else { let e = this.getVideoStartPts(l), t = Math.round(a * i); s = Math.min(s, iQ(l[0].dts, e) - t), n = Math.min(n, e - t) } } this.videoTrackConfig = { width: t.width, height: t.height, pixelRatio: t.pixelRatio } } if (Object.keys(h).length) return this.ISGenerated = !0, d ? (this._initPTS = { baseTime: n, timescale: a }, this._initDTS = { baseTime: s, timescale: a }) : n = a = void 0, { tracks: h, initPTS: n, timescale: a } } remuxVideo(e, t, i, r) { let n, s, a; let o = e.inputTimeScale, l = e.samples, u = [], h = l.length, c = this._initPTS, d = this.nextAvcDts, p = 8, m = this.videoSampleDuration, g = Number.POSITIVE_INFINITY, S = Number.NEGATIVE_INFINITY, A = !1; if (!i || null === d) { let e = t * o, r = l[0].pts - iQ(l[0].dts, l[0].pts); iX && null !== d && 15e3 > Math.abs(e - r - d) ? i = !0 : d = e - r } let _ = c.baseTime * o / c.timescale; for (let e = 0; e < h; e++) { let t = l[e]; t.pts = iQ(t.pts - _, d), t.dts = iQ(t.dts - _, d), t.dts < l[e > 0 ? e - 1 : e].dts && (A = !0) } A && l.sort(function (e, t) { let i = e.dts - t.dts, r = e.pts - t.pts; return i || r }), n = l[0].dts; let b = (s = l[l.length - 1].dts) - n, T = b ? Math.round(b / (h - 1)) : m || e.inputTimeScale / 30; if (i) { let e = n - d, i = e > T, r = e < -1; if ((i || r) && (i ? E.warn(`AVC: ${iY(e, !0)} ms (${e}dts) hole between fragments detected at ${t.toFixed(3)}`) : E.warn(`AVC: ${iY(-e, !0)} ms (${e}dts) overlapping between fragments detected at ${t.toFixed(3)}`), !r || d >= l[0].pts || iX)) { n = d; let t = l[0].pts - e; if (i) l[0].dts = n, l[0].pts = t; else for (let i = 0; i < l.length && !(l[i].dts > t); i++)l[i].dts -= e, l[i].pts -= e; E.log(`Video: Initial PTS/DTS adjusted: ${iY(t, !0)}/${iY(n, !0)}, delta: ${iY(e, !0)} ms`) } } let w = 0, M = 0, R = n = Math.max(0, n); for (let e = 0; e < h; e++) { let t = l[e], i = t.units, r = i.length, n = 0; for (let e = 0; e < r; e++)n += i[e].data.length; M += n, w += r, t.length = n, t.dts < R ? (t.dts = R, R += T / 4 | 0 || 1) : R = t.dts, g = Math.min(t.pts, g), S = Math.max(t.pts, S) } s = l[h - 1].dts; let C = M + 4 * w + 8; try { a = new Uint8Array(C) } catch (e) { this.observer.emit(v.ERROR, v.ERROR, { type: y.MUX_ERROR, details: x.REMUX_ALLOC_ERROR, fatal: !1, error: e, bytes: C, reason: `fail allocating video mdat ${C}` }); return } let I = new DataView(a.buffer); I.setUint32(0, C), a.set(iW.types.mdat, 4); let L = !1, P = Number.POSITIVE_INFINITY, D = Number.POSITIVE_INFINITY, O = Number.NEGATIVE_INFINITY, k = Number.NEGATIVE_INFINITY; for (let e = 0; e < h; e++) { let t; let i = l[e], n = i.units, s = 0; for (let e = 0, t = n.length; e < t; e++) { let t = n[e], i = t.data, r = t.data.byteLength; I.setUint32(p, r), p += 4, a.set(i, p), p += r, s += 4 + r } if (e < h - 1) m = l[e + 1].dts - i.dts, t = l[e + 1].pts - i.pts; else { let n = this.config, s = e > 0 ? i.dts - l[e - 1].dts : T; if (t = e > 0 ? i.pts - l[e - 1].pts : T, n.stretchShortVideoTrack && null !== this.nextAudioPts) { let e = Math.floor(n.maxBufferHole * o), t = (r ? g + r * o : this.nextAudioPts) - i.pts; t > e ? ((m = t - s) < 0 ? m = s : L = !0, E.log(`[mp4-remuxer]: It is approximately ${t / 90} ms to the next segment; using duration ${m / 90} ms for the last video frame.`)) : m = s } else m = s } let c = Math.round(i.pts - i.dts); P = Math.min(P, m), O = Math.max(O, m), D = Math.min(D, t), k = Math.max(k, t), u.push(new iJ(i.key, m, s, c)) } if (u.length) { if (iX) { if (iX < 70) { let e = u[0].flags; e.dependsOn = 2, e.isNonSync = 0 } } else if (iK && k - D < O - P && T / O < .025 && 0 === u[0].cts) { E.warn("Found irregular gaps in sample duration. Using PTS instead of DTS to determine MP4 sample duration."); let e = n; for (let t = 0, i = u.length; t < i; t++) { let r = e + u[t].duration, n = e + u[t].cts; if (t < i - 1) { let e = r + u[t + 1].cts; u[t].duration = e - n } else u[t].duration = t ? u[t - 1].duration : T; u[t].cts = 0, e = r } } } m = L || !m ? T : m, this.nextAvcDts = d = s + m, this.videoSampleDuration = m, this.isVideoContiguous = !0; let F = { data1: iW.moof(e.sequenceNumber++, n, f({}, e, { samples: u })), data2: a, startPTS: g / o, endPTS: (S + m) / o, startDTS: n / o, endDTS: d / o, type: "video", hasAudio: !1, hasVideo: !0, nb: u.length, dropped: e.dropped }; return e.samples = [], e.dropped = 0, F } getSamplesPerFrame(e) { switch (e.segmentCodec) { case "mp3": return 1152; case "ac3": return 1536; default: return 1024 } } remuxAudio(e, t, i, r, n) { let s; let a = e.inputTimeScale, o = e.samplerate ? e.samplerate : a, l = a / o, u = this.getSamplesPerFrame(e), h = u * l, c = this._initPTS, d = "mp3" === e.segmentCodec && this.typeSupported.mpeg, p = [], m = void 0 !== n, g = e.samples, S = d ? 0 : 8, A = this.nextAudioPts || -1, _ = t * a, b = c.baseTime * a / c.timescale; if (this.isAudioContiguous = i = i || g.length && A > 0 && (r && 9e3 > Math.abs(_ - A) || Math.abs(iQ(g[0].pts - b, _) - A) < 20 * h), g.forEach(function (e) { e.pts = iQ(e.pts - b, _) }), !i || A < 0) { if (!(g = g.filter(e => e.pts >= 0)).length) return; A = 0 === n ? 0 : r && !m ? Math.max(0, _) : g[0].pts } if ("aac" === e.segmentCodec) { let t = this.config.maxAudioFramesDrift; for (let i = 0, r = A; i < g.length; i++) { let n = g[i], s = n.pts, o = s - r, l = Math.abs(1e3 * o / a); if (o <= -t * h && m) 0 === i && (E.warn(`Audio frame @ ${(s / a).toFixed(3)}s overlaps nextAudioPts by ${Math.round(1e3 * o / a)} ms.`), this.nextAudioPts = A = r = s); else if (o >= t * h && l < 1e4 && m) { let t = Math.round(o / h); (r = s - t * h) < 0 && (t--, r += h), 0 === i && (this.nextAudioPts = A = r), E.warn(`[mp4-remuxer]: Injecting ${t} audio frame @ ${(r / a).toFixed(3)}s due to ${Math.round(1e3 * o / a)} ms gap.`); for (let s = 0; s < t; s++) { let t = Math.max(r, 0), s = iV.getSilentFrame(e.manifestCodec || e.codec, e.channelCount); s || (E.log("[mp4-remuxer]: Unable to get silent frame for given audio codec; duplicating last frame instead."), s = n.unit.subarray()), g.splice(i, 0, { unit: s, pts: t }), r += h, i++ } } n.pts = r, r += h } } let T = null, w = null, M = 0, R = g.length; for (; R--;)M += g[R].unit.byteLength; for (let t = 0, r = g.length; t < r; t++) { let r = g[t], n = r.unit, a = r.pts; if (null !== w) p[t - 1].duration = Math.round((a - w) / l); else { if (i && "aac" === e.segmentCodec && (a = A), T = a, !(M > 0)) return; M += S; try { s = new Uint8Array(M) } catch (e) { this.observer.emit(v.ERROR, v.ERROR, { type: y.MUX_ERROR, details: x.REMUX_ALLOC_ERROR, fatal: !1, error: e, bytes: M, reason: `fail allocating audio mdat ${M}` }); return } d || (new DataView(s.buffer).setUint32(0, M), s.set(iW.types.mdat, 4)) } s.set(n, S); let o = n.byteLength; S += o, p.push(new iJ(!0, u, o, 0)), w = a } let C = p.length; if (!C) return; let I = p[p.length - 1]; this.nextAudioPts = A = w + l * I.duration; let L = d ? new Uint8Array(0) : iW.moof(e.sequenceNumber++, T / l, f({}, e, { samples: p })); e.samples = []; let P = T / a, D = A / a, O = { data1: L, data2: s, startPTS: P, endPTS: D, startDTS: P, endDTS: D, type: "audio", hasAudio: !0, hasVideo: !1, nb: C }; return this.isAudioContiguous = !0, O } remuxEmptyAudio(e, t, i, r) { let n = e.inputTimeScale, s = e.samplerate ? e.samplerate : n, a = this.nextAudioPts, o = this._initDTS, l = 9e4 * o.baseTime / o.timescale, u = (null !== a ? a : r.startDTS * n) + l, h = r.endDTS * n + l, c = n / s * 1024, d = Math.ceil((h - u) / c), f = iV.getSilentFrame(e.manifestCodec || e.codec, e.channelCount); if (E.warn("[mp4-remuxer]: remux empty Audio"), !f) { E.trace("[mp4-remuxer]: Unable to remuxEmptyAudio since we were unable to get a silent frame for given audio codec"); return } let p = []; for (let e = 0; e < d; e++) { let t = u + e * c; p.push({ unit: f, pts: t, dts: t }) } return e.samples = p, this.remuxAudio(e, t, i, !1) } } function iQ(e, t) { let i; if (null === t) return e; for (i = t < e ? -0x200000000 : 0x200000000; Math.abs(e - t) > 0x100000000;)e += i; return e } function iZ(e, t, i, r) { let n = e.samples.length; if (!n) return; let s = e.inputTimeScale; for (let a = 0; a < n; a++) { let n = e.samples[a]; n.pts = iQ(n.pts - i.baseTime * s / i.timescale, t * s) / s, n.dts = iQ(n.dts - r.baseTime * s / r.timescale, t * s) / s } let a = e.samples; return e.samples = [], { samples: a } } function i$(e, t, i) { let r = e.samples.length; if (!r) return; let n = e.inputTimeScale; for (let s = 0; s < r; s++) { let r = e.samples[s]; r.pts = iQ(r.pts - i.baseTime * n / i.timescale, t * n) / n } e.samples.sort((e, t) => e.pts - t.pts); let s = e.samples; return e.samples = [], { samples: s } } class iJ { constructor(e, t, i, r) { this.size = void 0, this.duration = void 0, this.cts = void 0, this.flags = void 0, this.duration = t, this.size = i, this.cts = r, this.flags = { isLeading: 0, isDependedOn: 0, hasRedundancy: 0, degradPrio: 0, dependsOn: e ? 2 : 1, isNonSync: e ? 0 : 1 } } } class i0 { constructor() { this.emitInitSegment = !1, this.audioCodec = void 0, this.videoCodec = void 0, this.initData = void 0, this.initPTS = null, this.initTracks = void 0, this.lastEndTime = null } destroy() { } resetTimeStamp(e) { this.initPTS = e, this.lastEndTime = null } resetNextTimestamp() { this.lastEndTime = null } resetInitSegment(e, t, i, r) { this.audioCodec = t, this.videoCodec = i, this.generateInitSegment(function (e, t) { if (!e || !t) return e; let i = t.keyId; return i && t.isCommonEncryption && ev(e, ["moov", "trak"]).forEach(e => { let t = ev(e, ["mdia", "minf", "stbl", "stsd"])[0].subarray(8), r = ev(t, ["enca"]), n = r.length > 0; n || (r = ev(t, ["encv"])), r.forEach(e => { ev(n ? e.subarray(28) : e.subarray(78), ["sinf"]).forEach(e => { let t = e_(e); if (t) { let e = t.subarray(8, 24); e.some(e => 0 !== e) || (E.log(`[eme] Patching keyId in 'enc${n ? "a" : "v"}>sinf>>tenc' box: ${el.hexDump(e)} -> ${el.hexDump(i)}`), t.set(i, 8)) } }) }) }), e }(e, r)), this.emitInitSegment = !0 } generateInitSegment(e) { let { audioCodec: t, videoCodec: i } = this; if (!(null != e && e.byteLength)) { this.initTracks = void 0, this.initData = void 0; return } let r = this.initData = ey(e); r.audio && (t = i1(r.audio, C.AUDIO)), r.video && (i = i1(r.video, C.VIDEO)); let n = {}; r.audio && r.video ? n.audiovideo = { container: "video/mp4", codec: t + "," + i, initSegment: e, id: "main" } : r.audio ? n.audio = { container: "audio/mp4", codec: t, initSegment: e, id: "audio" } : r.video ? n.video = { container: "video/mp4", codec: i, initSegment: e, id: "main" } : E.warn("[passthrough-remuxer.ts]: initSegment does not contain moov or trak boxes."), this.initTracks = n } remux(e, t, i, r, n, s) { var a, o, l; let { initPTS: u, lastEndTime: h } = this, c = { audio: void 0, video: void 0, text: r, id3: i, initSegment: void 0 }; p(h) || (h = this.lastEndTime = n || 0); let d = t.samples; if (!(null != d && d.length)) return c; let f = { initPTS: void 0, timescale: 1 }, m = this.initData; if (null != (a = m) && a.length || (this.generateInitSegment(d), m = this.initData), !(null != (o = m) && o.length)) return E.warn("[passthrough-remuxer.ts]: Failed to generate initSegment."), c; this.emitInitSegment && (f.tracks = this.initTracks, this.emitInitSegment = !1); let g = function (e, t) { let i = 0, r = 0, n = 0, s = ev(e, ["moof", "traf"]); for (let e = 0; e < s.length; e++) { let a = s[e], o = ev(a, ["tfhd"])[0], l = t[ef(o, 4)]; if (!l) continue; let u = l.default, h = ef(o, 0) | (null == u ? void 0 : u.flags), c = null == u ? void 0 : u.duration; 8 & h && (c = 2 & h ? ef(o, 12) : ef(o, 8)); let d = l.timescale || 9e4, f = ev(a, ["trun"]); for (let e = 0; e < f.length; e++)(i = function (e) { let t = ef(e, 0), i = 8; 1 & t && (i += 4), 4 & t && (i += 4); let r = 0, n = ef(e, 4); for (let s = 0; s < n; s++)256 & t && (r += ef(e, i), i += 4), 512 & t && (i += 4), 1024 & t && (i += 4), 2048 & t && (i += 4); return r }(f[e])) || !c || (i = c * ef(f[e], 4)), l.type === C.VIDEO ? r += i / d : l.type === C.AUDIO && (n += i / d) } if (0 === r && 0 === n) { let t = 1 / 0, i = 0, r = 0, n = ev(e, ["sidx"]); for (let e = 0; e < n.length; e++) { let s = function (e) { let t = [], i = e[0], r = 8, n = ef(e, 8); r += 4; let s = 0, a = 0; 0 === i ? (s = ef(e, r), a = ef(e, r + 4), r += 8) : (s = ep(e, r), a = ep(e, r + 8), r += 16), r += 2; let o = e.length + a, l = ed(e, r); r += 2; for (let i = 0; i < l; i++) { let i = r, s = ef(e, i); i += 4; let a = 0x7fffffff & s; if (1 == (0x80000000 & s) >>> 31) return E.warn("SIDX has hierarchical references (not supported)"), null; let l = ef(e, i); i += 4, t.push({ referenceSize: a, subsegmentDuration: l, info: { duration: l / n, start: o, end: o + a - 1 } }), o += a, i += 4, r = i } return { earliestPresentationTime: s, timescale: n, version: i, referencesCount: l, references: t } }(n[e]); null != s && s.references && (t = Math.min(t, s.earliestPresentationTime / s.timescale), r = (i = Math.max(i, s.references.reduce((e, t) => e + t.info.duration || 0, 0) + s.earliestPresentationTime / s.timescale)) - t) } if (r && p(r)) return r } return r || n }(d, m), v = (l = m, ev(d, ["moof", "traf"]).reduce((e, t) => { let i = ev(t, ["tfdt"])[0], r = i[0], n = ev(t, ["tfhd"]).reduce((e, t) => { let n = l[ef(t, 4)]; if (n) { let t = ef(i, 4); if (1 === r) { if (0xffffffff === t) return E.warn("[mp4-demuxer]: Ignoring assumed invalid signed 64-bit track fragment decode time"), e; t *= 0x100000000, t += ef(i, 8) } let s = t / (n.timescale || 9e4); if (p(s) && (null === e || s < e)) return s } return e }, null); return null !== n && p(n) && (null === e || n < e) ? n : e }, null)), y = null === v ? n : v; ((function (e, t, i, r) { if (null === e) return !0; let n = Math.max(r, 1); return Math.abs(t - e.baseTime / e.timescale - i) > n })(u, y, n, g) || f.timescale !== u.timescale && s) && (f.initPTS = y - n, u && 1 === u.timescale && E.warn(`Adjusting initPTS by ${f.initPTS - u.baseTime}`), this.initPTS = u = { baseTime: f.initPTS, timescale: 1 }); let x = e ? y - u.baseTime / u.timescale : h, S = x + g; !function (e, t, i) { ev(t, ["moof", "traf"]).forEach(t => { ev(t, ["tfhd"]).forEach(r => { let n = e[ef(r, 4)]; if (!n) return; let s = n.timescale || 9e4; ev(t, ["tfdt"]).forEach(e => { let t = e[0], r = i * s; if (r) { let i = ef(e, 4); if (0 === t) i -= r, eg(e, 4, i = Math.max(i, 0)); else { i *= 0x100000000, i += ef(e, 8), i -= r; let t = Math.floor((i = Math.max(i, 0)) / 0x100000000), n = Math.floor(i % 0x100000000); eg(e, 4, t), eg(e, 8, n) } } }) }) }) }(m, d, u.baseTime / u.timescale), g > 0 ? this.lastEndTime = S : (E.warn("Duration parsed from mp4 should be greater than zero"), this.resetNextTimestamp()); let A = !!m.audio, _ = !!m.video, b = ""; A && (b += "audio"), _ && (b += "video"); let T = { data1: d, startPTS: x, startDTS: x, endPTS: S, endDTS: S, type: b, hasAudio: A, hasVideo: _, nb: 1, dropped: 0 }; return c.audio = "audio" === T.type ? T : void 0, c.video = "audio" !== T.type ? T : void 0, c.initSegment = f, c.id3 = iZ(i, n, u, u), r.samples.length && (c.text = i$(r, n, u)), c } } function i1(e, t) { let i = null == e ? void 0 : e.codec; if (i && i.length > 4) return i; if (t === C.AUDIO) { if ("ec-3" === i || "ac-3" === i || "alac" === i) return i; if ("fLaC" === i || "Opus" === i) return eH(i, !1); let e = "mp4a.40.5"; return E.info(`Parsed audio codec "${i}" or audio object type not handled. Using "${e}"`), e } return (E.warn(`Unhandled video codec "${i}"`), "hvc1" === i || "hev1" === i) ? "hvc1.1.6.L120.90" : "av01" === i ? "av01.0.04M.08" : "avc1.42e01e" } try { n = self.performance.now.bind(self.performance) } catch (e) { E.debug("Unable to use Performance API on this environment"), n = null == F ? void 0 : F.Date.now } let i2 = [{ demux: iC, remux: i0 }, { demux: iU, remux: iq }, { demux: iM, remux: iq }, { demux: iH, remux: iq }]; i2.splice(2, 0, { demux: iL, remux: iq }); class i3 { constructor(e, t, i, r, n) { this.async = !1, this.observer = void 0, this.typeSupported = void 0, this.config = void 0, this.vendor = void 0, this.id = void 0, this.demuxer = void 0, this.remuxer = void 0, this.decrypter = void 0, this.probe = void 0, this.decryptionPromise = null, this.transmuxConfig = void 0, this.currentTransmuxState = void 0, this.observer = e, this.typeSupported = t, this.config = i, this.vendor = r, this.id = n } configure(e) { this.transmuxConfig = e, this.decrypter && this.decrypter.reset() } push(e, t, i, r) { let s; let a = i.transmuxing; a.executeStart = n(); let o = new Uint8Array(e), { currentTransmuxState: l, transmuxConfig: u } = this; r && (this.currentTransmuxState = r); let { contiguous: h, discontinuity: c, trackSwitch: d, accurateTimeOffset: f, timeOffset: p, initSegmentChange: m } = r || l, { audioCodec: g, videoCodec: S, defaultInitPts: A, duration: _, initSegmentData: b } = u, T = (s = null, o.byteLength > 0 && (null == t ? void 0 : t.key) != null && null !== t.iv && null != t.method && (s = t), s); if (T && "AES-128" === T.method) { let e = this.getDecrypter(); if (!e.isSync()) return this.decryptionPromise = e.webCryptoDecrypt(o, T.key.buffer, T.iv.buffer).then(e => { let t = this.push(e, null, i); return this.decryptionPromise = null, t }), this.decryptionPromise; { let t = e.softwareDecrypt(o, T.key.buffer, T.iv.buffer); if (i.part > -1 && (t = e.flush()), !t) return a.executeEnd = n(), i4(i); o = new Uint8Array(t) } } let w = this.needsProbing(c, d); if (w) { let e = this.configureTransmuxer(o); if (e) return E.warn(`[transmuxer] ${e.message}`), this.observer.emit(v.ERROR, v.ERROR, { type: y.MEDIA_ERROR, details: x.FRAG_PARSING_ERROR, fatal: !1, error: e, reason: e.message }), a.executeEnd = n(), i4(i) } (c || d || m || w) && this.resetInitSegment(b, g, S, _, t), (c || m || w) && this.resetInitialTimestamp(A), h || this.resetContiguity(); let M = this.transmux(o, T, p, f, i), R = this.currentTransmuxState; return R.contiguous = !0, R.discontinuity = !1, R.trackSwitch = !1, a.executeEnd = n(), M } flush(e) { let t = e.transmuxing; t.executeStart = n(); let { decrypter: i, currentTransmuxState: r, decryptionPromise: s } = this; if (s) return s.then(() => this.flush(e)); let a = [], { timeOffset: o } = r; if (i) { let t = i.flush(); t && a.push(this.push(t, null, e)) } let { demuxer: l, remuxer: u } = this; if (!l || !u) return t.executeEnd = n(), [i4(e)]; let h = l.flush(o); return i5(h) ? h.then(t => (this.flushRemux(a, t, e), a)) : (this.flushRemux(a, h, e), a) } flushRemux(e, t, i) { let { audioTrack: r, videoTrack: s, id3Track: a, textTrack: o } = t, { accurateTimeOffset: l, timeOffset: u } = this.currentTransmuxState; E.log(`[transmuxer.ts]: Flushed fragment ${i.sn}${i.part > -1 ? " p: " + i.part : ""} of level ${i.level}`); let h = this.remuxer.remux(r, s, a, o, u, l, !0, this.id); e.push({ remuxResult: h, chunkMeta: i }), i.transmuxing.executeEnd = n() } resetInitialTimestamp(e) { let { demuxer: t, remuxer: i } = this; t && i && (t.resetTimeStamp(e), i.resetTimeStamp(e)) } resetContiguity() { let { demuxer: e, remuxer: t } = this; e && t && (e.resetContiguity(), t.resetNextTimestamp()) } resetInitSegment(e, t, i, r, n) { let { demuxer: s, remuxer: a } = this; s && a && (s.resetInitSegment(e, t, i, r), a.resetInitSegment(e, t, i, n)) } destroy() { this.demuxer && (this.demuxer.destroy(), this.demuxer = void 0), this.remuxer && (this.remuxer.destroy(), this.remuxer = void 0) } transmux(e, t, i, r, n) { return t && "SAMPLE-AES" === t.method ? this.transmuxSampleAes(e, t, i, r, n) : this.transmuxUnencrypted(e, i, r, n) } transmuxUnencrypted(e, t, i, r) { let { audioTrack: n, videoTrack: s, id3Track: a, textTrack: o } = this.demuxer.demux(e, t, !1, !this.config.progressive); return { remuxResult: this.remuxer.remux(n, s, a, o, t, i, !1, this.id), chunkMeta: r } } transmuxSampleAes(e, t, i, r, n) { return this.demuxer.demuxSampleAes(e, t, i).then(e => ({ remuxResult: this.remuxer.remux(e.audioTrack, e.videoTrack, e.id3Track, e.textTrack, i, r, !1, this.id), chunkMeta: n })) } configureTransmuxer(e) { let t; let { config: i, observer: r, typeSupported: n, vendor: s } = this; for (let i = 0, r = i2.length; i < r; i++) { var a; if (null != (a = i2[i].demux) && a.probe(e)) { t = i2[i]; break } } if (!t) return Error("Failed to find demuxer by probing fragment data"); let o = this.demuxer, l = this.remuxer, u = t.remux, h = t.demux; l && l instanceof u || (this.remuxer = new u(r, i, n, s)), o && o instanceof h || (this.demuxer = new h(r, i, n), this.probe = h.probe) } needsProbing(e, t) { return !this.demuxer || !this.remuxer || e || t } getDecrypter() { let e = this.decrypter; return e || (e = this.decrypter = new it(this.config)), e } } let i4 = e => ({ remuxResult: {}, chunkMeta: e }); function i5(e) { return "then" in e && e.then instanceof Function } class i8 { constructor(e, t, i, r, n) { this.audioCodec = void 0, this.videoCodec = void 0, this.initSegmentData = void 0, this.duration = void 0, this.defaultInitPts = void 0, this.audioCodec = e, this.videoCodec = t, this.initSegmentData = i, this.duration = r, this.defaultInitPts = n || null } } class i6 { constructor(e, t, i, r, n, s) { this.discontinuity = void 0, this.contiguous = void 0, this.accurateTimeOffset = void 0, this.trackSwitch = void 0, this.timeOffset = void 0, this.initSegmentChange = void 0, this.discontinuity = e, this.contiguous = t, this.accurateTimeOffset = i, this.trackSwitch = r, this.timeOffset = n, this.initSegmentChange = s } } var i9 = { exports: {} }; !function (e) { var t = Object.prototype.hasOwnProperty, i = "~"; function r() { } function n(e, t, i) { this.fn = e, this.context = t, this.once = i || !1 } function s(e, t, r, s, a) { if ("function" != typeof r) throw TypeError("The listener must be a function"); var o = new n(r, s || e, a), l = i ? i + t : t; return e._events[l] ? e._events[l].fn ? e._events[l] = [e._events[l], o] : e._events[l].push(o) : (e._events[l] = o, e._eventsCount++), e } function a(e, t) { 0 == --e._eventsCount ? e._events = new r : delete e._events[t] } function o() { this._events = new r, this._eventsCount = 0 } Object.create && (r.prototype = Object.create(null), new r().__proto__ || (i = !1)), o.prototype.eventNames = function () { var e, r, n = []; if (0 === this._eventsCount) return n; for (r in e = this._events) t.call(e, r) && n.push(i ? r.slice(1) : r); return Object.getOwnPropertySymbols ? n.concat(Object.getOwnPropertySymbols(e)) : n }, o.prototype.listeners = function (e) { var t = i ? i + e : e, r = this._events[t]; if (!r) return []; if (r.fn) return [r.fn]; for (var n = 0, s = r.length, a = Array(s); n < s; n++)a[n] = r[n].fn; return a }, o.prototype.listenerCount = function (e) { var t = i ? i + e : e, r = this._events[t]; return r ? r.fn ? 1 : r.length : 0 }, o.prototype.emit = function (e, t, r, n, s, a) { var o = i ? i + e : e; if (!this._events[o]) return !1; var l, u, h = this._events[o], c = arguments.length; if (h.fn) { switch (h.once && this.removeListener(e, h.fn, void 0, !0), c) { case 1: return h.fn.call(h.context), !0; case 2: return h.fn.call(h.context, t), !0; case 3: return h.fn.call(h.context, t, r), !0; case 4: return h.fn.call(h.context, t, r, n), !0; case 5: return h.fn.call(h.context, t, r, n, s), !0; case 6: return h.fn.call(h.context, t, r, n, s, a), !0 }for (u = 1, l = Array(c - 1); u < c; u++)l[u - 1] = arguments[u]; h.fn.apply(h.context, l) } else { var d, f = h.length; for (u = 0; u < f; u++)switch (h[u].once && this.removeListener(e, h[u].fn, void 0, !0), c) { case 1: h[u].fn.call(h[u].context); break; case 2: h[u].fn.call(h[u].context, t); break; case 3: h[u].fn.call(h[u].context, t, r); break; case 4: h[u].fn.call(h[u].context, t, r, n); break; default: if (!l) for (d = 1, l = Array(c - 1); d < c; d++)l[d - 1] = arguments[d]; h[u].fn.apply(h[u].context, l) } } return !0 }, o.prototype.on = function (e, t, i) { return s(this, e, t, i, !1) }, o.prototype.once = function (e, t, i) { return s(this, e, t, i, !0) }, o.prototype.removeListener = function (e, t, r, n) { var s = i ? i + e : e; if (!this._events[s]) return this; if (!t) return a(this, s), this; var o = this._events[s]; if (o.fn) o.fn !== t || n && !o.once || r && o.context !== r || a(this, s); else { for (var l = 0, u = [], h = o.length; l < h; l++)(o[l].fn !== t || n && !o[l].once || r && o[l].context !== r) && u.push(o[l]); u.length ? this._events[s] = 1 === u.length ? u[0] : u : a(this, s) } return this }, o.prototype.removeAllListeners = function (e) { var t; return e ? (t = i ? i + e : e, this._events[t] && a(this, t)) : (this._events = new r, this._eventsCount = 0), this }, o.prototype.off = o.prototype.removeListener, o.prototype.addListener = o.prototype.on, o.prefixed = i, o.EventEmitter = o, e.exports = o }(i9); var i7 = function (e) { return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e }(i9.exports); class re {
      constructor(e, t, i, r) { this.error = null, this.hls = void 0, this.id = void 0, this.observer = void 0, this.frag = null, this.part = null, this.useWorker = void 0, this.workerContext = null, this.onwmsg = void 0, this.transmuxer = null, this.onTransmuxComplete = void 0, this.onFlush = void 0; let n = e.config; this.hls = e, this.id = t, this.useWorker = !!n.enableWorker, this.onTransmuxComplete = i, this.onFlush = r; let s = (e, t) => { (t = t || {}).frag = this.frag, t.id = this.id, e === v.ERROR && (this.error = t.error), this.hls.trigger(e, t) }; this.observer = new i7, this.observer.on(v.FRAG_DECRYPTED, s), this.observer.on(v.ERROR, s); let a = eD(n.preferManagedMediaSource) || { isTypeSupported: () => !1 }, o = { mpeg: a.isTypeSupported("audio/mpeg"), mp3: a.isTypeSupported('audio/mp4; codecs="mp3"'), ac3: a.isTypeSupported('audio/mp4; codecs="ac-3"') }; if (this.useWorker && "undefined" != typeof Worker && (n.workerPath || "function" == typeof __HLS_WORKER_BUNDLE__)) { try { n.workerPath ? (E.log(`loading Web Worker ${n.workerPath} for "${t}"`), this.workerContext = function (e) { let t = new self.URL(e, self.location.href).href; return { worker: new self.Worker(t), scriptURL: t } }(n.workerPath)) : (E.log(`injecting Web Worker for "${t}"`), this.workerContext = function () { let e = new self.Blob([`var exports={};var module={exports:exports};function define(f){f()};define.amd=true;(${__HLS_WORKER_BUNDLE__.toString()})(true);`], { type: "text/javascript" }), t = self.URL.createObjectURL(e); return { worker: new self.Worker(t), objectURL: t } }()), this.onwmsg = e => this.onWorkerMessage(e); let { worker: e } = this.workerContext; e.addEventListener("message", this.onwmsg), e.onerror = e => { let i = Error(`${e.message}  (${e.filename}:${e.lineno})`); n.enableWorker = !1, E.warn(`Error in "${t}" Web Worker, fallback to inline`), this.hls.trigger(v.ERROR, { type: y.OTHER_ERROR, details: x.INTERNAL_EXCEPTION, fatal: !1, event: "demuxerWorker", error: i }) }, e.postMessage({ cmd: "init", typeSupported: o, vendor: "", id: t, config: JSON.stringify(n) }) } catch (e) { E.warn(`Error setting up "${t}" Web Worker, fallback to inline`, e), this.resetWorker(), this.error = null, this.transmuxer = new i3(this.observer, o, n, "", t) } return } this.transmuxer = new i3(this.observer, o, n, "", t) } resetWorker() { if (this.workerContext) { let { worker: e, objectURL: t } = this.workerContext; t && self.URL.revokeObjectURL(t), e.removeEventListener("message", this.onwmsg), e.onerror = null, e.terminate(), this.workerContext = null } } destroy() { if (this.workerContext) this.resetWorker(), this.onwmsg = void 0; else { let e = this.transmuxer; e && (e.destroy(), this.transmuxer = null) } let e = this.observer; e && e.removeAllListeners(), this.frag = null, this.observer = null, this.hls = null } push(e, t, i, r, n, s, a, o, l, u) {
        var h, c; l.transmuxing.start = self.performance.now(); let { transmuxer: d } = this, f = s ? s.start : n.start, p = n.decryptdata, m = this.frag, g = !(m && n.cc === m.cc), v = !(m && l.level === m.level), y = m ? l.sn - m.sn : -1, x = this.part ? l.part - this.part.index : -1, S = 0 === y && l.id > 1 && l.id === (null == m ? void 0 : m.stats.chunkCount), A = !v && (1 === y || 0 === y && (1 === x || S && x <= 0)), _ = self.performance.now(); (v || y || 0 === n.stats.parsing.start) && (n.stats.parsing.start = _), s && (x || !A) && (s.stats.parsing.start = _); let b = !(m && (null == (h = n.initSegment) ? void 0 : h.url) === (null == (c = m.initSegment) ? void 0 : c.url)), T = new i6(g, A, o, v, f, b); if (!A || g || b) {
          E.log(`[transmuxer-interface, ${n.type}]: Starting new transmux session for sn: ${l.sn} p: ${l.part} level: ${l.level} id: ${l.id}
        discontinuity: ${g}
        trackSwitch: ${v}
        contiguous: ${A}
        accurateTimeOffset: ${o}
        timeOffset: ${f}
        initSegmentChange: ${b}`); let e = new i8(i, r, t, a, u); this.configureTransmuxer(e)
        } if (this.frag = n, this.part = s, this.workerContext) this.workerContext.worker.postMessage({ cmd: "demux", data: e, decryptdata: p, chunkMeta: l, state: T }, e instanceof ArrayBuffer ? [e] : []); else if (d) { let t = d.push(e, p, l, T); i5(t) ? (d.async = !0, t.then(e => { this.handleTransmuxComplete(e) }).catch(e => { this.transmuxerError(e, l, "transmuxer-interface push error") })) : (d.async = !1, this.handleTransmuxComplete(t)) }
      } flush(e) { e.transmuxing.start = self.performance.now(); let { transmuxer: t } = this; if (this.workerContext) this.workerContext.worker.postMessage({ cmd: "flush", chunkMeta: e }); else if (t) { let i = t.flush(e); i5(i) || t.async ? (i5(i) || (i = Promise.resolve(i)), i.then(t => { this.handleFlushResult(t, e) }).catch(t => { this.transmuxerError(t, e, "transmuxer-interface flush error") })) : this.handleFlushResult(i, e) } } transmuxerError(e, t, i) { this.hls && (this.error = e, this.hls.trigger(v.ERROR, { type: y.MEDIA_ERROR, details: x.FRAG_PARSING_ERROR, chunkMeta: t, frag: this.frag || void 0, fatal: !1, error: e, err: e, reason: i })) } handleFlushResult(e, t) { e.forEach(e => { this.handleTransmuxComplete(e) }), this.onFlush(t) } onWorkerMessage(e) { let t = e.data; if (!(null != t && t.event)) { E.warn(`worker message received with no ${t ? "event name" : "data"}`); return } let i = this.hls; if (this.hls) switch (t.event) { case "init": { var r; let e = null == (r = this.workerContext) ? void 0 : r.objectURL; e && self.URL.revokeObjectURL(e); break } case "transmuxComplete": this.handleTransmuxComplete(t.data); break; case "flush": this.onFlush(t.data); break; case "workerLog": E[t.data.logType] && E[t.data.logType](t.data.message); break; default: t.data = t.data || {}, t.data.frag = this.frag, t.data.id = this.id, i.trigger(t.event, t.data) } } configureTransmuxer(e) { let { transmuxer: t } = this; this.workerContext ? this.workerContext.worker.postMessage({ cmd: "configure", config: e }) : t && t.configure(e) } handleTransmuxComplete(e) { e.chunkMeta.transmuxing.end = self.performance.now(), this.onTransmuxComplete(e) }
    } class rt extends is { constructor(e, t, i) { super(e, t, i, "[audio-stream-controller]", e3.AUDIO), this.videoBuffer = null, this.videoTrackCC = -1, this.waitingVideoCC = -1, this.bufferedTrack = null, this.switchingTrack = null, this.trackId = -1, this.waitingData = null, this.mainDetails = null, this.flushing = !1, this.bufferFlushed = !1, this.cachedTrackLoadedData = null, this._registerListeners() } onHandlerDestroying() { this._unregisterListeners(), super.onHandlerDestroying(), this.mainDetails = null, this.bufferedTrack = null, this.switchingTrack = null } _registerListeners() { let { hls: e } = this; e.on(v.MEDIA_ATTACHED, this.onMediaAttached, this), e.on(v.MEDIA_DETACHING, this.onMediaDetaching, this), e.on(v.MANIFEST_LOADING, this.onManifestLoading, this), e.on(v.LEVEL_LOADED, this.onLevelLoaded, this), e.on(v.AUDIO_TRACKS_UPDATED, this.onAudioTracksUpdated, this), e.on(v.AUDIO_TRACK_SWITCHING, this.onAudioTrackSwitching, this), e.on(v.AUDIO_TRACK_LOADED, this.onAudioTrackLoaded, this), e.on(v.ERROR, this.onError, this), e.on(v.BUFFER_RESET, this.onBufferReset, this), e.on(v.BUFFER_CREATED, this.onBufferCreated, this), e.on(v.BUFFER_FLUSHING, this.onBufferFlushing, this), e.on(v.BUFFER_FLUSHED, this.onBufferFlushed, this), e.on(v.INIT_PTS_FOUND, this.onInitPtsFound, this), e.on(v.FRAG_BUFFERED, this.onFragBuffered, this) } _unregisterListeners() { let { hls: e } = this; e.off(v.MEDIA_ATTACHED, this.onMediaAttached, this), e.off(v.MEDIA_DETACHING, this.onMediaDetaching, this), e.off(v.MANIFEST_LOADING, this.onManifestLoading, this), e.off(v.LEVEL_LOADED, this.onLevelLoaded, this), e.off(v.AUDIO_TRACKS_UPDATED, this.onAudioTracksUpdated, this), e.off(v.AUDIO_TRACK_SWITCHING, this.onAudioTrackSwitching, this), e.off(v.AUDIO_TRACK_LOADED, this.onAudioTrackLoaded, this), e.off(v.ERROR, this.onError, this), e.off(v.BUFFER_RESET, this.onBufferReset, this), e.off(v.BUFFER_CREATED, this.onBufferCreated, this), e.off(v.BUFFER_FLUSHING, this.onBufferFlushing, this), e.off(v.BUFFER_FLUSHED, this.onBufferFlushed, this), e.off(v.INIT_PTS_FOUND, this.onInitPtsFound, this), e.off(v.FRAG_BUFFERED, this.onFragBuffered, this) } onInitPtsFound(e, { frag: t, id: i, initPTS: r, timescale: n }) { if ("main" === i) { let e = t.cc; this.initPTS[t.cc] = { baseTime: r, timescale: n }, this.log(`InitPTS for cc: ${e} found from main: ${r}`), this.videoTrackCC = e, this.state === ir.WAITING_INIT_PTS && this.tick() } } startLoad(e) { if (!this.levels) { this.startPosition = e, this.state = ir.STOPPED; return } let t = this.lastCurrentTime; this.stopLoad(), this.setInterval(100), t > 0 && -1 === e ? (this.log(`Override startPosition with lastCurrentTime @${t.toFixed(3)}`), e = t, this.state = ir.IDLE) : (this.loadedmetadata = !1, this.state = ir.WAITING_TRACK), this.nextLoadPosition = this.startPosition = this.lastCurrentTime = e, this.tick() } doTick() { var e, t; switch (this.state) { case ir.IDLE: this.doTickIdle(); break; case ir.WAITING_TRACK: { let { levels: t, trackId: i } = this, r = null == t ? void 0 : null == (e = t[i]) ? void 0 : e.details; if (r) { if (this.waitForCdnTuneIn(r)) break; this.state = ir.WAITING_INIT_PTS } break } case ir.FRAG_LOADING_WAITING_RETRY: { let e = performance.now(), i = this.retryDate; if (!i || e >= i || null != (t = this.media) && t.seeking) { let { levels: e, trackId: t } = this; this.log("RetryDate reached, switch back to IDLE state"), this.resetStartWhenNotLoaded((null == e ? void 0 : e[t]) || null), this.state = ir.IDLE } break } case ir.WAITING_INIT_PTS: { let e = this.waitingData; if (e) { let { frag: t, part: i, cache: r, complete: n } = e; if (void 0 !== this.initPTS[t.cc]) { this.waitingData = null, this.waitingVideoCC = -1, this.state = ir.FRAG_LOADING; let e = { frag: t, part: i, payload: r.flush(), networkDetails: null }; this._handleFragmentLoadProgress(e), n && super._handleFragmentLoadComplete(e) } else if (this.videoTrackCC !== this.waitingVideoCC) this.log(`Waiting fragment cc (${t.cc}) cancelled because video is at cc ${this.videoTrackCC}`), this.clearWaitingFragment(); else { let e = this.getLoadPosition(), i = tZ.bufferInfo(this.mediaBuffer, e, this.config.maxBufferHole); 0 > tI(i.end, this.config.maxFragLookUpTolerance, t) && (this.log(`Waiting fragment cc (${t.cc}) @ ${t.start} cancelled because another fragment at ${i.end} is needed`), this.clearWaitingFragment()) } } else this.state = ir.IDLE } }this.onTickEnd() } clearWaitingFragment() { let e = this.waitingData; e && (this.fragmentTracker.removeFragment(e.frag), this.waitingData = null, this.waitingVideoCC = -1, this.state = ir.IDLE) } resetLoadingState() { this.clearWaitingFragment(), super.resetLoadingState() } onTickEnd() { let { media: e } = this; null != e && e.readyState && (this.lastCurrentTime = e.currentTime) } doTickIdle() { let { hls: e, levels: t, media: i, trackId: r } = this, n = e.config; if (!this.buffering || !i && (this.startFragRequested || !n.startFragPrefetch) || !(null != t && t[r])) return; let s = t[r], a = s.details; if (!a || a.live && this.levelLastLoaded !== s || this.waitForCdnTuneIn(a)) { this.state = ir.WAITING_TRACK; return } let o = this.mediaBuffer ? this.mediaBuffer : this.media; this.bufferFlushed && o && (this.bufferFlushed = !1, this.afterBufferFlushed(o, C.AUDIO, e3.AUDIO)); let l = this.getFwdBufferInfo(o, e3.AUDIO); if (null === l) return; if (!this.switchingTrack && this._streamEnded(l, a)) { e.trigger(v.BUFFER_EOS, { type: "audio" }), this.state = ir.ENDED; return } let u = this.getFwdBufferInfo(this.videoBuffer ? this.videoBuffer : this.media, e3.MAIN), h = l.len, c = this.getMaxBufferLength(null == u ? void 0 : u.len), d = a.fragments, f = d[0].start, p = this.getLoadPosition(), m = this.flushing ? p : l.end; if (this.switchingTrack && i && a.PTSKnown && p < f && (l.end > f || l.nextStart) && (this.log("Alt audio track ahead of main track, seek to start of alt audio track"), i.currentTime = f + .05), h >= c && !this.switchingTrack && m < d[d.length - 1].start) return; let g = this.getNextFragment(m, a), y = !1; if (g && this.isLoopLoading(g, m) && (y = !!g.gap, g = this.getNextFragmentLoopLoading(g, a, l, e3.MAIN, c)), !g) { this.bufferFlushed = !0; return } let x = u && g.start > u.end + a.targetduration; if (x || !(null != u && u.len) && l.len) { let e = this.getAppendedFrag(g.start, e3.MAIN); if (null === e || (y || (y = !!e.gap || !!x && 0 === u.len), x && !y || y && l.nextStart && l.nextStart < e.end)) return } this.loadFragment(g, s, m) } getMaxBufferLength(e) { let t = super.getMaxBufferLength(); return e ? Math.min(Math.max(t, e), this.config.maxMaxBufferLength) : t } onMediaDetaching() { this.videoBuffer = null, this.bufferFlushed = this.flushing = !1, super.onMediaDetaching() } onAudioTracksUpdated(e, { audioTracks: t }) { this.resetTransmuxer(), this.levels = t.map(e => new tp(e)) } onAudioTrackSwitching(e, t) { let i = !!t.url; this.trackId = t.id; let { fragCurrent: r } = this; r && (r.abortRequests(), this.removeUnbufferedFrags(r.start)), this.resetLoadingState(), i ? this.setInterval(100) : this.resetTransmuxer(), i ? (this.switchingTrack = t, this.state = ir.IDLE, this.flushAudioIfNeeded(t)) : (this.switchingTrack = null, this.bufferedTrack = t, this.state = ir.STOPPED), this.tick() } onManifestLoading() { this.fragmentTracker.removeAllFragments(), this.startPosition = this.lastCurrentTime = 0, this.bufferFlushed = this.flushing = !1, this.levels = this.mainDetails = this.waitingData = this.bufferedTrack = this.cachedTrackLoadedData = this.switchingTrack = null, this.startFragRequested = !1, this.trackId = this.videoTrackCC = this.waitingVideoCC = -1 } onLevelLoaded(e, t) { this.mainDetails = t.details, null !== this.cachedTrackLoadedData && (this.hls.trigger(v.AUDIO_TRACK_LOADED, this.cachedTrackLoadedData), this.cachedTrackLoadedData = null) } onAudioTrackLoaded(e, t) { var i, r; if (null == this.mainDetails) { this.cachedTrackLoadedData = t; return } let { levels: n } = this, { details: s, id: a } = t; if (!n) { this.warn(`Audio tracks were reset while loading level ${a}`); return } this.log(`Audio track ${a} loaded [${s.startSN},${s.endSN}]${s.lastPartSn ? `[part-${s.lastPartSn}-${s.lastPartIndex}]` : ""},duration:${s.totalduration}`); let o = n[a], l = 0; if (s.live || null != (i = o.details) && i.live) { this.checkLiveUpdate(s); let e = this.mainDetails; if (s.deltaUpdateFailed || !e) return; !o.details && s.hasProgramDateTime && e.hasProgramDateTime ? (t3(s, e), l = s.fragments[0].start) : l = this.alignPlaylists(s, o.details, null == (r = this.levelLastLoaded) ? void 0 : r.details) } o.details = s, this.levelLastLoaded = o, this.startFragRequested || !this.mainDetails && s.live || this.setStartPosition(this.mainDetails || s, l), this.state !== ir.WAITING_TRACK || this.waitForCdnTuneIn(s) || (this.state = ir.IDLE), this.tick() } _handleFragmentLoadProgress(e) { var t; let { frag: i, part: r, payload: n } = e, { config: s, trackId: a, levels: o } = this; if (!o) { this.warn(`Audio tracks were reset while fragment load was in progress. Fragment ${i.sn} of level ${i.level} will not be buffered`); return } let l = o[a]; if (!l) { this.warn("Audio track is undefined on fragment load progress"); return } let u = l.details; if (!u) { this.warn("Audio track details undefined on fragment load progress"), this.removeUnbufferedFrags(i.start); return } let h = s.defaultAudioCodec || l.audioCodec || "mp4a.40.2", c = this.transmuxer; c || (c = this.transmuxer = new re(this.hls, e3.AUDIO, this._handleTransmuxComplete.bind(this), this._handleTransmuxerFlush.bind(this))); let d = this.initPTS[i.cc], f = null == (t = i.initSegment) ? void 0 : t.data; if (void 0 !== d) { let e = r ? r.index : -1, t = new t$(i.level, i.sn, i.stats.chunkCount, n.byteLength, e, -1 !== e); c.push(n, f, h, "", i, r, u.totalduration, !1, t, d) } else { this.log(`Unknown video PTS for cc ${i.cc}, waiting for video PTS before demuxing audio frag ${i.sn} of [${u.startSN} ,${u.endSN}],track ${a}`); let { cache: e } = this.waitingData = this.waitingData || { frag: i, part: r, cache: new ia, complete: !1 }; e.push(new Uint8Array(n)), this.waitingVideoCC = this.videoTrackCC, this.state = ir.WAITING_INIT_PTS } } _handleFragmentLoadComplete(e) { if (this.waitingData) { this.waitingData.complete = !0; return } super._handleFragmentLoadComplete(e) } onBufferReset() { this.mediaBuffer = this.videoBuffer = null, this.loadedmetadata = !1 } onBufferCreated(e, t) { let i = t.tracks.audio; i && (this.mediaBuffer = i.buffer || null), t.tracks.video && (this.videoBuffer = t.tracks.video.buffer || null) } onFragBuffered(e, t) { let { frag: i, part: r } = t; if (i.type !== e3.AUDIO) { if (!this.loadedmetadata && i.type === e3.MAIN) { let e = this.videoBuffer || this.media; e && tZ.getBuffered(e).length && (this.loadedmetadata = !0) } return } if (this.fragContextChanged(i)) { this.warn(`Fragment ${i.sn}${r ? " p: " + r.index : ""} of level ${i.level} finished buffering, but was aborted. state: ${this.state}, audioSwitch: ${this.switchingTrack ? this.switchingTrack.name : "false"}`); return } if ("initSegment" !== i.sn) { this.fragPrevious = i; let e = this.switchingTrack; e && (this.bufferedTrack = e, this.switchingTrack = null, this.hls.trigger(v.AUDIO_TRACK_SWITCHED, d({}, e))) } this.fragBufferedComplete(i, r) } onError(e, t) { var i; if (t.fatal) { this.state = ir.ERROR; return } switch (t.details) { case x.FRAG_GAP: case x.FRAG_PARSING_ERROR: case x.FRAG_DECRYPT_ERROR: case x.FRAG_LOAD_ERROR: case x.FRAG_LOAD_TIMEOUT: case x.KEY_LOAD_ERROR: case x.KEY_LOAD_TIMEOUT: this.onFragmentOrKeyLoadError(e3.AUDIO, t); break; case x.AUDIO_TRACK_LOAD_ERROR: case x.AUDIO_TRACK_LOAD_TIMEOUT: case x.LEVEL_PARSING_ERROR: t.levelRetry || this.state !== ir.WAITING_TRACK || (null == (i = t.context) ? void 0 : i.type) !== e2.AUDIO_TRACK || (this.state = ir.IDLE); break; case x.BUFFER_APPEND_ERROR: case x.BUFFER_FULL_ERROR: if (!t.parent || "audio" !== t.parent) return; if (t.details === x.BUFFER_APPEND_ERROR) { this.resetLoadingState(); return } this.reduceLengthAndFlushBuffer(t) && (this.bufferedTrack = null, super.flushMainBuffer(0, Number.POSITIVE_INFINITY, "audio")); break; case x.INTERNAL_EXCEPTION: this.recoverWorkerError(t) } } onBufferFlushing(e, { type: t }) { t !== C.VIDEO && (this.flushing = !0) } onBufferFlushed(e, { type: t }) { if (t !== C.VIDEO) { this.flushing = !1, this.bufferFlushed = !0, this.state === ir.ENDED && (this.state = ir.IDLE); let e = this.mediaBuffer || this.media; e && (this.afterBufferFlushed(e, t, e3.AUDIO), this.tick()) } } _handleTransmuxComplete(e) { var t; let i = "audio", { hls: r } = this, { remuxResult: n, chunkMeta: s } = e, a = this.getCurrentContext(s); if (!a) { this.resetWhenMissingContext(s); return } let { frag: o, part: l, level: u } = a, { details: h } = u, { audio: c, text: d, id3: p, initSegment: m } = n; if (this.fragContextChanged(o) || !h) { this.fragmentTracker.removeFragment(o); return } if (this.state = ir.PARSING, this.switchingTrack && c && this.completeAudioSwitch(this.switchingTrack), null != m && m.tracks) { let e = o.initSegment || o; this._bufferInitSegment(u, m.tracks, e, s), r.trigger(v.FRAG_PARSING_INIT_SEGMENT, { frag: e, id: i, tracks: m.tracks }) } if (c) { let { startPTS: e, endPTS: t, startDTS: i, endDTS: r } = c; l && (l.elementaryStreams[C.AUDIO] = { startPTS: e, endPTS: t, startDTS: i, endDTS: r }), o.setElementaryStreamInfo(C.AUDIO, e, t, i, r), this.bufferFragmentData(c, o, l, s) } if (null != p && null != (t = p.samples) && t.length) { let e = f({ id: i, frag: o, details: h }, p); r.trigger(v.FRAG_PARSING_METADATA, e) } if (d) { let e = f({ id: i, frag: o, details: h }, d); r.trigger(v.FRAG_PARSING_USERDATA, e) } } _bufferInitSegment(e, t, i, r) { if (this.state !== ir.PARSING) return; t.video && delete t.video; let n = t.audio; if (!n) return; n.id = "audio"; let s = e.audioCodec; this.log(`Init audio buffer, container:${n.container}, codecs[level/parsed]=[${s}/${n.codec}]`), s && 1 === s.split(",").length && (n.levelCodec = s), this.hls.trigger(v.BUFFER_CODECS, t); let a = n.initSegment; if (null != a && a.byteLength) { let e = { type: "audio", frag: i, part: null, chunkMeta: r, parent: i.type, data: a }; this.hls.trigger(v.BUFFER_APPENDING, e) } this.tickImmediate() } loadFragment(e, t, i) { let r = this.fragmentTracker.getState(e); if (this.fragCurrent = e, this.switchingTrack || r === tY.NOT_LOADED || r === tY.PARTIAL) { var n; if ("initSegment" === e.sn) this._loadInitSegment(e, t); else if (null != (n = t.details) && n.live && !this.initPTS[e.cc]) { this.log(`Waiting for video PTS in continuity counter ${e.cc} of live stream before loading audio fragment ${e.sn} of level ${this.trackId}`), this.state = ir.WAITING_INIT_PTS; let i = this.mainDetails; i && i.fragments[0].start !== t.details.fragments[0].start && t3(t.details, i) } else this.startFragRequested = !0, super.loadFragment(e, t, i) } else this.clearTrackerIfNeeded(e) } flushAudioIfNeeded(e) { if (this.media && this.bufferedTrack) { let { name: t, lang: i, assocLang: r, characteristics: n, audioCodec: s, channels: a } = this.bufferedTrack; tG({ name: t, lang: i, assocLang: r, characteristics: n, audioCodec: s, channels: a }, e, tH) || (this.log("Switching audio track : flushing all audio"), super.flushMainBuffer(0, Number.POSITIVE_INFINITY, "audio"), this.bufferedTrack = null) } } completeAudioSwitch(e) { let { hls: t } = this; this.flushAudioIfNeeded(e), this.bufferedTrack = e, this.switchingTrack = null, t.trigger(v.AUDIO_TRACK_SWITCHED, d({}, e)) } } function ri(e, t) { if (e.length !== t.length) return !1; for (let i = 0; i < e.length; i++)if (!rr(e[i].attrs, t[i].attrs)) return !1; return !0 } function rr(e, t, i) { let r = e["STABLE-RENDITION-ID"]; return r && !i ? r === t["STABLE-RENDITION-ID"] : !(i || ["LANGUAGE", "NAME", "CHARACTERISTICS", "AUTOSELECT", "DEFAULT", "FORCED", "ASSOC-LANGUAGE"]).some(i => e[i] !== t[i]) } function rn(e, t) { return t.label.toLowerCase() === e.name.toLowerCase() && (!t.language || t.language.toLowerCase() === (e.lang || "").toLowerCase()) } class rs extends tO { constructor(e) { super(e, "[audio-track-controller]"), this.tracks = [], this.groupIds = null, this.tracksInGroup = [], this.trackId = -1, this.currentTrack = null, this.selectDefaultTrack = !0, this.registerListeners() } registerListeners() { let { hls: e } = this; e.on(v.MANIFEST_LOADING, this.onManifestLoading, this), e.on(v.MANIFEST_PARSED, this.onManifestParsed, this), e.on(v.LEVEL_LOADING, this.onLevelLoading, this), e.on(v.LEVEL_SWITCHING, this.onLevelSwitching, this), e.on(v.AUDIO_TRACK_LOADED, this.onAudioTrackLoaded, this), e.on(v.ERROR, this.onError, this) } unregisterListeners() { let { hls: e } = this; e.off(v.MANIFEST_LOADING, this.onManifestLoading, this), e.off(v.MANIFEST_PARSED, this.onManifestParsed, this), e.off(v.LEVEL_LOADING, this.onLevelLoading, this), e.off(v.LEVEL_SWITCHING, this.onLevelSwitching, this), e.off(v.AUDIO_TRACK_LOADED, this.onAudioTrackLoaded, this), e.off(v.ERROR, this.onError, this) } destroy() { this.unregisterListeners(), this.tracks.length = 0, this.tracksInGroup.length = 0, this.currentTrack = null, super.destroy() } onManifestLoading() { this.tracks = [], this.tracksInGroup = [], this.groupIds = null, this.currentTrack = null, this.trackId = -1, this.selectDefaultTrack = !0 } onManifestParsed(e, t) { this.tracks = t.audioTracks || [] } onAudioTrackLoaded(e, t) { let { id: i, groupId: r, details: n } = t, s = this.tracksInGroup[i]; if (!s || s.groupId !== r) { this.warn(`Audio track with id:${i} and group:${r} not found in active group ${null == s ? void 0 : s.groupId}`); return } let a = s.details; s.details = t.details, this.log(`Audio track ${i} "${s.name}" lang:${s.lang} group:${r} loaded [${n.startSN}-${n.endSN}]`), i === this.trackId && this.playlistLoaded(i, t, a) } onLevelLoading(e, t) { this.switchLevel(t.level) } onLevelSwitching(e, t) { this.switchLevel(t.level) } switchLevel(e) { let t = this.hls.levels[e]; if (!t) return; let i = t.audioGroups || null, r = this.groupIds, n = this.currentTrack; if (!i || (null == r ? void 0 : r.length) !== (null == i ? void 0 : i.length) || null != i && i.some(e => (null == r ? void 0 : r.indexOf(e)) === -1)) { this.groupIds = i, this.trackId = -1, this.currentTrack = null; let e = this.tracks.filter(e => !i || -1 !== i.indexOf(e.groupId)); if (e.length) this.selectDefaultTrack && !e.some(e => e.default) && (this.selectDefaultTrack = !1), e.forEach((e, t) => { e.id = t }); else if (!n && !this.tracksInGroup.length) return; this.tracksInGroup = e; let t = this.hls.config.audioPreference; if (!n && t) { let i = tz(t, e, tH); if (i > -1) n = e[i]; else { let e = tz(t, this.tracks); n = this.tracks[e] } } let r = this.findTrackId(n); -1 === r && n && (r = this.findTrackId(null)), this.log(`Updating audio tracks, ${e.length} track(s) found in group(s): ${null == i ? void 0 : i.join(",")}`), this.hls.trigger(v.AUDIO_TRACKS_UPDATED, { audioTracks: e }); let a = this.trackId; if (-1 !== r && -1 === a) this.setAudioTrack(r); else if (e.length && -1 === a) { var s; let t = Error(`No audio track selected for current audio group-ID(s): ${null == (s = this.groupIds) ? void 0 : s.join(",")} track count: ${e.length}`); this.warn(t.message), this.hls.trigger(v.ERROR, { type: y.MEDIA_ERROR, details: x.AUDIO_TRACK_LOAD_ERROR, fatal: !0, error: t }) } } else this.shouldReloadPlaylist(n) && this.setAudioTrack(this.trackId) } onError(e, t) { !t.fatal && t.context && (t.context.type !== e2.AUDIO_TRACK || t.context.id !== this.trackId || this.groupIds && -1 === this.groupIds.indexOf(t.context.groupId) || (this.requestScheduled = -1, this.checkRetry(t))) } get allAudioTracks() { return this.tracks } get audioTracks() { return this.tracksInGroup } get audioTrack() { return this.trackId } set audioTrack(e) { this.selectDefaultTrack = !1, this.setAudioTrack(e) } setAudioOption(e) { let t = this.hls; if (t.config.audioPreference = e, e) { let i = this.allAudioTracks; if (this.selectDefaultTrack = !1, i.length) { let r = this.currentTrack; if (r && tG(e, r, tH)) return r; let n = tz(e, this.tracksInGroup, tH); if (n > -1) { let e = this.tracksInGroup[n]; return this.setAudioTrack(n), e } if (r) { let r = t.loadLevel; -1 === r && (r = t.firstAutoLevel); let n = function (e, t, i, r, n) { let s = t[r], a = t.reduce((e, t, i) => { let r = t.uri; return (e[r] || (e[r] = [])).push(i), e }, {})[s.uri]; a.length > 1 && (r = Math.max.apply(Math, a)); let o = s.videoRange, l = s.frameRate, u = s.codecSet.substring(0, 4), h = tV(t, r, t => { if (t.videoRange !== o || t.frameRate !== l || t.codecSet.substring(0, 4) !== u) return !1; let r = t.audioGroups; return tz(e, i.filter(e => !r || -1 !== r.indexOf(e.groupId)), n) > -1 }); return h > -1 ? h : tV(t, r, t => { let r = t.audioGroups; return tz(e, i.filter(e => !r || -1 !== r.indexOf(e.groupId)), n) > -1 }) }(e, t.levels, i, r, tH); if (-1 === n) return null; t.nextLoadLevel = n } if (e.channels || e.audioCodec) { let t = tz(e, i); if (t > -1) return i[t] } } } return null } setAudioTrack(e) { let t = this.tracksInGroup; if (e < 0 || e >= t.length) { this.warn(`Invalid audio track id: ${e}`); return } this.clearTimer(), this.selectDefaultTrack = !1; let i = this.currentTrack, r = t[e], n = r.details && !r.details.live; if (e === this.trackId && r === i && n || (this.log(`Switching to audio-track ${e} "${r.name}" lang:${r.lang} group:${r.groupId} channels:${r.channels}`), this.trackId = e, this.currentTrack = r, this.hls.trigger(v.AUDIO_TRACK_SWITCHING, d({}, r)), n)) return; let s = this.switchParams(r.url, null == i ? void 0 : i.details, r.details); this.loadPlaylist(s) } findTrackId(e) { let t = this.tracksInGroup; for (let i = 0; i < t.length; i++) { let r = t[i]; if ((!this.selectDefaultTrack || r.default) && (!e || tG(e, r, tH))) return i } if (e) { let { name: i, lang: r, assocLang: n, characteristics: s, audioCodec: a, channels: o } = e; for (let e = 0; e < t.length; e++)if (tG({ name: i, lang: r, assocLang: n, characteristics: s, audioCodec: a, channels: o }, t[e], tH)) return e; for (let i = 0; i < t.length; i++) { let r = t[i]; if (rr(e.attrs, r.attrs, ["LANGUAGE", "ASSOC-LANGUAGE", "CHARACTERISTICS"])) return i } for (let i = 0; i < t.length; i++) { let r = t[i]; if (rr(e.attrs, r.attrs, ["LANGUAGE"])) return i } } return -1 } loadPlaylist(e) { let t = this.currentTrack; if (this.shouldLoadPlaylist(t) && t) { super.loadPlaylist(); let i = t.id, r = t.groupId, n = t.url; if (e) try { n = e.addDirectives(n) } catch (e) { this.warn(`Could not construct new URL with HLS Delivery Directives: ${e}`) } this.log(`loading audio-track playlist ${i} "${t.name}" lang:${t.lang} group:${r}`), this.clearTimer(), this.hls.trigger(v.AUDIO_TRACK_LOADING, { url: n, id: i, groupId: r, deliveryDirectives: e || null }) } } } class ra extends is { constructor(e, t, i) { super(e, t, i, "[subtitle-stream-controller]", e3.SUBTITLE), this.currentTrackId = -1, this.tracksBuffered = [], this.mainDetails = null, this._registerListeners() } onHandlerDestroying() { this._unregisterListeners(), super.onHandlerDestroying(), this.mainDetails = null } _registerListeners() { let { hls: e } = this; e.on(v.MEDIA_ATTACHED, this.onMediaAttached, this), e.on(v.MEDIA_DETACHING, this.onMediaDetaching, this), e.on(v.MANIFEST_LOADING, this.onManifestLoading, this), e.on(v.LEVEL_LOADED, this.onLevelLoaded, this), e.on(v.ERROR, this.onError, this), e.on(v.SUBTITLE_TRACKS_UPDATED, this.onSubtitleTracksUpdated, this), e.on(v.SUBTITLE_TRACK_SWITCH, this.onSubtitleTrackSwitch, this), e.on(v.SUBTITLE_TRACK_LOADED, this.onSubtitleTrackLoaded, this), e.on(v.SUBTITLE_FRAG_PROCESSED, this.onSubtitleFragProcessed, this), e.on(v.BUFFER_FLUSHING, this.onBufferFlushing, this), e.on(v.FRAG_BUFFERED, this.onFragBuffered, this) } _unregisterListeners() { let { hls: e } = this; e.off(v.MEDIA_ATTACHED, this.onMediaAttached, this), e.off(v.MEDIA_DETACHING, this.onMediaDetaching, this), e.off(v.MANIFEST_LOADING, this.onManifestLoading, this), e.off(v.LEVEL_LOADED, this.onLevelLoaded, this), e.off(v.ERROR, this.onError, this), e.off(v.SUBTITLE_TRACKS_UPDATED, this.onSubtitleTracksUpdated, this), e.off(v.SUBTITLE_TRACK_SWITCH, this.onSubtitleTrackSwitch, this), e.off(v.SUBTITLE_TRACK_LOADED, this.onSubtitleTrackLoaded, this), e.off(v.SUBTITLE_FRAG_PROCESSED, this.onSubtitleFragProcessed, this), e.off(v.BUFFER_FLUSHING, this.onBufferFlushing, this), e.off(v.FRAG_BUFFERED, this.onFragBuffered, this) } startLoad(e) { this.stopLoad(), this.state = ir.IDLE, this.setInterval(500), this.nextLoadPosition = this.startPosition = this.lastCurrentTime = e, this.tick() } onManifestLoading() { this.mainDetails = null, this.fragmentTracker.removeAllFragments() } onMediaDetaching() { this.tracksBuffered = [], super.onMediaDetaching() } onLevelLoaded(e, t) { this.mainDetails = t.details } onSubtitleFragProcessed(e, t) { let i; let { frag: r, success: n } = t; if (this.fragPrevious = r, this.state = ir.IDLE, !n) return; let s = this.tracksBuffered[this.currentTrackId]; if (!s) return; let a = r.start; for (let e = 0; e < s.length; e++)if (a >= s[e].start && a <= s[e].end) { i = s[e]; break } let o = r.start + r.duration; i ? i.end = o : (i = { start: a, end: o }, s.push(i)), this.fragmentTracker.fragBuffered(r), this.fragBufferedComplete(r, null) } onBufferFlushing(e, t) { let { startOffset: i, endOffset: r } = t; if (0 === i && r !== Number.POSITIVE_INFINITY) { let e = r - 1; if (e <= 0) return; t.endOffsetSubtitles = Math.max(0, e), this.tracksBuffered.forEach(t => { for (let i = 0; i < t.length;) { if (t[i].end <= e) { t.shift(); continue } if (t[i].start < e) t[i].start = e; else break; i++ } }), this.fragmentTracker.removeFragmentsInRange(i, e, e3.SUBTITLE) } } onFragBuffered(e, t) { if (!this.loadedmetadata && t.frag.type === e3.MAIN) { var i; null != (i = this.media) && i.buffered.length && (this.loadedmetadata = !0) } } onError(e, t) { let i = t.frag; (null == i ? void 0 : i.type) === e3.SUBTITLE && (t.details === x.FRAG_GAP && this.fragmentTracker.fragBuffered(i, !0), this.fragCurrent && this.fragCurrent.abortRequests(), this.state !== ir.STOPPED && (this.state = ir.IDLE)) } onSubtitleTracksUpdated(e, { subtitleTracks: t }) { if (this.levels && ri(this.levels, t)) { this.levels = t.map(e => new tp(e)); return } this.tracksBuffered = [], this.levels = t.map(e => { let t = new tp(e); return this.tracksBuffered[t.id] = [], t }), this.fragmentTracker.removeFragmentsInRange(0, Number.POSITIVE_INFINITY, e3.SUBTITLE), this.fragPrevious = null, this.mediaBuffer = null } onSubtitleTrackSwitch(e, t) { var i; if (this.currentTrackId = t.id, !(null != (i = this.levels) && i.length) || -1 === this.currentTrackId) { this.clearInterval(); return } let r = this.levels[this.currentTrackId]; null != r && r.details ? this.mediaBuffer = this.mediaBufferTimeRanges : this.mediaBuffer = null, r && this.setInterval(500) } onSubtitleTrackLoaded(e, t) { var i, r; let { currentTrackId: n, levels: s } = this, { details: a, id: o } = t; if (!s) { this.warn(`Subtitle tracks were reset while loading level ${o}`); return } let l = s[o]; if (o >= s.length || !l) return; this.log(`Subtitle track ${o} loaded [${a.startSN},${a.endSN}]${a.lastPartSn ? `[part-${a.lastPartSn}-${a.lastPartIndex}]` : ""},duration:${a.totalduration}`), this.mediaBuffer = this.mediaBufferTimeRanges; let u = 0; if (a.live || null != (i = l.details) && i.live) { let e = this.mainDetails; if (a.deltaUpdateFailed || !e) return; let t = e.fragments[0]; l.details ? 0 === (u = this.alignPlaylists(a, l.details, null == (r = this.levelLastLoaded) ? void 0 : r.details)) && t && tx(a, u = t.start) : a.hasProgramDateTime && e.hasProgramDateTime ? (t3(a, e), u = a.fragments[0].start) : t && tx(a, u = t.start) } l.details = a, this.levelLastLoaded = l, o === n && (this.startFragRequested || !this.mainDetails && a.live || this.setStartPosition(this.mainDetails || a, u), this.tick(), a.live && !this.fragCurrent && this.media && this.state === ir.IDLE && !tC(null, a.fragments, this.media.currentTime, 0) && (this.warn("Subtitle playlist not aligned with playback"), l.details = void 0)) } _handleFragmentLoadComplete(e) { let { frag: t, payload: i } = e, r = t.decryptdata, n = this.hls; if (!this.fragContextChanged(t) && i && i.byteLength > 0 && null != r && r.key && r.iv && "AES-128" === r.method) { let e = performance.now(); this.decrypter.decrypt(new Uint8Array(i), r.key.buffer, r.iv.buffer).catch(e => { throw n.trigger(v.ERROR, { type: y.MEDIA_ERROR, details: x.FRAG_DECRYPT_ERROR, fatal: !1, error: e, reason: e.message, frag: t }), e }).then(i => { let r = performance.now(); n.trigger(v.FRAG_DECRYPTED, { frag: t, payload: i, stats: { tstart: e, tdecrypt: r } }) }).catch(e => { this.warn(`${e.name}: ${e.message}`), this.state = ir.IDLE }) } } doTick() { if (!this.media) { this.state = ir.IDLE; return } if (this.state === ir.IDLE) { let { currentTrackId: e, levels: t } = this, i = null == t ? void 0 : t[e]; if (!i || !t.length || !i.details) return; let { config: r } = this, n = this.getLoadPosition(), { end: s, len: a } = tZ.bufferedInfo(this.tracksBuffered[this.currentTrackId] || [], n, r.maxBufferHole), o = this.getFwdBufferInfo(this.media, e3.MAIN), l = i.details; if (a > this.getMaxBufferLength(null == o ? void 0 : o.len) + l.levelTargetDuration) return; let u = l.fragments, h = u.length, c = l.edge, d = null, f = this.fragPrevious; if (s < c) { let e = r.maxFragLookUpTolerance; (d = tC(f, u, Math.max(u[0].start, s), s > c - e ? 0 : e)) || !f || !(f.start < u[0].start) || (d = u[0]) } else d = u[h - 1]; if (!d) return; if ("initSegment" !== (d = this.mapToInitFragWhenRequired(d)).sn) { let e = u[d.sn - l.startSN - 1]; e && e.cc === d.cc && this.fragmentTracker.getState(e) === tY.NOT_LOADED && (d = e) } this.fragmentTracker.getState(d) === tY.NOT_LOADED && this.loadFragment(d, i, s) } } getMaxBufferLength(e) { let t = super.getMaxBufferLength(); return e ? Math.max(t, e) : t } loadFragment(e, t, i) { this.fragCurrent = e, "initSegment" === e.sn ? this._loadInitSegment(e, t) : (this.startFragRequested = !0, super.loadFragment(e, t, i)) } get mediaBufferTimeRanges() { return new ro(this.tracksBuffered[this.currentTrackId] || []) } } class ro { constructor(e) { this.buffered = void 0; let t = (t, i, r) => { if ((i >>>= 0) > r - 1) throw new DOMException(`Failed to execute '${t}' on 'TimeRanges': The index provided (${i}) is greater than the maximum bound (${r})`); return e[i][t] }; this.buffered = { get length() { return e.length }, end: i => t("end", i, e.length), start: i => t("start", i, e.length) } } } class rl extends tO { constructor(e) { super(e, "[subtitle-track-controller]"), this.media = null, this.tracks = [], this.groupIds = null, this.tracksInGroup = [], this.trackId = -1, this.currentTrack = null, this.selectDefaultTrack = !0, this.queuedDefaultTrack = -1, this.asyncPollTrackChange = () => this.pollTrackChange(0), this.useTextTrackPolling = !1, this.subtitlePollingInterval = -1, this._subtitleDisplay = !0, this.onTextTracksChanged = () => { if (this.useTextTrackPolling || self.clearInterval(this.subtitlePollingInterval), !this.media || !this.hls.config.renderTextTracksNatively) return; let e = null, t = tt(this.media.textTracks); for (let i = 0; i < t.length; i++)if ("hidden" === t[i].mode) e = t[i]; else if ("showing" === t[i].mode) { e = t[i]; break } let i = this.findTrackForTextTrack(e); this.subtitleTrack !== i && this.setSubtitleTrack(i) }, this.registerListeners() } destroy() { this.unregisterListeners(), this.tracks.length = 0, this.tracksInGroup.length = 0, this.currentTrack = null, this.onTextTracksChanged = this.asyncPollTrackChange = null, super.destroy() } get subtitleDisplay() { return this._subtitleDisplay } set subtitleDisplay(e) { this._subtitleDisplay = e, this.trackId > -1 && this.toggleTrackModes() } registerListeners() { let { hls: e } = this; e.on(v.MEDIA_ATTACHED, this.onMediaAttached, this), e.on(v.MEDIA_DETACHING, this.onMediaDetaching, this), e.on(v.MANIFEST_LOADING, this.onManifestLoading, this), e.on(v.MANIFEST_PARSED, this.onManifestParsed, this), e.on(v.LEVEL_LOADING, this.onLevelLoading, this), e.on(v.LEVEL_SWITCHING, this.onLevelSwitching, this), e.on(v.SUBTITLE_TRACK_LOADED, this.onSubtitleTrackLoaded, this), e.on(v.ERROR, this.onError, this) } unregisterListeners() { let { hls: e } = this; e.off(v.MEDIA_ATTACHED, this.onMediaAttached, this), e.off(v.MEDIA_DETACHING, this.onMediaDetaching, this), e.off(v.MANIFEST_LOADING, this.onManifestLoading, this), e.off(v.MANIFEST_PARSED, this.onManifestParsed, this), e.off(v.LEVEL_LOADING, this.onLevelLoading, this), e.off(v.LEVEL_SWITCHING, this.onLevelSwitching, this), e.off(v.SUBTITLE_TRACK_LOADED, this.onSubtitleTrackLoaded, this), e.off(v.ERROR, this.onError, this) } onMediaAttached(e, t) { this.media = t.media, this.media && (this.queuedDefaultTrack > -1 && (this.subtitleTrack = this.queuedDefaultTrack, this.queuedDefaultTrack = -1), this.useTextTrackPolling = !(this.media.textTracks && "onchange" in this.media.textTracks), this.useTextTrackPolling ? this.pollTrackChange(500) : this.media.textTracks.addEventListener("change", this.asyncPollTrackChange)) } pollTrackChange(e) { self.clearInterval(this.subtitlePollingInterval), this.subtitlePollingInterval = self.setInterval(this.onTextTracksChanged, e) } onMediaDetaching() { this.media && (self.clearInterval(this.subtitlePollingInterval), this.useTextTrackPolling || this.media.textTracks.removeEventListener("change", this.asyncPollTrackChange), this.trackId > -1 && (this.queuedDefaultTrack = this.trackId), tt(this.media.textTracks).forEach(e => { e7(e) }), this.subtitleTrack = -1, this.media = null) } onManifestLoading() { this.tracks = [], this.groupIds = null, this.tracksInGroup = [], this.trackId = -1, this.currentTrack = null, this.selectDefaultTrack = !0 } onManifestParsed(e, t) { this.tracks = t.subtitleTracks } onSubtitleTrackLoaded(e, t) { let { id: i, groupId: r, details: n } = t, s = this.tracksInGroup[i]; if (!s || s.groupId !== r) { this.warn(`Subtitle track with id:${i} and group:${r} not found in active group ${null == s ? void 0 : s.groupId}`); return } let a = s.details; s.details = t.details, this.log(`Subtitle track ${i} "${s.name}" lang:${s.lang} group:${r} loaded [${n.startSN}-${n.endSN}]`), i === this.trackId && this.playlistLoaded(i, t, a) } onLevelLoading(e, t) { this.switchLevel(t.level) } onLevelSwitching(e, t) { this.switchLevel(t.level) } switchLevel(e) { let t = this.hls.levels[e]; if (!t) return; let i = t.subtitleGroups || null, r = this.groupIds, n = this.currentTrack; if (!i || (null == r ? void 0 : r.length) !== (null == i ? void 0 : i.length) || null != i && i.some(e => (null == r ? void 0 : r.indexOf(e)) === -1)) { this.groupIds = i, this.trackId = -1, this.currentTrack = null; let e = this.tracks.filter(e => !i || -1 !== i.indexOf(e.groupId)); if (e.length) this.selectDefaultTrack && !e.some(e => e.default) && (this.selectDefaultTrack = !1), e.forEach((e, t) => { e.id = t }); else if (!n && !this.tracksInGroup.length) return; this.tracksInGroup = e; let t = this.hls.config.subtitlePreference; if (!n && t) { this.selectDefaultTrack = !1; let i = tz(t, e); if (i > -1) n = e[i]; else { let e = tz(t, this.tracks); n = this.tracks[e] } } let r = this.findTrackId(n); -1 === r && n && (r = this.findTrackId(null)), this.log(`Updating subtitle tracks, ${e.length} track(s) found in "${null == i ? void 0 : i.join(",")}" group-id`), this.hls.trigger(v.SUBTITLE_TRACKS_UPDATED, { subtitleTracks: e }), -1 !== r && -1 === this.trackId && this.setSubtitleTrack(r) } else this.shouldReloadPlaylist(n) && this.setSubtitleTrack(this.trackId) } findTrackId(e) { let t = this.tracksInGroup, i = this.selectDefaultTrack; for (let r = 0; r < t.length; r++) { let n = t[r]; if ((!i || n.default) && (i || e) && (!e || tG(n, e))) return r } if (e) { for (let i = 0; i < t.length; i++) { let r = t[i]; if (rr(e.attrs, r.attrs, ["LANGUAGE", "ASSOC-LANGUAGE", "CHARACTERISTICS"])) return i } for (let i = 0; i < t.length; i++) { let r = t[i]; if (rr(e.attrs, r.attrs, ["LANGUAGE"])) return i } } return -1 } findTrackForTextTrack(e) { if (e) { let t = this.tracksInGroup; for (let i = 0; i < t.length; i++)if (rn(t[i], e)) return i } return -1 } onError(e, t) { !t.fatal && t.context && (t.context.type !== e2.SUBTITLE_TRACK || t.context.id !== this.trackId || this.groupIds && -1 === this.groupIds.indexOf(t.context.groupId) || this.checkRetry(t)) } get allSubtitleTracks() { return this.tracks } get subtitleTracks() { return this.tracksInGroup } get subtitleTrack() { return this.trackId } set subtitleTrack(e) { this.selectDefaultTrack = !1, this.setSubtitleTrack(e) } setSubtitleOption(e) { if (this.hls.config.subtitlePreference = e, e) { let t = this.allSubtitleTracks; if (this.selectDefaultTrack = !1, t.length) { let i = this.currentTrack; if (i && tG(e, i)) return i; let r = tz(e, this.tracksInGroup); if (r > -1) { let e = this.tracksInGroup[r]; return this.setSubtitleTrack(r), e } if (i); else { let i = tz(e, t); if (i > -1) return t[i] } } } return null } loadPlaylist(e) { super.loadPlaylist(); let t = this.currentTrack; if (this.shouldLoadPlaylist(t) && t) { let i = t.id, r = t.groupId, n = t.url; if (e) try { n = e.addDirectives(n) } catch (e) { this.warn(`Could not construct new URL with HLS Delivery Directives: ${e}`) } this.log(`Loading subtitle playlist for id ${i}`), this.hls.trigger(v.SUBTITLE_TRACK_LOADING, { url: n, id: i, groupId: r, deliveryDirectives: e || null }) } } toggleTrackModes() { let e; let { media: t } = this; if (!t) return; let i = tt(t.textTracks), r = this.currentTrack; if (!r || (e = i.filter(e => rn(r, e))[0]) || this.warn(`Unable to find subtitle TextTrack with name "${r.name}" and language "${r.lang}"`), [].slice.call(i).forEach(t => { "disabled" !== t.mode && t !== e && (t.mode = "disabled") }), e) { let t = this.subtitleDisplay ? "showing" : "hidden"; e.mode !== t && (e.mode = t) } } setSubtitleTrack(e) { let t = this.tracksInGroup; if (!this.media) { this.queuedDefaultTrack = e; return } if (e < -1 || e >= t.length || !p(e)) { this.warn(`Invalid subtitle track id: ${e}`); return } this.clearTimer(), this.selectDefaultTrack = !1; let i = this.currentTrack, r = t[e] || null; if (this.trackId = e, this.currentTrack = r, this.toggleTrackModes(), !r) { this.hls.trigger(v.SUBTITLE_TRACK_SWITCH, { id: e }); return } let n = !!r.details && !r.details.live; if (e === this.trackId && r === i && n) return; this.log(`Switching to subtitle-track ${e}` + (r ? ` "${r.name}" lang:${r.lang} group:${r.groupId}` : "")); let { id: s, groupId: a = "", name: o, type: l, url: u } = r; this.hls.trigger(v.SUBTITLE_TRACK_SWITCH, { id: s, groupId: a, name: o, type: l, url: u }); let h = this.switchParams(r.url, null == i ? void 0 : i.details, r.details); this.loadPlaylist(h) } } class ru { constructor(e) { this.buffers = void 0, this.queues = { video: [], audio: [], audiovideo: [] }, this.buffers = e } append(e, t, i) { let r = this.queues[t]; r.push(e), 1 !== r.length || i || this.executeNext(t) } insertAbort(e, t) { this.queues[t].unshift(e), this.executeNext(t) } appendBlocker(e) { let t; let i = new Promise(e => { t = e }), r = { execute: t, onStart: () => { }, onComplete: () => { }, onError: () => { } }; return this.append(r, e), i } executeNext(e) { let t = this.queues[e]; if (t.length) { let i = t[0]; try { i.execute() } catch (r) { E.warn(`[buffer-operation-queue]: Exception executing "${e}" SourceBuffer operation: ${r}`), i.onError(r); let t = this.buffers[e]; null != t && t.updating || this.shiftAndExecuteNext(e) } } } shiftAndExecuteNext(e) { this.queues[e].shift(), this.executeNext(e) } current(e) { return this.queues[e][0] } } let rh = /(avc[1234]|hvc1|hev1|dvh[1e]|vp09|av01)(?:\.[^.,]+)+/; class rc { constructor(e) { var t; this.details = null, this._objectUrl = null, this.operationQueue = void 0, this.listeners = void 0, this.hls = void 0, this.bufferCodecEventsExpected = 0, this._bufferCodecEventsTotal = 0, this.media = null, this.mediaSource = null, this.lastMpegAudioChunk = null, this.appendSource = void 0, this.appendErrors = { audio: 0, video: 0, audiovideo: 0 }, this.tracks = {}, this.pendingTracks = {}, this.sourceBuffer = void 0, this.log = void 0, this.warn = void 0, this.error = void 0, this._onEndStreaming = e => { this.hls && this.hls.pauseBuffering() }, this._onStartStreaming = e => { this.hls && this.hls.resumeBuffering() }, this._onMediaSourceOpen = () => { let { media: e, mediaSource: t } = this; this.log("Media source opened"), e && (e.removeEventListener("emptied", this._onMediaEmptied), this.updateMediaElementDuration(), this.hls.trigger(v.MEDIA_ATTACHED, { media: e, mediaSource: t })), t && t.removeEventListener("sourceopen", this._onMediaSourceOpen), this.checkPendingTracks() }, this._onMediaSourceClose = () => { this.log("Media source closed") }, this._onMediaSourceEnded = () => { this.log("Media source ended") }, this._onMediaEmptied = () => { let { mediaSrc: e, _objectUrl: t } = this; e !== t && E.error(`Media element src was set while attaching MediaSource (${t} > ${e})`) }, this.hls = e; let i = "[buffer-controller]"; this.appendSource = (t = eD(e.config.preferManagedMediaSource), "undefined" != typeof self && t === self.ManagedMediaSource), this.log = E.log.bind(E, i), this.warn = E.warn.bind(E, i), this.error = E.error.bind(E, i), this._initSourceBuffer(), this.registerListeners() } hasSourceTypes() { return this.getSourceBufferTypes().length > 0 || Object.keys(this.pendingTracks).length > 0 } destroy() { this.unregisterListeners(), this.details = null, this.lastMpegAudioChunk = null, this.hls = null } registerListeners() { let { hls: e } = this; e.on(v.MEDIA_ATTACHING, this.onMediaAttaching, this), e.on(v.MEDIA_DETACHING, this.onMediaDetaching, this), e.on(v.MANIFEST_LOADING, this.onManifestLoading, this), e.on(v.MANIFEST_PARSED, this.onManifestParsed, this), e.on(v.BUFFER_RESET, this.onBufferReset, this), e.on(v.BUFFER_APPENDING, this.onBufferAppending, this), e.on(v.BUFFER_CODECS, this.onBufferCodecs, this), e.on(v.BUFFER_EOS, this.onBufferEos, this), e.on(v.BUFFER_FLUSHING, this.onBufferFlushing, this), e.on(v.LEVEL_UPDATED, this.onLevelUpdated, this), e.on(v.FRAG_PARSED, this.onFragParsed, this), e.on(v.FRAG_CHANGED, this.onFragChanged, this) } unregisterListeners() { let { hls: e } = this; e.off(v.MEDIA_ATTACHING, this.onMediaAttaching, this), e.off(v.MEDIA_DETACHING, this.onMediaDetaching, this), e.off(v.MANIFEST_LOADING, this.onManifestLoading, this), e.off(v.MANIFEST_PARSED, this.onManifestParsed, this), e.off(v.BUFFER_RESET, this.onBufferReset, this), e.off(v.BUFFER_APPENDING, this.onBufferAppending, this), e.off(v.BUFFER_CODECS, this.onBufferCodecs, this), e.off(v.BUFFER_EOS, this.onBufferEos, this), e.off(v.BUFFER_FLUSHING, this.onBufferFlushing, this), e.off(v.LEVEL_UPDATED, this.onLevelUpdated, this), e.off(v.FRAG_PARSED, this.onFragParsed, this), e.off(v.FRAG_CHANGED, this.onFragChanged, this) } _initSourceBuffer() { this.sourceBuffer = {}, this.operationQueue = new ru(this.sourceBuffer), this.listeners = { audio: [], video: [], audiovideo: [] }, this.appendErrors = { audio: 0, video: 0, audiovideo: 0 }, this.lastMpegAudioChunk = null } onManifestLoading() { this.bufferCodecEventsExpected = this._bufferCodecEventsTotal = 0, this.details = null } onManifestParsed(e, t) { let i = 2; (!t.audio || t.video) && t.altAudio || (i = 1), this.bufferCodecEventsExpected = this._bufferCodecEventsTotal = i, this.log(`${this.bufferCodecEventsExpected} bufferCodec event(s) expected`) } onMediaAttaching(e, t) { let i = this.media = t.media, r = eD(this.appendSource); if (i && r) { var n; let e = this.mediaSource = new r; this.log(`created media source: ${null == (n = e.constructor) ? void 0 : n.name}`), e.addEventListener("sourceopen", this._onMediaSourceOpen), e.addEventListener("sourceended", this._onMediaSourceEnded), e.addEventListener("sourceclose", this._onMediaSourceClose), this.appendSource && (e.addEventListener("startstreaming", this._onStartStreaming), e.addEventListener("endstreaming", this._onEndStreaming)); let t = this._objectUrl = self.URL.createObjectURL(e); if (this.appendSource) try { i.removeAttribute("src"); let r = self.ManagedMediaSource; i.disableRemotePlayback = i.disableRemotePlayback || r && e instanceof r, rd(i), function (e, t) { let i = self.document.createElement("source"); i.type = "video/mp4", i.src = t, e.appendChild(i) }(i, t), i.load() } catch (e) { i.src = t } else i.src = t; i.addEventListener("emptied", this._onMediaEmptied) } } onMediaDetaching() { let { media: e, mediaSource: t, _objectUrl: i } = this; if (t) { if (this.log("media source detaching"), "open" === t.readyState) try { t.endOfStream() } catch (e) { this.warn(`onMediaDetaching: ${e.message} while calling endOfStream`) } this.onBufferReset(), t.removeEventListener("sourceopen", this._onMediaSourceOpen), t.removeEventListener("sourceended", this._onMediaSourceEnded), t.removeEventListener("sourceclose", this._onMediaSourceClose), this.appendSource && (t.removeEventListener("startstreaming", this._onStartStreaming), t.removeEventListener("endstreaming", this._onEndStreaming)), e && (e.removeEventListener("emptied", this._onMediaEmptied), i && self.URL.revokeObjectURL(i), this.mediaSrc === i ? (e.removeAttribute("src"), this.appendSource && rd(e), e.load()) : this.warn("media|source.src was changed by a third party - skip cleanup")), this.mediaSource = null, this.media = null, this._objectUrl = null, this.bufferCodecEventsExpected = this._bufferCodecEventsTotal, this.pendingTracks = {}, this.tracks = {} } this.hls.trigger(v.MEDIA_DETACHED, void 0) } onBufferReset() { this.getSourceBufferTypes().forEach(e => { this.resetBuffer(e) }), this._initSourceBuffer(), this.hls.resumeBuffering() } resetBuffer(e) { let t = this.sourceBuffer[e]; try { if (t) { var i; this.removeBufferListeners(e), this.sourceBuffer[e] = void 0, null != (i = this.mediaSource) && i.sourceBuffers.length && this.mediaSource.removeSourceBuffer(t) } } catch (t) { this.warn(`onBufferReset ${e}`, t) } } onBufferCodecs(e, t) { let i = this.getSourceBufferTypes().length, r = Object.keys(t); if (r.forEach(e => { if (i) { let i = this.tracks[e]; if (i && "function" == typeof i.buffer.changeType) { var r; let { id: n, codec: s, levelCodec: a, container: o, metadata: l } = t[e], u = eV(i.codec, i.levelCodec), h = null == u ? void 0 : u.replace(rh, "$1"), c = eV(s, a), d = null == (r = c) ? void 0 : r.replace(rh, "$1"); if (c && h !== d) { "audio" === e.slice(0, 5) && (c = eH(c, this.appendSource)); let t = `${o};codecs=${c}`; this.appendChangeType(e, t), this.log(`switching codec ${u} to ${c}`), this.tracks[e] = { buffer: i.buffer, codec: s, container: o, levelCodec: a, metadata: l, id: n } } } } else this.pendingTracks[e] = t[e] }), i) return; let n = Math.max(this.bufferCodecEventsExpected - 1, 0); this.bufferCodecEventsExpected !== n && (this.log(`${n} bufferCodec event(s) expected ${r.join(",")}`), this.bufferCodecEventsExpected = n), this.mediaSource && "open" === this.mediaSource.readyState && this.checkPendingTracks() } appendChangeType(e, t) { let { operationQueue: i } = this; i.append({ execute: () => { let r = this.sourceBuffer[e]; r && (this.log(`changing ${e} sourceBuffer type to ${t}`), r.changeType(t)), i.shiftAndExecuteNext(e) }, onStart: () => { }, onComplete: () => { }, onError: t => { this.warn(`Failed to change ${e} SourceBuffer type`, t) } }, e, !!this.pendingTracks[e]) } onBufferAppending(e, t) { let { hls: i, operationQueue: r, tracks: n } = this, { data: s, type: a, frag: o, part: l, chunkMeta: u } = t, h = u.buffering[a], c = self.performance.now(); h.start = c; let d = o.stats.buffering, f = l ? l.stats.buffering : null; 0 === d.start && (d.start = c), f && 0 === f.start && (f.start = c); let p = n.audio, m = !1; "audio" === a && (null == p ? void 0 : p.container) === "audio/mpeg" && (m = !this.lastMpegAudioChunk || 1 === u.id || this.lastMpegAudioChunk.sn !== u.sn, this.lastMpegAudioChunk = u); let g = o.start; r.append({ execute: () => { if (h.executeStart = self.performance.now(), m) { let e = this.sourceBuffer[a]; if (e) { let t = g - e.timestampOffset; Math.abs(t) >= .1 && (this.log(`Updating audio SourceBuffer timestampOffset to ${g} (delta: ${t}) sn: ${o.sn})`), e.timestampOffset = g) } } this.appendExecutor(s, a) }, onStart: () => { }, onComplete: () => { let e = self.performance.now(); h.executeEnd = h.end = e, 0 === d.first && (d.first = e), f && 0 === f.first && (f.first = e); let { sourceBuffer: t } = this, i = {}; for (let e in t) i[e] = tZ.getBuffered(t[e]); this.appendErrors[a] = 0, "audio" === a || "video" === a ? this.appendErrors.audiovideo = 0 : (this.appendErrors.audio = 0, this.appendErrors.video = 0), this.hls.trigger(v.BUFFER_APPENDED, { type: a, frag: o, part: l, chunkMeta: u, parent: o.type, timeRanges: i }) }, onError: e => { let t = { type: y.MEDIA_ERROR, parent: o.type, details: x.BUFFER_APPEND_ERROR, sourceBufferName: a, frag: o, part: l, chunkMeta: u, error: e, err: e, fatal: !1 }; if (e.code === DOMException.QUOTA_EXCEEDED_ERR) t.details = x.BUFFER_FULL_ERROR; else { let e = ++this.appendErrors[a]; t.details = x.BUFFER_APPEND_ERROR, this.warn(`Failed ${e}/${i.config.appendErrorMaxRetry} times to append segment in "${a}" sourceBuffer`), e >= i.config.appendErrorMaxRetry && (t.fatal = !0) } i.trigger(v.ERROR, t) } }, a, !!this.pendingTracks[a]) } onBufferFlushing(e, t) { let { operationQueue: i } = this, r = e => ({ execute: this.removeExecutor.bind(this, e, t.startOffset, t.endOffset), onStart: () => { }, onComplete: () => { this.hls.trigger(v.BUFFER_FLUSHED, { type: e }) }, onError: t => { this.warn(`Failed to remove from ${e} SourceBuffer`, t) } }); t.type ? i.append(r(t.type), t.type) : this.getSourceBufferTypes().forEach(e => { i.append(r(e), e) }) } onFragParsed(e, t) { let { frag: i, part: r } = t, n = [], s = r ? r.elementaryStreams : i.elementaryStreams; s[C.AUDIOVIDEO] ? n.push("audiovideo") : (s[C.AUDIO] && n.push("audio"), s[C.VIDEO] && n.push("video")), 0 === n.length && this.warn(`Fragments must have at least one ElementaryStreamType set. type: ${i.type} level: ${i.level} sn: ${i.sn}`), this.blockBuffers(() => { let e = self.performance.now(); i.stats.buffering.end = e, r && (r.stats.buffering.end = e); let t = r ? r.stats : i.stats; this.hls.trigger(v.FRAG_BUFFERED, { frag: i, part: r, stats: t, id: i.type }) }, n) } onFragChanged(e, t) { this.trimBuffers() } onBufferEos(e, t) { this.getSourceBufferTypes().reduce((e, i) => { let r = this.sourceBuffer[i]; return !r || t.type && t.type !== i || (r.ending = !0, r.ended || (r.ended = !0, this.log(`${i} sourceBuffer now EOS`))), e && !!(!r || r.ended) }, !0) && (this.log("Queueing mediaSource.endOfStream()"), this.blockBuffers(() => { this.getSourceBufferTypes().forEach(e => { let t = this.sourceBuffer[e]; t && (t.ending = !1) }); let { mediaSource: e } = this; if (!e || "open" !== e.readyState) { e && this.log(`Could not call mediaSource.endOfStream(). mediaSource.readyState: ${e.readyState}`); return } this.log("Calling mediaSource.endOfStream()"), e.endOfStream() })) } onLevelUpdated(e, { details: t }) { t.fragments.length && (this.details = t, this.getSourceBufferTypes().length ? this.blockBuffers(this.updateMediaElementDuration.bind(this)) : this.updateMediaElementDuration()) } trimBuffers() { let { hls: e, details: t, media: i } = this; if (!i || null === t || !this.getSourceBufferTypes().length) return; let r = e.config, n = i.currentTime, s = t.levelTargetDuration, a = t.live && null !== r.liveBackBufferLength ? r.liveBackBufferLength : r.backBufferLength; if (p(a) && a > 0) { let e = Math.max(a, s), t = Math.floor(n / s) * s - e; this.flushBackBuffer(n, s, t) } if (p(r.frontBufferFlushThreshold) && r.frontBufferFlushThreshold > 0) { let e = Math.max(Math.max(r.maxBufferLength, r.frontBufferFlushThreshold), s), t = Math.floor(n / s) * s + e; this.flushFrontBuffer(n, s, t) } } flushBackBuffer(e, t, i) { let { details: r, sourceBuffer: n } = this; this.getSourceBufferTypes().forEach(s => { let a = n[s]; if (a) { let n = tZ.getBuffered(a); if (n.length > 0 && i > n.start(0)) { if (this.hls.trigger(v.BACK_BUFFER_REACHED, { bufferEnd: i }), null != r && r.live) this.hls.trigger(v.LIVE_BACK_BUFFER_REACHED, { bufferEnd: i }); else if (a.ended && n.end(n.length - 1) - e < 2 * t) { this.log(`Cannot flush ${s} back buffer while SourceBuffer is in ended state`); return } this.hls.trigger(v.BUFFER_FLUSHING, { startOffset: 0, endOffset: i, type: s }) } } }) } flushFrontBuffer(e, t, i) { let { sourceBuffer: r } = this; this.getSourceBufferTypes().forEach(n => { let s = r[n]; if (s) { let r = tZ.getBuffered(s), a = r.length; if (a < 2) return; let o = r.start(a - 1), l = r.end(a - 1); if (i > o || e >= o && e <= l) return; if (s.ended && e - l < 2 * t) { this.log(`Cannot flush ${n} front buffer while SourceBuffer is in ended state`); return } this.hls.trigger(v.BUFFER_FLUSHING, { startOffset: o, endOffset: 1 / 0, type: n }) } }) } updateMediaElementDuration() { if (!this.details || !this.media || !this.mediaSource || "open" !== this.mediaSource.readyState) return; let { details: e, hls: t, media: i, mediaSource: r } = this, n = e.fragments[0].start + e.totalduration, s = i.duration, a = p(r.duration) ? r.duration : 0; e.live && t.config.liveDurationInfinity ? (r.duration = 1 / 0, this.updateSeekableRange(e)) : (n > a && n > s || !p(s)) && (this.log(`Updating Media Source duration to ${n.toFixed(3)}`), r.duration = n) } updateSeekableRange(e) { let t = this.mediaSource, i = e.fragments; if (i.length && e.live && null != t && t.setLiveSeekableRange) { let r = Math.max(0, i[0].start), n = Math.max(r, r + e.totalduration); this.log(`Media Source duration is set to ${t.duration}. Setting seekable range to ${r}-${n}.`), t.setLiveSeekableRange(r, n) } } checkPendingTracks() { let { bufferCodecEventsExpected: e, operationQueue: t, pendingTracks: i } = this, r = Object.keys(i).length; if (r && (!e || 2 === r || "audiovideo" in i)) { this.createSourceBuffers(i), this.pendingTracks = {}; let e = this.getSourceBufferTypes(); if (e.length) this.hls.trigger(v.BUFFER_CREATED, { tracks: this.tracks }), e.forEach(e => { t.executeNext(e) }); else { let e = Error("could not create source buffer for media codec(s)"); this.hls.trigger(v.ERROR, { type: y.MEDIA_ERROR, details: x.BUFFER_INCOMPATIBLE_CODECS_ERROR, fatal: !0, error: e, reason: e.message }) } } } createSourceBuffers(e) { let { sourceBuffer: t, mediaSource: i } = this; if (!i) throw Error("createSourceBuffers called when mediaSource was null"); for (let n in e) if (!t[n]) { var r; let s = e[n]; if (!s) throw Error(`source buffer exists for track ${n}, however track does not`); let a = (null == (r = s.levelCodec) ? void 0 : r.indexOf(",")) === -1 ? s.levelCodec : s.codec; a && "audio" === n.slice(0, 5) && (a = eH(a, this.appendSource)); let o = `${s.container};codecs=${a}`; this.log(`creating sourceBuffer(${o})`); try { let e = t[n] = i.addSourceBuffer(o); this.addBufferListener(n, "updatestart", this._onSBUpdateStart), this.addBufferListener(n, "updateend", this._onSBUpdateEnd), this.addBufferListener(n, "error", this._onSBUpdateError), this.appendSource && this.addBufferListener(n, "bufferedchange", (e, t) => { let i = t.removedRanges; null != i && i.length && this.hls.trigger(v.BUFFER_FLUSHED, { type: n }) }), this.tracks[n] = { buffer: e, codec: a, container: s.container, levelCodec: s.levelCodec, metadata: s.metadata, id: s.id } } catch (e) { this.error(`error while trying to add sourceBuffer: ${e.message}`), this.hls.trigger(v.ERROR, { type: y.MEDIA_ERROR, details: x.BUFFER_ADD_CODEC_ERROR, fatal: !1, error: e, sourceBufferName: n, mimeType: o }) } } } get mediaSrc() { var e, t; let i = (null == (e = this.media) ? void 0 : null == (t = e.querySelector) ? void 0 : t.call(e, "source")) || this.media; return null == i ? void 0 : i.src } _onSBUpdateStart(e) { let { operationQueue: t } = this; t.current(e).onStart() } _onSBUpdateEnd(e) { var t; if ((null == (t = this.mediaSource) ? void 0 : t.readyState) === "closed") { this.resetBuffer(e); return } let { operationQueue: i } = this; i.current(e).onComplete(), i.shiftAndExecuteNext(e) } _onSBUpdateError(e, t) { var i; let r = Error(`${e} SourceBuffer error. MediaSource readyState: ${null == (i = this.mediaSource) ? void 0 : i.readyState}`); this.error(`${r}`, t), this.hls.trigger(v.ERROR, { type: y.MEDIA_ERROR, details: x.BUFFER_APPENDING_ERROR, sourceBufferName: e, error: r, fatal: !1 }); let n = this.operationQueue.current(e); n && n.onError(r) } removeExecutor(e, t, i) { let { media: r, mediaSource: n, operationQueue: s, sourceBuffer: a } = this, o = a[e]; if (!r || !n || !o) { this.warn(`Attempting to remove from the ${e} SourceBuffer, but it does not exist`), s.shiftAndExecuteNext(e); return } let l = p(r.duration) ? r.duration : 1 / 0, u = p(n.duration) ? n.duration : 1 / 0, h = Math.max(0, t), c = Math.min(i, l, u); c > h && (!o.ending || o.ended) ? (o.ended = !1, this.log(`Removing [${h},${c}] from the ${e} SourceBuffer`), o.remove(h, c)) : s.shiftAndExecuteNext(e) } appendExecutor(e, t) { let i = this.sourceBuffer[t]; if (!i) { if (!this.pendingTracks[t]) throw Error(`Attempting to append to the ${t} SourceBuffer, but it does not exist`); return } i.ended = !1, i.appendBuffer(e) } blockBuffers(e, t = this.getSourceBufferTypes()) { if (!t.length) { this.log("Blocking operation requested, but no SourceBuffers exist"), Promise.resolve().then(e); return } let { operationQueue: i } = this; Promise.all(t.map(e => i.appendBlocker(e))).then(() => { e(), t.forEach(e => { let t = this.sourceBuffer[e]; null != t && t.updating || i.shiftAndExecuteNext(e) }) }) } getSourceBufferTypes() { return Object.keys(this.sourceBuffer) } addBufferListener(e, t, i) { let r = this.sourceBuffer[e]; if (!r) return; let n = i.bind(this, e); this.listeners[e].push({ event: t, listener: n }), r.addEventListener(t, n) } removeBufferListeners(e) { let t = this.sourceBuffer[e]; t && this.listeners[e].forEach(e => { t.removeEventListener(e.event, e.listener) }) } } function rd(e) { let t = e.querySelectorAll("source");[].slice.call(t).forEach(t => { e.removeChild(t) }) } let rf = { 42: 225, 92: 233, 94: 237, 95: 243, 96: 250, 123: 231, 124: 247, 125: 209, 126: 241, 127: 9608, 128: 174, 129: 176, 130: 189, 131: 191, 132: 8482, 133: 162, 134: 163, 135: 9834, 136: 224, 137: 32, 138: 232, 139: 226, 140: 234, 141: 238, 142: 244, 143: 251, 144: 193, 145: 201, 146: 211, 147: 218, 148: 220, 149: 252, 150: 8216, 151: 161, 152: 42, 153: 8217, 154: 9473, 155: 169, 156: 8480, 157: 8226, 158: 8220, 159: 8221, 160: 192, 161: 194, 162: 199, 163: 200, 164: 202, 165: 203, 166: 235, 167: 206, 168: 207, 169: 239, 170: 212, 171: 217, 172: 249, 173: 219, 174: 171, 175: 187, 176: 195, 177: 227, 178: 205, 179: 204, 180: 236, 181: 210, 182: 242, 183: 213, 184: 245, 185: 123, 186: 125, 187: 92, 188: 94, 189: 95, 190: 124, 191: 8764, 192: 196, 193: 228, 194: 214, 195: 246, 196: 223, 197: 165, 198: 164, 199: 9475, 200: 197, 201: 229, 202: 216, 203: 248, 204: 9487, 205: 9491, 206: 9495, 207: 9499 }, rp = e => String.fromCharCode(rf[e] || e), rm = { 17: 1, 18: 3, 21: 5, 22: 7, 23: 9, 16: 11, 19: 12, 20: 14 }, rg = { 17: 2, 18: 4, 21: 6, 22: 8, 23: 10, 19: 13, 20: 15 }, rv = { 25: 1, 26: 3, 29: 5, 30: 7, 31: 9, 24: 11, 27: 12, 28: 14 }, ry = { 25: 2, 26: 4, 29: 6, 30: 8, 31: 10, 27: 13, 28: 15 }, rx = ["white", "green", "blue", "cyan", "red", "yellow", "magenta", "black", "transparent"]; class rS { constructor() { this.time = null, this.verboseLevel = 0 } log(e, t) { if (this.verboseLevel >= e) { let i = "function" == typeof t ? t() : t; E.log(`${this.time} [${e}] ${i}`) } } } let rA = function (e) { let t = []; for (let i = 0; i < e.length; i++)t.push(e[i].toString(16)); return t }; class r_ { constructor() { this.foreground = "white", this.underline = !1, this.italics = !1, this.background = "black", this.flash = !1 } reset() { this.foreground = "white", this.underline = !1, this.italics = !1, this.background = "black", this.flash = !1 } setStyles(e) { let t = ["foreground", "underline", "italics", "background", "flash"]; for (let i = 0; i < t.length; i++) { let r = t[i]; e.hasOwnProperty(r) && (this[r] = e[r]) } } isDefault() { return "white" === this.foreground && !this.underline && !this.italics && "black" === this.background && !this.flash } equals(e) { return this.foreground === e.foreground && this.underline === e.underline && this.italics === e.italics && this.background === e.background && this.flash === e.flash } copy(e) { this.foreground = e.foreground, this.underline = e.underline, this.italics = e.italics, this.background = e.background, this.flash = e.flash } toString() { return "color=" + this.foreground + ", underline=" + this.underline + ", italics=" + this.italics + ", background=" + this.background + ", flash=" + this.flash } } class rE { constructor() { this.uchar = " ", this.penState = new r_ } reset() { this.uchar = " ", this.penState.reset() } setChar(e, t) { this.uchar = e, this.penState.copy(t) } setPenState(e) { this.penState.copy(e) } equals(e) { return this.uchar === e.uchar && this.penState.equals(e.penState) } copy(e) { this.uchar = e.uchar, this.penState.copy(e.penState) } isEmpty() { return " " === this.uchar && this.penState.isDefault() } } class rb { constructor(e) { this.chars = [], this.pos = 0, this.currPenState = new r_, this.cueStartTime = null, this.logger = void 0; for (let e = 0; e < 100; e++)this.chars.push(new rE); this.logger = e } equals(e) { for (let t = 0; t < 100; t++)if (!this.chars[t].equals(e.chars[t])) return !1; return !0 } copy(e) { for (let t = 0; t < 100; t++)this.chars[t].copy(e.chars[t]) } isEmpty() { let e = !0; for (let t = 0; t < 100; t++)if (!this.chars[t].isEmpty()) { e = !1; break } return e } setCursor(e) { this.pos !== e && (this.pos = e), this.pos < 0 ? (this.logger.log(3, "Negative cursor position " + this.pos), this.pos = 0) : this.pos > 100 && (this.logger.log(3, "Too large cursor position " + this.pos), this.pos = 100) } moveCursor(e) { let t = this.pos + e; if (e > 1) for (let e = this.pos + 1; e < t + 1; e++)this.chars[e].setPenState(this.currPenState); this.setCursor(t) } backSpace() { this.moveCursor(-1), this.chars[this.pos].setChar(" ", this.currPenState) } insertChar(e) { e >= 144 && this.backSpace(); let t = rp(e); if (this.pos >= 100) { this.logger.log(0, () => "Cannot insert " + e.toString(16) + " (" + t + ") at position " + this.pos + ". Skipping it!"); return } this.chars[this.pos].setChar(t, this.currPenState), this.moveCursor(1) } clearFromPos(e) { let t; for (t = e; t < 100; t++)this.chars[t].reset() } clear() { this.clearFromPos(0), this.pos = 0, this.currPenState.reset() } clearToEndOfRow() { this.clearFromPos(this.pos) } getTextString() { let e = [], t = !0; for (let i = 0; i < 100; i++) { let r = this.chars[i].uchar; " " !== r && (t = !1), e.push(r) } return t ? "" : e.join("") } setPenStyles(e) { this.currPenState.setStyles(e), this.chars[this.pos].setPenState(this.currPenState) } } class rT { constructor(e) { this.rows = [], this.currRow = 14, this.nrRollUpRows = null, this.lastOutputScreen = null, this.logger = void 0; for (let t = 0; t < 15; t++)this.rows.push(new rb(e)); this.logger = e } reset() { for (let e = 0; e < 15; e++)this.rows[e].clear(); this.currRow = 14 } equals(e) { let t = !0; for (let i = 0; i < 15; i++)if (!this.rows[i].equals(e.rows[i])) { t = !1; break } return t } copy(e) { for (let t = 0; t < 15; t++)this.rows[t].copy(e.rows[t]) } isEmpty() { let e = !0; for (let t = 0; t < 15; t++)if (!this.rows[t].isEmpty()) { e = !1; break } return e } backSpace() { this.rows[this.currRow].backSpace() } clearToEndOfRow() { this.rows[this.currRow].clearToEndOfRow() } insertChar(e) { this.rows[this.currRow].insertChar(e) } setPen(e) { this.rows[this.currRow].setPenStyles(e) } moveCursor(e) { this.rows[this.currRow].moveCursor(e) } setCursor(e) { this.logger.log(2, "setCursor: " + e), this.rows[this.currRow].setCursor(e) } setPAC(e) { this.logger.log(2, () => "pacData = " + JSON.stringify(e)); let t = e.row - 1; if (this.nrRollUpRows && t < this.nrRollUpRows - 1 && (t = this.nrRollUpRows - 1), this.nrRollUpRows && this.currRow !== t) { for (let e = 0; e < 15; e++)this.rows[e].clear(); let e = this.currRow + 1 - this.nrRollUpRows, i = this.lastOutputScreen; if (i) { let r = i.rows[e].cueStartTime, n = this.logger.time; if (null !== r && null !== n && r < n) for (let r = 0; r < this.nrRollUpRows; r++)this.rows[t - this.nrRollUpRows + r + 1].copy(i.rows[e + r]) } } this.currRow = t; let i = this.rows[this.currRow]; if (null !== e.indent) { let t = Math.max(e.indent - 1, 0); i.setCursor(e.indent), e.color = i.chars[t].penState.foreground } let r = { foreground: e.color, underline: e.underline, italics: e.italics, background: "black", flash: !1 }; this.setPen(r) } setBkgData(e) { this.logger.log(2, () => "bkgData = " + JSON.stringify(e)), this.backSpace(), this.setPen(e), this.insertChar(32) } setRollUpRows(e) { this.nrRollUpRows = e } rollUp() { if (null === this.nrRollUpRows) { this.logger.log(3, "roll_up but nrRollUpRows not set yet"); return } this.logger.log(1, () => this.getDisplayText()); let e = this.currRow + 1 - this.nrRollUpRows, t = this.rows.splice(e, 1)[0]; t.clear(), this.rows.splice(this.currRow, 0, t), this.logger.log(2, "Rolling up") } getDisplayText(e) { e = e || !1; let t = [], i = "", r = -1; for (let i = 0; i < 15; i++) { let n = this.rows[i].getTextString(); n && (r = i + 1, e ? t.push("Row " + r + ": '" + n + "'") : t.push(n.trim())) } return t.length > 0 && (i = e ? "[" + t.join(" | ") + "]" : t.join("\n")), i } getTextAndFormat() { return this.rows } } class rw { constructor(e, t, i) { this.chNr = void 0, this.outputFilter = void 0, this.mode = void 0, this.verbose = void 0, this.displayedMemory = void 0, this.nonDisplayedMemory = void 0, this.lastOutputScreen = void 0, this.currRollUpRow = void 0, this.writeScreen = void 0, this.cueStartTime = void 0, this.logger = void 0, this.chNr = e, this.outputFilter = t, this.mode = null, this.verbose = 0, this.displayedMemory = new rT(i), this.nonDisplayedMemory = new rT(i), this.lastOutputScreen = new rT(i), this.currRollUpRow = this.displayedMemory.rows[14], this.writeScreen = this.displayedMemory, this.mode = null, this.cueStartTime = null, this.logger = i } reset() { this.mode = null, this.displayedMemory.reset(), this.nonDisplayedMemory.reset(), this.lastOutputScreen.reset(), this.outputFilter.reset(), this.currRollUpRow = this.displayedMemory.rows[14], this.writeScreen = this.displayedMemory, this.mode = null, this.cueStartTime = null } getHandler() { return this.outputFilter } setHandler(e) { this.outputFilter = e } setPAC(e) { this.writeScreen.setPAC(e) } setBkgData(e) { this.writeScreen.setBkgData(e) } setMode(e) { e !== this.mode && (this.mode = e, this.logger.log(2, () => "MODE=" + e), "MODE_POP-ON" === this.mode ? this.writeScreen = this.nonDisplayedMemory : (this.writeScreen = this.displayedMemory, this.writeScreen.reset()), "MODE_ROLL-UP" !== this.mode && (this.displayedMemory.nrRollUpRows = null, this.nonDisplayedMemory.nrRollUpRows = null), this.mode = e) } insertChars(e) { for (let t = 0; t < e.length; t++)this.writeScreen.insertChar(e[t]); let t = this.writeScreen === this.displayedMemory ? "DISP" : "NON_DISP"; this.logger.log(2, () => t + ": " + this.writeScreen.getDisplayText(!0)), ("MODE_PAINT-ON" === this.mode || "MODE_ROLL-UP" === this.mode) && (this.logger.log(1, () => "DISPLAYED: " + this.displayedMemory.getDisplayText(!0)), this.outputDataUpdate()) } ccRCL() { this.logger.log(2, "RCL - Resume Caption Loading"), this.setMode("MODE_POP-ON") } ccBS() { this.logger.log(2, "BS - BackSpace"), "MODE_TEXT" !== this.mode && (this.writeScreen.backSpace(), this.writeScreen === this.displayedMemory && this.outputDataUpdate()) } ccAOF() { } ccAON() { } ccDER() { this.logger.log(2, "DER- Delete to End of Row"), this.writeScreen.clearToEndOfRow(), this.outputDataUpdate() } ccRU(e) { this.logger.log(2, "RU(" + e + ") - Roll Up"), this.writeScreen = this.displayedMemory, this.setMode("MODE_ROLL-UP"), this.writeScreen.setRollUpRows(e) } ccFON() { this.logger.log(2, "FON - Flash On"), this.writeScreen.setPen({ flash: !0 }) } ccRDC() { this.logger.log(2, "RDC - Resume Direct Captioning"), this.setMode("MODE_PAINT-ON") } ccTR() { this.logger.log(2, "TR"), this.setMode("MODE_TEXT") } ccRTD() { this.logger.log(2, "RTD"), this.setMode("MODE_TEXT") } ccEDM() { this.logger.log(2, "EDM - Erase Displayed Memory"), this.displayedMemory.reset(), this.outputDataUpdate(!0) } ccCR() { this.logger.log(2, "CR - Carriage Return"), this.writeScreen.rollUp(), this.outputDataUpdate(!0) } ccENM() { this.logger.log(2, "ENM - Erase Non-displayed Memory"), this.nonDisplayedMemory.reset() } ccEOC() { if (this.logger.log(2, "EOC - End Of Caption"), "MODE_POP-ON" === this.mode) { let e = this.displayedMemory; this.displayedMemory = this.nonDisplayedMemory, this.nonDisplayedMemory = e, this.writeScreen = this.nonDisplayedMemory, this.logger.log(1, () => "DISP: " + this.displayedMemory.getDisplayText()) } this.outputDataUpdate(!0) } ccTO(e) { this.logger.log(2, "TO(" + e + ") - Tab Offset"), this.writeScreen.moveCursor(e) } ccMIDROW(e) { let t = { flash: !1 }; if (t.underline = e % 2 == 1, t.italics = e >= 46, t.italics) t.foreground = "white"; else { let i = Math.floor(e / 2) - 16; t.foreground = ["white", "green", "blue", "cyan", "red", "yellow", "magenta"][i] } this.logger.log(2, "MIDROW: " + JSON.stringify(t)), this.writeScreen.setPen(t) } outputDataUpdate(e = !1) { let t = this.logger.time; null !== t && this.outputFilter && (null !== this.cueStartTime || this.displayedMemory.isEmpty() ? this.displayedMemory.equals(this.lastOutputScreen) || (this.outputFilter.newCue(this.cueStartTime, t, this.lastOutputScreen), e && this.outputFilter.dispatchCue && this.outputFilter.dispatchCue(), this.cueStartTime = this.displayedMemory.isEmpty() ? null : t) : this.cueStartTime = t, this.lastOutputScreen.copy(this.displayedMemory)) } cueSplitAtTime(e) { this.outputFilter && !this.displayedMemory.isEmpty() && (this.outputFilter.newCue && this.outputFilter.newCue(this.cueStartTime, e, this.displayedMemory), this.cueStartTime = e) } } class rM { constructor(e, t, i) { this.channels = void 0, this.currentChannel = 0, this.cmdHistory = { a: null, b: null }, this.logger = void 0; let r = this.logger = new rS; this.channels = [null, new rw(e, t, r), new rw(e + 1, i, r)] } getHandler(e) { return this.channels[e].getHandler() } setHandler(e, t) { this.channels[e].setHandler(t) } addData(e, t) { this.logger.time = e; for (let e = 0; e < t.length; e += 2) { var i; let r = 127 & t[e], n = 127 & t[e + 1], s = !1, a = null; if (0 === r && 0 === n) continue; this.logger.log(3, () => "[" + rA([t[e], t[e + 1]]) + "] -> (" + rA([r, n]) + ")"); let o = this.cmdHistory; if (r >= 16 && r <= 31) { if (o.a === r && o.b === n) { o.a = null, o.b = null, this.logger.log(3, () => "Repeated command (" + rA([r, n]) + ") is dropped"); continue } (i = this.cmdHistory).a = r, i.b = n, (s = this.parseCmd(r, n)) || (s = this.parseMidrow(r, n)), s || (s = this.parsePAC(r, n)), s || (s = this.parseBackgroundAttributes(r, n)) } else o.a = null, o.b = null; if (!s && (a = this.parseChars(r, n))) { let e = this.currentChannel; e && e > 0 ? this.channels[e].insertChars(a) : this.logger.log(2, "No channel found yet. TEXT-MODE?") } s || a || this.logger.log(2, () => "Couldn't parse cleaned data " + rA([r, n]) + " orig: " + rA([t[e], t[e + 1]])) } } parseCmd(e, t) { if (!((20 === e || 28 === e || 21 === e || 29 === e) && t >= 32 && t <= 47 || (23 === e || 31 === e) && t >= 33 && t <= 35)) return !1; let i = 20 === e || 21 === e || 23 === e ? 1 : 2, r = this.channels[i]; return 20 === e || 21 === e || 28 === e || 29 === e ? 32 === t ? r.ccRCL() : 33 === t ? r.ccBS() : 34 === t ? r.ccAOF() : 35 === t ? r.ccAON() : 36 === t ? r.ccDER() : 37 === t ? r.ccRU(2) : 38 === t ? r.ccRU(3) : 39 === t ? r.ccRU(4) : 40 === t ? r.ccFON() : 41 === t ? r.ccRDC() : 42 === t ? r.ccTR() : 43 === t ? r.ccRTD() : 44 === t ? r.ccEDM() : 45 === t ? r.ccCR() : 46 === t ? r.ccENM() : 47 === t && r.ccEOC() : r.ccTO(t - 32), this.currentChannel = i, !0 } parseMidrow(e, t) { let i = 0; if ((17 === e || 25 === e) && t >= 32 && t <= 47) { if ((i = 17 === e ? 1 : 2) !== this.currentChannel) return this.logger.log(0, "Mismatch channel in midrow parsing"), !1; let r = this.channels[i]; return !!r && (r.ccMIDROW(t), this.logger.log(3, () => "MIDROW (" + rA([e, t]) + ")"), !0) } return !1 } parsePAC(e, t) { let i; let r = (e >= 17 && e <= 23 || e >= 25 && e <= 31) && t >= 64 && t <= 127, n = (16 === e || 24 === e) && t >= 64 && t <= 95; if (!(r || n)) return !1; let s = e <= 23 ? 1 : 2; i = t >= 64 && t <= 95 ? 1 === s ? rm[e] : rv[e] : 1 === s ? rg[e] : ry[e]; let a = this.channels[s]; return !!a && (a.setPAC(this.interpretPAC(i, t)), this.currentChannel = s, !0) } interpretPAC(e, t) { let i; let r = { color: null, italics: !1, indent: null, underline: !1, row: e }; return i = t > 95 ? t - 96 : t - 64, r.underline = (1 & i) == 1, i <= 13 ? r.color = ["white", "green", "blue", "cyan", "red", "yellow", "magenta", "white"][Math.floor(i / 2)] : i <= 15 ? (r.italics = !0, r.color = "white") : r.indent = 4 * Math.floor((i - 16) / 2), r } parseChars(e, t) { let i; let r = null, n = null; if (e >= 25 ? (i = 2, n = e - 8) : (i = 1, n = e), n >= 17 && n <= 19) { let e; e = 17 === n ? t + 80 : 18 === n ? t + 112 : t + 144, this.logger.log(2, () => "Special char '" + rp(e) + "' in channel " + i), r = [e] } else e >= 32 && e <= 127 && (r = 0 === t ? [e] : [e, t]); return r && this.logger.log(3, () => "Char codes =  " + rA(r).join(",")), r } parseBackgroundAttributes(e, t) { let i; if (!((16 === e || 24 === e) && t >= 32 && t <= 47 || (23 === e || 31 === e) && t >= 45 && t <= 47)) return !1; let r = {}; return 16 === e || 24 === e ? (i = Math.floor((t - 32) / 2), r.background = rx[i], t % 2 == 1 && (r.background = r.background + "_semi")) : 45 === t ? r.background = "transparent" : (r.foreground = "black", 47 === t && (r.underline = !0)), this.channels[e <= 23 ? 1 : 2].setBkgData(r), !0 } reset() { var e; for (let e = 0; e < Object.keys(this.channels).length; e++) { let t = this.channels[e]; t && t.reset() } (e = this.cmdHistory).a = null, e.b = null } cueSplitAtTime(e) { for (let t = 0; t < this.channels.length; t++) { let i = this.channels[t]; i && i.cueSplitAtTime(e) } } } class rR { constructor(e, t) { this.timelineController = void 0, this.cueRanges = [], this.trackName = void 0, this.startTime = null, this.endTime = null, this.screen = null, this.timelineController = e, this.trackName = t } dispatchCue() { null !== this.startTime && (this.timelineController.addCues(this.trackName, this.startTime, this.endTime, this.screen, this.cueRanges), this.startTime = null) } newCue(e, t, i) { (null === this.startTime || this.startTime > e) && (this.startTime = e), this.endTime = t, this.screen = i, this.timelineController.createCaptionsTrack(this.trackName) } reset() { this.cueRanges = [], this.startTime = null } } var rC = function () { if (null != F && F.VTTCue) return self.VTTCue; let e = ["", "lr", "rl"], t = ["start", "middle", "end", "left", "right"]; function i(e, t) { if ("string" != typeof t || !Array.isArray(e)) return !1; let i = t.toLowerCase(); return !!~e.indexOf(i) && i } function r(e, ...t) { let i = 1; for (; i < arguments.length; i++) { let t = arguments[i]; for (let i in t) e[i] = t[i] } return e } function n(n, s, a) { let o = { enumerable: !0 }; this.hasBeenReset = !1; let l = "", u = !1, h = n, c = s, d = a, f = null, p = "", m = !0, g = "auto", v = "start", y = 50, x = "middle", S = 50, A = "middle"; Object.defineProperty(this, "id", r({}, o, { get: function () { return l }, set: function (e) { l = "" + e } })), Object.defineProperty(this, "pauseOnExit", r({}, o, { get: function () { return u }, set: function (e) { u = !!e } })), Object.defineProperty(this, "startTime", r({}, o, { get: function () { return h }, set: function (e) { if ("number" != typeof e) throw TypeError("Start time must be set to a number."); h = e, this.hasBeenReset = !0 } })), Object.defineProperty(this, "endTime", r({}, o, { get: function () { return c }, set: function (e) { if ("number" != typeof e) throw TypeError("End time must be set to a number."); c = e, this.hasBeenReset = !0 } })), Object.defineProperty(this, "text", r({}, o, { get: function () { return d }, set: function (e) { d = "" + e, this.hasBeenReset = !0 } })), Object.defineProperty(this, "region", r({}, o, { get: function () { return f }, set: function (e) { f = e, this.hasBeenReset = !0 } })), Object.defineProperty(this, "vertical", r({}, o, { get: function () { return p }, set: function (t) { let r = i(e, t); if (!1 === r) throw SyntaxError("An invalid or illegal string was specified."); p = r, this.hasBeenReset = !0 } })), Object.defineProperty(this, "snapToLines", r({}, o, { get: function () { return m }, set: function (e) { m = !!e, this.hasBeenReset = !0 } })), Object.defineProperty(this, "line", r({}, o, { get: function () { return g }, set: function (e) { if ("number" != typeof e && "auto" !== e) throw SyntaxError("An invalid number or illegal string was specified."); g = e, this.hasBeenReset = !0 } })), Object.defineProperty(this, "lineAlign", r({}, o, { get: function () { return v }, set: function (e) { let r = i(t, e); if (!r) throw SyntaxError("An invalid or illegal string was specified."); v = r, this.hasBeenReset = !0 } })), Object.defineProperty(this, "position", r({}, o, { get: function () { return y }, set: function (e) { if (e < 0 || e > 100) throw Error("Position must be between 0 and 100."); y = e, this.hasBeenReset = !0 } })), Object.defineProperty(this, "positionAlign", r({}, o, { get: function () { return x }, set: function (e) { let r = i(t, e); if (!r) throw SyntaxError("An invalid or illegal string was specified."); x = r, this.hasBeenReset = !0 } })), Object.defineProperty(this, "size", r({}, o, { get: function () { return S }, set: function (e) { if (e < 0 || e > 100) throw Error("Size must be between 0 and 100."); S = e, this.hasBeenReset = !0 } })), Object.defineProperty(this, "align", r({}, o, { get: function () { return A }, set: function (e) { let r = i(t, e); if (!r) throw SyntaxError("An invalid or illegal string was specified."); A = r, this.hasBeenReset = !0 } })), this.displayState = void 0 } return n.prototype.getCueAsHTML = function () { return self.WebVTT.convertCueToDOMTree(self, this.text) }, n }(); class rI { decode(e, t) { if (!e) return ""; if ("string" != typeof e) throw Error("Error - expected string data."); return decodeURIComponent(encodeURIComponent(e)) } } function rL(e) { function t(e, t, i, r) { return (0 | e) * 3600 + (0 | t) * 60 + (0 | i) + parseFloat(r || 0) } let i = e.match(/^(?:(\d+):)?(\d{2}):(\d{2})(\.\d+)?/); return i ? parseFloat(i[2]) > 59 ? t(i[2], i[3], 0, i[4]) : t(i[1], i[2], i[3], i[4]) : null } class rP { constructor() { this.values = Object.create(null) } set(e, t) { this.get(e) || "" === t || (this.values[e] = t) } get(e, t, i) { return i ? this.has(e) ? this.values[e] : t[i] : this.has(e) ? this.values[e] : t } has(e) { return e in this.values } alt(e, t, i) { for (let r = 0; r < i.length; ++r)if (t === i[r]) { this.set(e, t); break } } integer(e, t) { /^-?\d+$/.test(t) && this.set(e, parseInt(t, 10)) } percent(e, t) { if (/^([\d]{1,3})(\.[\d]*)?%$/.test(t)) { let i = parseFloat(t); if (i >= 0 && i <= 100) return this.set(e, i), !0 } return !1 } } function rD(e, t, i, r) { let n = r ? e.split(r) : [e]; for (let e in n) { if ("string" != typeof n[e]) continue; let r = n[e].split(i); 2 === r.length && t(r[0], r[1]) } } let rO = new rC(0, 0, ""), rk = "middle" === rO.align ? "middle" : "center"; function rF(e) { return e.replace(/<br(?: \/)?>/gi, "\n") } class rU { constructor() { this.state = "INITIAL", this.buffer = "", this.decoder = new rI, this.regionList = [], this.cue = null, this.oncue = void 0, this.onparsingerror = void 0, this.onflush = void 0 } parse(e) { let t = this; function i() { let e = t.buffer, i = 0; for (e = rF(e); i < e.length && "\r" !== e[i] && "\n" !== e[i];)++i; let r = e.slice(0, i); return "\r" === e[i] && ++i, "\n" === e[i] && ++i, t.buffer = e.slice(i), r } e && (t.buffer += t.decoder.decode(e, { stream: !0 })); try { let e = ""; if ("INITIAL" === t.state) { if (!/\r\n|\n/.test(t.buffer)) return this; let r = (e = i()).match(/^()?WEBVTT([ \t].*)?$/); if (!(null != r && r[0])) throw Error("Malformed WebVTT signature."); t.state = "HEADER" } let n = !1; for (; t.buffer && /\r\n|\n/.test(t.buffer);)switch (n ? n = !1 : e = i(), t.state) { case "HEADER": if (/:/.test(e)) { var r; r = e, rD(r, function (e, t) { }, /:/) } else e || (t.state = "ID"); continue; case "NOTE": e || (t.state = "ID"); continue; case "ID": if (/^NOTE($|[ \t])/.test(e)) { t.state = "NOTE"; break } if (!e) continue; if (t.cue = new rC(0, 0, ""), t.state = "CUE", -1 === e.indexOf("--\x3e")) { t.cue.id = e; continue } case "CUE": if (!t.cue) { t.state = "BADCUE"; continue } try { !function (e, t, i) { let r = e; function n() { let t = rL(e); if (null === t) throw Error("Malformed timestamp: " + r); return e = e.replace(/^[^\sa-zA-Z-]+/, ""), t } function s() { e = e.replace(/^\s+/, "") } if (s(), t.startTime = n(), s(), "--\x3e" !== e.slice(0, 3)) throw Error("Malformed time stamp (time stamps must be separated by '--\x3e'): " + r); e = e.slice(3), s(), t.endTime = n(), s(), function (e, t) { let r = new rP; rD(e, function (e, t) { let n; switch (e) { case "region": for (let n = i.length - 1; n >= 0; n--)if (i[n].id === t) { r.set(e, i[n].region); break } break; case "vertical": r.alt(e, t, ["rl", "lr"]); break; case "line": n = t.split(","), r.integer(e, n[0]), r.percent(e, n[0]) && r.set("snapToLines", !1), r.alt(e, n[0], ["auto"]), 2 === n.length && r.alt("lineAlign", n[1], ["start", rk, "end"]); break; case "position": n = t.split(","), r.percent(e, n[0]), 2 === n.length && r.alt("positionAlign", n[1], ["start", rk, "end", "line-left", "line-right", "auto"]); break; case "size": r.percent(e, t); break; case "align": r.alt(e, t, ["start", rk, "end", "left", "right"]) } }, /:/, /\s/), t.region = r.get("region", null), t.vertical = r.get("vertical", ""); let n = r.get("line", "auto"); "auto" === n && -1 === rO.line && (n = -1), t.line = n, t.lineAlign = r.get("lineAlign", "start"), t.snapToLines = r.get("snapToLines", !0), t.size = r.get("size", 100), t.align = r.get("align", rk); let s = r.get("position", "auto"); "auto" === s && 50 === rO.position && (s = "start" === t.align || "left" === t.align ? 0 : "end" === t.align || "right" === t.align ? 100 : 50), t.position = s }(e, t) }(e, t.cue, t.regionList) } catch (e) { t.cue = null, t.state = "BADCUE"; continue } t.state = "CUETEXT"; continue; case "CUETEXT": { let i = -1 !== e.indexOf("--\x3e"); if (!e || i && (n = !0)) { t.oncue && t.cue && t.oncue(t.cue), t.cue = null, t.state = "ID"; continue } if (null === t.cue) continue; t.cue.text && (t.cue.text += "\n"), t.cue.text += e } continue; case "BADCUE": e || (t.state = "ID") } } catch (e) { "CUETEXT" === t.state && t.cue && t.oncue && t.oncue(t.cue), t.cue = null, t.state = "INITIAL" === t.state ? "BADWEBVTT" : "BADCUE" } return this } flush() { try { if ((this.cue || "HEADER" === this.state) && (this.buffer += "\n\n", this.parse()), "INITIAL" === this.state || "BADWEBVTT" === this.state) throw Error("Malformed WebVTT signature.") } catch (e) { this.onparsingerror && this.onparsingerror(e) } return this.onflush && this.onflush(), this } } let rN = /\r\n|\n\r|\n|\r/g, rB = function (e, t, i = 0) { return e.slice(i, i + t.length) === t }, rz = function (e) { let t = parseInt(e.slice(-3)), i = parseInt(e.slice(-6, -4)), r = parseInt(e.slice(-9, -7)), n = e.length > 9 ? parseInt(e.substring(0, e.indexOf(":"))) : 0; if (!p(t) || !p(i) || !p(r) || !p(n)) throw Error(`Malformed X-TIMESTAMP-MAP: Local:${e}`); return t += 1e3 * i, t += 6e4 * r, t += 36e5 * n }, rG = function (e) { let t = 5381, i = e.length; for (; i;)t = 33 * t ^ e.charCodeAt(--i); return (t >>> 0).toString() }; function rH(e, t, i) { return rG(e.toString()) + rG(t.toString()) + rG(i) } let rV = function (e, t, i) { let r = e[t], n = e[r.prevCC]; if (!n || !n.new && r.new) { e.ccOffset = e.presentationOffset = r.start, r.new = !1; return } for (; null != (s = n) && s.new;) { var s; e.ccOffset += r.start - n.start, r.new = !1, n = e[(r = n).prevCC] } e.presentationOffset = i }, rW = "stpp.ttml.im1t", rj = /^(\d{2,}):(\d{2}):(\d{2}):(\d{2})\.?(\d+)?$/, rY = /^(\d*(?:\.\d*)?)(h|m|s|ms|f|t)$/, rX = { left: "start", center: "center", right: "end", start: "start", end: "end" }; function rK(e, t, i, r) { let n = ev(new Uint8Array(e), ["mdat"]); if (0 === n.length) { r(Error("Could not parse IMSC1 mdat")); return } let s = n.map(e => eo(e)), a = function (e, t, i = 1, r = !1) { return ij(e, 1, 1 / i, r) }(t.baseTime, 0, t.timescale); try { s.forEach(e => i(function (e, t) { let i = new DOMParser().parseFromString(e, "text/xml").getElementsByTagName("tt")[0]; if (!i) throw Error("Invalid ttml"); let r = { frameRate: 30, subFrameRate: 1, frameRateMultiplier: 0, tickRate: 0 }, n = Object.keys(r).reduce((e, t) => (e[t] = i.getAttribute(`ttp:${t}`) || r[t], e), {}), s = "preserve" !== i.getAttribute("xml:space"), a = rQ(rq(i, "styling", "style")), o = rQ(rq(i, "layout", "region")), l = rq(i, "body", "[begin]"); return [].map.call(l, e => { let i = function e(t, i) { return [].slice.call(t.childNodes).reduce((t, r, n) => { var s; return "br" === r.nodeName && n ? t + "\n" : null != (s = r.childNodes) && s.length ? e(r, i) : i ? t + r.textContent.trim().replace(/\s+/g, " ") : t + r.textContent }, "") }(e, s); if (!i || !e.hasAttribute("begin")) return null; let r = rJ(e.getAttribute("begin"), n), l = rJ(e.getAttribute("dur"), n), u = rJ(e.getAttribute("end"), n); if (null === r) throw r$(e); if (null === u) { if (null === l) throw r$(e); u = r + l } let h = new rC(r - t, u - t, i); h.id = rH(h.startTime, h.endTime, h.text); let c = o[e.getAttribute("region")], d = function (e, t, i) { let r = "http://www.w3.org/ns/ttml#styling", n = null, s = null != e && e.hasAttribute("style") ? e.getAttribute("style") : null; return s && i.hasOwnProperty(s) && (n = i[s]), ["displayAlign", "textAlign", "color", "backgroundColor", "fontSize", "fontFamily"].reduce((i, s) => { let a = rZ(t, r, s) || rZ(e, r, s) || rZ(n, r, s); return a && (i[s] = a), i }, {}) }(c, a[e.getAttribute("style")], a), { textAlign: p } = d; if (p) { let e = rX[p]; e && (h.lineAlign = e), h.align = p } return f(h, d), h }).filter(e => null !== e) }(e, a))) } catch (e) { r(e) } } function rq(e, t, i) { let r = e.getElementsByTagName(t)[0]; return r ? [].slice.call(r.querySelectorAll(i)) : [] } function rQ(e) { return e.reduce((e, t) => { let i = t.getAttribute("xml:id"); return i && (e[i] = t), e }, {}) } function rZ(e, t, i) { return e && e.hasAttributeNS(t, i) ? e.getAttributeNS(t, i) : null } function r$(e) { return Error(`Could not parse ttml timestamp ${e}`) } function rJ(e, t) { if (!e) return null; let i = rL(e); return null === i && (rj.test(e) ? i = function (e, t) { let i = rj.exec(e), r = (0 | i[4]) + (0 | i[5]) / t.subFrameRate; return (0 | i[1]) * 3600 + (0 | i[2]) * 60 + (0 | i[3]) + r / t.frameRate }(e, t) : rY.test(e) && (i = function (e, t) { let i = rY.exec(e), r = Number(i[1]); switch (i[2]) { case "h": return 3600 * r; case "m": return 60 * r; case "ms": return 1e3 * r; case "f": return r / t.frameRate; case "t": return r / t.tickRate }return r }(e, t))), i } class r0 { constructor(e) { this.hls = void 0, this.media = null, this.config = void 0, this.enabled = !0, this.Cues = void 0, this.textTracks = [], this.tracks = [], this.initPTS = [], this.unparsedVttFrags = [], this.captionsTracks = {}, this.nonNativeCaptionsTracks = {}, this.cea608Parser1 = void 0, this.cea608Parser2 = void 0, this.lastCc = -1, this.lastSn = -1, this.lastPartIndex = -1, this.prevCC = -1, this.vttCCs = r3(), this.captionsProperties = void 0, this.hls = e, this.config = e.config, this.Cues = e.config.cueHandler, this.captionsProperties = { textTrack1: { label: this.config.captionsTextTrack1Label, languageCode: this.config.captionsTextTrack1LanguageCode }, textTrack2: { label: this.config.captionsTextTrack2Label, languageCode: this.config.captionsTextTrack2LanguageCode }, textTrack3: { label: this.config.captionsTextTrack3Label, languageCode: this.config.captionsTextTrack3LanguageCode }, textTrack4: { label: this.config.captionsTextTrack4Label, languageCode: this.config.captionsTextTrack4LanguageCode } }, e.on(v.MEDIA_ATTACHING, this.onMediaAttaching, this), e.on(v.MEDIA_DETACHING, this.onMediaDetaching, this), e.on(v.MANIFEST_LOADING, this.onManifestLoading, this), e.on(v.MANIFEST_LOADED, this.onManifestLoaded, this), e.on(v.SUBTITLE_TRACKS_UPDATED, this.onSubtitleTracksUpdated, this), e.on(v.FRAG_LOADING, this.onFragLoading, this), e.on(v.FRAG_LOADED, this.onFragLoaded, this), e.on(v.FRAG_PARSING_USERDATA, this.onFragParsingUserdata, this), e.on(v.FRAG_DECRYPTED, this.onFragDecrypted, this), e.on(v.INIT_PTS_FOUND, this.onInitPtsFound, this), e.on(v.SUBTITLE_TRACKS_CLEARED, this.onSubtitleTracksCleared, this), e.on(v.BUFFER_FLUSHING, this.onBufferFlushing, this) } destroy() { let { hls: e } = this; e.off(v.MEDIA_ATTACHING, this.onMediaAttaching, this), e.off(v.MEDIA_DETACHING, this.onMediaDetaching, this), e.off(v.MANIFEST_LOADING, this.onManifestLoading, this), e.off(v.MANIFEST_LOADED, this.onManifestLoaded, this), e.off(v.SUBTITLE_TRACKS_UPDATED, this.onSubtitleTracksUpdated, this), e.off(v.FRAG_LOADING, this.onFragLoading, this), e.off(v.FRAG_LOADED, this.onFragLoaded, this), e.off(v.FRAG_PARSING_USERDATA, this.onFragParsingUserdata, this), e.off(v.FRAG_DECRYPTED, this.onFragDecrypted, this), e.off(v.INIT_PTS_FOUND, this.onInitPtsFound, this), e.off(v.SUBTITLE_TRACKS_CLEARED, this.onSubtitleTracksCleared, this), e.off(v.BUFFER_FLUSHING, this.onBufferFlushing, this), this.hls = this.config = null, this.cea608Parser1 = this.cea608Parser2 = void 0 } initCea608Parsers() { if (this.config.enableCEA708Captions && (!this.cea608Parser1 || !this.cea608Parser2)) { let e = new rR(this, "textTrack1"), t = new rR(this, "textTrack2"), i = new rR(this, "textTrack3"), r = new rR(this, "textTrack4"); this.cea608Parser1 = new rM(1, e, t), this.cea608Parser2 = new rM(3, i, r) } } addCues(e, t, i, r, n) { let s = !1; for (let e = n.length; e--;) { var a; let r = n[e], o = (a = r[0], Math.min(r[1], i) - Math.max(a, t)); if (o >= 0 && (r[0] = Math.min(r[0], t), r[1] = Math.max(r[1], i), s = !0, o / (i - t) > .5)) return } if (s || n.push([t, i]), this.config.renderTextTracksNatively) { let n = this.captionsTracks[e]; this.Cues.newCue(n, t, i, r) } else { let n = this.Cues.newCue(null, t, i, r); this.hls.trigger(v.CUES_PARSED, { type: "captions", cues: n, track: e }) } } onInitPtsFound(e, { frag: t, id: i, initPTS: r, timescale: n }) { let { unparsedVttFrags: s } = this; "main" === i && (this.initPTS[t.cc] = { baseTime: r, timescale: n }), s.length && (this.unparsedVttFrags = [], s.forEach(e => { this.onFragLoaded(v.FRAG_LOADED, e) })) } getExistingTrack(e, t) { let { media: i } = this; if (i) for (let r = 0; r < i.textTracks.length; r++) { let n = i.textTracks[r]; if (r2(n, { name: e, lang: t, attrs: {} })) return n } return null } createCaptionsTrack(e) { this.config.renderTextTracksNatively ? this.createNativeTrack(e) : this.createNonNativeTrack(e) } createNativeTrack(e) { if (this.captionsTracks[e]) return; let { captionsProperties: t, captionsTracks: i, media: r } = this, { label: n, languageCode: s } = t[e], a = this.getExistingTrack(n, s); if (a) i[e] = a, e7(i[e]), e6(i[e], r); else { let t = this.createTextTrack("captions", n, s); t && (t[e] = !0, i[e] = t) } } createNonNativeTrack(e) { if (this.nonNativeCaptionsTracks[e]) return; let t = this.captionsProperties[e]; if (!t) return; let i = { _id: e, label: t.label, kind: "captions", default: !!t.media && !!t.media.default, closedCaptions: t.media }; this.nonNativeCaptionsTracks[e] = i, this.hls.trigger(v.NON_NATIVE_TEXT_TRACKS_FOUND, { tracks: [i] }) } createTextTrack(e, t, i) { let r = this.media; if (r) return r.addTextTrack(e, t, i) } onMediaAttaching(e, t) { this.media = t.media, this._cleanTracks() } onMediaDetaching() { let { captionsTracks: e } = this; Object.keys(e).forEach(t => { e7(e[t]), delete e[t] }), this.nonNativeCaptionsTracks = {} } onManifestLoading() { this.lastCc = -1, this.lastSn = -1, this.lastPartIndex = -1, this.prevCC = -1, this.vttCCs = r3(), this._cleanTracks(), this.tracks = [], this.captionsTracks = {}, this.nonNativeCaptionsTracks = {}, this.textTracks = [], this.unparsedVttFrags = [], this.initPTS = [], this.cea608Parser1 && this.cea608Parser2 && (this.cea608Parser1.reset(), this.cea608Parser2.reset()) } _cleanTracks() { let { media: e } = this; if (!e) return; let t = e.textTracks; if (t) for (let e = 0; e < t.length; e++)e7(t[e]) } onSubtitleTracksUpdated(e, t) { let i = t.subtitleTracks || [], r = i.some(e => e.textCodec === rW); if (this.config.enableWebVTT || r && this.config.enableIMSC1) { if (ri(this.tracks, i)) { this.tracks = i; return } if (this.textTracks = [], this.tracks = i, this.config.renderTextTracksNatively) { let e = this.media, t = e ? tt(e.textTracks) : null; if (this.tracks.forEach((e, i) => { let r; if (t) { let i = null; for (let r = 0; r < t.length; r++)if (t[r] && r2(t[r], e)) { i = t[r], t[r] = null; break } i && (r = i) } if (r) e7(r); else { let t = r1(e); (r = this.createTextTrack(t, e.name, e.lang)) && (r.mode = "disabled") } r && this.textTracks.push(r) }), null != t && t.length) { let e = t.filter(e => null !== e).map(e => e.label); e.length && E.warn(`Media element contains unused subtitle tracks: ${e.join(", ")}. Replace media element for each source to clear TextTracks and captions menu.`) } } else if (this.tracks.length) { let e = this.tracks.map(e => ({ label: e.name, kind: e.type.toLowerCase(), default: e.default, subtitleTrack: e })); this.hls.trigger(v.NON_NATIVE_TEXT_TRACKS_FOUND, { tracks: e }) } } } onManifestLoaded(e, t) { this.config.enableCEA708Captions && t.captions && t.captions.forEach(e => { let t = /(?:CC|SERVICE)([1-4])/.exec(e.instreamId); if (!t) return; let i = `textTrack${t[1]}`, r = this.captionsProperties[i]; r && (r.label = e.name, e.lang && (r.languageCode = e.lang), r.media = e) }) } closedCaptionsForLevel(e) { let t = this.hls.levels[e.level]; return null == t ? void 0 : t.attrs["CLOSED-CAPTIONS"] } onFragLoading(e, t) { if (this.enabled && t.frag.type === e3.MAIN) { var i, r; let { cea608Parser1: e, cea608Parser2: n, lastSn: s } = this, { cc: a, sn: o } = t.frag, l = null != (i = null == (r = t.part) ? void 0 : r.index) ? i : -1; e && n && (o !== s + 1 || o === s && l !== this.lastPartIndex + 1 || a !== this.lastCc) && (e.reset(), n.reset()), this.lastCc = a, this.lastSn = o, this.lastPartIndex = l } } onFragLoaded(e, t) { let { frag: i, payload: r } = t; if (i.type === e3.SUBTITLE) { if (r.byteLength) { let e = i.decryptdata, n = "stats" in t; if (null == e || !e.encrypted || n) { let e = this.tracks[i.level], n = this.vttCCs; n[i.cc] || (n[i.cc] = { start: i.start, prevCC: this.prevCC, new: !0 }, this.prevCC = i.cc), e && e.textCodec === rW ? this._parseIMSC1(i, r) : this._parseVTTs(t) } } else this.hls.trigger(v.SUBTITLE_FRAG_PROCESSED, { success: !1, frag: i, error: Error("Empty subtitle payload") }) } } _parseIMSC1(e, t) { let i = this.hls; rK(t, this.initPTS[e.cc], t => { this._appendCues(t, e.level), i.trigger(v.SUBTITLE_FRAG_PROCESSED, { success: !0, frag: e }) }, t => { E.log(`Failed to parse IMSC1: ${t}`), i.trigger(v.SUBTITLE_FRAG_PROCESSED, { success: !1, frag: e, error: t }) }) } _parseVTTs(e) { var t; let { frag: i, payload: r } = e, { initPTS: n, unparsedVttFrags: s } = this, a = n.length - 1; if (!n[i.cc] && -1 === a) { s.push(e); return } let o = this.hls; !function (e, t, i, r, n, s, a) { let o; let l = new rU, u = eo(new Uint8Array(e)).trim().replace(rN, "\n").split("\n"), h = [], c = t ? function (e, t = 1) { return ij(e, 9e4, 1 / t) }(t.baseTime, t.timescale) : 0, d = "00:00.000", f = 0, p = 0, m = !0; l.oncue = function (e) { let s = i[r], a = i.ccOffset, l = (f - c) / 9e4; if (null != s && s.new && (void 0 !== p ? a = i.ccOffset = s.start : rV(i, r, l)), l) { if (!t) { o = Error("Missing initPTS for VTT MPEGTS"); return } a = l - i.presentationOffset } let u = e.endTime - e.startTime, d = iQ((e.startTime + a - p) * 9e4, 9e4 * n) / 9e4; e.startTime = Math.max(d, 0), e.endTime = Math.max(d + u, 0); let m = e.text.trim(); e.text = decodeURIComponent(encodeURIComponent(m)), e.id || (e.id = rH(e.startTime, e.endTime, m)), e.endTime > 0 && h.push(e) }, l.onparsingerror = function (e) { o = e }, l.onflush = function () { if (o) { a(o); return } s(h) }, u.forEach(e => { if (m) { if (rB(e, "X-TIMESTAMP-MAP=")) { m = !1, e.slice(16).split(",").forEach(e => { rB(e, "LOCAL:") ? d = e.slice(6) : rB(e, "MPEGTS:") && (f = parseInt(e.slice(7))) }); try { p = rz(d) / 1e3 } catch (e) { o = e } return } "" === e && (m = !1) } l.parse(e + "\n") }), l.flush() }(null != (t = i.initSegment) && t.data ? eE(i.initSegment.data, new Uint8Array(r)) : r, this.initPTS[i.cc], this.vttCCs, i.cc, i.start, e => { this._appendCues(e, i.level), o.trigger(v.SUBTITLE_FRAG_PROCESSED, { success: !0, frag: i }) }, t => { let n = "Missing initPTS for VTT MPEGTS" === t.message; n ? s.push(e) : this._fallbackToIMSC1(i, r), E.log(`Failed to parse VTT cue: ${t}`), n && a > i.cc || o.trigger(v.SUBTITLE_FRAG_PROCESSED, { success: !1, frag: i, error: t }) }) } _fallbackToIMSC1(e, t) { let i = this.tracks[e.level]; i.textCodec || rK(t, this.initPTS[e.cc], () => { i.textCodec = rW, this._parseIMSC1(e, t) }, () => { i.textCodec = "wvtt" }) } _appendCues(e, t) { let i = this.hls; if (this.config.renderTextTracksNatively) { let i = this.textTracks[t]; if (!i || "disabled" === i.mode) return; e.forEach(e => e9(i, e)) } else { let r = this.tracks[t]; if (!r) return; let n = r.default ? "default" : "subtitles" + t; i.trigger(v.CUES_PARSED, { type: "subtitles", cues: e, track: n }) } } onFragDecrypted(e, t) { let { frag: i } = t; i.type === e3.SUBTITLE && this.onFragLoaded(v.FRAG_LOADED, t) } onSubtitleTracksCleared() { this.tracks = [], this.captionsTracks = {} } onFragParsingUserdata(e, t) { this.initCea608Parsers(); let { cea608Parser1: i, cea608Parser2: r } = this; if (!this.enabled || !i || !r) return; let { frag: n, samples: s } = t; if (n.type !== e3.MAIN || "NONE" !== this.closedCaptionsForLevel(n)) for (let e = 0; e < s.length; e++) { let t = s[e].bytes; if (t) { let n = this.extractCea608Data(t); i.addData(s[e].pts, n[0]), r.addData(s[e].pts, n[1]) } } } onBufferFlushing(e, { startOffset: t, endOffset: i, endOffsetSubtitles: r, type: n }) { let { media: s } = this; if (s && !(s.currentTime < i)) { if (!n || "video" === n) { let { captionsTracks: e } = this; Object.keys(e).forEach(r => te(e[r], t, i)) } if (this.config.renderTextTracksNatively && 0 === t && void 0 !== r) { let { textTracks: e } = this; Object.keys(e).forEach(i => te(e[i], t, r)) } } } extractCea608Data(e) { let t = [[], []], i = 31 & e[0], r = 2; for (let n = 0; n < i; n++) { let i = e[r++], n = 127 & e[r++], s = 127 & e[r++]; if ((0 !== n || 0 !== s) && (4 & i) != 0) { let e = 3 & i; (0 === e || 1 === e) && (t[e].push(n), t[e].push(s)) } } return t } } function r1(e) { return e.characteristics && /transcribes-spoken-dialog/gi.test(e.characteristics) && /describes-music-and-sound/gi.test(e.characteristics) ? "captions" : "subtitles" } function r2(e, t) { return !!e && e.kind === r1(t) && rn(t, e) } function r3() { return { ccOffset: 0, presentationOffset: 0, 0: { start: 0, prevCC: -1, new: !0 } } } class r4 { constructor(e) { this.hls = void 0, this.autoLevelCapping = void 0, this.firstLevel = void 0, this.media = void 0, this.restrictedLevels = void 0, this.timer = void 0, this.clientRect = void 0, this.streamController = void 0, this.hls = e, this.autoLevelCapping = Number.POSITIVE_INFINITY, this.firstLevel = -1, this.media = null, this.restrictedLevels = [], this.timer = void 0, this.clientRect = null, this.registerListeners() } setStreamController(e) { this.streamController = e } destroy() { this.hls && this.unregisterListener(), this.timer && this.stopCapping(), this.media = null, this.clientRect = null, this.hls = this.streamController = null } registerListeners() { let { hls: e } = this; e.on(v.FPS_DROP_LEVEL_CAPPING, this.onFpsDropLevelCapping, this), e.on(v.MEDIA_ATTACHING, this.onMediaAttaching, this), e.on(v.MANIFEST_PARSED, this.onManifestParsed, this), e.on(v.LEVELS_UPDATED, this.onLevelsUpdated, this), e.on(v.BUFFER_CODECS, this.onBufferCodecs, this), e.on(v.MEDIA_DETACHING, this.onMediaDetaching, this) } unregisterListener() { let { hls: e } = this; e.off(v.FPS_DROP_LEVEL_CAPPING, this.onFpsDropLevelCapping, this), e.off(v.MEDIA_ATTACHING, this.onMediaAttaching, this), e.off(v.MANIFEST_PARSED, this.onManifestParsed, this), e.off(v.LEVELS_UPDATED, this.onLevelsUpdated, this), e.off(v.BUFFER_CODECS, this.onBufferCodecs, this), e.off(v.MEDIA_DETACHING, this.onMediaDetaching, this) } onFpsDropLevelCapping(e, t) { let i = this.hls.levels[t.droppedLevel]; this.isLevelAllowed(i) && this.restrictedLevels.push({ bitrate: i.bitrate, height: i.height, width: i.width }) } onMediaAttaching(e, t) { this.media = t.media instanceof HTMLVideoElement ? t.media : null, this.clientRect = null, this.timer && this.hls.levels.length && this.detectPlayerSize() } onManifestParsed(e, t) { let i = this.hls; this.restrictedLevels = [], this.firstLevel = t.firstLevel, i.config.capLevelToPlayerSize && t.video && this.startCapping() } onLevelsUpdated(e, t) { this.timer && p(this.autoLevelCapping) && this.detectPlayerSize() } onBufferCodecs(e, t) { this.hls.config.capLevelToPlayerSize && t.video && this.startCapping() } onMediaDetaching() { this.stopCapping() } detectPlayerSize() { if (this.media) { if (this.mediaHeight <= 0 || this.mediaWidth <= 0) { this.clientRect = null; return } let e = this.hls.levels; if (e.length) { let t = this.hls, i = this.getMaxLevel(e.length - 1); i !== this.autoLevelCapping && E.log(`Setting autoLevelCapping to ${i}: ${e[i].height}p@${e[i].bitrate} for media ${this.mediaWidth}x${this.mediaHeight}`), t.autoLevelCapping = i, t.autoLevelCapping > this.autoLevelCapping && this.streamController && this.streamController.nextLevelSwitch(), this.autoLevelCapping = t.autoLevelCapping } } } getMaxLevel(e) { let t = this.hls.levels; if (!t.length) return -1; let i = t.filter((t, i) => this.isLevelAllowed(t) && i <= e); return this.clientRect = null, r4.getMaxLevelByMediaSize(i, this.mediaWidth, this.mediaHeight) } startCapping() { this.timer || (this.autoLevelCapping = Number.POSITIVE_INFINITY, self.clearInterval(this.timer), this.timer = self.setInterval(this.detectPlayerSize.bind(this), 1e3), this.detectPlayerSize()) } stopCapping() { this.restrictedLevels = [], this.firstLevel = -1, this.autoLevelCapping = Number.POSITIVE_INFINITY, this.timer && (self.clearInterval(this.timer), this.timer = void 0) } getDimensions() { if (this.clientRect) return this.clientRect; let e = this.media, t = { width: 0, height: 0 }; if (e) { let i = e.getBoundingClientRect(); t.width = i.width, t.height = i.height, t.width || t.height || (t.width = i.right - i.left || e.width || 0, t.height = i.bottom - i.top || e.height || 0) } return this.clientRect = t, t } get mediaWidth() { return this.getDimensions().width * this.contentScaleFactor } get mediaHeight() { return this.getDimensions().height * this.contentScaleFactor } get contentScaleFactor() { let e = 1; if (!this.hls.config.ignoreDevicePixelRatio) try { e = self.devicePixelRatio } catch (e) { } return e } isLevelAllowed(e) { return !this.restrictedLevels.some(t => e.bitrate === t.bitrate && e.width === t.width && e.height === t.height) } static getMaxLevelByMediaSize(e, t, i) { if (!(null != e && e.length)) return -1; let r = (e, t) => !t || e.width !== t.width || e.height !== t.height, n = e.length - 1, s = Math.max(t, i); for (let t = 0; t < e.length; t += 1) { let i = e[t]; if ((i.width >= s || i.height >= s) && r(i, e[t + 1])) { n = t; break } } return n } } class r5 { constructor(e) { this.hls = void 0, this.isVideoPlaybackQualityAvailable = !1, this.timer = void 0, this.media = null, this.lastTime = void 0, this.lastDroppedFrames = 0, this.lastDecodedFrames = 0, this.streamController = void 0, this.hls = e, this.registerListeners() } setStreamController(e) { this.streamController = e } registerListeners() { this.hls.on(v.MEDIA_ATTACHING, this.onMediaAttaching, this) } unregisterListeners() { this.hls.off(v.MEDIA_ATTACHING, this.onMediaAttaching, this) } destroy() { this.timer && clearInterval(this.timer), this.unregisterListeners(), this.isVideoPlaybackQualityAvailable = !1, this.media = null } onMediaAttaching(e, t) { let i = this.hls.config; if (i.capLevelOnFPSDrop) { let e = t.media instanceof self.HTMLVideoElement ? t.media : null; this.media = e, e && "function" == typeof e.getVideoPlaybackQuality && (this.isVideoPlaybackQualityAvailable = !0), self.clearInterval(this.timer), this.timer = self.setInterval(this.checkFPSInterval.bind(this), i.fpsDroppedMonitoringPeriod) } } checkFPS(e, t, i) { let r = performance.now(); if (t) { if (this.lastTime) { let e = r - this.lastTime, n = i - this.lastDroppedFrames, s = t - this.lastDecodedFrames, a = 1e3 * n / e, o = this.hls; if (o.trigger(v.FPS_DROP, { currentDropped: n, currentDecoded: s, totalDroppedFrames: i }), a > 0 && n > o.config.fpsDroppedMonitoringThreshold * s) { let e = o.currentLevel; E.warn("drop FPS ratio greater than max allowed value for currentLevel: " + e), e > 0 && (-1 === o.autoLevelCapping || o.autoLevelCapping >= e) && (e -= 1, o.trigger(v.FPS_DROP_LEVEL_CAPPING, { level: e, droppedLevel: o.currentLevel }), o.autoLevelCapping = e, this.streamController.nextLevelSwitch()) } } this.lastTime = r, this.lastDroppedFrames = i, this.lastDecodedFrames = t } } checkFPSInterval() { let e = this.media; if (e) { if (this.isVideoPlaybackQualityAvailable) { let t = e.getVideoPlaybackQuality(); this.checkFPS(e, t.totalVideoFrames, t.droppedVideoFrames) } else this.checkFPS(e, e.webkitDecodedFrameCount, e.webkitDroppedFrameCount) } } } let r8 = "[eme]"; class r6 {
      constructor(e) { this.hls = void 0, this.config = void 0, this.media = null, this.keyFormatPromise = null, this.keySystemAccessPromises = {}, this._requestLicenseFailureCount = 0, this.mediaKeySessions = [], this.keyIdToKeySessionPromise = {}, this.setMediaKeysQueue = r6.CDMCleanupPromise ? [r6.CDMCleanupPromise] : [], this.debug = E.debug.bind(E, r8), this.log = E.log.bind(E, r8), this.warn = E.warn.bind(E, r8), this.error = E.error.bind(E, r8), this.onMediaEncrypted = e => { let { initDataType: t, initData: i } = e, r = `"${e.type}" event: init data type: "${t}"`; if (this.debug(r), null !== i) { if (!this.keyFormatPromise) { let e = Object.keys(this.keySystemAccessPromises); e.length || (e = V(this.config)); let t = e.map(H).filter(e => !!e); this.keyFormatPromise = this.getKeyFormatPromise(t) } this.keyFormatPromise.then(n => { let s, a; let o = B(n); if ("sinf" === t) { if (o !== U.FAIRPLAY) { this.warn(`Ignoring unexpected "${e.type}" event with init data type: "${t}" for selected key-system ${o}`); return } let n = ec(new Uint8Array(i)); try { let e = O(JSON.parse(n).sinf), t = e_(e); if (!t) throw Error("'schm' box missing or not cbcs/cenc with schi > tenc"); s = t.subarray(8, 24), a = U.FAIRPLAY } catch (e) { this.warn(`${r} Failed to parse sinf: ${e}`); return } } else { if (o !== U.WIDEVINE && o !== U.PLAYREADY) { this.warn(`Ignoring unexpected "${e.type}" event with init data type: "${t}" for selected key-system ${o}`); return } let n = function (e) { let t = []; if (e instanceof ArrayBuffer) { let i = e.byteLength, r = 0; for (; r + 32 < i;) { let i = function (e) { let t = e.getUint32(0), i = e.byteOffset, r = e.byteLength; if (r < t) return { offset: i, size: r }; if (0x70737368 !== e.getUint32(4)) return { offset: i, size: t }; let n = e.getUint32(8) >>> 24; if (0 !== n && 1 !== n) return { offset: i, size: t }; let s = e.buffer, a = el.hexDump(new Uint8Array(s, i + 12, 16)), o = e.getUint32(28), l = null, u = null; if (0 === n) { if (t - 32 < o || o < 22) return { offset: i, size: t }; u = new Uint8Array(s, i + 32, o) } else if (1 === n) { if (!o || r < i + 32 + 16 * o + 16) return { offset: i, size: t }; l = []; for (let e = 0; e < o; e++)l.push(new Uint8Array(s, i + 32 + 16 * e, 16)) } return { version: n, systemId: a, kids: l, data: u, offset: i, size: t } }(new DataView(e, r)); t.push(i), r += i.size } } return t }(i), l = n.filter(e => !!e.systemId && G(e.systemId) === o); l.length > 1 && this.warn(`${r} Using first of ${l.length} pssh found for selected key-system ${o}`); let u = l[0]; if (!u) { 0 === n.length || n.some(e => !e.systemId) ? this.warn(`${r} contains incomplete or invalid pssh data`) : this.log(`ignoring ${r} for ${n.map(e => G(e.systemId)).join(",")} pssh data in favor of playlist keys`); return } if (a = G(u.systemId), 0 === u.version && u.data) { if (a === U.WIDEVINE) { let e = u.data.length - 22; s = u.data.subarray(e, e + 16) } else a === U.PLAYREADY && (s = j(u.data)) } } if (!a || !s) { this.log(`Unable to handle ${r} with key-system ${o}`); return } let l = el.hexDump(s), { keyIdToKeySessionPromise: u, mediaKeySessions: h } = this, c = u[l]; for (let e = 0; e < h.length; e++) { let r = h[e], n = r.decryptdata; if (!n.keyId) continue; let a = el.hexDump(n.keyId); if (l === a || -1 !== n.uri.replace(/-/g, "").indexOf(l)) { if (c = u[a], n.pssh) break; delete u[a], n.pssh = new Uint8Array(i), n.keyId = s, (c = u[l] = c.then(() => this.generateRequestWithPreferredKeySession(r, t, i, "encrypted-event-key-match"))).catch(e => this.handleError(e)); break } } if (!c) { if (a !== o) { this.log(`Ignoring "${r}" with ${a} init data for selected key-system ${o}`); return } (c = u[l] = this.getKeySystemSelectionPromise([a]).then(({ keySystem: e, mediaKeys: r }) => { var n; this.throwIfDestroyed(); let a = new eR("ISO-23001-7", l, null != (n = H(e)) ? n : ""); return a.pssh = new Uint8Array(i), a.keyId = s, this.attemptSetMediaKeys(e, r).then(() => { this.throwIfDestroyed(); let n = this.createMediaKeySessionContext({ decryptdata: a, keySystem: e, mediaKeys: r }); return this.generateRequestWithPreferredKeySession(n, t, i, "encrypted-event-no-match") }) })).catch(e => this.handleError(e)) } }) } }, this.onWaitingForKey = e => { this.log(`"${e.type}" event`) }, this.hls = e, this.config = e.config, this.registerListeners() } destroy() { this.unregisterListeners(), this.onMediaDetached(); let e = this.config; e.requestMediaKeySystemAccessFunc = null, e.licenseXhrSetup = e.licenseResponseCallback = void 0, e.drmSystems = e.drmSystemOptions = {}, this.hls = this.config = this.keyIdToKeySessionPromise = null, this.onMediaEncrypted = this.onWaitingForKey = null } registerListeners() { this.hls.on(v.MEDIA_ATTACHED, this.onMediaAttached, this), this.hls.on(v.MEDIA_DETACHED, this.onMediaDetached, this), this.hls.on(v.MANIFEST_LOADING, this.onManifestLoading, this), this.hls.on(v.MANIFEST_LOADED, this.onManifestLoaded, this) } unregisterListeners() { this.hls.off(v.MEDIA_ATTACHED, this.onMediaAttached, this), this.hls.off(v.MEDIA_DETACHED, this.onMediaDetached, this), this.hls.off(v.MANIFEST_LOADING, this.onManifestLoading, this), this.hls.off(v.MANIFEST_LOADED, this.onManifestLoaded, this) } getLicenseServerUrl(e) { let { drmSystems: t, widevineLicenseUrl: i } = this.config, r = t[e]; return r ? r.licenseUrl : e === U.WIDEVINE && i ? i : void 0 } getLicenseServerUrlOrThrow(e) { let t = this.getLicenseServerUrl(e); if (void 0 === t) throw Error(`no license server URL configured for key-system "${e}"`); return t } getServerCertificateUrl(e) { let { drmSystems: t } = this.config, i = t[e]; if (i) return i.serverCertificateUrl; this.log(`No Server Certificate in config.drmSystems["${e}"]`) } attemptKeySystemAccess(e) { let t = this.hls.levels, i = (e, t, i) => !!e && i.indexOf(e) === t, r = t.map(e => e.audioCodec).filter(i), n = t.map(e => e.videoCodec).filter(i); return r.length + n.length === 0 && n.push("avc1.42e01e"), new Promise((t, i) => { let s = e => { let a = e.shift(); this.getMediaKeysPromise(a, r, n).then(e => t({ keySystem: a, mediaKeys: e })).catch(t => { e.length ? s(e) : t instanceof r9 ? i(t) : i(new r9({ type: y.KEY_SYSTEM_ERROR, details: x.KEY_SYSTEM_NO_ACCESS, error: t, fatal: !0 }, t.message)) }) }; s(e) }) } requestMediaKeySystemAccess(e, t) { let { requestMediaKeySystemAccessFunc: i } = this.config; if ("function" != typeof i) { let e = `Configured requestMediaKeySystemAccess is not a function ${i}`; return null === W && "http:" === self.location.protocol && (e = `navigator.requestMediaKeySystemAccess is not available over insecure protocol ${location.protocol}`), Promise.reject(Error(e)) } return i(e, t) } getMediaKeysPromise(e, t, i) { let r = function (e, t, i, r) { let n; switch (e) { case U.FAIRPLAY: n = ["cenc", "sinf"]; break; case U.WIDEVINE: case U.PLAYREADY: n = ["cenc"]; break; case U.CLEARKEY: n = ["cenc", "keyids"]; break; default: throw Error(`Unknown key-system: ${e}`) }return [{ initDataTypes: n, persistentState: r.persistentState || "optional", distinctiveIdentifier: r.distinctiveIdentifier || "optional", sessionTypes: r.sessionTypes || [r.sessionType || "temporary"], audioCapabilities: t.map(e => ({ contentType: `audio/mp4; codecs="${e}"`, robustness: r.audioRobustness || "", encryptionScheme: r.audioEncryptionScheme || null })), videoCapabilities: i.map(e => ({ contentType: `video/mp4; codecs="${e}"`, robustness: r.videoRobustness || "", encryptionScheme: r.videoEncryptionScheme || null })) }] }(e, t, i, this.config.drmSystemOptions), n = this.keySystemAccessPromises[e], s = null == n ? void 0 : n.keySystemAccess; if (!s) { this.log(`Requesting encrypted media "${e}" key-system access with config: ${JSON.stringify(r)}`), s = this.requestMediaKeySystemAccess(e, r); let t = this.keySystemAccessPromises[e] = { keySystemAccess: s }; return s.catch(t => { this.log(`Failed to obtain access to key-system "${e}": ${t}`) }), s.then(i => { this.log(`Access for key-system "${i.keySystem}" obtained`); let r = this.fetchServerCertificate(e); return this.log(`Create media-keys for "${e}"`), t.mediaKeys = i.createMediaKeys().then(t => (this.log(`Media-keys created for "${e}"`), r.then(i => i ? this.setMediaKeysServerCertificate(t, e, i) : t))), t.mediaKeys.catch(t => { this.error(`Failed to create media-keys for "${e}"}: ${t}`) }), t.mediaKeys }) } return s.then(() => n.mediaKeys) } createMediaKeySessionContext({ decryptdata: e, keySystem: t, mediaKeys: i }) { this.log(`Creating key-system session "${t}" keyId: ${el.hexDump(e.keyId || [])}`); let r = i.createSession(), n = { decryptdata: e, keySystem: t, mediaKeys: i, mediaKeysSession: r, keyStatus: "status-pending" }; return this.mediaKeySessions.push(n), n } renewKeySession(e) { let t = e.decryptdata; if (t.pssh) { let i = this.createMediaKeySessionContext(e), r = this.getKeyIdString(t); this.keyIdToKeySessionPromise[r] = this.generateRequestWithPreferredKeySession(i, "cenc", t.pssh, "expired") } else this.warn("Could not renew expired session. Missing pssh initData."); this.removeSession(e) } getKeyIdString(e) { if (!e) throw Error("Could not read keyId of undefined decryptdata"); if (null === e.keyId) throw Error("keyId is null"); return el.hexDump(e.keyId) } updateKeySession(e, t) {
        var i; let r = e.mediaKeysSession; return this.log(`Updating key-session "${r.sessionId}" for keyID ${el.hexDump((null == (i = e.decryptdata) ? void 0 : i.keyId) || [])}
      } (data length: ${t ? t.byteLength : t})`), r.update(t)
      } selectKeySystemFormat(e) { let t = Object.keys(e.levelkeys || {}); return this.keyFormatPromise || (this.log(`Selecting key-system from fragment (sn: ${e.sn} ${e.type}: ${e.level}) key formats ${t.join(", ")}`), this.keyFormatPromise = this.getKeyFormatPromise(t)), this.keyFormatPromise } getKeyFormatPromise(e) { return new Promise((t, i) => { let r = V(this.config), n = e.map(B).filter(e => !!e && -1 !== r.indexOf(e)); return this.getKeySystemSelectionPromise(n).then(({ keySystem: e }) => { let r = H(e); r ? t(r) : i(Error(`Unable to find format for key-system "${e}"`)) }).catch(i) }) } loadKey(e) { let t = e.keyInfo.decryptdata, i = this.getKeyIdString(t), r = `(keyId: ${i} format: "${t.keyFormat}" method: ${t.method} uri: ${t.uri})`; this.log(`Starting session for key ${r}`); let n = this.keyIdToKeySessionPromise[i]; return n || (n = this.keyIdToKeySessionPromise[i] = this.getKeySystemForKeyPromise(t).then(({ keySystem: i, mediaKeys: n }) => (this.throwIfDestroyed(), this.log(`Handle encrypted media sn: ${e.frag.sn} ${e.frag.type}: ${e.frag.level} using key ${r}`), this.attemptSetMediaKeys(i, n).then(() => { this.throwIfDestroyed(); let e = this.createMediaKeySessionContext({ keySystem: i, mediaKeys: n, decryptdata: t }); return this.generateRequestWithPreferredKeySession(e, "cenc", t.pssh, "playlist-key") })))).catch(e => this.handleError(e)), n } throwIfDestroyed(e = "Invalid state") { if (!this.hls) throw Error("invalid state") } handleError(e) { this.hls && (this.error(e.message), e instanceof r9 ? this.hls.trigger(v.ERROR, e.data) : this.hls.trigger(v.ERROR, { type: y.KEY_SYSTEM_ERROR, details: x.KEY_SYSTEM_NO_KEYS, error: e, fatal: !0 })) } getKeySystemForKeyPromise(e) { let t = this.getKeyIdString(e), i = this.keyIdToKeySessionPromise[t]; if (!i) { let t = B(e.keyFormat), i = t ? [t] : V(this.config); return this.attemptKeySystemAccess(i) } return i } getKeySystemSelectionPromise(e) { if (e.length || (e = V(this.config)), 0 === e.length) throw new r9({ type: y.KEY_SYSTEM_ERROR, details: x.KEY_SYSTEM_NO_CONFIGURED_LICENSE, fatal: !0 }, `Missing key-system license configuration options ${JSON.stringify({ drmSystems: this.config.drmSystems })}`); return this.attemptKeySystemAccess(e) } attemptSetMediaKeys(e, t) { let i = this.setMediaKeysQueue.slice(); this.log(`Setting media-keys for "${e}"`); let r = Promise.all(i).then(() => { if (!this.media) throw Error("Attempted to set mediaKeys without media element attached"); return this.media.setMediaKeys(t) }); return this.setMediaKeysQueue.push(r), r.then(() => { this.log(`Media-keys set for "${e}"`), i.push(r), this.setMediaKeysQueue = this.setMediaKeysQueue.filter(e => -1 === i.indexOf(e)) }) } generateRequestWithPreferredKeySession(e, t, i, r) { var n, s, a; let o = null == (n = this.config.drmSystems) ? void 0 : null == (s = n[e.keySystem]) ? void 0 : s.generateRequest; if (o) try { let r = o.call(this.hls, t, i, e); if (!r) throw Error("Invalid response from configured generateRequest filter"); t = r.initDataType, i = e.decryptdata.pssh = r.initData ? new Uint8Array(r.initData) : null } catch (e) { if (this.warn(e.message), null != (a = this.hls) && a.config.debug) throw e } if (null === i) return this.log(`Skipping key-session request for "${r}" (no initData)`), Promise.resolve(e); let l = this.getKeyIdString(e.decryptdata); this.log(`Generating key-session request for "${r}": ${l} (init data type: ${t} length: ${i ? i.byteLength : null})`); let u = new i7, h = e._onmessage = t => { let i = e.mediaKeysSession; if (!i) { u.emit("error", Error("invalid state")); return } let { messageType: r, message: n } = t; this.log(`"${r}" message event for session "${i.sessionId}" message size: ${n.byteLength}`), "license-request" === r || "license-renewal" === r ? this.renewLicense(e, n).catch(e => { this.handleError(e), u.emit("error", e) }) : "license-release" === r ? e.keySystem === U.FAIRPLAY && (this.updateKeySession(e, k("acknowledged")), this.removeSession(e)) : this.warn(`unhandled media key message type "${r}"`) }, c = e._onkeystatuseschange = t => { if (!e.mediaKeysSession) { u.emit("error", Error("invalid state")); return } this.onKeyStatusChange(e); let i = e.keyStatus; u.emit("keyStatus", i), "expired" === i && (this.warn(`${e.keySystem} expired for key ${l}`), this.renewKeySession(e)) }; e.mediaKeysSession.addEventListener("message", h), e.mediaKeysSession.addEventListener("keystatuseschange", c); let d = new Promise((e, t) => { u.on("error", t), u.on("keyStatus", i => { i.startsWith("usable") ? e() : "output-restricted" === i ? t(new r9({ type: y.KEY_SYSTEM_ERROR, details: x.KEY_SYSTEM_STATUS_OUTPUT_RESTRICTED, fatal: !1 }, "HDCP level output restricted")) : "internal-error" === i ? t(new r9({ type: y.KEY_SYSTEM_ERROR, details: x.KEY_SYSTEM_STATUS_INTERNAL_ERROR, fatal: !0 }, `key status changed to "${i}"`)) : "expired" === i ? t(Error("key expired while generating request")) : this.warn(`unhandled key status change "${i}"`) }) }); return e.mediaKeysSession.generateRequest(t, i).then(() => { var t; this.log(`Request generated for key-session "${null == (t = e.mediaKeysSession) ? void 0 : t.sessionId}" keyId: ${l}`) }).catch(e => { throw new r9({ type: y.KEY_SYSTEM_ERROR, details: x.KEY_SYSTEM_NO_SESSION, error: e, fatal: !1 }, `Error generating key-session request: ${e}`) }).then(() => d).catch(t => { throw u.removeAllListeners(), this.removeSession(e), t }).then(() => (u.removeAllListeners(), e)) } onKeyStatusChange(e) { e.mediaKeysSession.keyStatuses.forEach((t, i) => { this.log(`key status change "${t}" for keyStatuses keyId: ${el.hexDump("buffer" in i ? new Uint8Array(i.buffer, i.byteOffset, i.byteLength) : new Uint8Array(i))} session keyId: ${el.hexDump(new Uint8Array(e.decryptdata.keyId || []))} uri: ${e.decryptdata.uri}`), e.keyStatus = t }) } fetchServerCertificate(e) { let t = this.config, i = new t.loader(t), r = this.getServerCertificateUrl(e); return r ? (this.log(`Fetching server certificate for "${e}"`), new Promise((n, s) => { let a = { responseType: "arraybuffer", url: r }, o = t.certLoadPolicy.default, l = { loadPolicy: o, timeout: o.maxLoadTimeMs, maxRetry: 0, retryDelay: 0, maxRetryDelay: 0 }; i.load(a, l, { onSuccess: (e, t, i, r) => { n(e.data) }, onError: (t, i, n, o) => { s(new r9({ type: y.KEY_SYSTEM_ERROR, details: x.KEY_SYSTEM_SERVER_CERTIFICATE_REQUEST_FAILED, fatal: !0, networkDetails: n, response: d({ url: a.url, data: void 0 }, t) }, `"${e}" certificate request failed (${r}). Status: ${t.code} (${t.text})`)) }, onTimeout: (t, i, n) => { s(new r9({ type: y.KEY_SYSTEM_ERROR, details: x.KEY_SYSTEM_SERVER_CERTIFICATE_REQUEST_FAILED, fatal: !0, networkDetails: n, response: { url: a.url, data: void 0 } }, `"${e}" certificate request timed out (${r})`)) }, onAbort: (e, t, i) => { s(Error("aborted")) } }) })) : Promise.resolve() } setMediaKeysServerCertificate(e, t, i) { return new Promise((r, n) => { e.setServerCertificate(i).then(n => { this.log(`setServerCertificate ${n ? "success" : "not supported by CDM"} (${null == i ? void 0 : i.byteLength}) on "${t}"`), r(e) }).catch(e => { n(new r9({ type: y.KEY_SYSTEM_ERROR, details: x.KEY_SYSTEM_SERVER_CERTIFICATE_UPDATE_FAILED, error: e, fatal: !0 }, e.message)) }) }) } renewLicense(e, t) { return this.requestLicense(e, new Uint8Array(t)).then(t => this.updateKeySession(e, new Uint8Array(t)).catch(e => { throw new r9({ type: y.KEY_SYSTEM_ERROR, details: x.KEY_SYSTEM_SESSION_UPDATE_FAILED, error: e, fatal: !0 }, e.message) })) } unpackPlayReadyKeyMessage(e, t) { let i = String.fromCharCode.apply(null, new Uint16Array(t.buffer)); if (!i.includes("PlayReadyKeyMessage")) return e.setRequestHeader("Content-Type", "text/xml; charset=utf-8"), t; let r = new DOMParser().parseFromString(i, "application/xml"), n = r.querySelectorAll("HttpHeader"); if (n.length > 0) { let t; for (let i = 0, r = n.length; i < r; i++) { var s, a; let r = null == (s = (t = n[i]).querySelector("name")) ? void 0 : s.textContent, o = null == (a = t.querySelector("value")) ? void 0 : a.textContent; r && o && e.setRequestHeader(r, o) } } let o = r.querySelector("Challenge"), l = null == o ? void 0 : o.textContent; if (!l) throw Error("Cannot find <Challenge> in key message"); return k(atob(l)) } setupLicenseXHR(e, t, i, r) { let n = this.config.licenseXhrSetup; return n ? Promise.resolve().then(() => { if (!i.decryptdata) throw Error("Key removed"); return n.call(this.hls, e, t, i, r) }).catch(s => { if (!i.decryptdata) throw s; return e.open("POST", t, !0), n.call(this.hls, e, t, i, r) }).then(i => (e.readyState || e.open("POST", t, !0), { xhr: e, licenseChallenge: i || r })) : (e.open("POST", t, !0), Promise.resolve({ xhr: e, licenseChallenge: r })) } requestLicense(e, t) { let i = this.config.keyLoadPolicy.default; return new Promise((r, n) => { let s = this.getLicenseServerUrlOrThrow(e.keySystem); this.log(`Sending license request to URL: ${s}`); let a = new XMLHttpRequest; a.responseType = "arraybuffer", a.onreadystatechange = () => { if (!this.hls || !e.mediaKeysSession) return n(Error("invalid state")); if (4 === a.readyState) { if (200 === a.status) { this._requestLicenseFailureCount = 0; let t = a.response; this.log(`License received ${t instanceof ArrayBuffer ? t.byteLength : t}`); let i = this.config.licenseResponseCallback; if (i) try { t = i.call(this.hls, a, s, e) } catch (e) { this.error(e) } r(t) } else { let o = i.errorRetry, l = o ? o.maxNumRetry : 0; if (this._requestLicenseFailureCount++, this._requestLicenseFailureCount > l || a.status >= 400 && a.status < 500) n(new r9({ type: y.KEY_SYSTEM_ERROR, details: x.KEY_SYSTEM_LICENSE_REQUEST_FAILED, fatal: !0, networkDetails: a, response: { url: s, data: void 0, code: a.status, text: a.statusText } }, `License Request XHR failed (${s}). Status: ${a.status} (${a.statusText})`)); else { let i = l - this._requestLicenseFailureCount + 1; this.warn(`Retrying license request, ${i} attempts left`), this.requestLicense(e, t).then(r, n) } } } }, e.licenseXhr && e.licenseXhr.readyState !== XMLHttpRequest.DONE && e.licenseXhr.abort(), e.licenseXhr = a, this.setupLicenseXHR(a, s, e, t).then(({ xhr: t, licenseChallenge: i }) => { e.keySystem == U.PLAYREADY && (i = this.unpackPlayReadyKeyMessage(t, i)), t.send(i) }) }) } onMediaAttached(e, t) { if (!this.config.emeEnabled) return; let i = t.media; this.media = i, i.removeEventListener("encrypted", this.onMediaEncrypted), i.removeEventListener("waitingforkey", this.onWaitingForKey), i.addEventListener("encrypted", this.onMediaEncrypted), i.addEventListener("waitingforkey", this.onWaitingForKey) } onMediaDetached() { let e = this.media, t = this.mediaKeySessions; e && (e.removeEventListener("encrypted", this.onMediaEncrypted), e.removeEventListener("waitingforkey", this.onWaitingForKey), this.media = null), this._requestLicenseFailureCount = 0, this.setMediaKeysQueue = [], this.mediaKeySessions = [], this.keyIdToKeySessionPromise = {}, eR.clearKeyUriToKeyIdMap(); let i = t.length; r6.CDMCleanupPromise = Promise.all(t.map(e => this.removeSession(e)).concat(null == e ? void 0 : e.setMediaKeys(null).catch(e => { this.log(`Could not clear media keys: ${e}`) }))).then(() => { i && (this.log("finished closing key sessions and clearing media keys"), t.length = 0) }).catch(e => { this.log(`Could not close sessions and clear media keys: ${e}`) }) } onManifestLoading() { this.keyFormatPromise = null } onManifestLoaded(e, { sessionKeys: t }) { if (t && this.config.emeEnabled && !this.keyFormatPromise) { let e = t.reduce((e, t) => (-1 === e.indexOf(t.keyFormat) && e.push(t.keyFormat), e), []); this.log(`Selecting key-system from session-keys ${e.join(", ")}`), this.keyFormatPromise = this.getKeyFormatPromise(e) } } removeSession(e) { let { mediaKeysSession: t, licenseXhr: i } = e; if (t) { this.log(`Remove licenses and keys and close session ${t.sessionId}`), e._onmessage && (t.removeEventListener("message", e._onmessage), e._onmessage = void 0), e._onkeystatuseschange && (t.removeEventListener("keystatuseschange", e._onkeystatuseschange), e._onkeystatuseschange = void 0), i && i.readyState !== XMLHttpRequest.DONE && i.abort(), e.mediaKeysSession = e.decryptdata = e.licenseXhr = void 0; let r = this.mediaKeySessions.indexOf(e); return r > -1 && this.mediaKeySessions.splice(r, 1), t.remove().catch(e => { this.log(`Could not remove session: ${e}`) }).then(() => t.close()).catch(e => { this.log(`Could not close session: ${e}`) }) } }
    } r6.CDMCleanupPromise = void 0; class r9 extends Error { constructor(e, t) { super(t), this.data = void 0, e.error || (e.error = Error(t)), this.data = e, e.err = e.error } } !function (e) { e.MANIFEST = "m", e.AUDIO = "a", e.VIDEO = "v", e.MUXED = "av", e.INIT = "i", e.CAPTION = "c", e.TIMED_TEXT = "tt", e.KEY = "k", e.OTHER = "o" }(a || (a = {})), function (e) { e.DASH = "d", e.HLS = "h", e.SMOOTH = "s", e.OTHER = "o" }(o || (o = {})), function (e) { e.OBJECT = "CMCD-Object", e.REQUEST = "CMCD-Request", e.SESSION = "CMCD-Session", e.STATUS = "CMCD-Status" }(l || (l = {})); let r7 = { [l.OBJECT]: ["br", "d", "ot", "tb"], [l.REQUEST]: ["bl", "dl", "mtp", "nor", "nrr", "su"], [l.SESSION]: ["cid", "pr", "sf", "sid", "st", "v"], [l.STATUS]: ["bs", "rtp"] }; class ne { constructor(e, t) { this.value = void 0, this.params = void 0, Array.isArray(e) && (e = e.map(e => e instanceof ne ? e : new ne(e))), this.value = e, this.params = t } } class nt { constructor(e) { this.description = void 0, this.description = e } } let ni = "Bare Item", nr = /[\x00-\x1f\x7f]+/; function nn(e, t, i) { return Error(`failed to serialize "${Array.isArray(e) ? JSON.stringify(e) : e instanceof Map ? "Map{}" : e instanceof Set ? "Set{}" : "object" == typeof e ? JSON.stringify(e) : String(e)}" as ${t}`, { cause: i }) } function ns(e) { if (e < -0x38d7ea4c67fff || 0x38d7ea4c67fff < e) throw nn(e, "Integer"); return e.toString() } function na(e) { let t = e.description || e.toString().slice(7, -1); if (!1 === /^([a-zA-Z*])([!#$%&'*+\-.^_`|~\w:/]*)$/.test(t)) throw nn(t, "Token"); return t } function no(e) { switch (typeof e) { case "number": if (!p(e)) throw nn(e, ni); if (Number.isInteger(e)) return ns(e); return function (e) { let t = function e(t, i) { if (t < 0) return -e(-t, i); let r = Math.pow(10, i); if (!(Math.abs(t * r % 1 - .5) < Number.EPSILON)) return Math.round(t * r) / r; { let e = Math.floor(t * r); return (e % 2 == 0 ? e : e + 1) / r } }(e, 3); if (Math.floor(Math.abs(t)).toString().length > 12) throw nn(e, "Decimal"); let i = t.toString(); return i.includes(".") ? i : `${i}.0` }(e); case "string": return function (e) { if (nr.test(e)) throw nn(e, "String"); return `"${e.replace(/\\/g, "\\\\").replace(/"/g, '\\"')}"` }(e); case "symbol": return na(e); case "boolean": return function (e) { if ("boolean" != typeof e) throw nn(e, "Boolean"); return e ? "?1" : "?0" }(e); case "object": if (e instanceof Date) return `@${ns(e.getTime() / 1e3)}`; if (e instanceof Uint8Array) return function (e) { if (!1 === ArrayBuffer.isView(e)) throw nn(e, "Byte Sequence"); return `:${btoa(String.fromCharCode(...e))}:` }(e); if (e instanceof nt) return na(e); default: throw nn(e, ni) } } function nl(e) { if (!1 === /^[a-z*][a-z0-9\-_.*]*$/.test(e)) throw nn(e, "Key"); return e } function nu(e) { return null == e ? "" : Object.entries(e).map(([e, t]) => !0 === t ? `;${nl(e)}` : `;${nl(e)}=${no(t)}`).join("") } function nh(e) { return e instanceof ne ? `${no(e.value)}${nu(e.params)}` : no(e) } let nc = e => "ot" === e || "sf" === e || "st" === e, nd = e => "number" == typeof e ? p(e) : null != e && "" !== e && !1 !== e, nf = e => Math.round(e), np = e => 100 * nf(e / 100), nm = { br: nf, d: nf, bl: np, dl: np, mtp: np, nor: (e, t) => (null != t && t.baseUrl && (e = function (e, t) { let i = new URL(e), r = new URL(t); if (i.origin !== r.origin) return e; let n = i.pathname.split("/").slice(1), s = r.pathname.split("/").slice(1, -1); for (; n[0] === s[0];)n.shift(), s.shift(); for (; s.length;)s.shift(), n.unshift(".."); return n.join("/") }(e, t.baseUrl)), encodeURIComponent(e)), rtp: np, tb: nf }; function ng(e, t = {}) { return e ? function (e, t = { whitespace: !0 }) { if ("object" != typeof e) throw nn(e, "Dict"); let i = e instanceof Map ? e.entries() : Object.entries(e), r = null != t && t.whitespace ? " " : ""; return Array.from(i).map(([e, t]) => { t instanceof ne == !1 && (t = new ne(t)); let i = nl(e); if (!0 === t.value) i += nu(t.params); else if (i += "=", Array.isArray(t.value)) { var r; i += (r = t, `(${r.value.map(nh).join(" ")})${nu(r.params)}`) } else i += nh(t); return i }).join(`,${r}`) }(function (e, t) { let i = {}; if (null == e || "object" != typeof e) return i; let r = Object.keys(e).sort(), n = f({}, nm, null == t ? void 0 : t.formatters), s = null == t ? void 0 : t.filter; return r.forEach(r => { if (null != s && s(r)) return; let a = e[r], o = n[r]; o && (a = o(a, t)), ("v" !== r || 1 !== a) && ("pr" != r || 1 !== a) && nd(a) && (nc(r) && "string" == typeof a && (a = new nt(a)), i[r] = a) }), i }(e, t), f({ whitespace: !1 }, t)) : "" } let nv = /CMCD=[^&#]+/; class ny { constructor(e) { this.hls = void 0, this.config = void 0, this.media = void 0, this.sid = void 0, this.cid = void 0, this.useHeaders = !1, this.includeKeys = void 0, this.initialized = !1, this.starved = !1, this.buffering = !0, this.audioBuffer = void 0, this.videoBuffer = void 0, this.onWaiting = () => { this.initialized && (this.starved = !0), this.buffering = !0 }, this.onPlaying = () => { this.initialized || (this.initialized = !0), this.buffering = !1 }, this.applyPlaylistData = e => { try { this.apply(e, { ot: a.MANIFEST, su: !this.initialized }) } catch (e) { E.warn("Could not generate manifest CMCD data.", e) } }, this.applyFragmentData = e => { try { let t = e.frag, i = this.hls.levels[t.level], r = this.getObjectType(t), n = { d: 1e3 * t.duration, ot: r }; (r === a.VIDEO || r === a.AUDIO || r == a.MUXED) && (n.br = i.bitrate / 1e3, n.tb = this.getTopBandwidth(r) / 1e3, n.bl = this.getBufferLength(r)), this.apply(e, n) } catch (e) { E.warn("Could not generate segment CMCD data.", e) } }, this.hls = e; let t = this.config = e.config, { cmcd: i } = t; null != i && (t.pLoader = this.createPlaylistLoader(), t.fLoader = this.createFragmentLoader(), this.sid = i.sessionId || function () { try { return crypto.randomUUID() } catch (e) { try { let e = URL.createObjectURL(new Blob), t = e.toString(); return URL.revokeObjectURL(e), t.slice(t.lastIndexOf("/") + 1) } catch (t) { let e = new Date().getTime(); return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, t => { let i = (e + 16 * Math.random()) % 16 | 0; return e = Math.floor(e / 16), ("x" == t ? i : 3 & i | 8).toString(16) }) } } }(), this.cid = i.contentId, this.useHeaders = !0 === i.useHeaders, this.includeKeys = i.includeKeys, this.registerListeners()) } registerListeners() { let e = this.hls; e.on(v.MEDIA_ATTACHED, this.onMediaAttached, this), e.on(v.MEDIA_DETACHED, this.onMediaDetached, this), e.on(v.BUFFER_CREATED, this.onBufferCreated, this) } unregisterListeners() { let e = this.hls; e.off(v.MEDIA_ATTACHED, this.onMediaAttached, this), e.off(v.MEDIA_DETACHED, this.onMediaDetached, this), e.off(v.BUFFER_CREATED, this.onBufferCreated, this) } destroy() { this.unregisterListeners(), this.onMediaDetached(), this.hls = this.config = this.audioBuffer = this.videoBuffer = null, this.onWaiting = this.onPlaying = null } onMediaAttached(e, t) { this.media = t.media, this.media.addEventListener("waiting", this.onWaiting), this.media.addEventListener("playing", this.onPlaying) } onMediaDetached() { this.media && (this.media.removeEventListener("waiting", this.onWaiting), this.media.removeEventListener("playing", this.onPlaying), this.media = null) } onBufferCreated(e, t) { var i, r; this.audioBuffer = null == (i = t.tracks.audio) ? void 0 : i.buffer, this.videoBuffer = null == (r = t.tracks.video) ? void 0 : r.buffer } createData() { var e; return { v: 1, sf: o.HLS, sid: this.sid, cid: this.cid, pr: null == (e = this.media) ? void 0 : e.playbackRate, mtp: this.hls.bandwidthEstimate / 1e3 } } apply(e, t = {}) { f(t, this.createData()); let i = t.ot === a.INIT || t.ot === a.VIDEO || t.ot === a.MUXED; this.starved && i && (t.bs = !0, t.su = !0, this.starved = !1), null == t.su && (t.su = this.buffering); let { includeKeys: r } = this; if (r && (t = Object.keys(t).reduce((e, i) => (r.includes(i) && (e[i] = t[i]), e), {})), this.useHeaders) { var n; e.headers || (e.headers = {}), n = e.headers, f(n, function (e, t = {}) { if (!e) return {}; let i = Object.entries(e), r = Object.entries(r7).concat(Object.entries((null == t ? void 0 : t.customHeaderMap) || {})); return Object.entries(i.reduce((e, t) => { var i; let [n, s] = t, a = (null == (i = r.find(e => e[1].includes(n))) ? void 0 : i[0]) || l.REQUEST; return null != e[a] || (e[a] = {}), e[a][n] = s, e }, {})).reduce((e, [i, r]) => (e[i] = ng(r, t), e), {}) }(t, void 0)) } else e.url = function (e, t, i) { let r = function (e, t = {}) { if (!e) return ""; let i = ng(e, t); return `CMCD=${encodeURIComponent(i)}` }(t, void 0); if (!r) return e; if (nv.test(e)) return e.replace(nv, r); let n = e.includes("?") ? "&" : "?"; return `${e}${n}${r}` }(e.url, t) } getObjectType(e) { let { type: t } = e; return "subtitle" === t ? a.TIMED_TEXT : "initSegment" === e.sn ? a.INIT : "audio" === t ? a.AUDIO : "main" === t ? this.hls.audioTracks.length ? a.VIDEO : a.MUXED : void 0 } getTopBandwidth(e) { let t, i = 0, r = this.hls; if (e === a.AUDIO) t = r.audioTracks; else { let e = r.maxAutoLevel, i = e > -1 ? e + 1 : r.levels.length; t = r.levels.slice(0, i) } for (let e of t) e.bitrate > i && (i = e.bitrate); return i > 0 ? i : NaN } getBufferLength(e) { let t = this.hls.media, i = e === a.AUDIO ? this.audioBuffer : this.videoBuffer; return i && t ? 1e3 * tZ.bufferInfo(i, t.currentTime, this.config.maxBufferHole).len : NaN } createPlaylistLoader() { let { pLoader: e } = this.config, t = this.applyPlaylistData, i = e || this.config.loader; return class { constructor(e) { this.loader = void 0, this.loader = new i(e) } get stats() { return this.loader.stats } get context() { return this.loader.context } destroy() { this.loader.destroy() } abort() { this.loader.abort() } load(e, i, r) { t(e), this.loader.load(e, i, r) } } } createFragmentLoader() { let { fLoader: e } = this.config, t = this.applyFragmentData, i = e || this.config.loader; return class { constructor(e) { this.loader = void 0, this.loader = new i(e) } get stats() { return this.loader.stats } get context() { return this.loader.context } destroy() { this.loader.destroy() } abort() { this.loader.abort() } load(e, i, r) { t(e), this.loader.load(e, i, r) } } } } class nx { constructor(e) { this.hls = void 0, this.log = void 0, this.loader = null, this.uri = null, this.pathwayId = ".", this.pathwayPriority = null, this.timeToLoad = 300, this.reloadTimer = -1, this.updated = 0, this.started = !1, this.enabled = !0, this.levels = null, this.audioTracks = null, this.subtitleTracks = null, this.penalizedPathways = {}, this.hls = e, this.log = E.log.bind(E, "[content-steering]:"), this.registerListeners() } registerListeners() { let e = this.hls; e.on(v.MANIFEST_LOADING, this.onManifestLoading, this), e.on(v.MANIFEST_LOADED, this.onManifestLoaded, this), e.on(v.MANIFEST_PARSED, this.onManifestParsed, this), e.on(v.ERROR, this.onError, this) } unregisterListeners() { let e = this.hls; e && (e.off(v.MANIFEST_LOADING, this.onManifestLoading, this), e.off(v.MANIFEST_LOADED, this.onManifestLoaded, this), e.off(v.MANIFEST_PARSED, this.onManifestParsed, this), e.off(v.ERROR, this.onError, this)) } startLoad() { if (this.started = !0, this.clearTimeout(), this.enabled && this.uri) { if (this.updated) { let e = 1e3 * this.timeToLoad - (performance.now() - this.updated); if (e > 0) { this.scheduleRefresh(this.uri, e); return } } this.loadSteeringManifest(this.uri) } } stopLoad() { this.started = !1, this.loader && (this.loader.destroy(), this.loader = null), this.clearTimeout() } clearTimeout() { -1 !== this.reloadTimer && (self.clearTimeout(this.reloadTimer), this.reloadTimer = -1) } destroy() { this.unregisterListeners(), this.stopLoad(), this.hls = null, this.levels = this.audioTracks = this.subtitleTracks = null } removeLevel(e) { let t = this.levels; t && (this.levels = t.filter(t => t !== e)) } onManifestLoading() { this.stopLoad(), this.enabled = !0, this.timeToLoad = 300, this.updated = 0, this.uri = null, this.pathwayId = ".", this.levels = this.audioTracks = this.subtitleTracks = null } onManifestLoaded(e, t) { let { contentSteering: i } = t; null !== i && (this.pathwayId = i.pathwayId, this.uri = i.uri, this.started && this.startLoad()) } onManifestParsed(e, t) { this.audioTracks = t.audioTracks, this.subtitleTracks = t.subtitleTracks } onError(e, t) { let { errorAction: i } = t; if ((null == i ? void 0 : i.action) === tL.SendAlternateToPenaltyBox && i.flags === tP.MoveAllAlternatesMatchingHost) { let e = this.levels, r = this.pathwayPriority, n = this.pathwayId; if (t.context) { let { groupId: i, pathwayId: r, type: s } = t.context; i && e ? n = this.getPathwayForGroupId(i, s, n) : r && (n = r) } n in this.penalizedPathways || (this.penalizedPathways[n] = performance.now()), !r && e && (r = e.reduce((e, t) => (-1 === e.indexOf(t.pathwayId) && e.push(t.pathwayId), e), [])), r && r.length > 1 && (this.updatePathwayPriority(r), i.resolved = this.pathwayId !== n), i.resolved || E.warn(`Could not resolve ${t.details} ("${t.error.message}") with content-steering for Pathway: ${n} levels: ${e ? e.length : e} priorities: ${JSON.stringify(r)} penalized: ${JSON.stringify(this.penalizedPathways)}`) } } filterParsedLevels(e) { this.levels = e; let t = this.getLevelsForPathway(this.pathwayId); if (0 === t.length) { let i = e[0].pathwayId; this.log(`No levels found in Pathway ${this.pathwayId}. Setting initial Pathway to "${i}"`), t = this.getLevelsForPathway(i), this.pathwayId = i } return t.length !== e.length && this.log(`Found ${t.length}/${e.length} levels in Pathway "${this.pathwayId}"`), t } getLevelsForPathway(e) { return null === this.levels ? [] : this.levels.filter(t => e === t.pathwayId) } updatePathwayPriority(e) { let t; this.pathwayPriority = e; let i = this.penalizedPathways, r = performance.now(); Object.keys(i).forEach(e => { r - i[e] > 3e5 && delete i[e] }); for (let r = 0; r < e.length; r++) { let n = e[r]; if (n in i) continue; if (n === this.pathwayId) return; let s = this.hls.nextLoadLevel, a = this.hls.levels[s]; if ((t = this.getLevelsForPathway(n)).length > 0) { this.log(`Setting Pathway to "${n}"`), this.pathwayId = n, t_(t), this.hls.trigger(v.LEVELS_UPDATED, { levels: t }); let e = this.hls.levels[s]; a && e && this.levels && (e.attrs["STABLE-VARIANT-ID"] !== a.attrs["STABLE-VARIANT-ID"] && e.bitrate !== a.bitrate && this.log(`Unstable Pathways change from bitrate ${a.bitrate} to ${e.bitrate}`), this.hls.nextLoadLevel = s); break } } } getPathwayForGroupId(e, t, i) { let r = this.getLevelsForPathway(i).concat(this.levels || []); for (let i = 0; i < r.length; i++)if (t === e2.AUDIO_TRACK && r[i].hasAudioGroup(e) || t === e2.SUBTITLE_TRACK && r[i].hasSubtitleGroup(e)) return r[i].pathwayId; return i } clonePathways(e) { let t = this.levels; if (!t) return; let i = {}, r = {}; e.forEach(e => { let { ID: n, "BASE-ID": s, "URI-REPLACEMENT": a } = e; if (t.some(e => e.pathwayId === n)) return; let o = this.getLevelsForPathway(s).map(e => { let t = new w(e.attrs); t["PATHWAY-ID"] = n; let s = t.AUDIO && `${t.AUDIO}_clone_${n}`, o = t.SUBTITLES && `${t.SUBTITLES}_clone_${n}`; s && (i[t.AUDIO] = s, t.AUDIO = s), o && (r[t.SUBTITLES] = o, t.SUBTITLES = o); let l = nA(e.uri, t["STABLE-VARIANT-ID"], "PER-VARIANT-URIS", a), u = new tp({ attrs: t, audioCodec: e.audioCodec, bitrate: e.bitrate, height: e.height, name: e.name, url: l, videoCodec: e.videoCodec, width: e.width }); if (e.audioGroups) for (let t = 1; t < e.audioGroups.length; t++)u.addGroupId("audio", `${e.audioGroups[t]}_clone_${n}`); if (e.subtitleGroups) for (let t = 1; t < e.subtitleGroups.length; t++)u.addGroupId("text", `${e.subtitleGroups[t]}_clone_${n}`); return u }); t.push(...o), nS(this.audioTracks, i, a, n), nS(this.subtitleTracks, r, a, n) }) } loadSteeringManifest(e) { let t; let i = this.hls.config, r = i.loader; this.loader && this.loader.destroy(), this.loader = new r(i); try { t = new self.URL(e) } catch (t) { this.enabled = !1, this.log(`Failed to parse Steering Manifest URI: ${e}`); return } if ("data:" !== t.protocol) { let e = 0 | (this.hls.bandwidthEstimate || i.abrEwmaDefaultEstimate); t.searchParams.set("_HLS_pathway", this.pathwayId), t.searchParams.set("_HLS_throughput", "" + e) } let n = { responseType: "json", url: t.href }, s = i.steeringManifestLoadPolicy.default, a = s.errorRetry || s.timeoutRetry || {}, o = { loadPolicy: s, timeout: s.maxLoadTimeMs, maxRetry: a.maxNumRetry || 0, retryDelay: a.retryDelayMs || 0, maxRetryDelay: a.maxRetryDelayMs || 0 }; this.log(`Requesting steering manifest: ${t}`), this.loader.load(n, o, { onSuccess: (e, i, r, n) => { this.log(`Loaded steering manifest: "${t}"`); let s = e.data; if (1 !== s.VERSION) { this.log(`Steering VERSION ${s.VERSION} not supported!`); return } this.updated = performance.now(), this.timeToLoad = s.TTL; let { "RELOAD-URI": a, "PATHWAY-CLONES": o, "PATHWAY-PRIORITY": l } = s; if (a) try { this.uri = new self.URL(a, t).href } catch (e) { this.enabled = !1, this.log(`Failed to parse Steering Manifest RELOAD-URI: ${a}`); return } this.scheduleRefresh(this.uri || r.url), o && this.clonePathways(o); let u = { steeringManifest: s, url: t.toString() }; this.hls.trigger(v.STEERING_MANIFEST_LOADED, u), l && this.updatePathwayPriority(l) }, onError: (e, t, i, r) => { if (this.log(`Error loading steering manifest: ${e.code} ${e.text} (${t.url})`), this.stopLoad(), 410 === e.code) { this.enabled = !1, this.log(`Steering manifest ${t.url} no longer available`); return } let n = 1e3 * this.timeToLoad; if (429 === e.code) { let e = this.loader; if ("function" == typeof (null == e ? void 0 : e.getResponseHeader)) { let t = e.getResponseHeader("Retry-After"); t && (n = 1e3 * parseFloat(t)) } this.log(`Steering manifest ${t.url} rate limited`); return } this.scheduleRefresh(this.uri || t.url, n) }, onTimeout: (e, t, i) => { this.log(`Timeout loading steering manifest (${t.url})`), this.scheduleRefresh(this.uri || t.url) } }) } scheduleRefresh(e, t = 1e3 * this.timeToLoad) { this.clearTimeout(), this.reloadTimer = self.setTimeout(() => { var t; let i = null == (t = this.hls) ? void 0 : t.media; if (i && !i.ended) { this.loadSteeringManifest(e); return } this.scheduleRefresh(e, 1e3 * this.timeToLoad) }, t) } } function nS(e, t, i, r) { e && Object.keys(t).forEach(n => { let s = e.filter(e => e.groupId === n).map(e => { let s = f({}, e); return s.details = void 0, s.attrs = new w(s.attrs), s.url = s.attrs.URI = nA(e.url, e.attrs["STABLE-RENDITION-ID"], "PER-RENDITION-URIS", i), s.groupId = s.attrs["GROUP-ID"] = t[n], s.attrs["PATHWAY-ID"] = r, s }); e.push(...s) }) } function nA(e, t, i, r) { let n; let { HOST: s, PARAMS: a, [i]: o } = r; t && (n = null == o ? void 0 : o[t]) && (e = n); let l = new self.URL(e); return s && !n && (l.host = s), a && Object.keys(a).sort().forEach(e => { e && l.searchParams.set(e, a[e]) }), l.href } let n_ = /^age:\s*[\d.]+\s*$/im; class nE { constructor(e) { this.xhrSetup = void 0, this.requestTimeout = void 0, this.retryTimeout = void 0, this.retryDelay = void 0, this.config = null, this.callbacks = null, this.context = null, this.loader = null, this.stats = void 0, this.xhrSetup = e && e.xhrSetup || null, this.stats = new R, this.retryDelay = 0 } destroy() { this.callbacks = null, this.abortInternal(), this.loader = null, this.config = null, this.context = null, this.xhrSetup = null } abortInternal() { let e = this.loader; self.clearTimeout(this.requestTimeout), self.clearTimeout(this.retryTimeout), e && (e.onreadystatechange = null, e.onprogress = null, 4 !== e.readyState && (this.stats.aborted = !0, e.abort())) } abort() { var e; this.abortInternal(), null != (e = this.callbacks) && e.onAbort && this.callbacks.onAbort(this.stats, this.context, this.loader) } load(e, t, i) { if (this.stats.loading.start) throw Error("Loader can only be used once."); this.stats.loading.start = self.performance.now(), this.context = e, this.config = t, this.callbacks = i, this.loadInternal() } loadInternal() { let { config: e, context: t } = this; if (!e || !t) return; let i = this.loader = new self.XMLHttpRequest, r = this.stats; r.loading.first = 0, r.loaded = 0, r.aborted = !1; let n = this.xhrSetup; n ? Promise.resolve().then(() => { if (this.loader === i && !this.stats.aborted) return n(i, t.url) }).catch(e => { if (this.loader === i && !this.stats.aborted) return i.open("GET", t.url, !0), n(i, t.url) }).then(() => { this.loader !== i || this.stats.aborted || this.openAndSendXhr(i, t, e) }).catch(e => { this.callbacks.onError({ code: i.status, text: e.message }, t, i, r) }) : this.openAndSendXhr(i, t, e) } openAndSendXhr(e, t, i) { e.readyState || e.open("GET", t.url, !0); let r = t.headers, { maxTimeToFirstByteMs: n, maxLoadTimeMs: s } = i.loadPolicy; if (r) for (let t in r) e.setRequestHeader(t, r[t]); t.rangeEnd && e.setRequestHeader("Range", "bytes=" + t.rangeStart + "-" + (t.rangeEnd - 1)), e.onreadystatechange = this.readystatechange.bind(this), e.onprogress = this.loadprogress.bind(this), e.responseType = t.responseType, self.clearTimeout(this.requestTimeout), i.timeout = n && p(n) ? n : s, this.requestTimeout = self.setTimeout(this.loadtimeout.bind(this), i.timeout), e.send() } readystatechange() { let { context: e, loader: t, stats: i } = this; if (!e || !t) return; let r = t.readyState, n = this.config; if (!i.aborted && r >= 2 && (0 === i.loading.first && (i.loading.first = Math.max(self.performance.now(), i.loading.start), n.timeout !== n.loadPolicy.maxLoadTimeMs && (self.clearTimeout(this.requestTimeout), n.timeout = n.loadPolicy.maxLoadTimeMs, this.requestTimeout = self.setTimeout(this.loadtimeout.bind(this), n.loadPolicy.maxLoadTimeMs - (i.loading.first - i.loading.start)))), 4 === r)) { self.clearTimeout(this.requestTimeout), t.onreadystatechange = null, t.onprogress = null; let r = t.status, s = "text" === t.responseType ? t.responseText : null; if (r >= 200 && r < 300) { let n = null != s ? s : t.response; if (null != n) { i.loading.end = Math.max(self.performance.now(), i.loading.first); let s = "arraybuffer" === t.responseType ? n.byteLength : n.length; if (i.loaded = i.total = s, i.bwEstimate = 8e3 * i.total / (i.loading.end - i.loading.first), !this.callbacks) return; let a = this.callbacks.onProgress; if (a && a(i, e, n, t), !this.callbacks) return; let o = { url: t.responseURL, data: n, code: r }; this.callbacks.onSuccess(o, i, e, t); return } } let a = n.loadPolicy.errorRetry; tM(a, i.retry, !1, { url: e.url, data: void 0, code: r }) ? this.retry(a) : (E.error(`${r} while loading ${e.url}`), this.callbacks.onError({ code: r, text: t.statusText }, e, t, i)) } } loadtimeout() { if (!this.config) return; let e = this.config.loadPolicy.timeoutRetry; if (tM(e, this.stats.retry, !0)) this.retry(e); else { var t; E.warn(`timeout while loading ${null == (t = this.context) ? void 0 : t.url}`); let e = this.callbacks; e && (this.abortInternal(), e.onTimeout(this.stats, this.context, this.loader)) } } retry(e) { let { context: t, stats: i } = this; this.retryDelay = tT(e, i.retry), i.retry++, E.warn(`${status ? "HTTP Status " + status : "Timeout"} while loading ${null == t ? void 0 : t.url}, retrying ${i.retry}/${e.maxNumRetry} in ${this.retryDelay}ms`), this.abortInternal(), this.loader = null, self.clearTimeout(this.retryTimeout), this.retryTimeout = self.setTimeout(this.loadInternal.bind(this), this.retryDelay) } loadprogress(e) { let t = this.stats; t.loaded = e.loaded, e.lengthComputable && (t.total = e.total) } getCacheAge() { let e = null; if (this.loader && n_.test(this.loader.getAllResponseHeaders())) { let t = this.loader.getResponseHeader("age"); e = t ? parseFloat(t) : null } return e } getResponseHeader(e) { return this.loader && RegExp(`^${e}:\\s*[\\d.]+\\s*$`, "im").test(this.loader.getAllResponseHeaders()) ? this.loader.getResponseHeader(e) : null } } let nb = /(\d+)-(\d+)\/(\d+)/; class nT { constructor(e) { this.fetchSetup = void 0, this.requestTimeout = void 0, this.request = null, this.response = null, this.controller = void 0, this.context = null, this.config = null, this.callbacks = null, this.stats = void 0, this.loader = null, this.fetchSetup = e.fetchSetup || nw, this.controller = new self.AbortController, this.stats = new R } destroy() { this.loader = this.callbacks = this.context = this.config = this.request = null, this.abortInternal(), this.response = null, this.fetchSetup = this.controller = this.stats = null } abortInternal() { this.controller && !this.stats.loading.end && (this.stats.aborted = !0, this.controller.abort()) } abort() { var e; this.abortInternal(), null != (e = this.callbacks) && e.onAbort && this.callbacks.onAbort(this.stats, this.context, this.response) } load(e, t, i) { let r = this.stats; if (r.loading.start) throw Error("Loader can only be used once."); r.loading.start = self.performance.now(); let n = function (e, t) { let i = { method: "GET", mode: "cors", credentials: "same-origin", signal: t, headers: new self.Headers(f({}, e.headers)) }; return e.rangeEnd && i.headers.set("Range", "bytes=" + e.rangeStart + "-" + String(e.rangeEnd - 1)), i }(e, this.controller.signal), s = i.onProgress, a = "arraybuffer" === e.responseType, o = a ? "byteLength" : "length", { maxTimeToFirstByteMs: l, maxLoadTimeMs: u } = t.loadPolicy; this.context = e, this.config = t, this.callbacks = i, this.request = this.fetchSetup(e, n), self.clearTimeout(this.requestTimeout), t.timeout = l && p(l) ? l : u, this.requestTimeout = self.setTimeout(() => { this.abortInternal(), i.onTimeout(r, e, this.response) }, t.timeout), self.fetch(this.request).then(n => { this.response = this.loader = n; let o = Math.max(self.performance.now(), r.loading.start); if (self.clearTimeout(this.requestTimeout), t.timeout = u, this.requestTimeout = self.setTimeout(() => { this.abortInternal(), i.onTimeout(r, e, this.response) }, u - (o - r.loading.start)), !n.ok) { let { status: e, statusText: t } = n; throw new nM(t || "fetch, bad network response", e, n) } return (r.loading.first = o, r.total = function (e) { let t = e.get("Content-Range"); if (t) { let e = function (e) { let t = nb.exec(e); if (t) return parseInt(t[2]) - parseInt(t[1]) + 1 }(t); if (p(e)) return e } let i = e.get("Content-Length"); if (i) return parseInt(i) }(n.headers) || r.total, s && p(t.highWaterMark)) ? this.loadProgressively(n, r, e, t.highWaterMark, s) : a ? n.arrayBuffer() : "json" === e.responseType ? n.json() : n.text() }).then(n => { let a = this.response; if (!a) throw Error("loader destroyed"); self.clearTimeout(this.requestTimeout), r.loading.end = Math.max(self.performance.now(), r.loading.first); let l = n[o]; l && (r.loaded = r.total = l); let u = { url: a.url, data: n, code: a.status }; s && !p(t.highWaterMark) && s(r, e, n, a), i.onSuccess(u, r, e, a) }).catch(t => { if (self.clearTimeout(this.requestTimeout), r.aborted) return; let n = t && t.code || 0, s = t ? t.message : null; i.onError({ code: n, text: s }, e, t ? t.details : null, r) }) } getCacheAge() { let e = null; if (this.response) { let t = this.response.headers.get("age"); e = t ? parseFloat(t) : null } return e } getResponseHeader(e) { return this.response ? this.response.headers.get(e) : null } loadProgressively(e, t, i, r = 0, n) { let s = new ia, a = e.body.getReader(), o = () => a.read().then(a => { if (a.done) return s.dataLength && n(t, i, s.flush(), e), Promise.resolve(new ArrayBuffer(0)); let l = a.value, u = l.length; return t.loaded += u, u < r || s.dataLength ? (s.push(l), s.dataLength >= r && n(t, i, s.flush(), e)) : n(t, i, l, e), o() }).catch(() => Promise.reject()); return o() } } function nw(e, t) { return new self.Request(e.url, t) } class nM extends Error { constructor(e, t, i) { super(e), this.code = void 0, this.details = void 0, this.code = t, this.details = i } } let nR = /\s/, nC = d(d({ autoStartLoad: !0, startPosition: -1, defaultAudioCodec: void 0, debug: !1, capLevelOnFPSDrop: !1, capLevelToPlayerSize: !1, ignoreDevicePixelRatio: !1, preferManagedMediaSource: !0, initialLiveManifestSize: 1, maxBufferLength: 30, backBufferLength: 1 / 0, frontBufferFlushThreshold: 1 / 0, maxBufferSize: 6e7, maxBufferHole: .1, highBufferWatchdogPeriod: 2, nudgeOffset: .1, nudgeMaxRetry: 3, maxFragLookUpTolerance: .25, liveSyncDurationCount: 3, liveMaxLatencyDurationCount: 1 / 0, liveSyncDuration: void 0, liveMaxLatencyDuration: void 0, maxLiveSyncPlaybackRate: 1, liveDurationInfinity: !1, liveBackBufferLength: null, maxMaxBufferLength: 600, enableWorker: !0, workerPath: null, enableSoftwareAES: !0, startLevel: void 0, startFragPrefetch: !1, fpsDroppedMonitoringPeriod: 5e3, fpsDroppedMonitoringThreshold: .2, appendErrorMaxRetry: 3, loader: nE, fLoader: void 0, pLoader: void 0, xhrSetup: void 0, licenseXhrSetup: void 0, licenseResponseCallback: void 0, abrController: tW, bufferController: rc, capLevelController: r4, errorController: tD, fpsController: r5, stretchShortVideoTrack: !1, maxAudioFramesDrift: 1, forceKeyFrameOnDiscontinuity: !0, abrEwmaFastLive: 3, abrEwmaSlowLive: 9, abrEwmaFastVoD: 3, abrEwmaSlowVoD: 9, abrEwmaDefaultEstimate: 5e5, abrEwmaDefaultEstimateMax: 5e6, abrBandWidthFactor: .95, abrBandWidthUpFactor: .7, abrMaxWithRealBitrate: !1, maxStarvationDelay: 4, maxLoadingDelay: 4, minAutoBitrate: 0, emeEnabled: !1, widevineLicenseUrl: void 0, drmSystems: {}, drmSystemOptions: {}, requestMediaKeySystemAccessFunc: W, testBandwidth: !0, progressive: !1, lowLatencyMode: !0, cmcd: void 0, enableDateRangeMetadataCues: !0, enableEmsgMetadataCues: !0, enableID3MetadataCues: !0, useMediaCapabilities: !0, certLoadPolicy: { default: { maxTimeToFirstByteMs: 8e3, maxLoadTimeMs: 2e4, timeoutRetry: null, errorRetry: null } }, keyLoadPolicy: { default: { maxTimeToFirstByteMs: 8e3, maxLoadTimeMs: 2e4, timeoutRetry: { maxNumRetry: 1, retryDelayMs: 1e3, maxRetryDelayMs: 2e4, backoff: "linear" }, errorRetry: { maxNumRetry: 8, retryDelayMs: 1e3, maxRetryDelayMs: 2e4, backoff: "linear" } } }, manifestLoadPolicy: { default: { maxTimeToFirstByteMs: 1 / 0, maxLoadTimeMs: 2e4, timeoutRetry: { maxNumRetry: 2, retryDelayMs: 0, maxRetryDelayMs: 0 }, errorRetry: { maxNumRetry: 1, retryDelayMs: 1e3, maxRetryDelayMs: 8e3 } } }, playlistLoadPolicy: { default: { maxTimeToFirstByteMs: 1e4, maxLoadTimeMs: 2e4, timeoutRetry: { maxNumRetry: 2, retryDelayMs: 0, maxRetryDelayMs: 0 }, errorRetry: { maxNumRetry: 2, retryDelayMs: 1e3, maxRetryDelayMs: 8e3 } } }, fragLoadPolicy: { default: { maxTimeToFirstByteMs: 1e4, maxLoadTimeMs: 12e4, timeoutRetry: { maxNumRetry: 4, retryDelayMs: 0, maxRetryDelayMs: 0 }, errorRetry: { maxNumRetry: 6, retryDelayMs: 1e3, maxRetryDelayMs: 8e3 } } }, steeringManifestLoadPolicy: { default: { maxTimeToFirstByteMs: 1e4, maxLoadTimeMs: 2e4, timeoutRetry: { maxNumRetry: 2, retryDelayMs: 0, maxRetryDelayMs: 0 }, errorRetry: { maxNumRetry: 1, retryDelayMs: 1e3, maxRetryDelayMs: 8e3 } } }, manifestLoadingTimeOut: 1e4, manifestLoadingMaxRetry: 1, manifestLoadingRetryDelay: 1e3, manifestLoadingMaxRetryTimeout: 64e3, levelLoadingTimeOut: 1e4, levelLoadingMaxRetry: 4, levelLoadingRetryDelay: 1e3, levelLoadingMaxRetryTimeout: 64e3, fragLoadingTimeOut: 2e4, fragLoadingMaxRetry: 6, fragLoadingRetryDelay: 1e3, fragLoadingMaxRetryTimeout: 64e3 }, { cueHandler: { newCue(e, t, i, r) { let n, s, a, o, l; let u = [], h = self.VTTCue || self.TextTrackCue; for (let d = 0; d < r.rows.length; d++)if (n = r.rows[d], a = !0, o = 0, l = "", !n.isEmpty()) { var c; for (let e = 0; e < n.chars.length; e++)nR.test(n.chars[e].uchar) && a ? o++ : (l += n.chars[e].uchar, a = !1); n.cueStartTime = t, t === i && (i += 1e-4), o >= 16 ? o-- : o++; let r = rF(l.trim()), f = rH(t, i, r); null != e && null != (c = e.cues) && c.getCueById(f) || ((s = new h(t, i, r)).id = f, s.line = d + 1, s.align = "left", s.position = 10 + Math.min(80, 10 * Math.floor(8 * o / 32)), u.push(s)) } return e && u.length && (u.sort((e, t) => "auto" === e.line || "auto" === t.line ? 0 : e.line > 8 && t.line > 8 ? t.line - e.line : e.line - t.line), u.forEach(t => e9(e, t))), u } }, enableWebVTT: !0, enableIMSC1: !0, enableCEA708Captions: !0, captionsTextTrack1Label: "English", captionsTextTrack1LanguageCode: "en", captionsTextTrack2Label: "Spanish", captionsTextTrack2LanguageCode: "es", captionsTextTrack3Label: "Unknown CC", captionsTextTrack3LanguageCode: "", captionsTextTrack4Label: "Unknown CC", captionsTextTrack4LanguageCode: "", renderTextTracksNatively: !0 }), {}, { subtitleStreamController: ra, subtitleTrackController: rl, timelineController: r0, audioStreamController: rt, audioTrackController: rs, emeController: r6, cmcdController: ny, contentSteeringController: nx }); class nI extends tO { constructor(e, t) { super(e, "[level-controller]"), this._levels = [], this._firstLevel = -1, this._maxAutoLevel = -1, this._startLevel = void 0, this.currentLevel = null, this.currentLevelIndex = -1, this.manualLevelIndex = -1, this.steering = void 0, this.onParsedComplete = void 0, this.steering = t, this._registerListeners() } _registerListeners() { let { hls: e } = this; e.on(v.MANIFEST_LOADING, this.onManifestLoading, this), e.on(v.MANIFEST_LOADED, this.onManifestLoaded, this), e.on(v.LEVEL_LOADED, this.onLevelLoaded, this), e.on(v.LEVELS_UPDATED, this.onLevelsUpdated, this), e.on(v.FRAG_BUFFERED, this.onFragBuffered, this), e.on(v.ERROR, this.onError, this) } _unregisterListeners() { let { hls: e } = this; e.off(v.MANIFEST_LOADING, this.onManifestLoading, this), e.off(v.MANIFEST_LOADED, this.onManifestLoaded, this), e.off(v.LEVEL_LOADED, this.onLevelLoaded, this), e.off(v.LEVELS_UPDATED, this.onLevelsUpdated, this), e.off(v.FRAG_BUFFERED, this.onFragBuffered, this), e.off(v.ERROR, this.onError, this) } destroy() { this._unregisterListeners(), this.steering = null, this.resetLevels(), super.destroy() } stopLoad() { this._levels.forEach(e => { e.loadError = 0, e.fragmentError = 0 }), super.stopLoad() } resetLevels() { this._startLevel = void 0, this.manualLevelIndex = -1, this.currentLevelIndex = -1, this.currentLevel = null, this._levels = [], this._maxAutoLevel = -1 } onManifestLoading(e, t) { this.resetLevels() } onManifestLoaded(e, t) { let i = this.hls.config.preferManagedMediaSource, r = [], n = {}, a = {}, o = !1, l = !1, u = !1; t.levels.forEach(e => { var t, h; let c = e.attrs, { audioCodec: d, videoCodec: f } = e; (null == (t = d) ? void 0 : t.indexOf("mp4a.40.34")) !== -1 && (s || (s = /chrome|firefox/i.test(navigator.userAgent)), s && (e.audioCodec = d = void 0)), d && (e.audioCodec = d = eH(d, i)), (null == (h = f) ? void 0 : h.indexOf("avc1")) === 0 && (f = e.videoCodec = function (e) { let t = e.split(","); for (let e = 0; e < t.length; e++) { let i = t[e].split("."); if (i.length > 2) { let r = i.shift() + "."; r += parseInt(i.shift()).toString(16), r += ("000" + parseInt(i.shift()).toString(16)).slice(-4), t[e] = r } } return t.join(",") }(f)); let { width: p, height: m, unknownCodecs: g } = e; if (o || (o = !!(p && m)), l || (l = !!f), u || (u = !!d), null != g && g.length || d && !ek(d, "audio", i) || f && !ek(f, "video", i)) return; let { CODECS: v, "FRAME-RATE": y, "HDCP-LEVEL": x, "PATHWAY-ID": S, RESOLUTION: A, "VIDEO-RANGE": _ } = c, E = `${S || "."}-`, b = `${E}${e.bitrate}-${A}-${y}-${v}-${_}-${x}`; if (n[b]) { if (n[b].uri === e.url || e.attrs["PATHWAY-ID"]) n[b].addGroupId("audio", c.AUDIO), n[b].addGroupId("text", c.SUBTITLES); else { let t = a[b] += 1; e.attrs["PATHWAY-ID"] = Array(t + 1).join("."); let i = new tp(e); n[b] = i, r.push(i) } } else { let t = new tp(e); n[b] = t, a[b] = 1, r.push(t) } }), this.filterAndSortMediaOptions(r, t, o, l, u) } filterAndSortMediaOptions(e, t, i, r, n) { let s = [], a = [], o = e; if ((i || r) && n && (o = o.filter(({ videoCodec: e, videoRange: t, width: i, height: r }) => { var n; return (!!e || !!(i && r)) && !!(n = t) && th.indexOf(n) > -1 })), 0 === o.length) { Promise.resolve().then(() => { if (this.hls) { t.levels.length && this.warn(`One or more CODECS in variant not supported: ${JSON.stringify(t.levels[0].attrs)}`); let e = Error("no level with compatible codecs found in manifest"); this.hls.trigger(v.ERROR, { type: y.MEDIA_ERROR, details: x.MANIFEST_INCOMPATIBLE_CODECS_ERROR, fatal: !0, url: t.url, error: e, reason: e.message }) } }); return } if (t.audioTracks) { let { preferManagedMediaSource: e } = this.hls.config; nL(s = t.audioTracks.filter(t => !t.audioCodec || ek(t.audioCodec, "audio", e))) } t.subtitles && nL(a = t.subtitles); let l = o.slice(0); o.sort((e, t) => { if (e.attrs["HDCP-LEVEL"] !== t.attrs["HDCP-LEVEL"]) return (e.attrs["HDCP-LEVEL"] || "") > (t.attrs["HDCP-LEVEL"] || "") ? 1 : -1; if (i && e.height !== t.height) return e.height - t.height; if (e.frameRate !== t.frameRate) return e.frameRate - t.frameRate; if (e.videoRange !== t.videoRange) return th.indexOf(e.videoRange) - th.indexOf(t.videoRange); if (e.videoCodec !== t.videoCodec) { let i = eN(e.videoCodec), r = eN(t.videoCodec); if (i !== r) return r - i } if (e.uri === t.uri && e.codecSet !== t.codecSet) { let i = eB(e.codecSet), r = eB(t.codecSet); if (i !== r) return r - i } return e.averageBitrate !== t.averageBitrate ? e.averageBitrate - t.averageBitrate : 0 }); let u = l[0]; if (this.steering && (o = this.steering.filterParsedLevels(o)).length !== l.length) { for (let e = 0; e < l.length; e++)if (l[e].pathwayId === o[0].pathwayId) { u = l[e]; break } } this._levels = o; for (let e = 0; e < o.length; e++)if (o[e] === u) { var h; this._firstLevel = e; let t = u.bitrate, i = this.hls.bandwidthEstimate; if (this.log(`manifest loaded, ${o.length} level(s) found, first bitrate: ${t}`), (null == (h = this.hls.userConfig) ? void 0 : h.abrEwmaDefaultEstimate) === void 0) { let e = Math.min(t, this.hls.config.abrEwmaDefaultEstimateMax); e > i && i === nC.abrEwmaDefaultEstimate && (this.hls.bandwidthEstimate = e) } break } let c = n && !r, d = { levels: o, audioTracks: s, subtitleTracks: a, sessionData: t.sessionData, sessionKeys: t.sessionKeys, firstLevel: this._firstLevel, stats: t.stats, audio: n, video: r, altAudio: !c && s.some(e => !!e.url) }; this.hls.trigger(v.MANIFEST_PARSED, d), (this.hls.config.autoStartLoad || this.hls.forceStartLoad) && this.hls.startLoad(this.hls.config.startPosition) } get levels() { return 0 === this._levels.length ? null : this._levels } get level() { return this.currentLevelIndex } set level(e) { let t = this._levels; if (0 === t.length) return; if (e < 0 || e >= t.length) { let i = Error("invalid level idx"), r = e < 0; if (this.hls.trigger(v.ERROR, { type: y.OTHER_ERROR, details: x.LEVEL_SWITCH_ERROR, level: e, fatal: r, error: i, reason: i.message }), r) return; e = Math.min(e, t.length - 1) } let i = this.currentLevelIndex, r = this.currentLevel, n = r ? r.attrs["PATHWAY-ID"] : void 0, s = t[e], a = s.attrs["PATHWAY-ID"]; if (this.currentLevelIndex = e, this.currentLevel = s, i === e && s.details && r && n === a) return; this.log(`Switching to level ${e} (${s.height ? s.height + "p " : ""}${s.videoRange ? s.videoRange + " " : ""}${s.codecSet ? s.codecSet + " " : ""}@${s.bitrate})${a ? " with Pathway " + a : ""} from level ${i}${n ? " with Pathway " + n : ""}`); let o = { level: e, attrs: s.attrs, details: s.details, bitrate: s.bitrate, averageBitrate: s.averageBitrate, maxBitrate: s.maxBitrate, realBitrate: s.realBitrate, width: s.width, height: s.height, codecSet: s.codecSet, audioCodec: s.audioCodec, videoCodec: s.videoCodec, audioGroups: s.audioGroups, subtitleGroups: s.subtitleGroups, loaded: s.loaded, loadError: s.loadError, fragmentError: s.fragmentError, name: s.name, id: s.id, uri: s.uri, url: s.url, urlId: 0, audioGroupIds: s.audioGroupIds, textGroupIds: s.textGroupIds }; this.hls.trigger(v.LEVEL_SWITCHING, o); let l = s.details; if (!l || l.live) { let e = this.switchParams(s.uri, null == r ? void 0 : r.details, l); this.loadPlaylist(e) } } get manualLevel() { return this.manualLevelIndex } set manualLevel(e) { this.manualLevelIndex = e, void 0 === this._startLevel && (this._startLevel = e), -1 !== e && (this.level = e) } get firstLevel() { return this._firstLevel } set firstLevel(e) { this._firstLevel = e } get startLevel() { if (void 0 === this._startLevel) { let e = this.hls.config.startLevel; return void 0 !== e ? e : this.hls.firstAutoLevel } return this._startLevel } set startLevel(e) { this._startLevel = e } onError(e, t) { !t.fatal && t.context && t.context.type === e2.LEVEL && t.context.level === this.level && this.checkRetry(t) } onFragBuffered(e, { frag: t }) { if (void 0 !== t && t.type === e3.MAIN) { let e = t.elementaryStreams; if (!Object.keys(e).some(t => !!e[t])) return; let i = this._levels[t.level]; null != i && i.loadError && (this.log(`Resetting level error count of ${i.loadError} on frag buffered`), i.loadError = 0) } } onLevelLoaded(e, t) { var i, r; let { level: n, details: s } = t, a = this._levels[n]; if (!a) { this.warn(`Invalid level index ${n}`), null != (r = t.deliveryDirectives) && r.skip && (s.deltaUpdateFailed = !0); return } n === this.currentLevelIndex ? (0 === a.fragmentError && (a.loadError = 0), this.playlistLoaded(n, t, a.details)) : null != (i = t.deliveryDirectives) && i.skip && (s.deltaUpdateFailed = !0) } loadPlaylist(e) { super.loadPlaylist(); let t = this.currentLevelIndex, i = this.currentLevel; if (i && this.shouldLoadPlaylist(i)) { let r = i.uri; if (e) try { r = e.addDirectives(r) } catch (e) { this.warn(`Could not construct new URL with HLS Delivery Directives: ${e}`) } let n = i.attrs["PATHWAY-ID"]; this.log(`Loading level index ${t}${(null == e ? void 0 : e.msn) !== void 0 ? " at sn " + e.msn + " part " + e.part : ""} with${n ? " Pathway " + n : ""} ${r}`), this.clearTimer(), this.hls.trigger(v.LEVEL_LOADING, { url: r, level: t, pathwayId: i.attrs["PATHWAY-ID"], id: 0, deliveryDirectives: e || null }) } } get nextLoadLevel() { return -1 !== this.manualLevelIndex ? this.manualLevelIndex : this.hls.nextAutoLevel } set nextLoadLevel(e) { this.level = e, -1 === this.manualLevelIndex && (this.hls.nextAutoLevel = e) } removeLevel(e) { var t; let i = this._levels.filter((t, i) => i !== e || (this.steering && this.steering.removeLevel(t), t === this.currentLevel && (this.currentLevel = null, this.currentLevelIndex = -1, t.details && t.details.fragments.forEach(e => e.level = -1)), !1)); t_(i), this._levels = i, this.currentLevelIndex > -1 && null != (t = this.currentLevel) && t.details && (this.currentLevelIndex = this.currentLevel.details.fragments[0].level), this.hls.trigger(v.LEVELS_UPDATED, { levels: i }) } onLevelsUpdated(e, { levels: t }) { this._levels = t } checkMaxAutoUpdated() { let { autoLevelCapping: e, maxAutoLevel: t, maxHdcpLevel: i } = this.hls; this._maxAutoLevel !== t && (this._maxAutoLevel = t, this.hls.trigger(v.MAX_AUTO_LEVEL_UPDATED, { autoLevelCapping: e, levels: this.levels, maxAutoLevel: t, minAutoLevel: this.hls.minAutoLevel, maxHdcpLevel: i })) } } function nL(e) { let t = {}; e.forEach(e => { let i = e.groupId || ""; e.id = t[i] = t[i] || 0, t[i]++ }) } class nP { constructor(e) { this.config = void 0, this.keyUriToKeyInfo = {}, this.emeController = null, this.config = e } abort(e) { for (let i in this.keyUriToKeyInfo) { let r = this.keyUriToKeyInfo[i].loader; if (r) { var t; if (e && e !== (null == (t = r.context) ? void 0 : t.frag.type)) return; r.abort() } } } detach() { for (let e in this.keyUriToKeyInfo) { let t = this.keyUriToKeyInfo[e]; (t.mediaKeySessionContext || t.decryptdata.isCommonEncryption) && delete this.keyUriToKeyInfo[e] } } destroy() { for (let e in this.detach(), this.keyUriToKeyInfo) { let t = this.keyUriToKeyInfo[e].loader; t && t.destroy() } this.keyUriToKeyInfo = {} } createKeyLoadError(e, t = x.KEY_LOAD_ERROR, i, r, n) { return new t6({ type: y.NETWORK_ERROR, details: t, fatal: !1, frag: e, response: n, error: i, networkDetails: r }) } loadClear(e, t) { if (this.emeController && this.config.emeEnabled) { let { sn: i, cc: r } = e; for (let e = 0; e < t.length; e++) { let n = t[e]; if (r <= n.cc && ("initSegment" === i || "initSegment" === n.sn || i < n.sn)) { this.emeController.selectKeySystemFormat(n).then(e => { n.setKeyFormat(e) }); break } } } } load(e) { return !e.decryptdata && e.encrypted && this.emeController && this.config.emeEnabled ? this.emeController.selectKeySystemFormat(e).then(t => this.loadInternal(e, t)) : this.loadInternal(e) } loadInternal(e, t) { var i, r, n; t && e.setKeyFormat(t); let s = e.decryptdata; if (!s) { let i = Error(t ? `Expected frag.decryptdata to be defined after setting format ${t}` : "Missing decryption data on fragment in onKeyLoading"); return Promise.reject(this.createKeyLoadError(e, x.KEY_LOAD_ERROR, i)) } let a = s.uri; if (!a) return Promise.reject(this.createKeyLoadError(e, x.KEY_LOAD_ERROR, Error(`Invalid key URI: "${a}"`))); let o = this.keyUriToKeyInfo[a]; if (null != (i = o) && i.decryptdata.key) return s.key = o.decryptdata.key, Promise.resolve({ frag: e, keyInfo: o }); if (null != (r = o) && r.keyLoadPromise) switch (null == (n = o.mediaKeySessionContext) ? void 0 : n.keyStatus) { case void 0: case "status-pending": case "usable": case "usable-in-future": return o.keyLoadPromise.then(t => (s.key = t.keyInfo.decryptdata.key, { frag: e, keyInfo: o })) }switch (o = this.keyUriToKeyInfo[a] = { decryptdata: s, keyLoadPromise: null, loader: null, mediaKeySessionContext: null }, s.method) { case "ISO-23001-7": case "SAMPLE-AES": case "SAMPLE-AES-CENC": case "SAMPLE-AES-CTR": if ("identity" === s.keyFormat) return this.loadKeyHTTP(o, e); return this.loadKeyEME(o, e); case "AES-128": return this.loadKeyHTTP(o, e); default: return Promise.reject(this.createKeyLoadError(e, x.KEY_LOAD_ERROR, Error(`Key supplied with unsupported METHOD: "${s.method}"`))) } } loadKeyEME(e, t) { let i = { frag: t, keyInfo: e }; if (this.emeController && this.config.emeEnabled) { let t = this.emeController.loadKey(i); if (t) return (e.keyLoadPromise = t.then(t => (e.mediaKeySessionContext = t, i))).catch(t => { throw e.keyLoadPromise = null, t }) } return Promise.resolve(i) } loadKeyHTTP(e, t) { let i = this.config, r = new i.loader(i); return t.keyLoader = e.loader = r, e.keyLoadPromise = new Promise((n, s) => { let a = { keyInfo: e, frag: t, responseType: "arraybuffer", url: e.decryptdata.uri }, o = i.keyLoadPolicy.default, l = { loadPolicy: o, timeout: o.maxLoadTimeMs, maxRetry: 0, retryDelay: 0, maxRetryDelay: 0 }; r.load(a, l, { onSuccess: (e, t, i, r) => { let { frag: a, keyInfo: o, url: l } = i; if (!a.decryptdata || o !== this.keyUriToKeyInfo[l]) return s(this.createKeyLoadError(a, x.KEY_LOAD_ERROR, Error("after key load, decryptdata unset or changed"), r)); o.decryptdata.key = a.decryptdata.key = new Uint8Array(e.data), a.keyLoader = null, o.loader = null, n({ frag: a, keyInfo: o }) }, onError: (e, i, r, n) => { this.resetLoader(i), s(this.createKeyLoadError(t, x.KEY_LOAD_ERROR, Error(`HTTP Error ${e.code} loading key ${e.text}`), r, d({ url: a.url, data: void 0 }, e))) }, onTimeout: (e, i, r) => { this.resetLoader(i), s(this.createKeyLoadError(t, x.KEY_LOAD_TIMEOUT, Error("key loading timed out"), r)) }, onAbort: (e, i, r) => { this.resetLoader(i), s(this.createKeyLoadError(t, x.INTERNAL_ABORTED, Error("key loading aborted"), r)) } }) }) } resetLoader(e) { let { frag: t, keyInfo: i, url: r } = e, n = i.loader; t.keyLoader === n && (t.keyLoader = null, i.loader = null), delete this.keyUriToKeyInfo[r], n && n.destroy() } } function nD() { return self.SourceBuffer || self.WebKitSourceBuffer } function nO() { if (!eD()) return !1; let e = nD(); return !e || e.prototype && "function" == typeof e.prototype.appendBuffer && "function" == typeof e.prototype.remove } function nk() { if (!nO()) return !1; let e = eD(); return "function" == typeof (null == e ? void 0 : e.isTypeSupported) && (["avc1.42E01E,mp4a.40.2", "av01.0.01M.08", "vp09.00.50.08"].some(t => e.isTypeSupported(eU(t, "video"))) || ["mp4a.40.2", "fLaC"].some(t => e.isTypeSupported(eU(t, "audio")))) } class nF { constructor(e, t, i, r) { this.config = void 0, this.media = null, this.fragmentTracker = void 0, this.hls = void 0, this.nudgeRetry = 0, this.stallReported = !1, this.stalled = null, this.moved = !1, this.seeking = !1, this.config = e, this.media = t, this.fragmentTracker = i, this.hls = r } destroy() { this.media = null, this.hls = this.fragmentTracker = null } poll(e, t) { let { config: i, media: r, stalled: n } = this; if (null === r) return; let { currentTime: s, seeking: a } = r, o = this.seeking && !a, l = !this.seeking && a; if (this.seeking = a, s !== e) { if (this.moved = !0, a || (this.nudgeRetry = 0), null !== n) { if (this.stallReported) { let e = self.performance.now() - n; E.warn(`playback not stuck anymore @${s}, after ${Math.round(e)}ms`), this.stallReported = !1 } this.stalled = null } return } if (l || o) { this.stalled = null; return } if (r.paused && !a || r.ended || 0 === r.playbackRate || !tZ.getBuffered(r).length) { this.nudgeRetry = 0; return } let u = tZ.bufferInfo(r, s, 0), h = u.nextStart || 0; if (a) { let e = u.len > 2, i = !h || t && t.start <= s || h - s > 2 && !this.fragmentTracker.getPartialFragment(s); if (e || i) return; this.moved = !1 } if (!this.moved && null !== this.stalled) { var c; if (!(u.len > 0) && !h) return; let e = Math.max(h, u.start || 0) - s, t = this.hls.levels ? this.hls.levels[this.hls.currentLevel] : null, i = (null == t ? void 0 : null == (c = t.details) ? void 0 : c.live) ? 2 * t.details.targetduration : 2, n = this.fragmentTracker.getPartialFragment(s); if (e > 0 && (e <= i || n)) { r.paused || this._trySkipBufferHole(n); return } } let d = self.performance.now(); if (null === n) { this.stalled = d; return } let f = d - n; if (!a && f >= 250 && (this._reportStall(u), !this.media)) return; let p = tZ.bufferInfo(r, s, i.maxBufferHole); this._tryFixBufferStall(p, f) } _tryFixBufferStall(e, t) { let { config: i, fragmentTracker: r, media: n } = this; if (null === n) return; let s = n.currentTime, a = r.getPartialFragment(s); !(a && (this._trySkipBufferHole(a) || !this.media)) && (e.len > i.maxBufferHole || e.nextStart && e.nextStart - s < i.maxBufferHole) && t > 1e3 * i.highBufferWatchdogPeriod && (E.warn("Trying to nudge playhead over buffer-hole"), this.stalled = null, this._tryNudgeBuffer()) } _reportStall(e) { let { hls: t, media: i, stallReported: r } = this; if (!r && i) { this.stallReported = !0; let r = Error(`Playback stalling at @${i.currentTime} due to low buffer (${JSON.stringify(e)})`); E.warn(r.message), t.trigger(v.ERROR, { type: y.MEDIA_ERROR, details: x.BUFFER_STALLED_ERROR, fatal: !1, error: r, buffer: e.len }) } } _trySkipBufferHole(e) { let { config: t, hls: i, media: r } = this; if (null === r) return 0; let n = r.currentTime, s = tZ.bufferInfo(r, n, 0), a = n < s.start ? s.start : s.nextStart; if (a) { let o = s.len <= t.maxBufferHole, l = s.len > 0 && s.len < 1 && r.readyState < 3, u = a - n; if (u > 0 && (o || l)) { if (u > t.maxBufferHole) { let { fragmentTracker: t } = this, i = !1; if (0 === n) { let e = t.getAppendedFrag(0, e3.MAIN); e && a < e.end && (i = !0) } if (!i) { let i = e || t.getAppendedFrag(n, e3.MAIN); if (i) { let e = !1, r = i.end; for (; r < a;) { let i = t.getPartialFragment(r); if (i) r += i.duration; else { e = !0; break } } if (e) return 0 } } } let s = Math.max(a + .05, n + .1); if (E.warn(`skipping hole, adjusting currentTime from ${n} to ${s}`), this.moved = !0, this.stalled = null, r.currentTime = s, e && !e.gap) { let t = Error(`fragment loaded with buffer holes, seeking from ${n} to ${s}`); i.trigger(v.ERROR, { type: y.MEDIA_ERROR, details: x.BUFFER_SEEK_OVER_HOLE, fatal: !1, error: t, reason: t.message, frag: e }) } return s } } return 0 } _tryNudgeBuffer() { let { config: e, hls: t, media: i, nudgeRetry: r } = this; if (null === i) return; let n = i.currentTime; if (this.nudgeRetry++, r < e.nudgeMaxRetry) { let s = n + (r + 1) * e.nudgeOffset, a = Error(`Nudging 'currentTime' from ${n} to ${s}`); E.warn(a.message), i.currentTime = s, t.trigger(v.ERROR, { type: y.MEDIA_ERROR, details: x.BUFFER_NUDGE_ON_STALL, error: a, fatal: !1 }) } else { let i = Error(`Playhead still not moving while enough data buffered @${n} after ${e.nudgeMaxRetry} nudges`); E.error(i.message), t.trigger(v.ERROR, { type: y.MEDIA_ERROR, details: x.BUFFER_STALLED_ERROR, error: i, fatal: !0 }) } } } class nU extends is { constructor(e, t, i) { super(e, t, i, "[stream-controller]", e3.MAIN), this.audioCodecSwap = !1, this.gapController = null, this.level = -1, this._forceStartLoad = !1, this.altAudio = !1, this.audioOnly = !1, this.fragPlaying = null, this.onvplaying = null, this.onvseeked = null, this.fragLastKbps = 0, this.couldBacktrack = !1, this.backtrackFragment = null, this.audioCodecSwitch = !1, this.videoBuffer = null, this._registerListeners() } _registerListeners() { let { hls: e } = this; e.on(v.MEDIA_ATTACHED, this.onMediaAttached, this), e.on(v.MEDIA_DETACHING, this.onMediaDetaching, this), e.on(v.MANIFEST_LOADING, this.onManifestLoading, this), e.on(v.MANIFEST_PARSED, this.onManifestParsed, this), e.on(v.LEVEL_LOADING, this.onLevelLoading, this), e.on(v.LEVEL_LOADED, this.onLevelLoaded, this), e.on(v.FRAG_LOAD_EMERGENCY_ABORTED, this.onFragLoadEmergencyAborted, this), e.on(v.ERROR, this.onError, this), e.on(v.AUDIO_TRACK_SWITCHING, this.onAudioTrackSwitching, this), e.on(v.AUDIO_TRACK_SWITCHED, this.onAudioTrackSwitched, this), e.on(v.BUFFER_CREATED, this.onBufferCreated, this), e.on(v.BUFFER_FLUSHED, this.onBufferFlushed, this), e.on(v.LEVELS_UPDATED, this.onLevelsUpdated, this), e.on(v.FRAG_BUFFERED, this.onFragBuffered, this) } _unregisterListeners() { let { hls: e } = this; e.off(v.MEDIA_ATTACHED, this.onMediaAttached, this), e.off(v.MEDIA_DETACHING, this.onMediaDetaching, this), e.off(v.MANIFEST_LOADING, this.onManifestLoading, this), e.off(v.MANIFEST_PARSED, this.onManifestParsed, this), e.off(v.LEVEL_LOADED, this.onLevelLoaded, this), e.off(v.FRAG_LOAD_EMERGENCY_ABORTED, this.onFragLoadEmergencyAborted, this), e.off(v.ERROR, this.onError, this), e.off(v.AUDIO_TRACK_SWITCHING, this.onAudioTrackSwitching, this), e.off(v.AUDIO_TRACK_SWITCHED, this.onAudioTrackSwitched, this), e.off(v.BUFFER_CREATED, this.onBufferCreated, this), e.off(v.BUFFER_FLUSHED, this.onBufferFlushed, this), e.off(v.LEVELS_UPDATED, this.onLevelsUpdated, this), e.off(v.FRAG_BUFFERED, this.onFragBuffered, this) } onHandlerDestroying() { this._unregisterListeners(), super.onHandlerDestroying() } startLoad(e) { if (this.levels) { let { lastCurrentTime: t, hls: i } = this; if (this.stopLoad(), this.setInterval(100), this.level = -1, !this.startFragRequested) { let e = i.startLevel; -1 === e && (i.config.testBandwidth && this.levels.length > 1 ? (e = 0, this.bitrateTest = !0) : e = i.firstAutoLevel), i.nextLoadLevel = e, this.level = i.loadLevel, this.loadedmetadata = !1 } t > 0 && -1 === e && (this.log(`Override startPosition with lastCurrentTime @${t.toFixed(3)}`), e = t), this.state = ir.IDLE, this.nextLoadPosition = this.startPosition = this.lastCurrentTime = e, this.tick() } else this._forceStartLoad = !0, this.state = ir.STOPPED } stopLoad() { this._forceStartLoad = !1, super.stopLoad() } doTick() { switch (this.state) { case ir.WAITING_LEVEL: { let { levels: e, level: t } = this, i = null == e ? void 0 : e[t], r = null == i ? void 0 : i.details; if (r && (!r.live || this.levelLastLoaded === i)) { if (this.waitForCdnTuneIn(r)) break; this.state = ir.IDLE } else this.hls.nextLoadLevel !== this.level && (this.state = ir.IDLE); break } case ir.FRAG_LOADING_WAITING_RETRY: { var e; let t = self.performance.now(), i = this.retryDate; if (!i || t >= i || null != (e = this.media) && e.seeking) { let { levels: e, level: t } = this, i = null == e ? void 0 : e[t]; this.resetStartWhenNotLoaded(i || null), this.state = ir.IDLE } } }this.state === ir.IDLE && this.doTickIdle(), this.onTickEnd() } onTickEnd() { super.onTickEnd(), this.checkBuffer(), this.checkFragmentChanged() } doTickIdle() { let { hls: e, levelLastLoaded: t, levels: i, media: r } = this; if (null === t || !r && (this.startFragRequested || !e.config.startFragPrefetch) || this.altAudio && this.audioOnly) return; let n = this.buffering ? e.nextLoadLevel : e.loadLevel; if (!(null != i && i[n])) return; let s = i[n], a = this.getMainFwdBufferInfo(); if (null === a) return; let o = this.getLevelDetails(); if (o && this._streamEnded(a, o)) { let e = {}; this.altAudio && (e.type = "video"), this.hls.trigger(v.BUFFER_EOS, e), this.state = ir.ENDED; return } if (!this.buffering) return; e.loadLevel !== n && -1 === e.manualLevel && this.log(`Adapting to level ${n} from level ${this.level}`), this.level = e.nextLoadLevel = n; let l = s.details; if (!l || this.state === ir.WAITING_LEVEL || l.live && this.levelLastLoaded !== s) { this.level = n, this.state = ir.WAITING_LEVEL; return } let u = a.len, h = this.getMaxBufferLength(s.maxBitrate); if (u >= h) return; this.backtrackFragment && this.backtrackFragment.start > a.end && (this.backtrackFragment = null); let c = this.backtrackFragment ? this.backtrackFragment.start : a.end, d = this.getNextFragment(c, l); if (this.couldBacktrack && !this.fragPrevious && d && "initSegment" !== d.sn && this.fragmentTracker.getState(d) !== tY.OK) { var f; let e = (null != (f = this.backtrackFragment) ? f : d).sn - l.startSN, t = l.fragments[e - 1]; t && d.cc === t.cc && (d = t, this.fragmentTracker.removeFragment(t)) } else this.backtrackFragment && a.len && (this.backtrackFragment = null); if (d && this.isLoopLoading(d, c)) { if (!d.gap) { let e = this.audioOnly && !this.altAudio ? C.AUDIO : C.VIDEO, t = (e === C.VIDEO ? this.videoBuffer : this.mediaBuffer) || this.media; t && this.afterBufferFlushed(t, e, e3.MAIN) } d = this.getNextFragmentLoopLoading(d, l, a, e3.MAIN, h) } d && (!d.initSegment || d.initSegment.data || this.bitrateTest || (d = d.initSegment), this.loadFragment(d, s, c)) } loadFragment(e, t, i) { let r = this.fragmentTracker.getState(e); this.fragCurrent = e, r === tY.NOT_LOADED || r === tY.PARTIAL ? "initSegment" === e.sn ? this._loadInitSegment(e, t) : this.bitrateTest ? (this.log(`Fragment ${e.sn} of level ${e.level} is being downloaded to test bitrate and will not be buffered`), this._loadBitrateTestFrag(e, t)) : (this.startFragRequested = !0, super.loadFragment(e, t, i)) : this.clearTrackerIfNeeded(e) } getBufferedFrag(e) { return this.fragmentTracker.getBufferedFrag(e, e3.MAIN) } followingBufferedFrag(e) { return e ? this.getBufferedFrag(e.end + .5) : null } immediateLevelSwitch() { this.abortCurrentFrag(), this.flushMainBuffer(0, Number.POSITIVE_INFINITY) } nextLevelSwitch() { let { levels: e, media: t } = this; if (null != t && t.readyState) { let i; let r = this.getAppendedFrag(t.currentTime); r && r.start > 1 && this.flushMainBuffer(0, r.start - 1); let n = this.getLevelDetails(); if (null != n && n.live) { let e = this.getMainFwdBufferInfo(); if (!e || e.len < 2 * n.targetduration) return } if (!t.paused && e) { let t = e[this.hls.nextLoadLevel], r = this.fragLastKbps; i = r && this.fragCurrent ? this.fragCurrent.duration * t.maxBitrate / (1e3 * r) + 1 : 0 } else i = 0; let s = this.getBufferedFrag(t.currentTime + i); if (s) { let e = this.followingBufferedFrag(s); if (e) { this.abortCurrentFrag(); let t = e.maxStartPTS ? e.maxStartPTS : e.start, i = e.duration, r = Math.max(s.end, t + Math.min(Math.max(i - this.config.maxFragLookUpTolerance, i * (this.couldBacktrack ? .5 : .125)), i * (this.couldBacktrack ? .75 : .25))); this.flushMainBuffer(r, Number.POSITIVE_INFINITY) } } } } abortCurrentFrag() { let e = this.fragCurrent; switch (this.fragCurrent = null, this.backtrackFragment = null, e && (e.abortRequests(), this.fragmentTracker.removeFragment(e)), this.state) { case ir.KEY_LOADING: case ir.FRAG_LOADING: case ir.FRAG_LOADING_WAITING_RETRY: case ir.PARSING: case ir.PARSED: this.state = ir.IDLE }this.nextLoadPosition = this.getLoadPosition() } flushMainBuffer(e, t) { super.flushMainBuffer(e, t, this.altAudio ? "video" : null) } onMediaAttached(e, t) { super.onMediaAttached(e, t); let i = t.media; this.onvplaying = this.onMediaPlaying.bind(this), this.onvseeked = this.onMediaSeeked.bind(this), i.addEventListener("playing", this.onvplaying), i.addEventListener("seeked", this.onvseeked), this.gapController = new nF(this.config, i, this.fragmentTracker, this.hls) } onMediaDetaching() { let { media: e } = this; e && this.onvplaying && this.onvseeked && (e.removeEventListener("playing", this.onvplaying), e.removeEventListener("seeked", this.onvseeked), this.onvplaying = this.onvseeked = null, this.videoBuffer = null), this.fragPlaying = null, this.gapController && (this.gapController.destroy(), this.gapController = null), super.onMediaDetaching() } onMediaPlaying() { this.tick() } onMediaSeeked() { let e = this.media, t = e ? e.currentTime : null; p(t) && this.log(`Media seeked to ${t.toFixed(3)}`); let i = this.getMainFwdBufferInfo(); if (null === i || 0 === i.len) { this.warn(`Main forward buffer length on "seeked" event ${i ? i.len : "empty"})`); return } this.tick() } onManifestLoading() { this.log("Trigger BUFFER_RESET"), this.hls.trigger(v.BUFFER_RESET, void 0), this.fragmentTracker.removeAllFragments(), this.couldBacktrack = !1, this.startPosition = this.lastCurrentTime = this.fragLastKbps = 0, this.levels = this.fragPlaying = this.backtrackFragment = this.levelLastLoaded = null, this.altAudio = this.audioOnly = this.startFragRequested = !1 } onManifestParsed(e, t) { let i = !1, r = !1; t.levels.forEach(e => { let t = e.audioCodec; t && (i = i || -1 !== t.indexOf("mp4a.40.2"), r = r || -1 !== t.indexOf("mp4a.40.5")) }), this.audioCodecSwitch = i && r && !function () { var e; let t = nD(); return "function" == typeof (null == t ? void 0 : null == (e = t.prototype) ? void 0 : e.changeType) }(), this.audioCodecSwitch && this.log("Both AAC/HE-AAC audio found in levels; declaring level codec as HE-AAC"), this.levels = t.levels, this.startFragRequested = !1 } onLevelLoading(e, t) { let { levels: i } = this; if (!i || this.state !== ir.IDLE) return; let r = i[t.level]; (!r.details || r.details.live && this.levelLastLoaded !== r || this.waitForCdnTuneIn(r.details)) && (this.state = ir.WAITING_LEVEL) } onLevelLoaded(e, t) { var i, r; let { levels: n } = this, s = t.level, a = t.details, o = a.totalduration; if (!n) { this.warn(`Levels were reset while loading level ${s}`); return } this.log(`Level ${s} loaded [${a.startSN},${a.endSN}]${a.lastPartSn ? `[part-${a.lastPartSn}-${a.lastPartIndex}]` : ""}, cc [${a.startCC}, ${a.endCC}] duration:${o}`); let l = n[s], u = this.fragCurrent; u && (this.state === ir.FRAG_LOADING || this.state === ir.FRAG_LOADING_WAITING_RETRY) && u.level !== t.level && u.loader && this.abortCurrentFrag(); let h = 0; if (a.live || null != (i = l.details) && i.live) { if (this.checkLiveUpdate(a), a.deltaUpdateFailed) return; h = this.alignPlaylists(a, l.details, null == (r = this.levelLastLoaded) ? void 0 : r.details) } if (l.details = a, this.levelLastLoaded = l, this.hls.trigger(v.LEVEL_UPDATED, { details: a, level: s }), this.state === ir.WAITING_LEVEL) { if (this.waitForCdnTuneIn(a)) return; this.state = ir.IDLE } this.startFragRequested ? a.live && this.synchronizeToLiveEdge(a) : this.setStartPosition(a, h), this.tick() } _handleFragmentLoadProgress(e) { var t; let { frag: i, part: r, payload: n } = e, { levels: s } = this; if (!s) { this.warn(`Levels were reset while fragment load was in progress. Fragment ${i.sn} of level ${i.level} will not be buffered`); return } let a = s[i.level], o = a.details; if (!o) { this.warn(`Dropping fragment ${i.sn} of level ${i.level} after level details were reset`), this.fragmentTracker.removeFragment(i); return } let l = a.videoCodec, u = o.PTSKnown || !o.live, h = null == (t = i.initSegment) ? void 0 : t.data, c = this._getAudioCodec(a), d = this.transmuxer = this.transmuxer || new re(this.hls, e3.MAIN, this._handleTransmuxComplete.bind(this), this._handleTransmuxerFlush.bind(this)), f = r ? r.index : -1, p = new t$(i.level, i.sn, i.stats.chunkCount, n.byteLength, f, -1 !== f), m = this.initPTS[i.cc]; d.push(n, h, c, l, i, r, o.totalduration, u, p, m) } onAudioTrackSwitching(e, t) { let i = this.altAudio; if (!t.url) { if (this.mediaBuffer !== this.media) { this.log("Switching on main audio, use media.buffered to schedule main fragment loading"), this.mediaBuffer = this.media; let e = this.fragCurrent; e && (this.log("Switching to main audio track, cancel main fragment load"), e.abortRequests(), this.fragmentTracker.removeFragment(e)), this.resetTransmuxer(), this.resetLoadingState() } else this.audioOnly && this.resetTransmuxer(); let e = this.hls; i && (e.trigger(v.BUFFER_FLUSHING, { startOffset: 0, endOffset: Number.POSITIVE_INFINITY, type: null }), this.fragmentTracker.removeAllFragments()), e.trigger(v.AUDIO_TRACK_SWITCHED, t) } } onAudioTrackSwitched(e, t) { let i = t.id, r = !!this.hls.audioTracks[i].url; if (r) { let e = this.videoBuffer; e && this.mediaBuffer !== e && (this.log("Switching on alternate audio, use video.buffered to schedule main fragment loading"), this.mediaBuffer = e) } this.altAudio = r, this.tick() } onBufferCreated(e, t) { let i, r; let n = t.tracks, s = !1; for (let e in n) { let t = n[e]; if ("main" === t.id) { if (r = e, i = t, "video" === e) { let t = n[e]; t && (this.videoBuffer = t.buffer) } } else s = !0 } s && i ? (this.log(`Alternate track found, use ${r}.buffered to schedule main fragment loading`), this.mediaBuffer = i.buffer) : this.mediaBuffer = this.media } onFragBuffered(e, t) { let { frag: i, part: r } = t; if (i && i.type !== e3.MAIN) return; if (this.fragContextChanged(i)) { this.warn(`Fragment ${i.sn}${r ? " p: " + r.index : ""} of level ${i.level} finished buffering, but was aborted. state: ${this.state}`), this.state === ir.PARSED && (this.state = ir.IDLE); return } let n = r ? r.stats : i.stats; this.fragLastKbps = Math.round(8 * n.total / (n.buffering.end - n.loading.first)), "initSegment" !== i.sn && (this.fragPrevious = i), this.fragBufferedComplete(i, r) } onError(e, t) { var i; if (t.fatal) { this.state = ir.ERROR; return } switch (t.details) { case x.FRAG_GAP: case x.FRAG_PARSING_ERROR: case x.FRAG_DECRYPT_ERROR: case x.FRAG_LOAD_ERROR: case x.FRAG_LOAD_TIMEOUT: case x.KEY_LOAD_ERROR: case x.KEY_LOAD_TIMEOUT: this.onFragmentOrKeyLoadError(e3.MAIN, t); break; case x.LEVEL_LOAD_ERROR: case x.LEVEL_LOAD_TIMEOUT: case x.LEVEL_PARSING_ERROR: t.levelRetry || this.state !== ir.WAITING_LEVEL || (null == (i = t.context) ? void 0 : i.type) !== e2.LEVEL || (this.state = ir.IDLE); break; case x.BUFFER_APPEND_ERROR: case x.BUFFER_FULL_ERROR: if (!t.parent || "main" !== t.parent) return; if (t.details === x.BUFFER_APPEND_ERROR) { this.resetLoadingState(); return } this.reduceLengthAndFlushBuffer(t) && this.flushMainBuffer(0, Number.POSITIVE_INFINITY); break; case x.INTERNAL_EXCEPTION: this.recoverWorkerError(t) } } checkBuffer() { let { media: e, gapController: t } = this; if (e && t && e.readyState) { if (this.loadedmetadata || !tZ.getBuffered(e).length) { let e = this.state !== ir.IDLE ? this.fragCurrent : null; t.poll(this.lastCurrentTime, e) } this.lastCurrentTime = e.currentTime } } onFragLoadEmergencyAborted() { this.state = ir.IDLE, this.loadedmetadata || (this.startFragRequested = !1, this.nextLoadPosition = this.startPosition), this.tickImmediate() } onBufferFlushed(e, { type: t }) { if (t !== C.AUDIO || this.audioOnly && !this.altAudio) { let e = (t === C.VIDEO ? this.videoBuffer : this.mediaBuffer) || this.media; this.afterBufferFlushed(e, t, e3.MAIN), this.tick() } } onLevelsUpdated(e, t) { this.level > -1 && this.fragCurrent && (this.level = this.fragCurrent.level), this.levels = t.levels } swapAudioCodec() { this.audioCodecSwap = !this.audioCodecSwap } seekToStartPos() { let { media: e } = this; if (!e) return; let t = e.currentTime, i = this.startPosition; if (i >= 0 && t < i) { if (e.seeking) { this.log(`could not seek to ${i}, already seeking at ${t}`); return } let r = tZ.getBuffered(e), n = (r.length ? r.start(0) : 0) - i; n > 0 && (n < this.config.maxBufferHole || n < this.config.maxFragLookUpTolerance) && (this.log(`adjusting start position by ${n} to match buffer start`), i += n, this.startPosition = i), this.log(`seek to target start position ${i} from current time ${t}`), e.currentTime = i } } _getAudioCodec(e) { let t = this.config.defaultAudioCodec || e.audioCodec; return this.audioCodecSwap && t && (this.log("Swapping audio codec"), t = -1 !== t.indexOf("mp4a.40.5") ? "mp4a.40.2" : "mp4a.40.5"), t } _loadBitrateTestFrag(e, t) { e.bitrateTest = !0, this._doFragLoad(e, t).then(i => { let { hls: r } = this; if (!i || this.fragContextChanged(e)) return; t.fragmentError = 0, this.state = ir.IDLE, this.startFragRequested = !1, this.bitrateTest = !1; let n = e.stats; n.parsing.start = n.parsing.end = n.buffering.start = n.buffering.end = self.performance.now(), r.trigger(v.FRAG_LOADED, i), e.bitrateTest = !1 }) } _handleTransmuxComplete(e) { var t; let i = "main", { hls: r } = this, { remuxResult: n, chunkMeta: s } = e, a = this.getCurrentContext(s); if (!a) { this.resetWhenMissingContext(s); return } let { frag: o, part: l, level: u } = a, { video: h, text: c, id3: d, initSegment: f } = n, { details: m } = u, g = this.altAudio ? void 0 : n.audio; if (this.fragContextChanged(o)) { this.fragmentTracker.removeFragment(o); return } if (this.state = ir.PARSING, f) { if (null != f && f.tracks) { let e = o.initSegment || o; this._bufferInitSegment(u, f.tracks, e, s), r.trigger(v.FRAG_PARSING_INIT_SEGMENT, { frag: e, id: i, tracks: f.tracks }) } let e = f.initPTS, t = f.timescale; p(e) && (this.initPTS[o.cc] = { baseTime: e, timescale: t }, r.trigger(v.INIT_PTS_FOUND, { frag: o, id: i, initPTS: e, timescale: t })) } if (h && m && "initSegment" !== o.sn) { let e = m.fragments[o.sn - 1 - m.startSN], t = o.sn === m.startSN, i = !e || o.cc > e.cc; if (!1 !== n.independent) { let { startPTS: e, endPTS: r, startDTS: n, endDTS: a } = h; if (l) l.elementaryStreams[h.type] = { startPTS: e, endPTS: r, startDTS: n, endDTS: a }; else if (h.firstKeyFrame && h.independent && 1 === s.id && !i && (this.couldBacktrack = !0), h.dropped && h.independent) { let n = this.getMainFwdBufferInfo(), s = (n ? n.end : this.getLoadPosition()) + this.config.maxBufferHole, l = h.firstKeyFramePTS ? h.firstKeyFramePTS : e; if (t || !(s < l - this.config.maxBufferHole) || i) i && (o.gap = !0); else { this.backtrack(o); return } o.setElementaryStreamInfo(h.type, o.start, r, o.start, a, !0) } else t && e > 2 && (o.gap = !0); o.setElementaryStreamInfo(h.type, e, r, n, a), this.backtrackFragment && (this.backtrackFragment = o), this.bufferFragmentData(h, o, l, s, t || i) } else if (t || i) o.gap = !0; else { this.backtrack(o); return } } if (g) { let { startPTS: e, endPTS: t, startDTS: i, endDTS: r } = g; l && (l.elementaryStreams[C.AUDIO] = { startPTS: e, endPTS: t, startDTS: i, endDTS: r }), o.setElementaryStreamInfo(C.AUDIO, e, t, i, r), this.bufferFragmentData(g, o, l, s) } if (m && null != d && null != (t = d.samples) && t.length) { let e = { id: i, frag: o, details: m, samples: d.samples }; r.trigger(v.FRAG_PARSING_METADATA, e) } if (m && c) { let e = { id: i, frag: o, details: m, samples: c.samples }; r.trigger(v.FRAG_PARSING_USERDATA, e) } } _bufferInitSegment(e, t, i, r) { if (this.state !== ir.PARSING) return; this.audioOnly = !!t.audio && !t.video, this.altAudio && !this.audioOnly && delete t.audio; let { audio: n, video: s, audiovideo: a } = t; if (n) { let t = e.audioCodec, i = navigator.userAgent.toLowerCase(); if (this.audioCodecSwitch) { t && (t = -1 !== t.indexOf("mp4a.40.5") ? "mp4a.40.2" : "mp4a.40.5"); let e = n.metadata; e && "channelCount" in e && 1 !== (e.channelCount || 1) && -1 === i.indexOf("firefox") && (t = "mp4a.40.5") } t && -1 !== t.indexOf("mp4a.40.5") && -1 !== i.indexOf("android") && "audio/mpeg" !== n.container && (t = "mp4a.40.2", this.log(`Android: force audio codec to ${t}`)), e.audioCodec && e.audioCodec !== t && this.log(`Swapping manifest audio codec "${e.audioCodec}" for "${t}"`), n.levelCodec = t, n.id = "main", this.log(`Init audio buffer, container:${n.container}, codecs[selected/level/parsed]=[${t || ""}/${e.audioCodec || ""}/${n.codec}]`) } s && (s.levelCodec = e.videoCodec, s.id = "main", this.log(`Init video buffer, container:${s.container}, codecs[level/parsed]=[${e.videoCodec || ""}/${s.codec}]`)), a && this.log(`Init audiovideo buffer, container:${a.container}, codecs[level/parsed]=[${e.codecs}/${a.codec}]`), this.hls.trigger(v.BUFFER_CODECS, t), Object.keys(t).forEach(e => { let n = t[e].initSegment; null != n && n.byteLength && this.hls.trigger(v.BUFFER_APPENDING, { type: e, data: n, frag: i, part: null, chunkMeta: r, parent: i.type }) }), this.tickImmediate() } getMainFwdBufferInfo() { return this.getFwdBufferInfo(this.mediaBuffer ? this.mediaBuffer : this.media, e3.MAIN) } backtrack(e) { this.couldBacktrack = !0, this.backtrackFragment = e, this.resetTransmuxer(), this.flushBufferGap(e), this.fragmentTracker.removeFragment(e), this.fragPrevious = null, this.nextLoadPosition = e.start, this.state = ir.IDLE } checkFragmentChanged() { let e = this.media, t = null; if (e && e.readyState > 1 && !1 === e.seeking) { let i = e.currentTime; if (tZ.isBuffered(e, i) ? t = this.getAppendedFrag(i) : tZ.isBuffered(e, i + .1) && (t = this.getAppendedFrag(i + .1)), t) { this.backtrackFragment = null; let e = this.fragPlaying, i = t.level; e && t.sn === e.sn && e.level === i || (this.fragPlaying = t, this.hls.trigger(v.FRAG_CHANGED, { frag: t }), e && e.level === i || this.hls.trigger(v.LEVEL_SWITCHED, { level: i })) } } } get nextLevel() { let e = this.nextBufferedFrag; return e ? e.level : -1 } get currentFrag() { let e = this.media; return e ? this.fragPlaying || this.getAppendedFrag(e.currentTime) : null } get currentProgramDateTime() { let e = this.media; if (e) { let t = e.currentTime, i = this.currentFrag; if (i && p(t) && p(i.programDateTime)) return new Date(i.programDateTime + (t - i.start) * 1e3) } return null } get currentLevel() { let e = this.currentFrag; return e ? e.level : -1 } get nextBufferedFrag() { let e = this.currentFrag; return e ? this.followingBufferedFrag(e) : null } get forceStartLoad() { return this._forceStartLoad } } class nN { static get version() { return "1.5.20" } static isMSESupported() { return nO() } static isSupported() { return nk() } static getMediaSource() { return eD() } static get Events() { return v } static get ErrorTypes() { return y } static get ErrorDetails() { return x } static get DefaultConfig() { return nN.defaultConfig ? nN.defaultConfig : nC } static set DefaultConfig(e) { nN.defaultConfig = e } constructor(e = {}) { this.config = void 0, this.userConfig = void 0, this.coreComponents = void 0, this.networkControllers = void 0, this.started = !1, this._emitter = new i7, this._autoLevelCapping = -1, this._maxHdcpLevel = null, this.abrController = void 0, this.bufferController = void 0, this.capLevelController = void 0, this.latencyController = void 0, this.levelController = void 0, this.streamController = void 0, this.audioTrackController = void 0, this.subtitleTrackController = void 0, this.emeController = void 0, this.cmcdController = void 0, this._media = null, this.url = null, this.triggeringException = void 0, function (e, t) { if ("object" == typeof console && !0 === e || "object" == typeof e) { !function (e, ...t) { t.forEach(function (t) { _[t] = e[t] ? e[t].bind(e) : function (e) { let t = self.console[e]; return t ? t.bind(self.console, `[${e}] >`) : S }(t) }) }(e, "debug", "log", "info", "warn", "error"); try { _.log(`Debug logs enabled for "${t}" in hls.js version 1.5.20`) } catch (e) { _ = A } } else _ = A }(e.debug || !1, "Hls instance"); let t = this.config = function (e, t) { if ((t.liveSyncDurationCount || t.liveMaxLatencyDurationCount) && (t.liveSyncDuration || t.liveMaxLatencyDuration)) throw Error("Illegal hls.js config: don't mix up liveSyncDurationCount/liveMaxLatencyDurationCount and liveSyncDuration/liveMaxLatencyDuration"); if (void 0 !== t.liveMaxLatencyDurationCount && (void 0 === t.liveSyncDurationCount || t.liveMaxLatencyDurationCount <= t.liveSyncDurationCount)) throw Error('Illegal hls.js config: "liveMaxLatencyDurationCount" must be greater than "liveSyncDurationCount"'); if (void 0 !== t.liveMaxLatencyDuration && (void 0 === t.liveSyncDuration || t.liveMaxLatencyDuration <= t.liveSyncDuration)) throw Error('Illegal hls.js config: "liveMaxLatencyDuration" must be greater than "liveSyncDuration"'); let i = function e(t) { return t && "object" == typeof t ? Array.isArray(t) ? t.map(e) : Object.keys(t).reduce((i, r) => (i[r] = e(t[r]), i), {}) : t }(e), r = ["TimeOut", "MaxRetry", "RetryDelay", "MaxRetryTimeout"]; return ["manifest", "level", "frag"].forEach(e => { let n = `${"level" === e ? "playlist" : e}LoadPolicy`, s = void 0 === t[n], a = []; r.forEach(r => { let o = `${e}Loading${r}`, l = t[o]; if (void 0 !== l && s) { a.push(o); let e = i[n].default; switch (t[n] = { default: e }, r) { case "TimeOut": e.maxLoadTimeMs = l, e.maxTimeToFirstByteMs = l; break; case "MaxRetry": e.errorRetry.maxNumRetry = l, e.timeoutRetry.maxNumRetry = l; break; case "RetryDelay": e.errorRetry.retryDelayMs = l, e.timeoutRetry.retryDelayMs = l; break; case "MaxRetryTimeout": e.errorRetry.maxRetryDelayMs = l, e.timeoutRetry.maxRetryDelayMs = l } } }), a.length && E.warn(`hls.js config: "${a.join('", "')}" setting(s) are deprecated, use "${n}": ${JSON.stringify(t[n])}`) }), d(d({}, i), t) }(nN.DefaultConfig, e); this.userConfig = e, t.progressive && function (e) { let t = e.loader; t !== nT && t !== nE ? (E.log("[config]: Custom loader detected, cannot enable progressive streaming"), e.progressive = !1) : function () { if (self.fetch && self.AbortController && self.ReadableStream && self.Request) try { return new self.ReadableStream({}), !0 } catch (e) { } return !1 }() && (e.loader = nT, e.progressive = !0, e.enableSoftwareAES = !0, E.log("[config]: Progressive streaming enabled, using FetchLoader")) }(t); let { abrController: i, bufferController: r, capLevelController: n, errorController: s, fpsController: a } = t, o = new s(this), l = this.abrController = new i(this), u = this.bufferController = new r(this), h = this.capLevelController = new n(this), c = new a(this), f = new e8(this), p = new to(this), m = t.contentSteeringController, g = m ? new m(this) : null, y = this.levelController = new nI(this, g), x = new tX(this), b = new nP(this.config), T = this.streamController = new nU(this, x, b); h.setStreamController(T), c.setStreamController(T); let w = [f, y, T]; g && w.splice(1, 0, g), this.networkControllers = w; let M = [l, u, h, c, p, x]; this.audioTrackController = this.createController(t.audioTrackController, w); let R = t.audioStreamController; R && w.push(new R(this, x, b)), this.subtitleTrackController = this.createController(t.subtitleTrackController, w); let C = t.subtitleStreamController; C && w.push(new C(this, x, b)), this.createController(t.timelineController, M), b.emeController = this.emeController = this.createController(t.emeController, M), this.cmcdController = this.createController(t.cmcdController, M), this.latencyController = this.createController(tl, M), this.coreComponents = M, w.push(o); let I = o.onErrorOut; "function" == typeof I && this.on(v.ERROR, I, o) } createController(e, t) { if (e) { let i = new e(this); return t && t.push(i), i } return null } on(e, t, i = this) { this._emitter.on(e, t, i) } once(e, t, i = this) { this._emitter.once(e, t, i) } removeAllListeners(e) { this._emitter.removeAllListeners(e) } off(e, t, i = this, r) { this._emitter.off(e, t, i, r) } listeners(e) { return this._emitter.listeners(e) } emit(e, t, i) { return this._emitter.emit(e, t, i) } trigger(e, t) { if (this.config.debug) return this.emit(e, e, t); try { return this.emit(e, e, t) } catch (t) { if (E.error("An internal error happened while handling event " + e + '. Error message: "' + t.message + '". Here is a stacktrace:', t), !this.triggeringException) { this.triggeringException = !0; let i = e === v.ERROR; this.trigger(v.ERROR, { type: y.OTHER_ERROR, details: x.INTERNAL_EXCEPTION, fatal: i, event: e, error: t }), this.triggeringException = !1 } } return !1 } listenerCount(e) { return this._emitter.listenerCount(e) } destroy() { E.log("destroy"), this.trigger(v.DESTROYING, void 0), this.detachMedia(), this.removeAllListeners(), this._autoLevelCapping = -1, this.url = null, this.networkControllers.forEach(e => e.destroy()), this.networkControllers.length = 0, this.coreComponents.forEach(e => e.destroy()), this.coreComponents.length = 0; let e = this.config; e.xhrSetup = e.fetchSetup = void 0, this.userConfig = null } attachMedia(e) { E.log("attachMedia"), this._media = e, this.trigger(v.MEDIA_ATTACHING, { media: e }) } detachMedia() { E.log("detachMedia"), this.trigger(v.MEDIA_DETACHING, void 0), this._media = null } loadSource(e) { this.stopLoad(); let t = this.media, i = this.url, r = this.url = h.buildAbsoluteURL(self.location.href, e, { alwaysNormalize: !0 }); this._autoLevelCapping = -1, this._maxHdcpLevel = null, E.log(`loadSource:${r}`), t && i && (i !== r || this.bufferController.hasSourceTypes()) && (this.detachMedia(), this.attachMedia(t)), this.trigger(v.MANIFEST_LOADING, { url: e }) } startLoad(e = -1) { E.log(`startLoad(${e})`), this.started = !0, this.resumeBuffering(); for (let t = 0; t < this.networkControllers.length && (this.networkControllers[t].startLoad(e), this.started && this.networkControllers); t++); } stopLoad() { E.log("stopLoad"), this.started = !1; for (let e = 0; e < this.networkControllers.length && (this.networkControllers[e].stopLoad(), !this.started && this.networkControllers); e++); } resumeBuffering() { E.log("resume buffering"), this.networkControllers.forEach(e => { e.resumeBuffering && e.resumeBuffering() }) } pauseBuffering() { E.log("pause buffering"), this.networkControllers.forEach(e => { e.pauseBuffering && e.pauseBuffering() }) } swapAudioCodec() { E.log("swapAudioCodec"), this.streamController.swapAudioCodec() } recoverMediaError() { E.log("recoverMediaError"); let e = this._media; this.detachMedia(), e && this.attachMedia(e) } removeLevel(e) { this.levelController.removeLevel(e) } get levels() { return this.levelController.levels || [] } get currentLevel() { return this.streamController.currentLevel } set currentLevel(e) { E.log(`set currentLevel:${e}`), this.levelController.manualLevel = e, this.streamController.immediateLevelSwitch() } get nextLevel() { return this.streamController.nextLevel } set nextLevel(e) { E.log(`set nextLevel:${e}`), this.levelController.manualLevel = e, this.streamController.nextLevelSwitch() } get loadLevel() { return this.levelController.level } set loadLevel(e) { E.log(`set loadLevel:${e}`), this.levelController.manualLevel = e } get nextLoadLevel() { return this.levelController.nextLoadLevel } set nextLoadLevel(e) { this.levelController.nextLoadLevel = e } get firstLevel() { return Math.max(this.levelController.firstLevel, this.minAutoLevel) } set firstLevel(e) { E.log(`set firstLevel:${e}`), this.levelController.firstLevel = e } get startLevel() { let e = this.levelController.startLevel; return -1 === e && this.abrController.forcedAutoLevel > -1 ? this.abrController.forcedAutoLevel : e } set startLevel(e) { E.log(`set startLevel:${e}`), -1 !== e && (e = Math.max(e, this.minAutoLevel)), this.levelController.startLevel = e } get capLevelToPlayerSize() { return this.config.capLevelToPlayerSize } set capLevelToPlayerSize(e) { let t = !!e; t !== this.config.capLevelToPlayerSize && (t ? this.capLevelController.startCapping() : (this.capLevelController.stopCapping(), this.autoLevelCapping = -1, this.streamController.nextLevelSwitch()), this.config.capLevelToPlayerSize = t) } get autoLevelCapping() { return this._autoLevelCapping } get bandwidthEstimate() { let { bwEstimator: e } = this.abrController; return e ? e.getEstimate() : NaN } set bandwidthEstimate(e) { this.abrController.resetEstimator(e) } get ttfbEstimate() { let { bwEstimator: e } = this.abrController; return e ? e.getEstimateTTFB() : NaN } set autoLevelCapping(e) { this._autoLevelCapping !== e && (E.log(`set autoLevelCapping:${e}`), this._autoLevelCapping = e, this.levelController.checkMaxAutoUpdated()) } get maxHdcpLevel() { return this._maxHdcpLevel } set maxHdcpLevel(e) { tu.indexOf(e) > -1 && this._maxHdcpLevel !== e && (this._maxHdcpLevel = e, this.levelController.checkMaxAutoUpdated()) } get autoLevelEnabled() { return -1 === this.levelController.manualLevel } get manualLevel() { return this.levelController.manualLevel } get minAutoLevel() { let { levels: e, config: { minAutoBitrate: t } } = this; if (!e) return 0; let i = e.length; for (let r = 0; r < i; r++)if (e[r].maxBitrate >= t) return r; return 0 } get maxAutoLevel() { let e; let { levels: t, autoLevelCapping: i, maxHdcpLevel: r } = this; if (e = -1 === i && null != t && t.length ? t.length - 1 : i, r) for (let i = e; i--;) { let e = t[i].attrs["HDCP-LEVEL"]; if (e && e <= r) return i } return e } get firstAutoLevel() { return this.abrController.firstAutoLevel } get nextAutoLevel() { return this.abrController.nextAutoLevel } set nextAutoLevel(e) { this.abrController.nextAutoLevel = e } get playingDate() { return this.streamController.currentProgramDateTime } get mainForwardBufferInfo() { return this.streamController.getMainFwdBufferInfo() } setAudioOption(e) { var t; return null == (t = this.audioTrackController) ? void 0 : t.setAudioOption(e) } setSubtitleOption(e) { var t; return null == (t = this.subtitleTrackController) || t.setSubtitleOption(e), null } get allAudioTracks() { let e = this.audioTrackController; return e ? e.allAudioTracks : [] } get audioTracks() { let e = this.audioTrackController; return e ? e.audioTracks : [] } get audioTrack() { let e = this.audioTrackController; return e ? e.audioTrack : -1 } set audioTrack(e) { let t = this.audioTrackController; t && (t.audioTrack = e) } get allSubtitleTracks() { let e = this.subtitleTrackController; return e ? e.allSubtitleTracks : [] } get subtitleTracks() { let e = this.subtitleTrackController; return e ? e.subtitleTracks : [] } get subtitleTrack() { let e = this.subtitleTrackController; return e ? e.subtitleTrack : -1 } get media() { return this._media } set subtitleTrack(e) { let t = this.subtitleTrackController; t && (t.subtitleTrack = e) } get subtitleDisplay() { let e = this.subtitleTrackController; return !!e && e.subtitleDisplay } set subtitleDisplay(e) { let t = this.subtitleTrackController; t && (t.subtitleDisplay = e) } get lowLatencyMode() { return this.config.lowLatencyMode } set lowLatencyMode(e) { this.config.lowLatencyMode = e } get liveSyncPosition() { return this.latencyController.liveSyncPosition } get latency() { return this.latencyController.latency } get maxLatency() { return this.latencyController.maxLatency } get targetLatency() { return this.latencyController.targetLatency } get drift() { return this.latencyController.drift } get forceStartLoad() { return this.streamController.forceStartLoad } } nN.defaultConfig = void 0
  }, 9318: (e, t, i) => { "use strict"; i.d(t, { Af: () => o, Nz: () => n, u5: () => l, y3: () => c }); var r = i(6540); function n(e, t, i) { if (!e) return; if (!0 === i(e)) return e; let r = t ? e.return : e.child; for (; r;) { let e = n(r, t, i); if (e) return e; r = t ? null : r.sibling } } function s(e) { try { return Object.defineProperties(e, { _currentRenderer: { get: () => null, set() { } }, _currentRenderer2: { get: () => null, set() { } } }) } catch (t) { return e } } (() => { var e, t; return "undefined" != typeof window && ((null == (e = window.document) ? void 0 : e.createElement) || (null == (t = window.navigator) ? void 0 : t.product) === "ReactNative") })() ? r.useLayoutEffect : r.useEffect; let a = s(r.createContext(null)); class o extends r.Component { render() { return r.createElement(a.Provider, { value: this._reactInternals }, this.props.children) } } function l() { let e = r.useContext(a); if (null === e) throw Error("its-fine: useFiber must be called within a <FiberProvider />!"); let t = r.useId(); return r.useMemo(() => { for (let i of [e, null == e ? void 0 : e.alternate]) { if (!i) continue; let e = n(i, !1, e => { let i = e.memoizedState; for (; i;) { if (i.memoizedState === t) return !0; i = i.next } }); if (e) return e } }, [e, t]) } let u = Symbol.for("react.context"), h = e => null !== e && "object" == typeof e && "$$typeof" in e && e.$$typeof === u; function c() { let e = function () { let e = l(), [t] = r.useState(() => new Map); t.clear(); let i = e; for (; i;) { let e = i.type; h(e) && e !== a && !t.has(e) && t.set(e, r.use(s(e))), i = i.return } return t }(); return r.useMemo(() => Array.from(e.keys()).reduce((t, i) => n => r.createElement(t, null, r.createElement(i.Provider, { ...n, value: e.get(i) })), e => r.createElement(o, { ...e })), [e]) } }, 4066: (e, t, i) => { "use strict"; function r(e, t, i) { return Math.max(e, Math.min(t, i)) } i.d(t, { A: () => h }); var n = class { isRunning = !1; value = 0; from = 0; to = 0; currentTime = 0; lerp; duration; easing; onUpdate; advance(e) { if (!this.isRunning) return; let t = !1; if (this.duration && this.easing) { this.currentTime += e; let i = r(0, this.currentTime / this.duration, 1), n = (t = i >= 1) ? 1 : this.easing(i); this.value = this.from + (this.to - this.from) * n } else if (this.lerp) { var i, n, s; this.value = (i = this.value, n = this.to, (1 - (s = 1 - Math.exp(-(60 * this.lerp) * e))) * i + s * n), Math.round(this.value) === this.to && (this.value = this.to, t = !0) } else this.value = this.to, t = !0; t && this.stop(), this.onUpdate?.(this.value, t) } stop() { this.isRunning = !1 } fromTo(e, t, { lerp: i, duration: r, easing: n, onStart: s, onUpdate: a }) { this.from = this.value = e, this.to = t, this.lerp = i, this.duration = r, this.easing = n, this.currentTime = 0, this.isRunning = !0, s?.(), this.onUpdate = a } }, s = class { constructor(e, t, { autoResize: i = !0, debounce: r = 250 } = {}) { this.wrapper = e, this.content = t, i && (this.debouncedResize = function (e, t) { let i; return function (...r) { let n = this; clearTimeout(i), i = setTimeout(() => { i = void 0, e.apply(n, r) }, t) } }(this.resize, r), this.wrapper instanceof Window ? window.addEventListener("resize", this.debouncedResize, !1) : (this.wrapperResizeObserver = new ResizeObserver(this.debouncedResize), this.wrapperResizeObserver.observe(this.wrapper)), this.contentResizeObserver = new ResizeObserver(this.debouncedResize), this.contentResizeObserver.observe(this.content)), this.resize() } width = 0; height = 0; scrollHeight = 0; scrollWidth = 0; debouncedResize; wrapperResizeObserver; contentResizeObserver; destroy() { this.wrapperResizeObserver?.disconnect(), this.contentResizeObserver?.disconnect(), this.wrapper === window && this.debouncedResize && window.removeEventListener("resize", this.debouncedResize, !1) } resize = () => { this.onWrapperResize(), this.onContentResize() }; onWrapperResize = () => { this.wrapper instanceof Window ? (this.width = window.innerWidth, this.height = window.innerHeight) : (this.width = this.wrapper.clientWidth, this.height = this.wrapper.clientHeight) }; onContentResize = () => { this.wrapper instanceof Window ? (this.scrollHeight = this.content.scrollHeight, this.scrollWidth = this.content.scrollWidth) : (this.scrollHeight = this.wrapper.scrollHeight, this.scrollWidth = this.wrapper.scrollWidth) }; get limit() { return { x: this.scrollWidth - this.width, y: this.scrollHeight - this.height } } }, a = class { events = {}; emit(e, ...t) { let i = this.events[e] || []; for (let e = 0, r = i.length; e < r; e++)i[e]?.(...t) } on(e, t) { return this.events[e]?.push(t) || (this.events[e] = [t]), () => { this.events[e] = this.events[e]?.filter(e => t !== e) } } off(e, t) { this.events[e] = this.events[e]?.filter(e => t !== e) } destroy() { this.events = {} } }, o = 100 / 6, l = { passive: !1 }, u = class { constructor(e, t = { wheelMultiplier: 1, touchMultiplier: 1 }) { this.element = e, this.options = t, window.addEventListener("resize", this.onWindowResize, !1), this.onWindowResize(), this.element.addEventListener("wheel", this.onWheel, l), this.element.addEventListener("touchstart", this.onTouchStart, l), this.element.addEventListener("touchmove", this.onTouchMove, l), this.element.addEventListener("touchend", this.onTouchEnd, l) } touchStart = { x: 0, y: 0 }; lastDelta = { x: 0, y: 0 }; window = { width: 0, height: 0 }; emitter = new a; on(e, t) { return this.emitter.on(e, t) } destroy() { this.emitter.destroy(), window.removeEventListener("resize", this.onWindowResize, !1), this.element.removeEventListener("wheel", this.onWheel, l), this.element.removeEventListener("touchstart", this.onTouchStart, l), this.element.removeEventListener("touchmove", this.onTouchMove, l), this.element.removeEventListener("touchend", this.onTouchEnd, l) } onTouchStart = e => { let { clientX: t, clientY: i } = e.targetTouches ? e.targetTouches[0] : e; this.touchStart.x = t, this.touchStart.y = i, this.lastDelta = { x: 0, y: 0 }, this.emitter.emit("scroll", { deltaX: 0, deltaY: 0, event: e }) }; onTouchMove = e => { let { clientX: t, clientY: i } = e.targetTouches ? e.targetTouches[0] : e, r = -(t - this.touchStart.x) * this.options.touchMultiplier, n = -(i - this.touchStart.y) * this.options.touchMultiplier; this.touchStart.x = t, this.touchStart.y = i, this.lastDelta = { x: r, y: n }, this.emitter.emit("scroll", { deltaX: r, deltaY: n, event: e }) }; onTouchEnd = e => { this.emitter.emit("scroll", { deltaX: this.lastDelta.x, deltaY: this.lastDelta.y, event: e }) }; onWheel = e => { let { deltaX: t, deltaY: i, deltaMode: r } = e, n = 1 === r ? o : 2 === r ? this.window.width : 1, s = 1 === r ? o : 2 === r ? this.window.height : 1; t *= n, i *= s, t *= this.options.wheelMultiplier, i *= this.options.wheelMultiplier, this.emitter.emit("scroll", { deltaX: t, deltaY: i, event: e }) }; onWindowResize = () => { this.window = { width: window.innerWidth, height: window.innerHeight } } }, h = class { _isScrolling = !1; _isStopped = !1; _isLocked = !1; _preventNextNativeScrollEvent = !1; _resetVelocityTimeout = null; __rafID = null; isTouching; time = 0; userData = {}; lastVelocity = 0; velocity = 0; direction = 0; options; targetScroll; animatedScroll; animate = new n; emitter = new a; dimensions; virtualScroll; constructor({ wrapper: e = window, content: t = document.documentElement, eventsTarget: i = e, smoothWheel: r = !0, syncTouch: n = !1, syncTouchLerp: a = .075, touchInertiaMultiplier: o = 35, duration: l, easing: h = e => Math.min(1, 1.001 - Math.pow(2, -10 * e)), lerp: c = .1, infinite: d = !1, orientation: f = "vertical", gestureOrientation: p = "vertical", touchMultiplier: m = 1, wheelMultiplier: g = 1, autoResize: v = !0, prevent: y, virtualScroll: x, overscroll: S = !0, autoRaf: A = !1, anchors: _ = !1, __experimental__naiveDimensions: E = !1 } = {}) { window.lenisVersion = "1.2.3", e && e !== document.documentElement || (e = window), this.options = { wrapper: e, content: t, eventsTarget: i, smoothWheel: r, syncTouch: n, syncTouchLerp: a, touchInertiaMultiplier: o, duration: l, easing: h, lerp: c, infinite: d, gestureOrientation: p, orientation: f, touchMultiplier: m, wheelMultiplier: g, autoResize: v, prevent: y, virtualScroll: x, overscroll: S, autoRaf: A, anchors: _, __experimental__naiveDimensions: E }, this.dimensions = new s(e, t, { autoResize: v }), this.updateClassName(), this.targetScroll = this.animatedScroll = this.actualScroll, this.options.wrapper.addEventListener("scroll", this.onNativeScroll, !1), this.options.wrapper.addEventListener("scrollend", this.onScrollEnd, { capture: !0 }), this.options.anchors && this.options.wrapper === window && this.options.wrapper.addEventListener("click", this.onClick, !1), this.options.wrapper.addEventListener("pointerdown", this.onPointerDown, !1), this.virtualScroll = new u(i, { touchMultiplier: m, wheelMultiplier: g }), this.virtualScroll.on("scroll", this.onVirtualScroll), this.options.autoRaf && (this.__rafID = requestAnimationFrame(this.raf)) } destroy() { this.emitter.destroy(), this.options.wrapper.removeEventListener("scroll", this.onNativeScroll, !1), this.options.wrapper.removeEventListener("scrollend", this.onScrollEnd, { capture: !0 }), this.options.wrapper.removeEventListener("pointerdown", this.onPointerDown, !1), this.options.anchors && this.options.wrapper === window && this.options.wrapper.removeEventListener("click", this.onClick, !1), this.virtualScroll.destroy(), this.dimensions.destroy(), this.cleanUpClassName(), this.__rafID && cancelAnimationFrame(this.__rafID) } on(e, t) { return this.emitter.on(e, t) } off(e, t) { return this.emitter.off(e, t) } onScrollEnd = e => { e instanceof CustomEvent || "smooth" !== this.isScrolling && !1 !== this.isScrolling || e.stopPropagation() }; dispatchScrollendEvent = () => { this.options.wrapper.dispatchEvent(new CustomEvent("scrollend", { bubbles: this.options.wrapper === window, detail: { lenisScrollEnd: !0 } })) }; setScroll(e) { this.isHorizontal ? this.options.wrapper.scrollTo({ left: e, behavior: "instant" }) : this.options.wrapper.scrollTo({ top: e, behavior: "instant" }) } onClick = e => { let t = e.composedPath().find(e => e instanceof HTMLAnchorElement && (e.getAttribute("href")?.startsWith("#") || e.getAttribute("href")?.startsWith("/#") || e.getAttribute("href")?.startsWith("./#"))); if (t) { let e = t.getAttribute("href"); if (e) { let t = "object" == typeof this.options.anchors && this.options.anchors ? this.options.anchors : void 0; this.scrollTo(`#${e.split("#")[1]}`, t) } } }; onPointerDown = e => { 1 === e.button && this.reset() }; onVirtualScroll = e => { if ("function" == typeof this.options.virtualScroll && !1 === this.options.virtualScroll(e)) return; let { deltaX: t, deltaY: i, event: r } = e; if (this.emitter.emit("virtual-scroll", { deltaX: t, deltaY: i, event: r }), r.ctrlKey || r.lenisStopPropagation) return; let n = r.type.includes("touch"), s = r.type.includes("wheel"); this.isTouching = "touchstart" === r.type || "touchmove" === r.type; let a = 0 === t && 0 === i; if (this.options.syncTouch && n && "touchstart" === r.type && a && !this.isStopped && !this.isLocked) { this.reset(); return } let o = "vertical" === this.options.gestureOrientation && 0 === i || "horizontal" === this.options.gestureOrientation && 0 === t; if (a || o) return; let l = r.composedPath(); l = l.slice(0, l.indexOf(this.rootElement)); let u = this.options.prevent; if (l.find(e => e instanceof HTMLElement && ("function" == typeof u && u?.(e) || e.hasAttribute?.("data-lenis-prevent") || n && e.hasAttribute?.("data-lenis-prevent-touch") || s && e.hasAttribute?.("data-lenis-prevent-wheel")))) return; if (this.isStopped || this.isLocked) { r.preventDefault(); return } if (!(this.options.syncTouch && n || this.options.smoothWheel && s)) { this.isScrolling = "native", this.animate.stop(), r.lenisStopPropagation = !0; return } let h = i; "both" === this.options.gestureOrientation ? h = Math.abs(i) > Math.abs(t) ? i : t : "horizontal" === this.options.gestureOrientation && (h = t), (!this.options.overscroll || this.options.infinite || this.options.wrapper !== window && (this.animatedScroll > 0 && this.animatedScroll < this.limit || 0 === this.animatedScroll && i > 0 || this.animatedScroll === this.limit && i < 0)) && (r.lenisStopPropagation = !0), r.preventDefault(); let c = n && this.options.syncTouch, d = n && "touchend" === r.type && Math.abs(h) > 5; d && (h = this.velocity * this.options.touchInertiaMultiplier), this.scrollTo(this.targetScroll + h, { programmatic: !1, ...c ? { lerp: d ? this.options.syncTouchLerp : 1 } : { lerp: this.options.lerp, duration: this.options.duration, easing: this.options.easing } }) }; resize() { this.dimensions.resize(), this.animatedScroll = this.targetScroll = this.actualScroll, this.emit() } emit() { this.emitter.emit("scroll", this) } onNativeScroll = () => { if (null !== this._resetVelocityTimeout && (clearTimeout(this._resetVelocityTimeout), this._resetVelocityTimeout = null), this._preventNextNativeScrollEvent) { this._preventNextNativeScrollEvent = !1; return } if (!1 === this.isScrolling || "native" === this.isScrolling) { let e = this.animatedScroll; this.animatedScroll = this.targetScroll = this.actualScroll, this.lastVelocity = this.velocity, this.velocity = this.animatedScroll - e, this.direction = Math.sign(this.animatedScroll - e), this.isStopped || (this.isScrolling = "native"), this.emit(), 0 !== this.velocity && (this._resetVelocityTimeout = setTimeout(() => { this.lastVelocity = this.velocity, this.velocity = 0, this.isScrolling = !1, this.emit() }, 400)) } }; reset() { this.isLocked = !1, this.isScrolling = !1, this.animatedScroll = this.targetScroll = this.actualScroll, this.lastVelocity = this.velocity = 0, this.animate.stop() } start() { this.isStopped && (this.reset(), this.isStopped = !1) } stop() { this.isStopped || (this.reset(), this.isStopped = !0) } raf = e => { let t = e - (this.time || e); this.time = e, this.animate.advance(.001 * t), this.options.autoRaf && (this.__rafID = requestAnimationFrame(this.raf)) }; scrollTo(e, { offset: t = 0, immediate: i = !1, lock: n = !1, duration: s = this.options.duration, easing: a = this.options.easing, lerp: o = this.options.lerp, onStart: l, onComplete: u, force: h = !1, programmatic: c = !0, userData: d } = {}) { if (!this.isStopped && !this.isLocked || h) { if ("string" == typeof e && ["top", "left", "start"].includes(e)) e = 0; else if ("string" == typeof e && ["bottom", "right", "end"].includes(e)) e = this.limit; else { let i; if ("string" == typeof e ? i = document.querySelector(e) : e instanceof HTMLElement && e?.nodeType && (i = e), i) { if (this.options.wrapper !== window) { let e = this.rootElement.getBoundingClientRect(); t -= this.isHorizontal ? e.left : e.top } let r = i.getBoundingClientRect(); e = (this.isHorizontal ? r.left : r.top) + this.animatedScroll } } if ("number" == typeof e) { if (e += t, e = Math.round(e), this.options.infinite ? c && (this.targetScroll = this.animatedScroll = this.scroll) : e = r(0, e, this.limit), e === this.targetScroll) { l?.(this), u?.(this); return } if (this.userData = d ?? {}, i) { this.animatedScroll = this.targetScroll = e, this.setScroll(this.scroll), this.reset(), this.preventNextNativeScrollEvent(), this.emit(), u?.(this), this.userData = {}, requestAnimationFrame(() => { this.dispatchScrollendEvent() }); return } c || (this.targetScroll = e), this.animate.fromTo(this.animatedScroll, e, { duration: s, easing: a, lerp: o, onStart: () => { n && (this.isLocked = !0), this.isScrolling = "smooth", l?.(this) }, onUpdate: (e, t) => { this.isScrolling = "smooth", this.lastVelocity = this.velocity, this.velocity = e - this.animatedScroll, this.direction = Math.sign(this.velocity), this.animatedScroll = e, this.setScroll(this.scroll), c && (this.targetScroll = e), t || this.emit(), t && (this.reset(), this.emit(), u?.(this), this.userData = {}, requestAnimationFrame(() => { this.dispatchScrollendEvent() }), this.preventNextNativeScrollEvent()) } }) } } } preventNextNativeScrollEvent() { this._preventNextNativeScrollEvent = !0, requestAnimationFrame(() => { this._preventNextNativeScrollEvent = !1 }) } get rootElement() { return this.options.wrapper === window ? document.documentElement : this.options.wrapper } get limit() { return this.options.__experimental__naiveDimensions ? this.isHorizontal ? this.rootElement.scrollWidth - this.rootElement.clientWidth : this.rootElement.scrollHeight - this.rootElement.clientHeight : this.dimensions.limit[this.isHorizontal ? "x" : "y"] } get isHorizontal() { return "horizontal" === this.options.orientation } get actualScroll() { let e = this.options.wrapper; return this.isHorizontal ? e.scrollX ?? e.scrollLeft : e.scrollY ?? e.scrollTop } get scroll() { var e; return this.options.infinite ? (this.animatedScroll % (e = this.limit) + e) % e : this.animatedScroll } get progress() { return 0 === this.limit ? 1 : this.scroll / this.limit } get isScrolling() { return this._isScrolling } set isScrolling(e) { this._isScrolling !== e && (this._isScrolling = e, this.updateClassName()) } get isStopped() { return this._isStopped } set isStopped(e) { this._isStopped !== e && (this._isStopped = e, this.updateClassName()) } get isLocked() { return this._isLocked } set isLocked(e) { this._isLocked !== e && (this._isLocked = e, this.updateClassName()) } get isSmooth() { return "smooth" === this.isScrolling } get className() { let e = "lenis"; return this.isStopped && (e += " lenis-stopped"), this.isLocked && (e += " lenis-locked"), this.isScrolling && (e += " lenis-scrolling"), "smooth" === this.isScrolling && (e += " lenis-smooth"), e } updateClassName() { this.cleanUpClassName(), this.rootElement.className = `${this.rootElement.className} ${this.className}`.trim() } cleanUpClassName() { this.rootElement.className = this.rootElement.className.replace(/lenis(-\w+)?/g, "").trim() } } }, 3033: (e, t, i) => { "use strict"; i.d(t, { P6: () => a, vG: () => f, tu: () => u, XG: () => c, KZ: () => y, rU: () => o, PT: () => w, DW: () => p, WH: () => d, Mc: () => R, yL: () => x, TU: () => function e(t, i) { if (t) return "function" == typeof t && g() ? y(t, i) : p(t) ? S(t) : Array.isArray(t) ? t.map(t => e(t, i) || A.easeOut) : A[t] }, YE: () => l, c$: () => k, KJ: () => E, Wp: () => F, nL: () => g }); var r = i(4435); let n = (0, r.p)(() => void 0 !== window.ScrollTimeline); class s { constructor(e) { this.stop = () => this.runAll("stop"), this.animations = e.filter(Boolean) } get finished() { return Promise.all(this.animations.map(e => "finished" in e ? e.finished : e)) } getAll(e) { return this.animations[0][e] } setAll(e, t) { for (let i = 0; i < this.animations.length; i++)this.animations[i][e] = t } attachTimeline(e, t) { let i = this.animations.map(i => n() && i.attachTimeline ? i.attachTimeline(e) : "function" == typeof t ? t(i) : void 0); return () => { i.forEach((e, t) => { e && e(), this.animations[t].stop() }) } } get time() { return this.getAll("time") } set time(e) { this.setAll("time", e) } get speed() { return this.getAll("speed") } set speed(e) { this.setAll("speed", e) } get startTime() { return this.getAll("startTime") } get duration() { let e = 0; for (let t = 0; t < this.animations.length; t++)e = Math.max(e, this.animations[t].duration); return e } runAll(e) { this.animations.forEach(t => t[e]()) } flatten() { this.runAll("flatten") } play() { this.runAll("play") } pause() { this.runAll("pause") } cancel() { this.runAll("cancel") } complete() { this.runAll("complete") } } class a extends s { then(e, t) { return Promise.all(this.animations).then(e).catch(t) } } function o(e, t) { return e ? e[t] || e.default || e : void 0 } let l = 2e4; function u(e) { let t = 0, i = e.next(t); for (; !i.done && t < l;)t += 50, i = e.next(t); return t >= l ? 1 / 0 : t } var h = i(7331); function c(e, t = 100, i) { let r = i({ ...e, keyframes: [0, t] }), n = Math.min(u(r), l); return { type: "keyframes", ease: e => r.next(n * e).value / t, duration: (0, h.X)(n) } } function d(e) { return "function" == typeof e } function f(e, t) { e.timeline = t, e.onfinish = null } let p = e => Array.isArray(e) && "number" == typeof e[0], m = { linearEasing: void 0 }, g = function (e, t) { let i = (0, r.p)(e); return () => { var e; return null !== (e = m[t]) && void 0 !== e ? e : i() } }(() => { try { document.createElement("div").animate({ opacity: 0 }, { easing: "linear(0, 1)" }) } catch (e) { return !1 } return !0 }, "linearEasing"); var v = i(6896); let y = (e, t, i = 10) => { let r = "", n = Math.max(Math.round(t / i), 2); for (let t = 0; t < n; t++)r += e((0, v.q)(0, n - 1, t)) + ", "; return `linear(${r.substring(0, r.length - 2)})` }; function x(e) { return !!("function" == typeof e && g() || !e || "string" == typeof e && (e in A || g()) || p(e) || Array.isArray(e) && e.every(x)) } let S = ([e, t, i, r]) => `cubic-bezier(${e}, ${t}, ${i}, ${r})`, A = { linear: "linear", ease: "ease", easeIn: "ease-in", easeOut: "ease-out", easeInOut: "ease-in-out", circIn: S([0, .65, .55, 1]), circOut: S([.55, 0, 1, .45]), backIn: S([.31, .01, .66, -.59]), backOut: S([.33, 1.53, .69, .99]) }, _ = { x: !1, y: !1 }; function E(e, t, i) { var r; if (e instanceof Element) return [e]; if ("string" == typeof e) { let n = document; t && (n = t.current); let s = null !== (r = null == i ? void 0 : i[e]) && void 0 !== r ? r : n.querySelectorAll(e); return s ? Array.from(s) : [] } return Array.from(e) } function b(e, t) { let i = E(e), r = new AbortController; return [i, { passive: !0, ...t, signal: r.signal }, () => r.abort()] } function T(e) { return t => { "touch" === t.pointerType || _.x || _.y || e(t) } } function w(e, t, i = {}) { let [r, n, s] = b(e, i), a = T(e => { let { target: i } = e, r = t(e); if ("function" != typeof r || !i) return; let s = T(e => { r(e), i.removeEventListener("pointerleave", s) }); i.addEventListener("pointerleave", s, n) }); return r.forEach(e => { e.addEventListener("pointerenter", a, n) }), s } let M = (e, t) => !!t && (e === t || M(e, t.parentElement)), R = e => "mouse" === e.pointerType ? "number" != typeof e.button || e.button <= 0 : !1 !== e.isPrimary, C = new Set(["BUTTON", "INPUT", "SELECT", "TEXTAREA", "A"]), I = new WeakSet; function L(e) { return t => { "Enter" === t.key && e(t) } } function P(e, t) { e.dispatchEvent(new PointerEvent("pointer" + t, { isPrimary: !0, bubbles: !0 })) } let D = (e, t) => { let i = e.currentTarget; if (!i) return; let r = L(() => { if (I.has(i)) return; P(i, "down"); let e = L(() => { P(i, "up") }); i.addEventListener("keyup", e, t), i.addEventListener("blur", () => P(i, "cancel"), t) }); i.addEventListener("keydown", r, t), i.addEventListener("blur", () => i.removeEventListener("keydown", r), t) }; function O(e) { return R(e) && !(_.x || _.y) } function k(e, t, i = {}) { let [r, n, s] = b(e, i), a = e => { let r = e.currentTarget; if (!O(e) || I.has(r)) return; I.add(r); let s = t(e), a = (e, t) => { window.removeEventListener("pointerup", o), window.removeEventListener("pointercancel", l), O(e) && I.has(r) && (I.delete(r), "function" == typeof s && s(e, { success: t })) }, o = e => { a(e, i.useGlobalTarget || M(r, e.target)) }, l = e => { a(e, !1) }; window.addEventListener("pointerup", o, n), window.addEventListener("pointercancel", l, n) }; return r.forEach(e => { C.has(e.tagName) || -1 !== e.tabIndex || null !== e.getAttribute("tabindex") || (e.tabIndex = 0), (i.useGlobalTarget ? window : e).addEventListener("pointerdown", a, n), e.addEventListener("focus", e => D(e, n), n) }), s } function F(e) { return "x" === e || "y" === e ? _[e] ? null : (_[e] = !0, () => { _[e] = !1 }) : _.x || _.y ? null : (_.x = _.y = !0, () => { _.x = _.y = !1 }) } i(1533) }, 8104: (e, t, i) => { "use strict"; i.d(t, { $: () => n, V: () => s }); var r = i(1533); let n = r.l, s = r.l }, 4435: (e, t, i) => { "use strict"; function r(e) { let t; return () => (void 0 === t && (t = e()), t) } i.d(t, { p: () => r }) }, 1533: (e, t, i) => { "use strict"; i.d(t, { l: () => r }); let r = e => e }, 6896: (e, t, i) => { "use strict"; i.d(t, { q: () => r }); let r = (e, t, i) => { let r = t - e; return 0 === r ? 1 : (i - e) / r } }, 7331: (e, t, i) => { "use strict"; i.d(t, { X: () => n, f: () => r }); let r = e => 1e3 * e, n = e => e / 1e3 }, 4922: (e, t, i) => {
    "use strict"; let r, n, s, a, o; i.d(t, { $EB: () => A, $Ed: () => aE, $Kf: () => sQ, $NF: () => lO, $O9: () => ew, $Yl: () => j, $_I: () => eP, $ei: () => P, $p8: () => l0, A$4: () => nU, AKb: () => lc, ALV: () => ra, AQS: () => iV, Am1: () => un, B69: () => nt, B6O: () => a6, BER: () => ef, BH$: () => aN, BKk: () => sn, BND: () => hg, BRH: () => lF, BXX: () => e9, B_h: () => to, CMB: () => eQ, CR7: () => t7, CSG: () => li, CV9: () => oa, CVz: () => tr, CWW: () => tw, Cfg: () => eM, CmU: () => l8, CwR: () => uE, D$Q: () => o5, DAe: () => tU, DXC: () => aF, Df: () => o7, Dmk: () => ej, E0M: () => hx, EAD: () => s0, EQC: () => tP, EZo: () => b, EdD: () => w, F1T: () => sh, F1l: () => u7, FCc: () => aU, FFZ: () => id, FNr: () => ln, FV: () => eu, FXf: () => C, FZo: () => l3, Fn: () => tS, Fpm: () => u4, FvD: () => aK, Fvi: () => ep, Fvt: () => ls, G3T: () => tM, GBG: () => lS, GJx: () => eA, GOR: () => aZ, GWd: () => eK, GYF: () => sZ, GZZ: () => or, G_z: () => lt, Gu$: () => oQ, Gwm: () => J, GxU: () => nR, H23: () => tA, H2z: () => h_, HIg: () => eX, HLH: () => t1, HO_: () => tT, HPb: () => t8, HXV: () => tt, HgN: () => i4, HiM: () => lQ, Hit: () => lx, Ho_: () => op, Hrb: () => nF, Hrq: () => iS, I46: () => sq, I9Y: () => iz, IE4: () => e5, IUQ: () => re, IWo: () => hm, Iit: () => st, Ipv: () => aJ, Iw4: () => uU, IzY: () => hS, Jnc: () => f, K52: () => ee, KDk: () => ts, KLL: () => tZ, KPJ: () => lw, KRh: () => er, Ke9: () => tF, Kef: () => tE, Ktl: () => ig, Kwu: () => T, Kzg: () => ui, Kzv: () => eq, LAk: () => ec, Ld9: () => hA, LiQ: () => F, LlO: () => sr, LoY: () => nq, LuO: () => uV, MBL: () => lA, MOq: () => iA, MSw: () => oq, MW4: () => nB, Mjd: () => eo, Mmk: () => i$, N1A: () => aP, N2s: () => ub, N5j: () => tH, NRn: () => rc, NTi: () => E, NZq: () => eD, Nex: () => hE, Nt7: () => z, Nv2: () => aj, Nwf: () => uD, Nz6: () => e8, O0B: () => rt, O3Y: () => o$, O49: () => tB, O9p: () => rK, ONl: () => aV, OUM: () => eO, Oax: () => nz, Om: () => eS, OuU: () => N, P5j: () => uO, PFK: () => hu, PJ3: () => tL, PPD: () => aa, PTz: () => ro, Pdi: () => lf, Pem: () => aX, Pf$: () => ug, Pq0: () => rl, Q1f: () => nS, QCA: () => oV, QP0: () => g, Qev: () => iR, Qrf: () => th, R1W: () => hr, R3r: () => sm, RJ4: () => tN, ROr: () => t2, RQf: () => ez, RcT: () => ie, RiT: () => lE, Riy: () => tn, Rkk: () => tG, RlV: () => rU, RoJ: () => s_, RrE: () => W, Ru$: () => t3, RyA: () => y, S$4: () => tx, S20: () => a0, SUR: () => l6, SYV: () => aY, ScU: () => lk, T6I: () => ly, TDQ: () => o_, THS: () => nP, TMh: () => ii, Tap: () => lU, TdN: () => iT, TiK: () => il, TkQ: () => e2, U3G: () => $, UJ6: () => lg, UPV: () => oJ, UTZ: () => em, Ufg: () => oY, UpK: () => sB, UtB: () => uJ, UtX: () => ur, V3x: () => eW, V9B: () => nb, VCu: () => a$, VGF: () => e3, VT0: () => eJ, VVr: () => tJ, Vb5: () => d, VnP: () => on, Vnu: () => im, Vwu: () => hb, VxR: () => tQ, W9U: () => t_, WBB: () => oj, WNZ: () => c, WTh: () => hd, Wdf: () => ib, Wew: () => eH, Wk7: () => v, Wyr: () => iE, XG_: () => tb, XIg: () => _, XJ7: () => o1, XMJ: () => uN, XTe: () => l9, XrR: () => en, Y9S: () => lL, YHV: () => uq, YJl: () => sf, YOZ: () => lv, YRT: () => lD, Yhb: () => lm, Yuy: () => eN, Z0B: () => ot, Z58: () => sy, ZLX: () => s7, ZM4: () => hv, ZQM: () => e0, Zcv: () => ar, Zpd: () => oZ, Zr2: () => tq, ZyN: () => lJ, _4j: () => o8, _QJ: () => tf, _Ut: () => si, _xc: () => u9, a$r: () => eR, a55: () => iP, a5J: () => td, aEY: () => H, aHM: () => lR, aJ8: () => ed, aMy: () => tR, aVO: () => lr, agE: () => ip, amv: () => is, b4q: () => sc, bC7: () => tg, bCz: () => M, bI3: () => tj, bTm: () => m, baL: () => nO, bdM: () => oX, bkx: () => eB, brA: () => Q, bw0: () => et, c5h: () => aQ, c90: () => e4, cHt: () => eU, cRK: () => sg, cZY: () => u2, caT: () => ei, cj9: () => iB, czI: () => tl, dAo: () => os, dYF: () => rs, dcC: () => e$, dhZ: () => tk, dth: () => lB, dwI: () => iG, dzP: () => uH, e0p: () => Y, eB$: () => sx, eHc: () => K, eHs: () => sA, eaF: () => n6, eoi: () => iu, er$: () => tK, ezk: () => lp, f4X: () => k, fBL: () => eF, fJr: () => t4, fP5: () => uv, fTw: () => hn, fc6: () => nk, g7M: () => eh, gJ2: () => eV, gO9: () => R, gPd: () => i7, gWB: () => ic, ghU: () => e_, h2z: () => tO, hB5: () => x, hIf: () => iy, hZF: () => l_, h_9: () => lM, hdd: () => B, hgQ: () => V, hjs: () => uQ, hsX: () => S, hxR: () => eb, hy7: () => eg, hzE: () => hs, i7d: () => ss, i7u: () => iw, iNn: () => n7, iOZ: () => aq, iUH: () => eL, ibB: () => a1, ie2: () => U, imn: () => nE, ix0: () => eG, iyt: () => rC, j6: () => o0, jGm: () => ou, jR7: () => e6, jUj: () => sv, jej: () => iQ, jf0: () => tX, jsO: () => t9, jut: () => l4, jzd: () => ih, k6Q: () => e7, k6q: () => eC, k8v: () => tW, kBv: () => u, kEx: () => lP, kG0: () => t0, kLi: () => i8, kO0: () => io, kRr: () => eI, kTW: () => eE, kTp: () => te, kYr: () => t6, k_V: () => uZ, keZ: () => ul, klZ: () => it, kn4: () => rN, kqe: () => t$, kxk: () => sk, kyO: () => ea, l2R: () => lT, lGu: () => q, lGw: () => ld, lMl: () => nm, lPF: () => iX, lc7: () => tC, ljd: () => tI, lxW: () => se, lyL: () => tm, mcG: () => iq, mrM: () => ab, nCl: () => lj, nEu: () => ov, nNL: () => el, nST: () => I, nWS: () => ri, nZQ: () => uu, nc$: () => uz, nzx: () => oc, o6l: () => sd, oVO: () => t5, oh6: () => uW, ojh: () => D, ojs: () => ty, ov9: () => X, pBf: () => ti, pFK: () => og, pHI: () => eT, pPE: () => uk, paN: () => e1, ppV: () => i1, psI: () => tc, q2: () => o4, qBx: () => le, qFE: () => om, qU7: () => od, qUd: () => lZ, qa3: () => ta, qad: () => O, qq$: () => iY, qtW: () => nG, r6x: () => l5, rFo: () => rr, rKP: () => oK, rOG: () => i_, rQf: () => tD, rSH: () => tu, rYR: () => tz, rrX: () => uB, s0K: () => oi, sKt: () => ir, sPf: () => l, tBo: () => uY, tJf: () => ek, tXL: () => o9, tcD: () => of, tz3: () => lb, uB5: () => tp, uSd: () => o6, uV5: () => ex, uWO: () => s1, uXQ: () => iv, ubm: () => su, uov: () => ix, ure: () => l1, v9J: () => iM, veJ: () => lN, vim: () => ia, vmz: () => nN, vyJ: () => tY, wAk: () => oh, wTz: () => tV, wfO: () => ey, wn6: () => G, wrO: () => eY, wtR: () => h, wvS: () => nD, xFO: () => ev, xJ6: () => oz, xOk: () => l2, xSv: () => Z, xZx: () => u_, xfg: () => oo, xiE: () => iZ, y3Z: () => tv, y9J: () => rn, y_p: () => es, ypk: () => oE, ywQ: () => p, zD7: () => uh, zdS: () => eZ, zgK: () => rq, znC: () => L }); let l = "174", u = { LEFT: 0, MIDDLE: 1, RIGHT: 2, ROTATE: 0, DOLLY: 1, PAN: 2 }, h = { ROTATE: 0, PAN: 1, DOLLY_PAN: 2, DOLLY_ROTATE: 3 }, c = 0, d = 1, f = 2, p = 3, m = 0, g = 1, v = 2, y = 3, x = 0, S = 1, A = 2, _ = 0, E = 1, b = 2, T = 3, w = 4, M = 5, R = 100, C = 101, I = 102, L = 103, P = 104, D = 200, O = 201, k = 202, F = 203, U = 204, N = 205, B = 206, z = 207, G = 208, H = 209, V = 210, W = 211, j = 212, Y = 213, X = 214, K = 0, q = 1, Q = 2, Z = 3, $ = 4, J = 5, ee = 6, et = 7, ei = 0, er = 1, en = 2, es = 0, ea = 1, eo = 2, el = 3, eu = 4, eh = 5, ec = 6, ed = 7, ef = "attached", ep = "detached", em = 300, eg = 301, ev = 302, ey = 303, ex = 304, eS = 306, eA = 1e3, e_ = 1001, eE = 1002, eb = 1003, eT = 1004, ew = 1004, eM = 1005, eR = 1005, eC = 1006, eI = 1007, eL = 1007, eP = 1008, eD = 1008, eO = 1009, ek = 1010, eF = 1011, eU = 1012, eN = 1013, eB = 1014, ez = 1015, eG = 1016, eH = 1017, eV = 1018, eW = 1020, ej = 35902, eY = 1021, eX = 1022, eK = 1023, eq = 1024, eQ = 1025, eZ = 1026, e$ = 1027, eJ = 1028, e0 = 1029, e1 = 1030, e2 = 1031, e3 = 1032, e4 = 1033, e5 = 33776, e8 = 33777, e6 = 33778, e9 = 33779, e7 = 35840, te = 35841, tt = 35842, ti = 35843, tr = 36196, tn = 37492, ts = 37496, ta = 37808, to = 37809, tl = 37810, tu = 37811, th = 37812, tc = 37813, td = 37814, tf = 37815, tp = 37816, tm = 37817, tg = 37818, tv = 37819, ty = 37820, tx = 37821, tS = 36492, tA = 36494, t_ = 36495, tE = 36283, tb = 36284, tT = 36285, tw = 36286, tM = 2200, tR = 2201, tC = 2202, tI = 2300, tL = 2301, tP = 2302, tD = 2400, tO = 2401, tk = 2402, tF = 2500, tU = 2501, tN = 0, tB = 1, tz = 2, tG = 3200, tH = 3201, tV = 3202, tW = 3203, tj = 0, tY = 1, tX = "", tK = "srgb", tq = "srgb-linear", tQ = "linear", tZ = "srgb", t$ = 0, tJ = 7680, t0 = 7681, t1 = 7682, t2 = 7683, t3 = 34055, t4 = 34056, t5 = 5386, t8 = 512, t6 = 513, t9 = 514, t7 = 515, ie = 516, it = 517, ii = 518, ir = 519, is = 512, ia = 513, io = 514, il = 515, iu = 516, ih = 517, ic = 518, id = 519, ip = 35044, im = 35048, ig = 35040, iv = 35045, iy = 35049, ix = 35041, iS = 35046, iA = 35050, i_ = 35042, iE = "100", ib = "300 es", iT = 2e3, iw = 2001, iM = { COMPUTE: "compute", RENDER: "render" }; class iR { addEventListener(e, t) { void 0 === this._listeners && (this._listeners = {}); let i = this._listeners; void 0 === i[e] && (i[e] = []), -1 === i[e].indexOf(t) && i[e].push(t) } hasEventListener(e, t) { let i = this._listeners; return void 0 !== i && void 0 !== i[e] && -1 !== i[e].indexOf(t) } removeEventListener(e, t) { let i = this._listeners; if (void 0 === i) return; let r = i[e]; if (void 0 !== r) { let e = r.indexOf(t); -1 !== e && r.splice(e, 1) } } dispatchEvent(e) { let t = this._listeners; if (void 0 === t) return; let i = t[e.type]; if (void 0 !== i) { e.target = this; let t = i.slice(0); for (let i = 0, r = t.length; i < r; i++)t[i].call(this, e); e.target = null } } } let iC = ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "0a", "0b", "0c", "0d", "0e", "0f", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "1a", "1b", "1c", "1d", "1e", "1f", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "2a", "2b", "2c", "2d", "2e", "2f", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "3a", "3b", "3c", "3d", "3e", "3f", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "4a", "4b", "4c", "4d", "4e", "4f", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "5a", "5b", "5c", "5d", "5e", "5f", "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "6a", "6b", "6c", "6d", "6e", "6f", "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "7a", "7b", "7c", "7d", "7e", "7f", "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "8a", "8b", "8c", "8d", "8e", "8f", "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "9a", "9b", "9c", "9d", "9e", "9f", "a0", "a1", "a2", "a3", "a4", "a5", "a6", "a7", "a8", "a9", "aa", "ab", "ac", "ad", "ae", "af", "b0", "b1", "b2", "b3", "b4", "b5", "b6", "b7", "b8", "b9", "ba", "bb", "bc", "bd", "be", "bf", "c0", "c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9", "ca", "cb", "cc", "cd", "ce", "cf", "d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7", "d8", "d9", "da", "db", "dc", "dd", "de", "df", "e0", "e1", "e2", "e3", "e4", "e5", "e6", "e7", "e8", "e9", "ea", "eb", "ec", "ed", "ee", "ef", "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "fa", "fb", "fc", "fd", "fe", "ff"], iI = 1234567, iL = Math.PI / 180, iP = 180 / Math.PI; function iD() { let e = 0xffffffff * Math.random() | 0, t = 0xffffffff * Math.random() | 0, i = 0xffffffff * Math.random() | 0, r = 0xffffffff * Math.random() | 0; return (iC[255 & e] + iC[e >> 8 & 255] + iC[e >> 16 & 255] + iC[e >> 24 & 255] + "-" + iC[255 & t] + iC[t >> 8 & 255] + "-" + iC[t >> 16 & 15 | 64] + iC[t >> 24 & 255] + "-" + iC[63 & i | 128] + iC[i >> 8 & 255] + "-" + iC[i >> 16 & 255] + iC[i >> 24 & 255] + iC[255 & r] + iC[r >> 8 & 255] + iC[r >> 16 & 255] + iC[r >> 24 & 255]).toLowerCase() } function iO(e, t, i) { return Math.max(t, Math.min(i, e)) } function ik(e, t) { return (e % t + t) % t } function iF(e, t, i) { return (1 - i) * e + i * t } function iU(e, t) { switch (t.constructor) { case Float32Array: return e; case Uint32Array: return e / 0xffffffff; case Uint16Array: return e / 65535; case Uint8Array: return e / 255; case Int32Array: return Math.max(e / 0x7fffffff, -1); case Int16Array: return Math.max(e / 32767, -1); case Int8Array: return Math.max(e / 127, -1); default: throw Error("Invalid component type.") } } function iN(e, t) { switch (t.constructor) { case Float32Array: return e; case Uint32Array: return Math.round(0xffffffff * e); case Uint16Array: return Math.round(65535 * e); case Uint8Array: return Math.round(255 * e); case Int32Array: return Math.round(0x7fffffff * e); case Int16Array: return Math.round(32767 * e); case Int8Array: return Math.round(127 * e); default: throw Error("Invalid component type.") } } let iB = { DEG2RAD: iL, RAD2DEG: iP, generateUUID: iD, clamp: iO, euclideanModulo: ik, mapLinear: function (e, t, i, r, n) { return r + (e - t) * (n - r) / (i - t) }, inverseLerp: function (e, t, i) { return e !== t ? (i - e) / (t - e) : 0 }, lerp: iF, damp: function (e, t, i, r) { return iF(e, t, 1 - Math.exp(-i * r)) }, pingpong: function (e, t = 1) { return t - Math.abs(ik(e, 2 * t) - t) }, smoothstep: function (e, t, i) { return e <= t ? 0 : e >= i ? 1 : (e = (e - t) / (i - t)) * e * (3 - 2 * e) }, smootherstep: function (e, t, i) { return e <= t ? 0 : e >= i ? 1 : (e = (e - t) / (i - t)) * e * e * (e * (6 * e - 15) + 10) }, randInt: function (e, t) { return e + Math.floor(Math.random() * (t - e + 1)) }, randFloat: function (e, t) { return e + Math.random() * (t - e) }, randFloatSpread: function (e) { return e * (.5 - Math.random()) }, seededRandom: function (e) { void 0 !== e && (iI = e); let t = iI += 0x6d2b79f5; return t = Math.imul(t ^ t >>> 15, 1 | t), (((t ^= t + Math.imul(t ^ t >>> 7, 61 | t)) ^ t >>> 14) >>> 0) / 0x100000000 }, degToRad: function (e) { return e * iL }, radToDeg: function (e) { return e * iP }, isPowerOfTwo: function (e) { return (e & e - 1) == 0 && 0 !== e }, ceilPowerOfTwo: function (e) { return Math.pow(2, Math.ceil(Math.log(e) / Math.LN2)) }, floorPowerOfTwo: function (e) { return Math.pow(2, Math.floor(Math.log(e) / Math.LN2)) }, setQuaternionFromProperEuler: function (e, t, i, r, n) { let s = Math.cos, a = Math.sin, o = s(i / 2), l = a(i / 2), u = s((t + r) / 2), h = a((t + r) / 2), c = s((t - r) / 2), d = a((t - r) / 2), f = s((r - t) / 2), p = a((r - t) / 2); switch (n) { case "XYX": e.set(o * h, l * c, l * d, o * u); break; case "YZY": e.set(l * d, o * h, l * c, o * u); break; case "ZXZ": e.set(l * c, l * d, o * h, o * u); break; case "XZX": e.set(o * h, l * p, l * f, o * u); break; case "YXY": e.set(l * f, o * h, l * p, o * u); break; case "ZYZ": e.set(l * p, l * f, o * h, o * u); break; default: console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + n) } }, normalize: iN, denormalize: iU }; class iz { constructor(e = 0, t = 0) { iz.prototype.isVector2 = !0, this.x = e, this.y = t } get width() { return this.x } set width(e) { this.x = e } get height() { return this.y } set height(e) { this.y = e } set(e, t) { return this.x = e, this.y = t, this } setScalar(e) { return this.x = e, this.y = e, this } setX(e) { return this.x = e, this } setY(e) { return this.y = e, this } setComponent(e, t) { switch (e) { case 0: this.x = t; break; case 1: this.y = t; break; default: throw Error("index is out of range: " + e) }return this } getComponent(e) { switch (e) { case 0: return this.x; case 1: return this.y; default: throw Error("index is out of range: " + e) } } clone() { return new this.constructor(this.x, this.y) } copy(e) { return this.x = e.x, this.y = e.y, this } add(e) { return this.x += e.x, this.y += e.y, this } addScalar(e) { return this.x += e, this.y += e, this } addVectors(e, t) { return this.x = e.x + t.x, this.y = e.y + t.y, this } addScaledVector(e, t) { return this.x += e.x * t, this.y += e.y * t, this } sub(e) { return this.x -= e.x, this.y -= e.y, this } subScalar(e) { return this.x -= e, this.y -= e, this } subVectors(e, t) { return this.x = e.x - t.x, this.y = e.y - t.y, this } multiply(e) { return this.x *= e.x, this.y *= e.y, this } multiplyScalar(e) { return this.x *= e, this.y *= e, this } divide(e) { return this.x /= e.x, this.y /= e.y, this } divideScalar(e) { return this.multiplyScalar(1 / e) } applyMatrix3(e) { let t = this.x, i = this.y, r = e.elements; return this.x = r[0] * t + r[3] * i + r[6], this.y = r[1] * t + r[4] * i + r[7], this } min(e) { return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this } max(e) { return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this } clamp(e, t) { return this.x = iO(this.x, e.x, t.x), this.y = iO(this.y, e.y, t.y), this } clampScalar(e, t) { return this.x = iO(this.x, e, t), this.y = iO(this.y, e, t), this } clampLength(e, t) { let i = this.length(); return this.divideScalar(i || 1).multiplyScalar(iO(i, e, t)) } floor() { return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this } ceil() { return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this } round() { return this.x = Math.round(this.x), this.y = Math.round(this.y), this } roundToZero() { return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this } negate() { return this.x = -this.x, this.y = -this.y, this } dot(e) { return this.x * e.x + this.y * e.y } cross(e) { return this.x * e.y - this.y * e.x } lengthSq() { return this.x * this.x + this.y * this.y } length() { return Math.sqrt(this.x * this.x + this.y * this.y) } manhattanLength() { return Math.abs(this.x) + Math.abs(this.y) } normalize() { return this.divideScalar(this.length() || 1) } angle() { return Math.atan2(-this.y, -this.x) + Math.PI } angleTo(e) { let t = Math.sqrt(this.lengthSq() * e.lengthSq()); return 0 === t ? Math.PI / 2 : Math.acos(iO(this.dot(e) / t, -1, 1)) } distanceTo(e) { return Math.sqrt(this.distanceToSquared(e)) } distanceToSquared(e) { let t = this.x - e.x, i = this.y - e.y; return t * t + i * i } manhattanDistanceTo(e) { return Math.abs(this.x - e.x) + Math.abs(this.y - e.y) } setLength(e) { return this.normalize().multiplyScalar(e) } lerp(e, t) { return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this } lerpVectors(e, t, i) { return this.x = e.x + (t.x - e.x) * i, this.y = e.y + (t.y - e.y) * i, this } equals(e) { return e.x === this.x && e.y === this.y } fromArray(e, t = 0) { return this.x = e[t], this.y = e[t + 1], this } toArray(e = [], t = 0) { return e[t] = this.x, e[t + 1] = this.y, e } fromBufferAttribute(e, t) { return this.x = e.getX(t), this.y = e.getY(t), this } rotateAround(e, t) { let i = Math.cos(t), r = Math.sin(t), n = this.x - e.x, s = this.y - e.y; return this.x = n * i - s * r + e.x, this.y = n * r + s * i + e.y, this } random() { return this.x = Math.random(), this.y = Math.random(), this } *[Symbol.iterator]() { yield this.x, yield this.y } } class iG { constructor(e, t, i, r, n, s, a, o, l) { iG.prototype.isMatrix3 = !0, this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1], void 0 !== e && this.set(e, t, i, r, n, s, a, o, l) } set(e, t, i, r, n, s, a, o, l) { let u = this.elements; return u[0] = e, u[1] = r, u[2] = a, u[3] = t, u[4] = n, u[5] = o, u[6] = i, u[7] = s, u[8] = l, this } identity() { return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this } copy(e) { let t = this.elements, i = e.elements; return t[0] = i[0], t[1] = i[1], t[2] = i[2], t[3] = i[3], t[4] = i[4], t[5] = i[5], t[6] = i[6], t[7] = i[7], t[8] = i[8], this } extractBasis(e, t, i) { return e.setFromMatrix3Column(this, 0), t.setFromMatrix3Column(this, 1), i.setFromMatrix3Column(this, 2), this } setFromMatrix4(e) { let t = e.elements; return this.set(t[0], t[4], t[8], t[1], t[5], t[9], t[2], t[6], t[10]), this } multiply(e) { return this.multiplyMatrices(this, e) } premultiply(e) { return this.multiplyMatrices(e, this) } multiplyMatrices(e, t) { let i = e.elements, r = t.elements, n = this.elements, s = i[0], a = i[3], o = i[6], l = i[1], u = i[4], h = i[7], c = i[2], d = i[5], f = i[8], p = r[0], m = r[3], g = r[6], v = r[1], y = r[4], x = r[7], S = r[2], A = r[5], _ = r[8]; return n[0] = s * p + a * v + o * S, n[3] = s * m + a * y + o * A, n[6] = s * g + a * x + o * _, n[1] = l * p + u * v + h * S, n[4] = l * m + u * y + h * A, n[7] = l * g + u * x + h * _, n[2] = c * p + d * v + f * S, n[5] = c * m + d * y + f * A, n[8] = c * g + d * x + f * _, this } multiplyScalar(e) { let t = this.elements; return t[0] *= e, t[3] *= e, t[6] *= e, t[1] *= e, t[4] *= e, t[7] *= e, t[2] *= e, t[5] *= e, t[8] *= e, this } determinant() { let e = this.elements, t = e[0], i = e[1], r = e[2], n = e[3], s = e[4], a = e[5], o = e[6], l = e[7], u = e[8]; return t * s * u - t * a * l - i * n * u + i * a * o + r * n * l - r * s * o } invert() { let e = this.elements, t = e[0], i = e[1], r = e[2], n = e[3], s = e[4], a = e[5], o = e[6], l = e[7], u = e[8], h = u * s - a * l, c = a * o - u * n, d = l * n - s * o, f = t * h + i * c + r * d; if (0 === f) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0); let p = 1 / f; return e[0] = h * p, e[1] = (r * l - u * i) * p, e[2] = (a * i - r * s) * p, e[3] = c * p, e[4] = (u * t - r * o) * p, e[5] = (r * n - a * t) * p, e[6] = d * p, e[7] = (i * o - l * t) * p, e[8] = (s * t - i * n) * p, this } transpose() { let e; let t = this.elements; return e = t[1], t[1] = t[3], t[3] = e, e = t[2], t[2] = t[6], t[6] = e, e = t[5], t[5] = t[7], t[7] = e, this } getNormalMatrix(e) { return this.setFromMatrix4(e).invert().transpose() } transposeIntoArray(e) { let t = this.elements; return e[0] = t[0], e[1] = t[3], e[2] = t[6], e[3] = t[1], e[4] = t[4], e[5] = t[7], e[6] = t[2], e[7] = t[5], e[8] = t[8], this } setUvTransform(e, t, i, r, n, s, a) { let o = Math.cos(n), l = Math.sin(n); return this.set(i * o, i * l, -i * (o * s + l * a) + s + e, -r * l, r * o, -r * (-l * s + o * a) + a + t, 0, 0, 1), this } scale(e, t) { return this.premultiply(iH.makeScale(e, t)), this } rotate(e) { return this.premultiply(iH.makeRotation(-e)), this } translate(e, t) { return this.premultiply(iH.makeTranslation(e, t)), this } makeTranslation(e, t) { return e.isVector2 ? this.set(1, 0, e.x, 0, 1, e.y, 0, 0, 1) : this.set(1, 0, e, 0, 1, t, 0, 0, 1), this } makeRotation(e) { let t = Math.cos(e), i = Math.sin(e); return this.set(t, -i, 0, i, t, 0, 0, 0, 1), this } makeScale(e, t) { return this.set(e, 0, 0, 0, t, 0, 0, 0, 1), this } equals(e) { let t = this.elements, i = e.elements; for (let e = 0; e < 9; e++)if (t[e] !== i[e]) return !1; return !0 } fromArray(e, t = 0) { for (let i = 0; i < 9; i++)this.elements[i] = e[i + t]; return this } toArray(e = [], t = 0) { let i = this.elements; return e[t] = i[0], e[t + 1] = i[1], e[t + 2] = i[2], e[t + 3] = i[3], e[t + 4] = i[4], e[t + 5] = i[5], e[t + 6] = i[6], e[t + 7] = i[7], e[t + 8] = i[8], e } clone() { return new this.constructor().fromArray(this.elements) } } let iH = new iG; function iV(e) { for (let t = e.length - 1; t >= 0; --t)if (e[t] >= 65535) return !0; return !1 } let iW = { Int8Array: Int8Array, Uint8Array: Uint8Array, Uint8ClampedArray: Uint8ClampedArray, Int16Array: Int16Array, Uint16Array: Uint16Array, Int32Array: Int32Array, Uint32Array: Uint32Array, Float32Array: Float32Array, Float64Array: Float64Array }; function ij(e, t) { return new iW[e](t) } function iY(e) { return document.createElementNS("http://www.w3.org/1999/xhtml", e) } function iX() { let e = iY("canvas"); return e.style.display = "block", e } let iK = {}; function iq(e) { e in iK || (iK[e] = !0, console.warn(e)) } function iQ(e, t, i) { return new Promise(function (r, n) { setTimeout(function s() { switch (e.clientWaitSync(t, e.SYNC_FLUSH_COMMANDS_BIT, 0)) { case e.WAIT_FAILED: n(); break; case e.TIMEOUT_EXPIRED: setTimeout(s, i); break; default: r() } }, i) }) } function iZ(e) { let t = e.elements; t[2] = .5 * t[2] + .5 * t[3], t[6] = .5 * t[6] + .5 * t[7], t[10] = .5 * t[10] + .5 * t[11], t[14] = .5 * t[14] + .5 * t[15] } function i$(e) { let t = e.elements; -1 === t[11] ? (t[10] = -t[10] - 1, t[14] = -t[14]) : (t[10] = -t[10], t[14] = -t[14] + 1) } let iJ = new iG().set(.4123908, .3575843, .1804808, .212639, .7151687, .0721923, .0193308, .1191948, .9505322), i0 = new iG().set(3.2409699, -1.5373832, -.4986108, -.9692436, 1.8759675, .0415551, .0556301, -.203977, 1.0569715), i1 = function () { let e = { enabled: !0, workingColorSpace: tq, spaces: {}, convert: function (e, t, i) { return !1 !== this.enabled && t !== i && t && i && (this.spaces[t].transfer === tZ && (e.r = i2(e.r), e.g = i2(e.g), e.b = i2(e.b)), this.spaces[t].primaries !== this.spaces[i].primaries && (e.applyMatrix3(this.spaces[t].toXYZ), e.applyMatrix3(this.spaces[i].fromXYZ)), this.spaces[i].transfer === tZ && (e.r = i3(e.r), e.g = i3(e.g), e.b = i3(e.b))), e }, fromWorkingColorSpace: function (e, t) { return this.convert(e, this.workingColorSpace, t) }, toWorkingColorSpace: function (e, t) { return this.convert(e, t, this.workingColorSpace) }, getPrimaries: function (e) { return this.spaces[e].primaries }, getTransfer: function (e) { return e === tX ? tQ : this.spaces[e].transfer }, getLuminanceCoefficients: function (e, t = this.workingColorSpace) { return e.fromArray(this.spaces[t].luminanceCoefficients) }, define: function (e) { Object.assign(this.spaces, e) }, _getMatrix: function (e, t, i) { return e.copy(this.spaces[t].toXYZ).multiply(this.spaces[i].fromXYZ) }, _getDrawingBufferColorSpace: function (e) { return this.spaces[e].outputColorSpaceConfig.drawingBufferColorSpace }, _getUnpackColorSpace: function (e = this.workingColorSpace) { return this.spaces[e].workingColorSpaceConfig.unpackColorSpace } }, t = [.64, .33, .3, .6, .15, .06], i = [.2126, .7152, .0722], r = [.3127, .329]; return e.define({ [tq]: { primaries: t, whitePoint: r, transfer: tQ, toXYZ: iJ, fromXYZ: i0, luminanceCoefficients: i, workingColorSpaceConfig: { unpackColorSpace: tK }, outputColorSpaceConfig: { drawingBufferColorSpace: tK } }, [tK]: { primaries: t, whitePoint: r, transfer: tZ, toXYZ: iJ, fromXYZ: i0, luminanceCoefficients: i, outputColorSpaceConfig: { drawingBufferColorSpace: tK } } }), e }(); function i2(e) { return e < .04045 ? .0773993808 * e : Math.pow(.9478672986 * e + .0521327014, 2.4) } function i3(e) { return e < .0031308 ? 12.92 * e : 1.055 * Math.pow(e, .41666) - .055 } class i4 { static getDataURL(e) { let t; if (/^data:/i.test(e.src) || "undefined" == typeof HTMLCanvasElement) return e.src; if (e instanceof HTMLCanvasElement) t = e; else { void 0 === r && (r = iY("canvas")), r.width = e.width, r.height = e.height; let i = r.getContext("2d"); e instanceof ImageData ? i.putImageData(e, 0, 0) : i.drawImage(e, 0, 0, e.width, e.height), t = r } return t.toDataURL("image/png") } static sRGBToLinear(e) { if ("undefined" != typeof HTMLImageElement && e instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && e instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && e instanceof ImageBitmap) { let t = iY("canvas"); t.width = e.width, t.height = e.height; let i = t.getContext("2d"); i.drawImage(e, 0, 0, e.width, e.height); let r = i.getImageData(0, 0, e.width, e.height), n = r.data; for (let e = 0; e < n.length; e++)n[e] = 255 * i2(n[e] / 255); return i.putImageData(r, 0, 0), t } if (!e.data) return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."), e; { let t = e.data.slice(0); for (let e = 0; e < t.length; e++)t instanceof Uint8Array || t instanceof Uint8ClampedArray ? t[e] = Math.floor(255 * i2(t[e] / 255)) : t[e] = i2(t[e]); return { data: t, width: e.width, height: e.height } } } } let i5 = 0; class i8 { constructor(e = null) { this.isSource = !0, Object.defineProperty(this, "id", { value: i5++ }), this.uuid = iD(), this.data = e, this.dataReady = !0, this.version = 0 } set needsUpdate(e) { !0 === e && this.version++ } toJSON(e) { let t = void 0 === e || "string" == typeof e; if (!t && void 0 !== e.images[this.uuid]) return e.images[this.uuid]; let i = { uuid: this.uuid, url: "" }, r = this.data; if (null !== r) { let e; if (Array.isArray(r)) { e = []; for (let t = 0, i = r.length; t < i; t++)r[t].isDataTexture ? e.push(i6(r[t].image)) : e.push(i6(r[t])) } else e = i6(r); i.url = e } return t || (e.images[this.uuid] = i), i } } function i6(e) { return "undefined" != typeof HTMLImageElement && e instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && e instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && e instanceof ImageBitmap ? i4.getDataURL(e) : e.data ? { data: Array.from(e.data), width: e.width, height: e.height, type: e.data.constructor.name } : (console.warn("THREE.Texture: Unable to serialize Texture."), {}) } let i9 = 0; class i7 extends iR { constructor(e = i7.DEFAULT_IMAGE, t = i7.DEFAULT_MAPPING, i = e_, r = e_, n = eC, s = eP, a = eK, o = eO, l = i7.DEFAULT_ANISOTROPY, u = tX) { super(), this.isTexture = !0, Object.defineProperty(this, "id", { value: i9++ }), this.uuid = iD(), this.name = "", this.source = new i8(e), this.mipmaps = [], this.mapping = t, this.channel = 0, this.wrapS = i, this.wrapT = r, this.magFilter = n, this.minFilter = s, this.anisotropy = l, this.format = a, this.internalFormat = null, this.type = o, this.offset = new iz(0, 0), this.repeat = new iz(1, 1), this.center = new iz(0, 0), this.rotation = 0, this.matrixAutoUpdate = !0, this.matrix = new iG, this.generateMipmaps = !0, this.premultiplyAlpha = !1, this.flipY = !0, this.unpackAlignment = 4, this.colorSpace = u, this.userData = {}, this.version = 0, this.onUpdate = null, this.renderTarget = null, this.isRenderTargetTexture = !1, this.pmremVersion = 0 } get image() { return this.source.data } set image(e = null) { this.source.data = e } updateMatrix() { this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y) } clone() { return new this.constructor().copy(this) } copy(e) { return this.name = e.name, this.source = e.source, this.mipmaps = e.mipmaps.slice(0), this.mapping = e.mapping, this.channel = e.channel, this.wrapS = e.wrapS, this.wrapT = e.wrapT, this.magFilter = e.magFilter, this.minFilter = e.minFilter, this.anisotropy = e.anisotropy, this.format = e.format, this.internalFormat = e.internalFormat, this.type = e.type, this.offset.copy(e.offset), this.repeat.copy(e.repeat), this.center.copy(e.center), this.rotation = e.rotation, this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrix.copy(e.matrix), this.generateMipmaps = e.generateMipmaps, this.premultiplyAlpha = e.premultiplyAlpha, this.flipY = e.flipY, this.unpackAlignment = e.unpackAlignment, this.colorSpace = e.colorSpace, this.renderTarget = e.renderTarget, this.isRenderTargetTexture = e.isRenderTargetTexture, this.userData = JSON.parse(JSON.stringify(e.userData)), this.needsUpdate = !0, this } toJSON(e) { let t = void 0 === e || "string" == typeof e; if (!t && void 0 !== e.textures[this.uuid]) return e.textures[this.uuid]; let i = { metadata: { version: 4.6, type: "Texture", generator: "Texture.toJSON" }, uuid: this.uuid, name: this.name, image: this.source.toJSON(e).uuid, mapping: this.mapping, channel: this.channel, repeat: [this.repeat.x, this.repeat.y], offset: [this.offset.x, this.offset.y], center: [this.center.x, this.center.y], rotation: this.rotation, wrap: [this.wrapS, this.wrapT], format: this.format, internalFormat: this.internalFormat, type: this.type, colorSpace: this.colorSpace, minFilter: this.minFilter, magFilter: this.magFilter, anisotropy: this.anisotropy, flipY: this.flipY, generateMipmaps: this.generateMipmaps, premultiplyAlpha: this.premultiplyAlpha, unpackAlignment: this.unpackAlignment }; return Object.keys(this.userData).length > 0 && (i.userData = this.userData), t || (e.textures[this.uuid] = i), i } dispose() { this.dispatchEvent({ type: "dispose" }) } transformUv(e) { if (this.mapping !== em) return e; if (e.applyMatrix3(this.matrix), e.x < 0 || e.x > 1) switch (this.wrapS) { case eA: e.x = e.x - Math.floor(e.x); break; case e_: e.x = e.x < 0 ? 0 : 1; break; case eE: 1 === Math.abs(Math.floor(e.x) % 2) ? e.x = Math.ceil(e.x) - e.x : e.x = e.x - Math.floor(e.x) }if (e.y < 0 || e.y > 1) switch (this.wrapT) { case eA: e.y = e.y - Math.floor(e.y); break; case e_: e.y = e.y < 0 ? 0 : 1; break; case eE: 1 === Math.abs(Math.floor(e.y) % 2) ? e.y = Math.ceil(e.y) - e.y : e.y = e.y - Math.floor(e.y) }return this.flipY && (e.y = 1 - e.y), e } set needsUpdate(e) { !0 === e && (this.version++, this.source.needsUpdate = !0) } set needsPMREMUpdate(e) { !0 === e && this.pmremVersion++ } } i7.DEFAULT_IMAGE = null, i7.DEFAULT_MAPPING = em, i7.DEFAULT_ANISOTROPY = 1; class re { constructor(e = 0, t = 0, i = 0, r = 1) { re.prototype.isVector4 = !0, this.x = e, this.y = t, this.z = i, this.w = r } get width() { return this.z } set width(e) { this.z = e } get height() { return this.w } set height(e) { this.w = e } set(e, t, i, r) { return this.x = e, this.y = t, this.z = i, this.w = r, this } setScalar(e) { return this.x = e, this.y = e, this.z = e, this.w = e, this } setX(e) { return this.x = e, this } setY(e) { return this.y = e, this } setZ(e) { return this.z = e, this } setW(e) { return this.w = e, this } setComponent(e, t) { switch (e) { case 0: this.x = t; break; case 1: this.y = t; break; case 2: this.z = t; break; case 3: this.w = t; break; default: throw Error("index is out of range: " + e) }return this } getComponent(e) { switch (e) { case 0: return this.x; case 1: return this.y; case 2: return this.z; case 3: return this.w; default: throw Error("index is out of range: " + e) } } clone() { return new this.constructor(this.x, this.y, this.z, this.w) } copy(e) { return this.x = e.x, this.y = e.y, this.z = e.z, this.w = void 0 !== e.w ? e.w : 1, this } add(e) { return this.x += e.x, this.y += e.y, this.z += e.z, this.w += e.w, this } addScalar(e) { return this.x += e, this.y += e, this.z += e, this.w += e, this } addVectors(e, t) { return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this.w = e.w + t.w, this } addScaledVector(e, t) { return this.x += e.x * t, this.y += e.y * t, this.z += e.z * t, this.w += e.w * t, this } sub(e) { return this.x -= e.x, this.y -= e.y, this.z -= e.z, this.w -= e.w, this } subScalar(e) { return this.x -= e, this.y -= e, this.z -= e, this.w -= e, this } subVectors(e, t) { return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this.w = e.w - t.w, this } multiply(e) { return this.x *= e.x, this.y *= e.y, this.z *= e.z, this.w *= e.w, this } multiplyScalar(e) { return this.x *= e, this.y *= e, this.z *= e, this.w *= e, this } applyMatrix4(e) { let t = this.x, i = this.y, r = this.z, n = this.w, s = e.elements; return this.x = s[0] * t + s[4] * i + s[8] * r + s[12] * n, this.y = s[1] * t + s[5] * i + s[9] * r + s[13] * n, this.z = s[2] * t + s[6] * i + s[10] * r + s[14] * n, this.w = s[3] * t + s[7] * i + s[11] * r + s[15] * n, this } divide(e) { return this.x /= e.x, this.y /= e.y, this.z /= e.z, this.w /= e.w, this } divideScalar(e) { return this.multiplyScalar(1 / e) } setAxisAngleFromQuaternion(e) { this.w = 2 * Math.acos(e.w); let t = Math.sqrt(1 - e.w * e.w); return t < 1e-4 ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = e.x / t, this.y = e.y / t, this.z = e.z / t), this } setAxisAngleFromRotationMatrix(e) { let t, i, r, n; let s = e.elements, a = s[0], o = s[4], l = s[8], u = s[1], h = s[5], c = s[9], d = s[2], f = s[6], p = s[10]; if (.01 > Math.abs(o - u) && .01 > Math.abs(l - d) && .01 > Math.abs(c - f)) { if (.1 > Math.abs(o + u) && .1 > Math.abs(l + d) && .1 > Math.abs(c + f) && .1 > Math.abs(a + h + p - 3)) return this.set(1, 0, 0, 0), this; t = Math.PI; let e = (a + 1) / 2, s = (h + 1) / 2, m = (p + 1) / 2, g = (o + u) / 4, v = (l + d) / 4, y = (c + f) / 4; return e > s && e > m ? e < .01 ? (i = 0, r = .707106781, n = .707106781) : (r = g / (i = Math.sqrt(e)), n = v / i) : s > m ? s < .01 ? (i = .707106781, r = 0, n = .707106781) : (i = g / (r = Math.sqrt(s)), n = y / r) : m < .01 ? (i = .707106781, r = .707106781, n = 0) : (i = v / (n = Math.sqrt(m)), r = y / n), this.set(i, r, n, t), this } let m = Math.sqrt((f - c) * (f - c) + (l - d) * (l - d) + (u - o) * (u - o)); return .001 > Math.abs(m) && (m = 1), this.x = (f - c) / m, this.y = (l - d) / m, this.z = (u - o) / m, this.w = Math.acos((a + h + p - 1) / 2), this } setFromMatrixPosition(e) { let t = e.elements; return this.x = t[12], this.y = t[13], this.z = t[14], this.w = t[15], this } min(e) { return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this.w = Math.min(this.w, e.w), this } max(e) { return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this.w = Math.max(this.w, e.w), this } clamp(e, t) { return this.x = iO(this.x, e.x, t.x), this.y = iO(this.y, e.y, t.y), this.z = iO(this.z, e.z, t.z), this.w = iO(this.w, e.w, t.w), this } clampScalar(e, t) { return this.x = iO(this.x, e, t), this.y = iO(this.y, e, t), this.z = iO(this.z, e, t), this.w = iO(this.w, e, t), this } clampLength(e, t) { let i = this.length(); return this.divideScalar(i || 1).multiplyScalar(iO(i, e, t)) } floor() { return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this } ceil() { return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this } round() { return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this } roundToZero() { return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this.z = Math.trunc(this.z), this.w = Math.trunc(this.w), this } negate() { return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this } dot(e) { return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w } lengthSq() { return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w } length() { return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w) } manhattanLength() { return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w) } normalize() { return this.divideScalar(this.length() || 1) } setLength(e) { return this.normalize().multiplyScalar(e) } lerp(e, t) { return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this.z += (e.z - this.z) * t, this.w += (e.w - this.w) * t, this } lerpVectors(e, t, i) { return this.x = e.x + (t.x - e.x) * i, this.y = e.y + (t.y - e.y) * i, this.z = e.z + (t.z - e.z) * i, this.w = e.w + (t.w - e.w) * i, this } equals(e) { return e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w } fromArray(e, t = 0) { return this.x = e[t], this.y = e[t + 1], this.z = e[t + 2], this.w = e[t + 3], this } toArray(e = [], t = 0) { return e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.z, e[t + 3] = this.w, e } fromBufferAttribute(e, t) { return this.x = e.getX(t), this.y = e.getY(t), this.z = e.getZ(t), this.w = e.getW(t), this } random() { return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this.w = Math.random(), this } *[Symbol.iterator]() { yield this.x, yield this.y, yield this.z, yield this.w } } class rt extends iR { constructor(e = 1, t = 1, i = {}) { super(), this.isRenderTarget = !0, this.width = e, this.height = t, this.depth = 1, this.scissor = new re(0, 0, e, t), this.scissorTest = !1, this.viewport = new re(0, 0, e, t); let r = new i7({ width: e, height: t, depth: 1 }, (i = Object.assign({ generateMipmaps: !1, internalFormat: null, minFilter: eC, depthBuffer: !0, stencilBuffer: !1, resolveDepthBuffer: !0, resolveStencilBuffer: !0, depthTexture: null, samples: 0, count: 1 }, i)).mapping, i.wrapS, i.wrapT, i.magFilter, i.minFilter, i.format, i.type, i.anisotropy, i.colorSpace); r.flipY = !1, r.generateMipmaps = i.generateMipmaps, r.internalFormat = i.internalFormat, this.textures = []; let n = i.count; for (let e = 0; e < n; e++)this.textures[e] = r.clone(), this.textures[e].isRenderTargetTexture = !0, this.textures[e].renderTarget = this; this.depthBuffer = i.depthBuffer, this.stencilBuffer = i.stencilBuffer, this.resolveDepthBuffer = i.resolveDepthBuffer, this.resolveStencilBuffer = i.resolveStencilBuffer, this._depthTexture = null, this.depthTexture = i.depthTexture, this.samples = i.samples } get texture() { return this.textures[0] } set texture(e) { this.textures[0] = e } set depthTexture(e) { null !== this._depthTexture && (this._depthTexture.renderTarget = null), null !== e && (e.renderTarget = this), this._depthTexture = e } get depthTexture() { return this._depthTexture } setSize(e, t, i = 1) { if (this.width !== e || this.height !== t || this.depth !== i) { this.width = e, this.height = t, this.depth = i; for (let r = 0, n = this.textures.length; r < n; r++)this.textures[r].image.width = e, this.textures[r].image.height = t, this.textures[r].image.depth = i; this.dispose() } this.viewport.set(0, 0, e, t), this.scissor.set(0, 0, e, t) } clone() { return new this.constructor().copy(this) } copy(e) { this.width = e.width, this.height = e.height, this.depth = e.depth, this.scissor.copy(e.scissor), this.scissorTest = e.scissorTest, this.viewport.copy(e.viewport), this.textures.length = 0; for (let t = 0, i = e.textures.length; t < i; t++) { this.textures[t] = e.textures[t].clone(), this.textures[t].isRenderTargetTexture = !0, this.textures[t].renderTarget = this; let i = Object.assign({}, e.textures[t].image); this.textures[t].source = new i8(i) } return this.depthBuffer = e.depthBuffer, this.stencilBuffer = e.stencilBuffer, this.resolveDepthBuffer = e.resolveDepthBuffer, this.resolveStencilBuffer = e.resolveStencilBuffer, null !== e.depthTexture && (this.depthTexture = e.depthTexture.clone()), this.samples = e.samples, this } dispose() { this.dispatchEvent({ type: "dispose" }) } } class ri extends rt { constructor(e = 1, t = 1, i = {}) { super(e, t, i), this.isWebGLRenderTarget = !0 } } class rr extends i7 { constructor(e = null, t = 1, i = 1, r = 1) { super(null), this.isDataArrayTexture = !0, this.image = { data: e, width: t, height: i, depth: r }, this.magFilter = eb, this.minFilter = eb, this.wrapR = e_, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1, this.layerUpdates = new Set } addLayerUpdate(e) { this.layerUpdates.add(e) } clearLayerUpdates() { this.layerUpdates.clear() } } class rn extends ri { constructor(e = 1, t = 1, i = 1, r = {}) { super(e, t, r), this.isWebGLArrayRenderTarget = !0, this.depth = i, this.texture = new rr(null, e, t, i), this.texture.isRenderTargetTexture = !0 } } class rs extends i7 { constructor(e = null, t = 1, i = 1, r = 1) { super(null), this.isData3DTexture = !0, this.image = { data: e, width: t, height: i, depth: r }, this.magFilter = eb, this.minFilter = eb, this.wrapR = e_, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1 } } class ra extends ri { constructor(e = 1, t = 1, i = 1, r = {}) { super(e, t, r), this.isWebGL3DRenderTarget = !0, this.depth = i, this.texture = new rs(null, e, t, i), this.texture.isRenderTargetTexture = !0 } } class ro { constructor(e = 0, t = 0, i = 0, r = 1) { this.isQuaternion = !0, this._x = e, this._y = t, this._z = i, this._w = r } static slerpFlat(e, t, i, r, n, s, a) { let o = i[r + 0], l = i[r + 1], u = i[r + 2], h = i[r + 3], c = n[s + 0], d = n[s + 1], f = n[s + 2], p = n[s + 3]; if (0 === a) { e[t + 0] = o, e[t + 1] = l, e[t + 2] = u, e[t + 3] = h; return } if (1 === a) { e[t + 0] = c, e[t + 1] = d, e[t + 2] = f, e[t + 3] = p; return } if (h !== p || o !== c || l !== d || u !== f) { let e = 1 - a, t = o * c + l * d + u * f + h * p, i = t >= 0 ? 1 : -1, r = 1 - t * t; if (r > Number.EPSILON) { let n = Math.sqrt(r), s = Math.atan2(n, t * i); e = Math.sin(e * s) / n, a = Math.sin(a * s) / n } let n = a * i; if (o = o * e + c * n, l = l * e + d * n, u = u * e + f * n, h = h * e + p * n, e === 1 - a) { let e = 1 / Math.sqrt(o * o + l * l + u * u + h * h); o *= e, l *= e, u *= e, h *= e } } e[t] = o, e[t + 1] = l, e[t + 2] = u, e[t + 3] = h } static multiplyQuaternionsFlat(e, t, i, r, n, s) { let a = i[r], o = i[r + 1], l = i[r + 2], u = i[r + 3], h = n[s], c = n[s + 1], d = n[s + 2], f = n[s + 3]; return e[t] = a * f + u * h + o * d - l * c, e[t + 1] = o * f + u * c + l * h - a * d, e[t + 2] = l * f + u * d + a * c - o * h, e[t + 3] = u * f - a * h - o * c - l * d, e } get x() { return this._x } set x(e) { this._x = e, this._onChangeCallback() } get y() { return this._y } set y(e) { this._y = e, this._onChangeCallback() } get z() { return this._z } set z(e) { this._z = e, this._onChangeCallback() } get w() { return this._w } set w(e) { this._w = e, this._onChangeCallback() } set(e, t, i, r) { return this._x = e, this._y = t, this._z = i, this._w = r, this._onChangeCallback(), this } clone() { return new this.constructor(this._x, this._y, this._z, this._w) } copy(e) { return this._x = e.x, this._y = e.y, this._z = e.z, this._w = e.w, this._onChangeCallback(), this } setFromEuler(e, t = !0) { let i = e._x, r = e._y, n = e._z, s = e._order, a = Math.cos, o = Math.sin, l = a(i / 2), u = a(r / 2), h = a(n / 2), c = o(i / 2), d = o(r / 2), f = o(n / 2); switch (s) { case "XYZ": this._x = c * u * h + l * d * f, this._y = l * d * h - c * u * f, this._z = l * u * f + c * d * h, this._w = l * u * h - c * d * f; break; case "YXZ": this._x = c * u * h + l * d * f, this._y = l * d * h - c * u * f, this._z = l * u * f - c * d * h, this._w = l * u * h + c * d * f; break; case "ZXY": this._x = c * u * h - l * d * f, this._y = l * d * h + c * u * f, this._z = l * u * f + c * d * h, this._w = l * u * h - c * d * f; break; case "ZYX": this._x = c * u * h - l * d * f, this._y = l * d * h + c * u * f, this._z = l * u * f - c * d * h, this._w = l * u * h + c * d * f; break; case "YZX": this._x = c * u * h + l * d * f, this._y = l * d * h + c * u * f, this._z = l * u * f - c * d * h, this._w = l * u * h - c * d * f; break; case "XZY": this._x = c * u * h - l * d * f, this._y = l * d * h - c * u * f, this._z = l * u * f + c * d * h, this._w = l * u * h + c * d * f; break; default: console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + s) }return !0 === t && this._onChangeCallback(), this } setFromAxisAngle(e, t) { let i = t / 2, r = Math.sin(i); return this._x = e.x * r, this._y = e.y * r, this._z = e.z * r, this._w = Math.cos(i), this._onChangeCallback(), this } setFromRotationMatrix(e) { let t = e.elements, i = t[0], r = t[4], n = t[8], s = t[1], a = t[5], o = t[9], l = t[2], u = t[6], h = t[10], c = i + a + h; if (c > 0) { let e = .5 / Math.sqrt(c + 1); this._w = .25 / e, this._x = (u - o) * e, this._y = (n - l) * e, this._z = (s - r) * e } else if (i > a && i > h) { let e = 2 * Math.sqrt(1 + i - a - h); this._w = (u - o) / e, this._x = .25 * e, this._y = (r + s) / e, this._z = (n + l) / e } else if (a > h) { let e = 2 * Math.sqrt(1 + a - i - h); this._w = (n - l) / e, this._x = (r + s) / e, this._y = .25 * e, this._z = (o + u) / e } else { let e = 2 * Math.sqrt(1 + h - i - a); this._w = (s - r) / e, this._x = (n + l) / e, this._y = (o + u) / e, this._z = .25 * e } return this._onChangeCallback(), this } setFromUnitVectors(e, t) { let i = e.dot(t) + 1; return i < Number.EPSILON ? (i = 0, Math.abs(e.x) > Math.abs(e.z) ? (this._x = -e.y, this._y = e.x, this._z = 0) : (this._x = 0, this._y = -e.z, this._z = e.y)) : (this._x = e.y * t.z - e.z * t.y, this._y = e.z * t.x - e.x * t.z, this._z = e.x * t.y - e.y * t.x), this._w = i, this.normalize() } angleTo(e) { return 2 * Math.acos(Math.abs(iO(this.dot(e), -1, 1))) } rotateTowards(e, t) { let i = this.angleTo(e); if (0 === i) return this; let r = Math.min(1, t / i); return this.slerp(e, r), this } identity() { return this.set(0, 0, 0, 1) } invert() { return this.conjugate() } conjugate() { return this._x *= -1, this._y *= -1, this._z *= -1, this._onChangeCallback(), this } dot(e) { return this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w } lengthSq() { return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w } length() { return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w) } normalize() { let e = this.length(); return 0 === e ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (e = 1 / e, this._x = this._x * e, this._y = this._y * e, this._z = this._z * e, this._w = this._w * e), this._onChangeCallback(), this } multiply(e) { return this.multiplyQuaternions(this, e) } premultiply(e) { return this.multiplyQuaternions(e, this) } multiplyQuaternions(e, t) { let i = e._x, r = e._y, n = e._z, s = e._w, a = t._x, o = t._y, l = t._z, u = t._w; return this._x = i * u + s * a + r * l - n * o, this._y = r * u + s * o + n * a - i * l, this._z = n * u + s * l + i * o - r * a, this._w = s * u - i * a - r * o - n * l, this._onChangeCallback(), this } slerp(e, t) { if (0 === t) return this; if (1 === t) return this.copy(e); let i = this._x, r = this._y, n = this._z, s = this._w, a = s * e._w + i * e._x + r * e._y + n * e._z; if (a < 0 ? (this._w = -e._w, this._x = -e._x, this._y = -e._y, this._z = -e._z, a = -a) : this.copy(e), a >= 1) return this._w = s, this._x = i, this._y = r, this._z = n, this; let o = 1 - a * a; if (o <= Number.EPSILON) { let e = 1 - t; return this._w = e * s + t * this._w, this._x = e * i + t * this._x, this._y = e * r + t * this._y, this._z = e * n + t * this._z, this.normalize(), this } let l = Math.sqrt(o), u = Math.atan2(l, a), h = Math.sin((1 - t) * u) / l, c = Math.sin(t * u) / l; return this._w = s * h + this._w * c, this._x = i * h + this._x * c, this._y = r * h + this._y * c, this._z = n * h + this._z * c, this._onChangeCallback(), this } slerpQuaternions(e, t, i) { return this.copy(e).slerp(t, i) } random() { let e = 2 * Math.PI * Math.random(), t = 2 * Math.PI * Math.random(), i = Math.random(), r = Math.sqrt(1 - i), n = Math.sqrt(i); return this.set(r * Math.sin(e), r * Math.cos(e), n * Math.sin(t), n * Math.cos(t)) } equals(e) { return e._x === this._x && e._y === this._y && e._z === this._z && e._w === this._w } fromArray(e, t = 0) { return this._x = e[t], this._y = e[t + 1], this._z = e[t + 2], this._w = e[t + 3], this._onChangeCallback(), this } toArray(e = [], t = 0) { return e[t] = this._x, e[t + 1] = this._y, e[t + 2] = this._z, e[t + 3] = this._w, e } fromBufferAttribute(e, t) { return this._x = e.getX(t), this._y = e.getY(t), this._z = e.getZ(t), this._w = e.getW(t), this._onChangeCallback(), this } toJSON() { return this.toArray() } _onChange(e) { return this._onChangeCallback = e, this } _onChangeCallback() { } *[Symbol.iterator]() { yield this._x, yield this._y, yield this._z, yield this._w } } class rl { constructor(e = 0, t = 0, i = 0) { rl.prototype.isVector3 = !0, this.x = e, this.y = t, this.z = i } set(e, t, i) { return void 0 === i && (i = this.z), this.x = e, this.y = t, this.z = i, this } setScalar(e) { return this.x = e, this.y = e, this.z = e, this } setX(e) { return this.x = e, this } setY(e) { return this.y = e, this } setZ(e) { return this.z = e, this } setComponent(e, t) { switch (e) { case 0: this.x = t; break; case 1: this.y = t; break; case 2: this.z = t; break; default: throw Error("index is out of range: " + e) }return this } getComponent(e) { switch (e) { case 0: return this.x; case 1: return this.y; case 2: return this.z; default: throw Error("index is out of range: " + e) } } clone() { return new this.constructor(this.x, this.y, this.z) } copy(e) { return this.x = e.x, this.y = e.y, this.z = e.z, this } add(e) { return this.x += e.x, this.y += e.y, this.z += e.z, this } addScalar(e) { return this.x += e, this.y += e, this.z += e, this } addVectors(e, t) { return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this } addScaledVector(e, t) { return this.x += e.x * t, this.y += e.y * t, this.z += e.z * t, this } sub(e) { return this.x -= e.x, this.y -= e.y, this.z -= e.z, this } subScalar(e) { return this.x -= e, this.y -= e, this.z -= e, this } subVectors(e, t) { return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this } multiply(e) { return this.x *= e.x, this.y *= e.y, this.z *= e.z, this } multiplyScalar(e) { return this.x *= e, this.y *= e, this.z *= e, this } multiplyVectors(e, t) { return this.x = e.x * t.x, this.y = e.y * t.y, this.z = e.z * t.z, this } applyEuler(e) { return this.applyQuaternion(rh.setFromEuler(e)) } applyAxisAngle(e, t) { return this.applyQuaternion(rh.setFromAxisAngle(e, t)) } applyMatrix3(e) { let t = this.x, i = this.y, r = this.z, n = e.elements; return this.x = n[0] * t + n[3] * i + n[6] * r, this.y = n[1] * t + n[4] * i + n[7] * r, this.z = n[2] * t + n[5] * i + n[8] * r, this } applyNormalMatrix(e) { return this.applyMatrix3(e).normalize() } applyMatrix4(e) { let t = this.x, i = this.y, r = this.z, n = e.elements, s = 1 / (n[3] * t + n[7] * i + n[11] * r + n[15]); return this.x = (n[0] * t + n[4] * i + n[8] * r + n[12]) * s, this.y = (n[1] * t + n[5] * i + n[9] * r + n[13]) * s, this.z = (n[2] * t + n[6] * i + n[10] * r + n[14]) * s, this } applyQuaternion(e) { let t = this.x, i = this.y, r = this.z, n = e.x, s = e.y, a = e.z, o = e.w, l = 2 * (s * r - a * i), u = 2 * (a * t - n * r), h = 2 * (n * i - s * t); return this.x = t + o * l + s * h - a * u, this.y = i + o * u + a * l - n * h, this.z = r + o * h + n * u - s * l, this } project(e) { return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix) } unproject(e) { return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(e.matrixWorld) } transformDirection(e) { let t = this.x, i = this.y, r = this.z, n = e.elements; return this.x = n[0] * t + n[4] * i + n[8] * r, this.y = n[1] * t + n[5] * i + n[9] * r, this.z = n[2] * t + n[6] * i + n[10] * r, this.normalize() } divide(e) { return this.x /= e.x, this.y /= e.y, this.z /= e.z, this } divideScalar(e) { return this.multiplyScalar(1 / e) } min(e) { return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this } max(e) { return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this } clamp(e, t) { return this.x = iO(this.x, e.x, t.x), this.y = iO(this.y, e.y, t.y), this.z = iO(this.z, e.z, t.z), this } clampScalar(e, t) { return this.x = iO(this.x, e, t), this.y = iO(this.y, e, t), this.z = iO(this.z, e, t), this } clampLength(e, t) { let i = this.length(); return this.divideScalar(i || 1).multiplyScalar(iO(i, e, t)) } floor() { return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this } ceil() { return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this } round() { return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this } roundToZero() { return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this.z = Math.trunc(this.z), this } negate() { return this.x = -this.x, this.y = -this.y, this.z = -this.z, this } dot(e) { return this.x * e.x + this.y * e.y + this.z * e.z } lengthSq() { return this.x * this.x + this.y * this.y + this.z * this.z } length() { return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z) } manhattanLength() { return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) } normalize() { return this.divideScalar(this.length() || 1) } setLength(e) { return this.normalize().multiplyScalar(e) } lerp(e, t) { return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this.z += (e.z - this.z) * t, this } lerpVectors(e, t, i) { return this.x = e.x + (t.x - e.x) * i, this.y = e.y + (t.y - e.y) * i, this.z = e.z + (t.z - e.z) * i, this } cross(e) { return this.crossVectors(this, e) } crossVectors(e, t) { let i = e.x, r = e.y, n = e.z, s = t.x, a = t.y, o = t.z; return this.x = r * o - n * a, this.y = n * s - i * o, this.z = i * a - r * s, this } projectOnVector(e) { let t = e.lengthSq(); if (0 === t) return this.set(0, 0, 0); let i = e.dot(this) / t; return this.copy(e).multiplyScalar(i) } projectOnPlane(e) { return ru.copy(this).projectOnVector(e), this.sub(ru) } reflect(e) { return this.sub(ru.copy(e).multiplyScalar(2 * this.dot(e))) } angleTo(e) { let t = Math.sqrt(this.lengthSq() * e.lengthSq()); return 0 === t ? Math.PI / 2 : Math.acos(iO(this.dot(e) / t, -1, 1)) } distanceTo(e) { return Math.sqrt(this.distanceToSquared(e)) } distanceToSquared(e) { let t = this.x - e.x, i = this.y - e.y, r = this.z - e.z; return t * t + i * i + r * r } manhattanDistanceTo(e) { return Math.abs(this.x - e.x) + Math.abs(this.y - e.y) + Math.abs(this.z - e.z) } setFromSpherical(e) { return this.setFromSphericalCoords(e.radius, e.phi, e.theta) } setFromSphericalCoords(e, t, i) { let r = Math.sin(t) * e; return this.x = r * Math.sin(i), this.y = Math.cos(t) * e, this.z = r * Math.cos(i), this } setFromCylindrical(e) { return this.setFromCylindricalCoords(e.radius, e.theta, e.y) } setFromCylindricalCoords(e, t, i) { return this.x = e * Math.sin(t), this.y = i, this.z = e * Math.cos(t), this } setFromMatrixPosition(e) { let t = e.elements; return this.x = t[12], this.y = t[13], this.z = t[14], this } setFromMatrixScale(e) { let t = this.setFromMatrixColumn(e, 0).length(), i = this.setFromMatrixColumn(e, 1).length(), r = this.setFromMatrixColumn(e, 2).length(); return this.x = t, this.y = i, this.z = r, this } setFromMatrixColumn(e, t) { return this.fromArray(e.elements, 4 * t) } setFromMatrix3Column(e, t) { return this.fromArray(e.elements, 3 * t) } setFromEuler(e) { return this.x = e._x, this.y = e._y, this.z = e._z, this } setFromColor(e) { return this.x = e.r, this.y = e.g, this.z = e.b, this } equals(e) { return e.x === this.x && e.y === this.y && e.z === this.z } fromArray(e, t = 0) { return this.x = e[t], this.y = e[t + 1], this.z = e[t + 2], this } toArray(e = [], t = 0) { return e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.z, e } fromBufferAttribute(e, t) { return this.x = e.getX(t), this.y = e.getY(t), this.z = e.getZ(t), this } random() { return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this } randomDirection() { let e = Math.random() * Math.PI * 2, t = 2 * Math.random() - 1, i = Math.sqrt(1 - t * t); return this.x = i * Math.cos(e), this.y = t, this.z = i * Math.sin(e), this } *[Symbol.iterator]() { yield this.x, yield this.y, yield this.z } } let ru = new rl, rh = new ro; class rc { constructor(e = new rl(Infinity, Infinity, Infinity), t = new rl(-1 / 0, -1 / 0, -1 / 0)) { this.isBox3 = !0, this.min = e, this.max = t } set(e, t) { return this.min.copy(e), this.max.copy(t), this } setFromArray(e) { this.makeEmpty(); for (let t = 0, i = e.length; t < i; t += 3)this.expandByPoint(rf.fromArray(e, t)); return this } setFromBufferAttribute(e) { this.makeEmpty(); for (let t = 0, i = e.count; t < i; t++)this.expandByPoint(rf.fromBufferAttribute(e, t)); return this } setFromPoints(e) { this.makeEmpty(); for (let t = 0, i = e.length; t < i; t++)this.expandByPoint(e[t]); return this } setFromCenterAndSize(e, t) { let i = rf.copy(t).multiplyScalar(.5); return this.min.copy(e).sub(i), this.max.copy(e).add(i), this } setFromObject(e, t = !1) { return this.makeEmpty(), this.expandByObject(e, t) } clone() { return new this.constructor().copy(this) } copy(e) { return this.min.copy(e.min), this.max.copy(e.max), this } makeEmpty() { return this.min.x = this.min.y = this.min.z = Infinity, this.max.x = this.max.y = this.max.z = -1 / 0, this } isEmpty() { return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z } getCenter(e) { return this.isEmpty() ? e.set(0, 0, 0) : e.addVectors(this.min, this.max).multiplyScalar(.5) } getSize(e) { return this.isEmpty() ? e.set(0, 0, 0) : e.subVectors(this.max, this.min) } expandByPoint(e) { return this.min.min(e), this.max.max(e), this } expandByVector(e) { return this.min.sub(e), this.max.add(e), this } expandByScalar(e) { return this.min.addScalar(-e), this.max.addScalar(e), this } expandByObject(e, t = !1) { e.updateWorldMatrix(!1, !1); let i = e.geometry; if (void 0 !== i) { let r = i.getAttribute("position"); if (!0 === t && void 0 !== r && !0 !== e.isInstancedMesh) for (let t = 0, i = r.count; t < i; t++)!0 === e.isMesh ? e.getVertexPosition(t, rf) : rf.fromBufferAttribute(r, t), rf.applyMatrix4(e.matrixWorld), this.expandByPoint(rf); else void 0 !== e.boundingBox ? (null === e.boundingBox && e.computeBoundingBox(), rp.copy(e.boundingBox)) : (null === i.boundingBox && i.computeBoundingBox(), rp.copy(i.boundingBox)), rp.applyMatrix4(e.matrixWorld), this.union(rp) } let r = e.children; for (let e = 0, i = r.length; e < i; e++)this.expandByObject(r[e], t); return this } containsPoint(e) { return e.x >= this.min.x && e.x <= this.max.x && e.y >= this.min.y && e.y <= this.max.y && e.z >= this.min.z && e.z <= this.max.z } containsBox(e) { return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y && this.min.z <= e.min.z && e.max.z <= this.max.z } getParameter(e, t) { return t.set((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y), (e.z - this.min.z) / (this.max.z - this.min.z)) } intersectsBox(e) { return e.max.x >= this.min.x && e.min.x <= this.max.x && e.max.y >= this.min.y && e.min.y <= this.max.y && e.max.z >= this.min.z && e.min.z <= this.max.z } intersectsSphere(e) { return this.clampPoint(e.center, rf), rf.distanceToSquared(e.center) <= e.radius * e.radius } intersectsPlane(e) { let t, i; return e.normal.x > 0 ? (t = e.normal.x * this.min.x, i = e.normal.x * this.max.x) : (t = e.normal.x * this.max.x, i = e.normal.x * this.min.x), e.normal.y > 0 ? (t += e.normal.y * this.min.y, i += e.normal.y * this.max.y) : (t += e.normal.y * this.max.y, i += e.normal.y * this.min.y), e.normal.z > 0 ? (t += e.normal.z * this.min.z, i += e.normal.z * this.max.z) : (t += e.normal.z * this.max.z, i += e.normal.z * this.min.z), t <= -e.constant && i >= -e.constant } intersectsTriangle(e) { if (this.isEmpty()) return !1; this.getCenter(rA), r_.subVectors(this.max, rA), rm.subVectors(e.a, rA), rg.subVectors(e.b, rA), rv.subVectors(e.c, rA), ry.subVectors(rg, rm), rx.subVectors(rv, rg), rS.subVectors(rm, rv); let t = [0, -ry.z, ry.y, 0, -rx.z, rx.y, 0, -rS.z, rS.y, ry.z, 0, -ry.x, rx.z, 0, -rx.x, rS.z, 0, -rS.x, -ry.y, ry.x, 0, -rx.y, rx.x, 0, -rS.y, rS.x, 0]; return !!(rT(t, rm, rg, rv, r_) && rT(t = [1, 0, 0, 0, 1, 0, 0, 0, 1], rm, rg, rv, r_)) && (rE.crossVectors(ry, rx), rT(t = [rE.x, rE.y, rE.z], rm, rg, rv, r_)) } clampPoint(e, t) { return t.copy(e).clamp(this.min, this.max) } distanceToPoint(e) { return this.clampPoint(e, rf).distanceTo(e) } getBoundingSphere(e) { return this.isEmpty() ? e.makeEmpty() : (this.getCenter(e.center), e.radius = .5 * this.getSize(rf).length()), e } intersect(e) { return this.min.max(e.min), this.max.min(e.max), this.isEmpty() && this.makeEmpty(), this } union(e) { return this.min.min(e.min), this.max.max(e.max), this } applyMatrix4(e) { return this.isEmpty() || (rd[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e), rd[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e), rd[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e), rd[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e), rd[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e), rd[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e), rd[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e), rd[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e), this.setFromPoints(rd)), this } translate(e) { return this.min.add(e), this.max.add(e), this } equals(e) { return e.min.equals(this.min) && e.max.equals(this.max) } } let rd = [new rl, new rl, new rl, new rl, new rl, new rl, new rl, new rl], rf = new rl, rp = new rc, rm = new rl, rg = new rl, rv = new rl, ry = new rl, rx = new rl, rS = new rl, rA = new rl, r_ = new rl, rE = new rl, rb = new rl; function rT(e, t, i, r, n) { for (let s = 0, a = e.length - 3; s <= a; s += 3) { rb.fromArray(e, s); let a = n.x * Math.abs(rb.x) + n.y * Math.abs(rb.y) + n.z * Math.abs(rb.z), o = t.dot(rb), l = i.dot(rb), u = r.dot(rb); if (Math.max(-Math.max(o, l, u), Math.min(o, l, u)) > a) return !1 } return !0 } let rw = new rc, rM = new rl, rR = new rl; class rC { constructor(e = new rl, t = -1) { this.isSphere = !0, this.center = e, this.radius = t } set(e, t) { return this.center.copy(e), this.radius = t, this } setFromPoints(e, t) { let i = this.center; void 0 !== t ? i.copy(t) : rw.setFromPoints(e).getCenter(i); let r = 0; for (let t = 0, n = e.length; t < n; t++)r = Math.max(r, i.distanceToSquared(e[t])); return this.radius = Math.sqrt(r), this } copy(e) { return this.center.copy(e.center), this.radius = e.radius, this } isEmpty() { return this.radius < 0 } makeEmpty() { return this.center.set(0, 0, 0), this.radius = -1, this } containsPoint(e) { return e.distanceToSquared(this.center) <= this.radius * this.radius } distanceToPoint(e) { return e.distanceTo(this.center) - this.radius } intersectsSphere(e) { let t = this.radius + e.radius; return e.center.distanceToSquared(this.center) <= t * t } intersectsBox(e) { return e.intersectsSphere(this) } intersectsPlane(e) { return Math.abs(e.distanceToPoint(this.center)) <= this.radius } clampPoint(e, t) { let i = this.center.distanceToSquared(e); return t.copy(e), i > this.radius * this.radius && (t.sub(this.center).normalize(), t.multiplyScalar(this.radius).add(this.center)), t } getBoundingBox(e) { return this.isEmpty() ? e.makeEmpty() : (e.set(this.center, this.center), e.expandByScalar(this.radius)), e } applyMatrix4(e) { return this.center.applyMatrix4(e), this.radius = this.radius * e.getMaxScaleOnAxis(), this } translate(e) { return this.center.add(e), this } expandByPoint(e) { if (this.isEmpty()) return this.center.copy(e), this.radius = 0, this; rM.subVectors(e, this.center); let t = rM.lengthSq(); if (t > this.radius * this.radius) { let e = Math.sqrt(t), i = (e - this.radius) * .5; this.center.addScaledVector(rM, i / e), this.radius += i } return this } union(e) { return e.isEmpty() || (this.isEmpty() ? this.copy(e) : !0 === this.center.equals(e.center) ? this.radius = Math.max(this.radius, e.radius) : (rR.subVectors(e.center, this.center).setLength(e.radius), this.expandByPoint(rM.copy(e.center).add(rR)), this.expandByPoint(rM.copy(e.center).sub(rR)))), this } equals(e) { return e.center.equals(this.center) && e.radius === this.radius } clone() { return new this.constructor().copy(this) } } let rI = new rl, rL = new rl, rP = new rl, rD = new rl, rO = new rl, rk = new rl, rF = new rl; class rU { constructor(e = new rl, t = new rl(0, 0, -1)) { this.origin = e, this.direction = t } set(e, t) { return this.origin.copy(e), this.direction.copy(t), this } copy(e) { return this.origin.copy(e.origin), this.direction.copy(e.direction), this } at(e, t) { return t.copy(this.origin).addScaledVector(this.direction, e) } lookAt(e) { return this.direction.copy(e).sub(this.origin).normalize(), this } recast(e) { return this.origin.copy(this.at(e, rI)), this } closestPointToPoint(e, t) { t.subVectors(e, this.origin); let i = t.dot(this.direction); return i < 0 ? t.copy(this.origin) : t.copy(this.origin).addScaledVector(this.direction, i) } distanceToPoint(e) { return Math.sqrt(this.distanceSqToPoint(e)) } distanceSqToPoint(e) { let t = rI.subVectors(e, this.origin).dot(this.direction); return t < 0 ? this.origin.distanceToSquared(e) : (rI.copy(this.origin).addScaledVector(this.direction, t), rI.distanceToSquared(e)) } distanceSqToSegment(e, t, i, r) { let n, s, a, o; rL.copy(e).add(t).multiplyScalar(.5), rP.copy(t).sub(e).normalize(), rD.copy(this.origin).sub(rL); let l = .5 * e.distanceTo(t), u = -this.direction.dot(rP), h = rD.dot(this.direction), c = -rD.dot(rP), d = rD.lengthSq(), f = Math.abs(1 - u * u); if (f > 0) { if (n = u * c - h, s = u * h - c, o = l * f, n >= 0) { if (s >= -o) { if (s <= o) { let e = 1 / f; n *= e, s *= e, a = n * (n + u * s + 2 * h) + s * (u * n + s + 2 * c) + d } else a = -(n = Math.max(0, -(u * (s = l) + h))) * n + s * (s + 2 * c) + d } else a = -(n = Math.max(0, -(u * (s = -l) + h))) * n + s * (s + 2 * c) + d } else s <= -o ? (s = (n = Math.max(0, -(-u * l + h))) > 0 ? -l : Math.min(Math.max(-l, -c), l), a = -n * n + s * (s + 2 * c) + d) : s <= o ? (n = 0, a = (s = Math.min(Math.max(-l, -c), l)) * (s + 2 * c) + d) : (s = (n = Math.max(0, -(u * l + h))) > 0 ? l : Math.min(Math.max(-l, -c), l), a = -n * n + s * (s + 2 * c) + d) } else s = u > 0 ? -l : l, a = -(n = Math.max(0, -(u * s + h))) * n + s * (s + 2 * c) + d; return i && i.copy(this.origin).addScaledVector(this.direction, n), r && r.copy(rL).addScaledVector(rP, s), a } intersectSphere(e, t) { rI.subVectors(e.center, this.origin); let i = rI.dot(this.direction), r = rI.dot(rI) - i * i, n = e.radius * e.radius; if (r > n) return null; let s = Math.sqrt(n - r), a = i - s, o = i + s; return o < 0 ? null : a < 0 ? this.at(o, t) : this.at(a, t) } intersectsSphere(e) { return this.distanceSqToPoint(e.center) <= e.radius * e.radius } distanceToPlane(e) { let t = e.normal.dot(this.direction); if (0 === t) return 0 === e.distanceToPoint(this.origin) ? 0 : null; let i = -(this.origin.dot(e.normal) + e.constant) / t; return i >= 0 ? i : null } intersectPlane(e, t) { let i = this.distanceToPlane(e); return null === i ? null : this.at(i, t) } intersectsPlane(e) { let t = e.distanceToPoint(this.origin); return !!(0 === t || e.normal.dot(this.direction) * t < 0) } intersectBox(e, t) { let i, r, n, s, a, o; let l = 1 / this.direction.x, u = 1 / this.direction.y, h = 1 / this.direction.z, c = this.origin; return (l >= 0 ? (i = (e.min.x - c.x) * l, r = (e.max.x - c.x) * l) : (i = (e.max.x - c.x) * l, r = (e.min.x - c.x) * l), u >= 0 ? (n = (e.min.y - c.y) * u, s = (e.max.y - c.y) * u) : (n = (e.max.y - c.y) * u, s = (e.min.y - c.y) * u), i > s || n > r) ? null : ((n > i || isNaN(i)) && (i = n), (s < r || isNaN(r)) && (r = s), h >= 0 ? (a = (e.min.z - c.z) * h, o = (e.max.z - c.z) * h) : (a = (e.max.z - c.z) * h, o = (e.min.z - c.z) * h), i > o || a > r) ? null : ((a > i || i != i) && (i = a), (o < r || r != r) && (r = o), r < 0) ? null : this.at(i >= 0 ? i : r, t) } intersectsBox(e) { return null !== this.intersectBox(e, rI) } intersectTriangle(e, t, i, r, n) { let s; rO.subVectors(t, e), rk.subVectors(i, e), rF.crossVectors(rO, rk); let a = this.direction.dot(rF); if (a > 0) { if (r) return null; s = 1 } else { if (!(a < 0)) return null; s = -1, a = -a } rD.subVectors(this.origin, e); let o = s * this.direction.dot(rk.crossVectors(rD, rk)); if (o < 0) return null; let l = s * this.direction.dot(rO.cross(rD)); if (l < 0 || o + l > a) return null; let u = -s * rD.dot(rF); return u < 0 ? null : this.at(u / a, n) } applyMatrix4(e) { return this.origin.applyMatrix4(e), this.direction.transformDirection(e), this } equals(e) { return e.origin.equals(this.origin) && e.direction.equals(this.direction) } clone() { return new this.constructor().copy(this) } } class rN { constructor(e, t, i, r, n, s, a, o, l, u, h, c, d, f, p, m) { rN.prototype.isMatrix4 = !0, this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], void 0 !== e && this.set(e, t, i, r, n, s, a, o, l, u, h, c, d, f, p, m) } set(e, t, i, r, n, s, a, o, l, u, h, c, d, f, p, m) { let g = this.elements; return g[0] = e, g[4] = t, g[8] = i, g[12] = r, g[1] = n, g[5] = s, g[9] = a, g[13] = o, g[2] = l, g[6] = u, g[10] = h, g[14] = c, g[3] = d, g[7] = f, g[11] = p, g[15] = m, this } identity() { return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this } clone() { return new rN().fromArray(this.elements) } copy(e) { let t = this.elements, i = e.elements; return t[0] = i[0], t[1] = i[1], t[2] = i[2], t[3] = i[3], t[4] = i[4], t[5] = i[5], t[6] = i[6], t[7] = i[7], t[8] = i[8], t[9] = i[9], t[10] = i[10], t[11] = i[11], t[12] = i[12], t[13] = i[13], t[14] = i[14], t[15] = i[15], this } copyPosition(e) { let t = this.elements, i = e.elements; return t[12] = i[12], t[13] = i[13], t[14] = i[14], this } setFromMatrix3(e) { let t = e.elements; return this.set(t[0], t[3], t[6], 0, t[1], t[4], t[7], 0, t[2], t[5], t[8], 0, 0, 0, 0, 1), this } extractBasis(e, t, i) { return e.setFromMatrixColumn(this, 0), t.setFromMatrixColumn(this, 1), i.setFromMatrixColumn(this, 2), this } makeBasis(e, t, i) { return this.set(e.x, t.x, i.x, 0, e.y, t.y, i.y, 0, e.z, t.z, i.z, 0, 0, 0, 0, 1), this } extractRotation(e) { let t = this.elements, i = e.elements, r = 1 / rB.setFromMatrixColumn(e, 0).length(), n = 1 / rB.setFromMatrixColumn(e, 1).length(), s = 1 / rB.setFromMatrixColumn(e, 2).length(); return t[0] = i[0] * r, t[1] = i[1] * r, t[2] = i[2] * r, t[3] = 0, t[4] = i[4] * n, t[5] = i[5] * n, t[6] = i[6] * n, t[7] = 0, t[8] = i[8] * s, t[9] = i[9] * s, t[10] = i[10] * s, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this } makeRotationFromEuler(e) { let t = this.elements, i = e.x, r = e.y, n = e.z, s = Math.cos(i), a = Math.sin(i), o = Math.cos(r), l = Math.sin(r), u = Math.cos(n), h = Math.sin(n); if ("XYZ" === e.order) { let e = s * u, i = s * h, r = a * u, n = a * h; t[0] = o * u, t[4] = -o * h, t[8] = l, t[1] = i + r * l, t[5] = e - n * l, t[9] = -a * o, t[2] = n - e * l, t[6] = r + i * l, t[10] = s * o } else if ("YXZ" === e.order) { let e = o * u, i = o * h, r = l * u, n = l * h; t[0] = e + n * a, t[4] = r * a - i, t[8] = s * l, t[1] = s * h, t[5] = s * u, t[9] = -a, t[2] = i * a - r, t[6] = n + e * a, t[10] = s * o } else if ("ZXY" === e.order) { let e = o * u, i = o * h, r = l * u, n = l * h; t[0] = e - n * a, t[4] = -s * h, t[8] = r + i * a, t[1] = i + r * a, t[5] = s * u, t[9] = n - e * a, t[2] = -s * l, t[6] = a, t[10] = s * o } else if ("ZYX" === e.order) { let e = s * u, i = s * h, r = a * u, n = a * h; t[0] = o * u, t[4] = r * l - i, t[8] = e * l + n, t[1] = o * h, t[5] = n * l + e, t[9] = i * l - r, t[2] = -l, t[6] = a * o, t[10] = s * o } else if ("YZX" === e.order) { let e = s * o, i = s * l, r = a * o, n = a * l; t[0] = o * u, t[4] = n - e * h, t[8] = r * h + i, t[1] = h, t[5] = s * u, t[9] = -a * u, t[2] = -l * u, t[6] = i * h + r, t[10] = e - n * h } else if ("XZY" === e.order) { let e = s * o, i = s * l, r = a * o, n = a * l; t[0] = o * u, t[4] = -h, t[8] = l * u, t[1] = e * h + n, t[5] = s * u, t[9] = i * h - r, t[2] = r * h - i, t[6] = a * u, t[10] = n * h + e } return t[3] = 0, t[7] = 0, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this } makeRotationFromQuaternion(e) { return this.compose(rG, e, rH) } lookAt(e, t, i) { let r = this.elements; return rj.subVectors(e, t), 0 === rj.lengthSq() && (rj.z = 1), rj.normalize(), rV.crossVectors(i, rj), 0 === rV.lengthSq() && (1 === Math.abs(i.z) ? rj.x += 1e-4 : rj.z += 1e-4, rj.normalize(), rV.crossVectors(i, rj)), rV.normalize(), rW.crossVectors(rj, rV), r[0] = rV.x, r[4] = rW.x, r[8] = rj.x, r[1] = rV.y, r[5] = rW.y, r[9] = rj.y, r[2] = rV.z, r[6] = rW.z, r[10] = rj.z, this } multiply(e) { return this.multiplyMatrices(this, e) } premultiply(e) { return this.multiplyMatrices(e, this) } multiplyMatrices(e, t) { let i = e.elements, r = t.elements, n = this.elements, s = i[0], a = i[4], o = i[8], l = i[12], u = i[1], h = i[5], c = i[9], d = i[13], f = i[2], p = i[6], m = i[10], g = i[14], v = i[3], y = i[7], x = i[11], S = i[15], A = r[0], _ = r[4], E = r[8], b = r[12], T = r[1], w = r[5], M = r[9], R = r[13], C = r[2], I = r[6], L = r[10], P = r[14], D = r[3], O = r[7], k = r[11], F = r[15]; return n[0] = s * A + a * T + o * C + l * D, n[4] = s * _ + a * w + o * I + l * O, n[8] = s * E + a * M + o * L + l * k, n[12] = s * b + a * R + o * P + l * F, n[1] = u * A + h * T + c * C + d * D, n[5] = u * _ + h * w + c * I + d * O, n[9] = u * E + h * M + c * L + d * k, n[13] = u * b + h * R + c * P + d * F, n[2] = f * A + p * T + m * C + g * D, n[6] = f * _ + p * w + m * I + g * O, n[10] = f * E + p * M + m * L + g * k, n[14] = f * b + p * R + m * P + g * F, n[3] = v * A + y * T + x * C + S * D, n[7] = v * _ + y * w + x * I + S * O, n[11] = v * E + y * M + x * L + S * k, n[15] = v * b + y * R + x * P + S * F, this } multiplyScalar(e) { let t = this.elements; return t[0] *= e, t[4] *= e, t[8] *= e, t[12] *= e, t[1] *= e, t[5] *= e, t[9] *= e, t[13] *= e, t[2] *= e, t[6] *= e, t[10] *= e, t[14] *= e, t[3] *= e, t[7] *= e, t[11] *= e, t[15] *= e, this } determinant() { let e = this.elements, t = e[0], i = e[4], r = e[8], n = e[12], s = e[1], a = e[5], o = e[9], l = e[13], u = e[2], h = e[6], c = e[10], d = e[14], f = e[3]; return f * (+n * o * h - r * l * h - n * a * c + i * l * c + r * a * d - i * o * d) + e[7] * (+t * o * d - t * l * c + n * s * c - r * s * d + r * l * u - n * o * u) + e[11] * (+t * l * h - t * a * d - n * s * h + i * s * d + n * a * u - i * l * u) + e[15] * (-r * a * u - t * o * h + t * a * c + r * s * h - i * s * c + i * o * u) } transpose() { let e; let t = this.elements; return e = t[1], t[1] = t[4], t[4] = e, e = t[2], t[2] = t[8], t[8] = e, e = t[6], t[6] = t[9], t[9] = e, e = t[3], t[3] = t[12], t[12] = e, e = t[7], t[7] = t[13], t[13] = e, e = t[11], t[11] = t[14], t[14] = e, this } setPosition(e, t, i) { let r = this.elements; return e.isVector3 ? (r[12] = e.x, r[13] = e.y, r[14] = e.z) : (r[12] = e, r[13] = t, r[14] = i), this } invert() { let e = this.elements, t = e[0], i = e[1], r = e[2], n = e[3], s = e[4], a = e[5], o = e[6], l = e[7], u = e[8], h = e[9], c = e[10], d = e[11], f = e[12], p = e[13], m = e[14], g = e[15], v = h * m * l - p * c * l + p * o * d - a * m * d - h * o * g + a * c * g, y = f * c * l - u * m * l - f * o * d + s * m * d + u * o * g - s * c * g, x = u * p * l - f * h * l + f * a * d - s * p * d - u * a * g + s * h * g, S = f * h * o - u * p * o - f * a * c + s * p * c + u * a * m - s * h * m, A = t * v + i * y + r * x + n * S; if (0 === A) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0); let _ = 1 / A; return e[0] = v * _, e[1] = (p * c * n - h * m * n - p * r * d + i * m * d + h * r * g - i * c * g) * _, e[2] = (a * m * n - p * o * n + p * r * l - i * m * l - a * r * g + i * o * g) * _, e[3] = (h * o * n - a * c * n - h * r * l + i * c * l + a * r * d - i * o * d) * _, e[4] = y * _, e[5] = (u * m * n - f * c * n + f * r * d - t * m * d - u * r * g + t * c * g) * _, e[6] = (f * o * n - s * m * n - f * r * l + t * m * l + s * r * g - t * o * g) * _, e[7] = (s * c * n - u * o * n + u * r * l - t * c * l - s * r * d + t * o * d) * _, e[8] = x * _, e[9] = (f * h * n - u * p * n - f * i * d + t * p * d + u * i * g - t * h * g) * _, e[10] = (s * p * n - f * a * n + f * i * l - t * p * l - s * i * g + t * a * g) * _, e[11] = (u * a * n - s * h * n - u * i * l + t * h * l + s * i * d - t * a * d) * _, e[12] = S * _, e[13] = (u * p * r - f * h * r + f * i * c - t * p * c - u * i * m + t * h * m) * _, e[14] = (f * a * r - s * p * r - f * i * o + t * p * o + s * i * m - t * a * m) * _, e[15] = (s * h * r - u * a * r + u * i * o - t * h * o - s * i * c + t * a * c) * _, this } scale(e) { let t = this.elements, i = e.x, r = e.y, n = e.z; return t[0] *= i, t[4] *= r, t[8] *= n, t[1] *= i, t[5] *= r, t[9] *= n, t[2] *= i, t[6] *= r, t[10] *= n, t[3] *= i, t[7] *= r, t[11] *= n, this } getMaxScaleOnAxis() { let e = this.elements; return Math.sqrt(Math.max(e[0] * e[0] + e[1] * e[1] + e[2] * e[2], e[4] * e[4] + e[5] * e[5] + e[6] * e[6], e[8] * e[8] + e[9] * e[9] + e[10] * e[10])) } makeTranslation(e, t, i) { return e.isVector3 ? this.set(1, 0, 0, e.x, 0, 1, 0, e.y, 0, 0, 1, e.z, 0, 0, 0, 1) : this.set(1, 0, 0, e, 0, 1, 0, t, 0, 0, 1, i, 0, 0, 0, 1), this } makeRotationX(e) { let t = Math.cos(e), i = Math.sin(e); return this.set(1, 0, 0, 0, 0, t, -i, 0, 0, i, t, 0, 0, 0, 0, 1), this } makeRotationY(e) { let t = Math.cos(e), i = Math.sin(e); return this.set(t, 0, i, 0, 0, 1, 0, 0, -i, 0, t, 0, 0, 0, 0, 1), this } makeRotationZ(e) { let t = Math.cos(e), i = Math.sin(e); return this.set(t, -i, 0, 0, i, t, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this } makeRotationAxis(e, t) { let i = Math.cos(t), r = Math.sin(t), n = 1 - i, s = e.x, a = e.y, o = e.z, l = n * s, u = n * a; return this.set(l * s + i, l * a - r * o, l * o + r * a, 0, l * a + r * o, u * a + i, u * o - r * s, 0, l * o - r * a, u * o + r * s, n * o * o + i, 0, 0, 0, 0, 1), this } makeScale(e, t, i) { return this.set(e, 0, 0, 0, 0, t, 0, 0, 0, 0, i, 0, 0, 0, 0, 1), this } makeShear(e, t, i, r, n, s) { return this.set(1, i, n, 0, e, 1, s, 0, t, r, 1, 0, 0, 0, 0, 1), this } compose(e, t, i) { let r = this.elements, n = t._x, s = t._y, a = t._z, o = t._w, l = n + n, u = s + s, h = a + a, c = n * l, d = n * u, f = n * h, p = s * u, m = s * h, g = a * h, v = o * l, y = o * u, x = o * h, S = i.x, A = i.y, _ = i.z; return r[0] = (1 - (p + g)) * S, r[1] = (d + x) * S, r[2] = (f - y) * S, r[3] = 0, r[4] = (d - x) * A, r[5] = (1 - (c + g)) * A, r[6] = (m + v) * A, r[7] = 0, r[8] = (f + y) * _, r[9] = (m - v) * _, r[10] = (1 - (c + p)) * _, r[11] = 0, r[12] = e.x, r[13] = e.y, r[14] = e.z, r[15] = 1, this } decompose(e, t, i) { let r = this.elements, n = rB.set(r[0], r[1], r[2]).length(), s = rB.set(r[4], r[5], r[6]).length(), a = rB.set(r[8], r[9], r[10]).length(); 0 > this.determinant() && (n = -n), e.x = r[12], e.y = r[13], e.z = r[14], rz.copy(this); let o = 1 / n, l = 1 / s, u = 1 / a; return rz.elements[0] *= o, rz.elements[1] *= o, rz.elements[2] *= o, rz.elements[4] *= l, rz.elements[5] *= l, rz.elements[6] *= l, rz.elements[8] *= u, rz.elements[9] *= u, rz.elements[10] *= u, t.setFromRotationMatrix(rz), i.x = n, i.y = s, i.z = a, this } makePerspective(e, t, i, r, n, s, a = iT) { let o, l; let u = this.elements; if (a === iT) o = -(s + n) / (s - n), l = -2 * s * n / (s - n); else if (a === iw) o = -s / (s - n), l = -s * n / (s - n); else throw Error("THREE.Matrix4.makePerspective(): Invalid coordinate system: " + a); return u[0] = 2 * n / (t - e), u[4] = 0, u[8] = (t + e) / (t - e), u[12] = 0, u[1] = 0, u[5] = 2 * n / (i - r), u[9] = (i + r) / (i - r), u[13] = 0, u[2] = 0, u[6] = 0, u[10] = o, u[14] = l, u[3] = 0, u[7] = 0, u[11] = -1, u[15] = 0, this } makeOrthographic(e, t, i, r, n, s, a = iT) { let o, l; let u = this.elements, h = 1 / (t - e), c = 1 / (i - r), d = 1 / (s - n); if (a === iT) o = (s + n) * d, l = -2 * d; else if (a === iw) o = n * d, l = -1 * d; else throw Error("THREE.Matrix4.makeOrthographic(): Invalid coordinate system: " + a); return u[0] = 2 * h, u[4] = 0, u[8] = 0, u[12] = -((t + e) * h), u[1] = 0, u[5] = 2 * c, u[9] = 0, u[13] = -((i + r) * c), u[2] = 0, u[6] = 0, u[10] = l, u[14] = -o, u[3] = 0, u[7] = 0, u[11] = 0, u[15] = 1, this } equals(e) { let t = this.elements, i = e.elements; for (let e = 0; e < 16; e++)if (t[e] !== i[e]) return !1; return !0 } fromArray(e, t = 0) { for (let i = 0; i < 16; i++)this.elements[i] = e[i + t]; return this } toArray(e = [], t = 0) { let i = this.elements; return e[t] = i[0], e[t + 1] = i[1], e[t + 2] = i[2], e[t + 3] = i[3], e[t + 4] = i[4], e[t + 5] = i[5], e[t + 6] = i[6], e[t + 7] = i[7], e[t + 8] = i[8], e[t + 9] = i[9], e[t + 10] = i[10], e[t + 11] = i[11], e[t + 12] = i[12], e[t + 13] = i[13], e[t + 14] = i[14], e[t + 15] = i[15], e } } let rB = new rl, rz = new rN, rG = new rl(0, 0, 0), rH = new rl(1, 1, 1), rV = new rl, rW = new rl, rj = new rl, rY = new rN, rX = new ro; class rK { constructor(e = 0, t = 0, i = 0, r = rK.DEFAULT_ORDER) { this.isEuler = !0, this._x = e, this._y = t, this._z = i, this._order = r } get x() { return this._x } set x(e) { this._x = e, this._onChangeCallback() } get y() { return this._y } set y(e) { this._y = e, this._onChangeCallback() } get z() { return this._z } set z(e) { this._z = e, this._onChangeCallback() } get order() { return this._order } set order(e) { this._order = e, this._onChangeCallback() } set(e, t, i, r = this._order) { return this._x = e, this._y = t, this._z = i, this._order = r, this._onChangeCallback(), this } clone() { return new this.constructor(this._x, this._y, this._z, this._order) } copy(e) { return this._x = e._x, this._y = e._y, this._z = e._z, this._order = e._order, this._onChangeCallback(), this } setFromRotationMatrix(e, t = this._order, i = !0) { let r = e.elements, n = r[0], s = r[4], a = r[8], o = r[1], l = r[5], u = r[9], h = r[2], c = r[6], d = r[10]; switch (t) { case "XYZ": this._y = Math.asin(iO(a, -1, 1)), .9999999 > Math.abs(a) ? (this._x = Math.atan2(-u, d), this._z = Math.atan2(-s, n)) : (this._x = Math.atan2(c, l), this._z = 0); break; case "YXZ": this._x = Math.asin(-iO(u, -1, 1)), .9999999 > Math.abs(u) ? (this._y = Math.atan2(a, d), this._z = Math.atan2(o, l)) : (this._y = Math.atan2(-h, n), this._z = 0); break; case "ZXY": this._x = Math.asin(iO(c, -1, 1)), .9999999 > Math.abs(c) ? (this._y = Math.atan2(-h, d), this._z = Math.atan2(-s, l)) : (this._y = 0, this._z = Math.atan2(o, n)); break; case "ZYX": this._y = Math.asin(-iO(h, -1, 1)), .9999999 > Math.abs(h) ? (this._x = Math.atan2(c, d), this._z = Math.atan2(o, n)) : (this._x = 0, this._z = Math.atan2(-s, l)); break; case "YZX": this._z = Math.asin(iO(o, -1, 1)), .9999999 > Math.abs(o) ? (this._x = Math.atan2(-u, l), this._y = Math.atan2(-h, n)) : (this._x = 0, this._y = Math.atan2(a, d)); break; case "XZY": this._z = Math.asin(-iO(s, -1, 1)), .9999999 > Math.abs(s) ? (this._x = Math.atan2(c, l), this._y = Math.atan2(a, n)) : (this._x = Math.atan2(-u, d), this._y = 0); break; default: console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + t) }return this._order = t, !0 === i && this._onChangeCallback(), this } setFromQuaternion(e, t, i) { return rY.makeRotationFromQuaternion(e), this.setFromRotationMatrix(rY, t, i) } setFromVector3(e, t = this._order) { return this.set(e.x, e.y, e.z, t) } reorder(e) { return rX.setFromEuler(this), this.setFromQuaternion(rX, e) } equals(e) { return e._x === this._x && e._y === this._y && e._z === this._z && e._order === this._order } fromArray(e) { return this._x = e[0], this._y = e[1], this._z = e[2], void 0 !== e[3] && (this._order = e[3]), this._onChangeCallback(), this } toArray(e = [], t = 0) { return e[t] = this._x, e[t + 1] = this._y, e[t + 2] = this._z, e[t + 3] = this._order, e } _onChange(e) { return this._onChangeCallback = e, this } _onChangeCallback() { } *[Symbol.iterator]() { yield this._x, yield this._y, yield this._z, yield this._order } } rK.DEFAULT_ORDER = "XYZ"; class rq { constructor() { this.mask = 1 } set(e) { this.mask = (1 << e | 0) >>> 0 } enable(e) { this.mask |= 1 << e | 0 } enableAll() { this.mask = -1 } toggle(e) { this.mask ^= 1 << e | 0 } disable(e) { this.mask &= ~(1 << e | 0) } disableAll() { this.mask = 0 } test(e) { return (this.mask & e.mask) != 0 } isEnabled(e) { return (this.mask & (1 << e | 0)) != 0 } } let rQ = 0, rZ = new rl, r$ = new ro, rJ = new rN, r0 = new rl, r1 = new rl, r2 = new rl, r3 = new ro, r4 = new rl(1, 0, 0), r5 = new rl(0, 1, 0), r8 = new rl(0, 0, 1), r6 = { type: "added" }, r9 = { type: "removed" }, r7 = { type: "childadded", child: null }, ne = { type: "childremoved", child: null }; class nt extends iR { constructor() { super(), this.isObject3D = !0, Object.defineProperty(this, "id", { value: rQ++ }), this.uuid = iD(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = nt.DEFAULT_UP.clone(); let e = new rl, t = new rK, i = new ro, r = new rl(1, 1, 1); t._onChange(function () { i.setFromEuler(t, !1) }), i._onChange(function () { t.setFromQuaternion(i, void 0, !1) }), Object.defineProperties(this, { position: { configurable: !0, enumerable: !0, value: e }, rotation: { configurable: !0, enumerable: !0, value: t }, quaternion: { configurable: !0, enumerable: !0, value: i }, scale: { configurable: !0, enumerable: !0, value: r }, modelViewMatrix: { value: new rN }, normalMatrix: { value: new iG } }), this.matrix = new rN, this.matrixWorld = new rN, this.matrixAutoUpdate = nt.DEFAULT_MATRIX_AUTO_UPDATE, this.matrixWorldAutoUpdate = nt.DEFAULT_MATRIX_WORLD_AUTO_UPDATE, this.matrixWorldNeedsUpdate = !1, this.layers = new rq, this.visible = !0, this.castShadow = !1, this.receiveShadow = !1, this.frustumCulled = !0, this.renderOrder = 0, this.animations = [], this.userData = {} } onBeforeShadow() { } onAfterShadow() { } onBeforeRender() { } onAfterRender() { } applyMatrix4(e) { this.matrixAutoUpdate && this.updateMatrix(), this.matrix.premultiply(e), this.matrix.decompose(this.position, this.quaternion, this.scale) } applyQuaternion(e) { return this.quaternion.premultiply(e), this } setRotationFromAxisAngle(e, t) { this.quaternion.setFromAxisAngle(e, t) } setRotationFromEuler(e) { this.quaternion.setFromEuler(e, !0) } setRotationFromMatrix(e) { this.quaternion.setFromRotationMatrix(e) } setRotationFromQuaternion(e) { this.quaternion.copy(e) } rotateOnAxis(e, t) { return r$.setFromAxisAngle(e, t), this.quaternion.multiply(r$), this } rotateOnWorldAxis(e, t) { return r$.setFromAxisAngle(e, t), this.quaternion.premultiply(r$), this } rotateX(e) { return this.rotateOnAxis(r4, e) } rotateY(e) { return this.rotateOnAxis(r5, e) } rotateZ(e) { return this.rotateOnAxis(r8, e) } translateOnAxis(e, t) { return rZ.copy(e).applyQuaternion(this.quaternion), this.position.add(rZ.multiplyScalar(t)), this } translateX(e) { return this.translateOnAxis(r4, e) } translateY(e) { return this.translateOnAxis(r5, e) } translateZ(e) { return this.translateOnAxis(r8, e) } localToWorld(e) { return this.updateWorldMatrix(!0, !1), e.applyMatrix4(this.matrixWorld) } worldToLocal(e) { return this.updateWorldMatrix(!0, !1), e.applyMatrix4(rJ.copy(this.matrixWorld).invert()) } lookAt(e, t, i) { e.isVector3 ? r0.copy(e) : r0.set(e, t, i); let r = this.parent; this.updateWorldMatrix(!0, !1), r1.setFromMatrixPosition(this.matrixWorld), this.isCamera || this.isLight ? rJ.lookAt(r1, r0, this.up) : rJ.lookAt(r0, r1, this.up), this.quaternion.setFromRotationMatrix(rJ), r && (rJ.extractRotation(r.matrixWorld), r$.setFromRotationMatrix(rJ), this.quaternion.premultiply(r$.invert())) } add(e) { if (arguments.length > 1) { for (let e = 0; e < arguments.length; e++)this.add(arguments[e]); return this } return e === this ? console.error("THREE.Object3D.add: object can't be added as a child of itself.", e) : e && e.isObject3D ? (e.removeFromParent(), e.parent = this, this.children.push(e), e.dispatchEvent(r6), r7.child = e, this.dispatchEvent(r7), r7.child = null) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", e), this } remove(e) { if (arguments.length > 1) { for (let e = 0; e < arguments.length; e++)this.remove(arguments[e]); return this } let t = this.children.indexOf(e); return -1 !== t && (e.parent = null, this.children.splice(t, 1), e.dispatchEvent(r9), ne.child = e, this.dispatchEvent(ne), ne.child = null), this } removeFromParent() { let e = this.parent; return null !== e && e.remove(this), this } clear() { return this.remove(...this.children) } attach(e) { return this.updateWorldMatrix(!0, !1), rJ.copy(this.matrixWorld).invert(), null !== e.parent && (e.parent.updateWorldMatrix(!0, !1), rJ.multiply(e.parent.matrixWorld)), e.applyMatrix4(rJ), e.removeFromParent(), e.parent = this, this.children.push(e), e.updateWorldMatrix(!1, !0), e.dispatchEvent(r6), r7.child = e, this.dispatchEvent(r7), r7.child = null, this } getObjectById(e) { return this.getObjectByProperty("id", e) } getObjectByName(e) { return this.getObjectByProperty("name", e) } getObjectByProperty(e, t) { if (this[e] === t) return this; for (let i = 0, r = this.children.length; i < r; i++) { let r = this.children[i].getObjectByProperty(e, t); if (void 0 !== r) return r } } getObjectsByProperty(e, t, i = []) { this[e] === t && i.push(this); let r = this.children; for (let n = 0, s = r.length; n < s; n++)r[n].getObjectsByProperty(e, t, i); return i } getWorldPosition(e) { return this.updateWorldMatrix(!0, !1), e.setFromMatrixPosition(this.matrixWorld) } getWorldQuaternion(e) { return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(r1, e, r2), e } getWorldScale(e) { return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(r1, r3, e), e } getWorldDirection(e) { this.updateWorldMatrix(!0, !1); let t = this.matrixWorld.elements; return e.set(t[8], t[9], t[10]).normalize() } raycast() { } traverse(e) { e(this); let t = this.children; for (let i = 0, r = t.length; i < r; i++)t[i].traverse(e) } traverseVisible(e) { if (!1 === this.visible) return; e(this); let t = this.children; for (let i = 0, r = t.length; i < r; i++)t[i].traverseVisible(e) } traverseAncestors(e) { let t = this.parent; null !== t && (e(t), t.traverseAncestors(e)) } updateMatrix() { this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0 } updateMatrixWorld(e) { this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || e) && (!0 === this.matrixWorldAutoUpdate && (null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix)), this.matrixWorldNeedsUpdate = !1, e = !0); let t = this.children; for (let i = 0, r = t.length; i < r; i++)t[i].updateMatrixWorld(e) } updateWorldMatrix(e, t) { let i = this.parent; if (!0 === e && null !== i && i.updateWorldMatrix(!0, !1), this.matrixAutoUpdate && this.updateMatrix(), !0 === this.matrixWorldAutoUpdate && (null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix)), !0 === t) { let e = this.children; for (let t = 0, i = e.length; t < i; t++)e[t].updateWorldMatrix(!1, !0) } } toJSON(e) { let t = void 0 === e || "string" == typeof e, i = {}; t && (e = { geometries: {}, materials: {}, textures: {}, images: {}, shapes: {}, skeletons: {}, animations: {}, nodes: {} }, i.metadata = { version: 4.6, type: "Object", generator: "Object3D.toJSON" }); let r = {}; function n(t, i) { return void 0 === t[i.uuid] && (t[i.uuid] = i.toJSON(e)), i.uuid } if (r.uuid = this.uuid, r.type = this.type, "" !== this.name && (r.name = this.name), !0 === this.castShadow && (r.castShadow = !0), !0 === this.receiveShadow && (r.receiveShadow = !0), !1 === this.visible && (r.visible = !1), !1 === this.frustumCulled && (r.frustumCulled = !1), 0 !== this.renderOrder && (r.renderOrder = this.renderOrder), Object.keys(this.userData).length > 0 && (r.userData = this.userData), r.layers = this.layers.mask, r.matrix = this.matrix.toArray(), r.up = this.up.toArray(), !1 === this.matrixAutoUpdate && (r.matrixAutoUpdate = !1), this.isInstancedMesh && (r.type = "InstancedMesh", r.count = this.count, r.instanceMatrix = this.instanceMatrix.toJSON(), null !== this.instanceColor && (r.instanceColor = this.instanceColor.toJSON())), this.isBatchedMesh && (r.type = "BatchedMesh", r.perObjectFrustumCulled = this.perObjectFrustumCulled, r.sortObjects = this.sortObjects, r.drawRanges = this._drawRanges, r.reservedRanges = this._reservedRanges, r.visibility = this._visibility, r.active = this._active, r.bounds = this._bounds.map(e => ({ boxInitialized: e.boxInitialized, boxMin: e.box.min.toArray(), boxMax: e.box.max.toArray(), sphereInitialized: e.sphereInitialized, sphereRadius: e.sphere.radius, sphereCenter: e.sphere.center.toArray() })), r.maxInstanceCount = this._maxInstanceCount, r.maxVertexCount = this._maxVertexCount, r.maxIndexCount = this._maxIndexCount, r.geometryInitialized = this._geometryInitialized, r.geometryCount = this._geometryCount, r.matricesTexture = this._matricesTexture.toJSON(e), null !== this._colorsTexture && (r.colorsTexture = this._colorsTexture.toJSON(e)), null !== this.boundingSphere && (r.boundingSphere = { center: r.boundingSphere.center.toArray(), radius: r.boundingSphere.radius }), null !== this.boundingBox && (r.boundingBox = { min: r.boundingBox.min.toArray(), max: r.boundingBox.max.toArray() })), this.isScene) this.background && (this.background.isColor ? r.background = this.background.toJSON() : this.background.isTexture && (r.background = this.background.toJSON(e).uuid)), this.environment && this.environment.isTexture && !0 !== this.environment.isRenderTargetTexture && (r.environment = this.environment.toJSON(e).uuid); else if (this.isMesh || this.isLine || this.isPoints) { r.geometry = n(e.geometries, this.geometry); let t = this.geometry.parameters; if (void 0 !== t && void 0 !== t.shapes) { let i = t.shapes; if (Array.isArray(i)) for (let t = 0, r = i.length; t < r; t++) { let r = i[t]; n(e.shapes, r) } else n(e.shapes, i) } } if (this.isSkinnedMesh && (r.bindMode = this.bindMode, r.bindMatrix = this.bindMatrix.toArray(), void 0 !== this.skeleton && (n(e.skeletons, this.skeleton), r.skeleton = this.skeleton.uuid)), void 0 !== this.material) { if (Array.isArray(this.material)) { let t = []; for (let i = 0, r = this.material.length; i < r; i++)t.push(n(e.materials, this.material[i])); r.material = t } else r.material = n(e.materials, this.material) } if (this.children.length > 0) { r.children = []; for (let t = 0; t < this.children.length; t++)r.children.push(this.children[t].toJSON(e).object) } if (this.animations.length > 0) { r.animations = []; for (let t = 0; t < this.animations.length; t++) { let i = this.animations[t]; r.animations.push(n(e.animations, i)) } } if (t) { let t = s(e.geometries), r = s(e.materials), n = s(e.textures), a = s(e.images), o = s(e.shapes), l = s(e.skeletons), u = s(e.animations), h = s(e.nodes); t.length > 0 && (i.geometries = t), r.length > 0 && (i.materials = r), n.length > 0 && (i.textures = n), a.length > 0 && (i.images = a), o.length > 0 && (i.shapes = o), l.length > 0 && (i.skeletons = l), u.length > 0 && (i.animations = u), h.length > 0 && (i.nodes = h) } return i.object = r, i; function s(e) { let t = []; for (let i in e) { let r = e[i]; delete r.metadata, t.push(r) } return t } } clone(e) { return new this.constructor().copy(this, e) } copy(e, t = !0) { if (this.name = e.name, this.up.copy(e.up), this.position.copy(e.position), this.rotation.order = e.rotation.order, this.quaternion.copy(e.quaternion), this.scale.copy(e.scale), this.matrix.copy(e.matrix), this.matrixWorld.copy(e.matrixWorld), this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrixWorldAutoUpdate = e.matrixWorldAutoUpdate, this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate, this.layers.mask = e.layers.mask, this.visible = e.visible, this.castShadow = e.castShadow, this.receiveShadow = e.receiveShadow, this.frustumCulled = e.frustumCulled, this.renderOrder = e.renderOrder, this.animations = e.animations.slice(), this.userData = JSON.parse(JSON.stringify(e.userData)), !0 === t) for (let t = 0; t < e.children.length; t++) { let i = e.children[t]; this.add(i.clone()) } return this } } nt.DEFAULT_UP = new rl(0, 1, 0), nt.DEFAULT_MATRIX_AUTO_UPDATE = !0, nt.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = !0; let ni = new rl, nr = new rl, nn = new rl, ns = new rl, na = new rl, no = new rl, nl = new rl, nu = new rl, nh = new rl, nc = new rl, nd = new re, nf = new re, np = new re; class nm { constructor(e = new rl, t = new rl, i = new rl) { this.a = e, this.b = t, this.c = i } static getNormal(e, t, i, r) { r.subVectors(i, t), ni.subVectors(e, t), r.cross(ni); let n = r.lengthSq(); return n > 0 ? r.multiplyScalar(1 / Math.sqrt(n)) : r.set(0, 0, 0) } static getBarycoord(e, t, i, r, n) { ni.subVectors(r, t), nr.subVectors(i, t), nn.subVectors(e, t); let s = ni.dot(ni), a = ni.dot(nr), o = ni.dot(nn), l = nr.dot(nr), u = nr.dot(nn), h = s * l - a * a; if (0 === h) return n.set(0, 0, 0), null; let c = 1 / h, d = (l * o - a * u) * c, f = (s * u - a * o) * c; return n.set(1 - d - f, f, d) } static containsPoint(e, t, i, r) { return null !== this.getBarycoord(e, t, i, r, ns) && ns.x >= 0 && ns.y >= 0 && ns.x + ns.y <= 1 } static getInterpolation(e, t, i, r, n, s, a, o) { return null === this.getBarycoord(e, t, i, r, ns) ? (o.x = 0, o.y = 0, "z" in o && (o.z = 0), "w" in o && (o.w = 0), null) : (o.setScalar(0), o.addScaledVector(n, ns.x), o.addScaledVector(s, ns.y), o.addScaledVector(a, ns.z), o) } static getInterpolatedAttribute(e, t, i, r, n, s) { return nd.setScalar(0), nf.setScalar(0), np.setScalar(0), nd.fromBufferAttribute(e, t), nf.fromBufferAttribute(e, i), np.fromBufferAttribute(e, r), s.setScalar(0), s.addScaledVector(nd, n.x), s.addScaledVector(nf, n.y), s.addScaledVector(np, n.z), s } static isFrontFacing(e, t, i, r) { return ni.subVectors(i, t), nr.subVectors(e, t), 0 > ni.cross(nr).dot(r) } set(e, t, i) { return this.a.copy(e), this.b.copy(t), this.c.copy(i), this } setFromPointsAndIndices(e, t, i, r) { return this.a.copy(e[t]), this.b.copy(e[i]), this.c.copy(e[r]), this } setFromAttributeAndIndices(e, t, i, r) { return this.a.fromBufferAttribute(e, t), this.b.fromBufferAttribute(e, i), this.c.fromBufferAttribute(e, r), this } clone() { return new this.constructor().copy(this) } copy(e) { return this.a.copy(e.a), this.b.copy(e.b), this.c.copy(e.c), this } getArea() { return ni.subVectors(this.c, this.b), nr.subVectors(this.a, this.b), .5 * ni.cross(nr).length() } getMidpoint(e) { return e.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3) } getNormal(e) { return nm.getNormal(this.a, this.b, this.c, e) } getPlane(e) { return e.setFromCoplanarPoints(this.a, this.b, this.c) } getBarycoord(e, t) { return nm.getBarycoord(e, this.a, this.b, this.c, t) } getInterpolation(e, t, i, r, n) { return nm.getInterpolation(e, this.a, this.b, this.c, t, i, r, n) } containsPoint(e) { return nm.containsPoint(e, this.a, this.b, this.c) } isFrontFacing(e) { return nm.isFrontFacing(this.a, this.b, this.c, e) } intersectsBox(e) { return e.intersectsTriangle(this) } closestPointToPoint(e, t) { let i, r; let n = this.a, s = this.b, a = this.c; na.subVectors(s, n), no.subVectors(a, n), nu.subVectors(e, n); let o = na.dot(nu), l = no.dot(nu); if (o <= 0 && l <= 0) return t.copy(n); nh.subVectors(e, s); let u = na.dot(nh), h = no.dot(nh); if (u >= 0 && h <= u) return t.copy(s); let c = o * h - u * l; if (c <= 0 && o >= 0 && u <= 0) return i = o / (o - u), t.copy(n).addScaledVector(na, i); nc.subVectors(e, a); let d = na.dot(nc), f = no.dot(nc); if (f >= 0 && d <= f) return t.copy(a); let p = d * l - o * f; if (p <= 0 && l >= 0 && f <= 0) return r = l / (l - f), t.copy(n).addScaledVector(no, r); let m = u * f - d * h; if (m <= 0 && h - u >= 0 && d - f >= 0) return nl.subVectors(a, s), r = (h - u) / (h - u + (d - f)), t.copy(s).addScaledVector(nl, r); let g = 1 / (m + p + c); return i = p * g, r = c * g, t.copy(n).addScaledVector(na, i).addScaledVector(no, r) } equals(e) { return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c) } } let ng = { aliceblue: 0xf0f8ff, antiquewhite: 0xfaebd7, aqua: 65535, aquamarine: 8388564, azure: 0xf0ffff, beige: 0xf5f5dc, bisque: 0xffe4c4, black: 0, blanchedalmond: 0xffebcd, blue: 255, blueviolet: 9055202, brown: 0xa52a2a, burlywood: 0xdeb887, cadetblue: 6266528, chartreuse: 8388352, chocolate: 0xd2691e, coral: 0xff7f50, cornflowerblue: 6591981, cornsilk: 0xfff8dc, crimson: 0xdc143c, cyan: 65535, darkblue: 139, darkcyan: 35723, darkgoldenrod: 0xb8860b, darkgray: 0xa9a9a9, darkgreen: 25600, darkgrey: 0xa9a9a9, darkkhaki: 0xbdb76b, darkmagenta: 9109643, darkolivegreen: 5597999, darkorange: 0xff8c00, darkorchid: 0x9932cc, darkred: 9109504, darksalmon: 0xe9967a, darkseagreen: 9419919, darkslateblue: 4734347, darkslategray: 3100495, darkslategrey: 3100495, darkturquoise: 52945, darkviolet: 9699539, deeppink: 0xff1493, deepskyblue: 49151, dimgray: 6908265, dimgrey: 6908265, dodgerblue: 2003199, firebrick: 0xb22222, floralwhite: 0xfffaf0, forestgreen: 2263842, fuchsia: 0xff00ff, gainsboro: 0xdcdcdc, ghostwhite: 0xf8f8ff, gold: 0xffd700, goldenrod: 0xdaa520, gray: 8421504, green: 32768, greenyellow: 0xadff2f, grey: 8421504, honeydew: 0xf0fff0, hotpink: 0xff69b4, indianred: 0xcd5c5c, indigo: 4915330, ivory: 0xfffff0, khaki: 0xf0e68c, lavender: 0xe6e6fa, lavenderblush: 0xfff0f5, lawngreen: 8190976, lemonchiffon: 0xfffacd, lightblue: 0xadd8e6, lightcoral: 0xf08080, lightcyan: 0xe0ffff, lightgoldenrodyellow: 0xfafad2, lightgray: 0xd3d3d3, lightgreen: 9498256, lightgrey: 0xd3d3d3, lightpink: 0xffb6c1, lightsalmon: 0xffa07a, lightseagreen: 2142890, lightskyblue: 8900346, lightslategray: 7833753, lightslategrey: 7833753, lightsteelblue: 0xb0c4de, lightyellow: 0xffffe0, lime: 65280, limegreen: 3329330, linen: 0xfaf0e6, magenta: 0xff00ff, maroon: 8388608, mediumaquamarine: 6737322, mediumblue: 205, mediumorchid: 0xba55d3, mediumpurple: 9662683, mediumseagreen: 3978097, mediumslateblue: 8087790, mediumspringgreen: 64154, mediumturquoise: 4772300, mediumvioletred: 0xc71585, midnightblue: 1644912, mintcream: 0xf5fffa, mistyrose: 0xffe4e1, moccasin: 0xffe4b5, navajowhite: 0xffdead, navy: 128, oldlace: 0xfdf5e6, olive: 8421376, olivedrab: 7048739, orange: 0xffa500, orangered: 0xff4500, orchid: 0xda70d6, palegoldenrod: 0xeee8aa, palegreen: 0x98fb98, paleturquoise: 0xafeeee, palevioletred: 0xdb7093, papayawhip: 0xffefd5, peachpuff: 0xffdab9, peru: 0xcd853f, pink: 0xffc0cb, plum: 0xdda0dd, powderblue: 0xb0e0e6, purple: 8388736, rebeccapurple: 6697881, red: 0xff0000, rosybrown: 0xbc8f8f, royalblue: 4286945, saddlebrown: 9127187, salmon: 0xfa8072, sandybrown: 0xf4a460, seagreen: 3050327, seashell: 0xfff5ee, sienna: 0xa0522d, silver: 0xc0c0c0, skyblue: 8900331, slateblue: 6970061, slategray: 7372944, slategrey: 7372944, snow: 0xfffafa, springgreen: 65407, steelblue: 4620980, tan: 0xd2b48c, teal: 32896, thistle: 0xd8bfd8, tomato: 0xff6347, turquoise: 4251856, violet: 0xee82ee, wheat: 0xf5deb3, white: 0xffffff, whitesmoke: 0xf5f5f5, yellow: 0xffff00, yellowgreen: 0x9acd32 }, nv = { h: 0, s: 0, l: 0 }, ny = { h: 0, s: 0, l: 0 }; function nx(e, t, i) { return (i < 0 && (i += 1), i > 1 && (i -= 1), i < 1 / 6) ? e + (t - e) * 6 * i : i < .5 ? t : i < 2 / 3 ? e + (t - e) * 6 * (2 / 3 - i) : e } class nS { constructor(e, t, i) { return this.isColor = !0, this.r = 1, this.g = 1, this.b = 1, this.set(e, t, i) } set(e, t, i) { return void 0 === t && void 0 === i ? e && e.isColor ? this.copy(e) : "number" == typeof e ? this.setHex(e) : "string" == typeof e && this.setStyle(e) : this.setRGB(e, t, i), this } setScalar(e) { return this.r = e, this.g = e, this.b = e, this } setHex(e, t = tK) { return e = Math.floor(e), this.r = (e >> 16 & 255) / 255, this.g = (e >> 8 & 255) / 255, this.b = (255 & e) / 255, i1.toWorkingColorSpace(this, t), this } setRGB(e, t, i, r = i1.workingColorSpace) { return this.r = e, this.g = t, this.b = i, i1.toWorkingColorSpace(this, r), this } setHSL(e, t, i, r = i1.workingColorSpace) { if (e = ik(e, 1), t = iO(t, 0, 1), i = iO(i, 0, 1), 0 === t) this.r = this.g = this.b = i; else { let r = i <= .5 ? i * (1 + t) : i + t - i * t, n = 2 * i - r; this.r = nx(n, r, e + 1 / 3), this.g = nx(n, r, e), this.b = nx(n, r, e - 1 / 3) } return i1.toWorkingColorSpace(this, r), this } setStyle(e, t = tK) { let i; function r(t) { void 0 !== t && 1 > parseFloat(t) && console.warn("THREE.Color: Alpha component of " + e + " will be ignored.") } if (i = /^(\w+)\(([^\)]*)\)/.exec(e)) { let n; let s = i[1], a = i[2]; switch (s) { case "rgb": case "rgba": if (n = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a)) return r(n[4]), this.setRGB(Math.min(255, parseInt(n[1], 10)) / 255, Math.min(255, parseInt(n[2], 10)) / 255, Math.min(255, parseInt(n[3], 10)) / 255, t); if (n = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a)) return r(n[4]), this.setRGB(Math.min(100, parseInt(n[1], 10)) / 100, Math.min(100, parseInt(n[2], 10)) / 100, Math.min(100, parseInt(n[3], 10)) / 100, t); break; case "hsl": case "hsla": if (n = /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a)) return r(n[4]), this.setHSL(parseFloat(n[1]) / 360, parseFloat(n[2]) / 100, parseFloat(n[3]) / 100, t); break; default: console.warn("THREE.Color: Unknown color model " + e) } } else if (i = /^\#([A-Fa-f\d]+)$/.exec(e)) { let r = i[1], n = r.length; if (3 === n) return this.setRGB(parseInt(r.charAt(0), 16) / 15, parseInt(r.charAt(1), 16) / 15, parseInt(r.charAt(2), 16) / 15, t); if (6 === n) return this.setHex(parseInt(r, 16), t); console.warn("THREE.Color: Invalid hex color " + e) } else if (e && e.length > 0) return this.setColorName(e, t); return this } setColorName(e, t = tK) { let i = ng[e.toLowerCase()]; return void 0 !== i ? this.setHex(i, t) : console.warn("THREE.Color: Unknown color " + e), this } clone() { return new this.constructor(this.r, this.g, this.b) } copy(e) { return this.r = e.r, this.g = e.g, this.b = e.b, this } copySRGBToLinear(e) { return this.r = i2(e.r), this.g = i2(e.g), this.b = i2(e.b), this } copyLinearToSRGB(e) { return this.r = i3(e.r), this.g = i3(e.g), this.b = i3(e.b), this } convertSRGBToLinear() { return this.copySRGBToLinear(this), this } convertLinearToSRGB() { return this.copyLinearToSRGB(this), this } getHex(e = tK) { return i1.fromWorkingColorSpace(nA.copy(this), e), 65536 * Math.round(iO(255 * nA.r, 0, 255)) + 256 * Math.round(iO(255 * nA.g, 0, 255)) + Math.round(iO(255 * nA.b, 0, 255)) } getHexString(e = tK) { return ("000000" + this.getHex(e).toString(16)).slice(-6) } getHSL(e, t = i1.workingColorSpace) { let i, r; i1.fromWorkingColorSpace(nA.copy(this), t); let n = nA.r, s = nA.g, a = nA.b, o = Math.max(n, s, a), l = Math.min(n, s, a), u = (l + o) / 2; if (l === o) i = 0, r = 0; else { let e = o - l; switch (r = u <= .5 ? e / (o + l) : e / (2 - o - l), o) { case n: i = (s - a) / e + (s < a ? 6 : 0); break; case s: i = (a - n) / e + 2; break; case a: i = (n - s) / e + 4 }i /= 6 } return e.h = i, e.s = r, e.l = u, e } getRGB(e, t = i1.workingColorSpace) { return i1.fromWorkingColorSpace(nA.copy(this), t), e.r = nA.r, e.g = nA.g, e.b = nA.b, e } getStyle(e = tK) { i1.fromWorkingColorSpace(nA.copy(this), e); let t = nA.r, i = nA.g, r = nA.b; return e !== tK ? `color(${e} ${t.toFixed(3)} ${i.toFixed(3)} ${r.toFixed(3)})` : `rgb(${Math.round(255 * t)},${Math.round(255 * i)},${Math.round(255 * r)})` } offsetHSL(e, t, i) { return this.getHSL(nv), this.setHSL(nv.h + e, nv.s + t, nv.l + i) } add(e) { return this.r += e.r, this.g += e.g, this.b += e.b, this } addColors(e, t) { return this.r = e.r + t.r, this.g = e.g + t.g, this.b = e.b + t.b, this } addScalar(e) { return this.r += e, this.g += e, this.b += e, this } sub(e) { return this.r = Math.max(0, this.r - e.r), this.g = Math.max(0, this.g - e.g), this.b = Math.max(0, this.b - e.b), this } multiply(e) { return this.r *= e.r, this.g *= e.g, this.b *= e.b, this } multiplyScalar(e) { return this.r *= e, this.g *= e, this.b *= e, this } lerp(e, t) { return this.r += (e.r - this.r) * t, this.g += (e.g - this.g) * t, this.b += (e.b - this.b) * t, this } lerpColors(e, t, i) { return this.r = e.r + (t.r - e.r) * i, this.g = e.g + (t.g - e.g) * i, this.b = e.b + (t.b - e.b) * i, this } lerpHSL(e, t) { this.getHSL(nv), e.getHSL(ny); let i = iF(nv.h, ny.h, t), r = iF(nv.s, ny.s, t), n = iF(nv.l, ny.l, t); return this.setHSL(i, r, n), this } setFromVector3(e) { return this.r = e.x, this.g = e.y, this.b = e.z, this } applyMatrix3(e) { let t = this.r, i = this.g, r = this.b, n = e.elements; return this.r = n[0] * t + n[3] * i + n[6] * r, this.g = n[1] * t + n[4] * i + n[7] * r, this.b = n[2] * t + n[5] * i + n[8] * r, this } equals(e) { return e.r === this.r && e.g === this.g && e.b === this.b } fromArray(e, t = 0) { return this.r = e[t], this.g = e[t + 1], this.b = e[t + 2], this } toArray(e = [], t = 0) { return e[t] = this.r, e[t + 1] = this.g, e[t + 2] = this.b, e } fromBufferAttribute(e, t) { return this.r = e.getX(t), this.g = e.getY(t), this.b = e.getZ(t), this } toJSON() { return this.getHex() } *[Symbol.iterator]() { yield this.r, yield this.g, yield this.b } } let nA = new nS; nS.NAMES = ng; let n_ = 0; class nE extends iR { constructor() { super(), this.isMaterial = !0, Object.defineProperty(this, "id", { value: n_++ }), this.uuid = iD(), this.name = "", this.type = "Material", this.blending = E, this.side = x, this.vertexColors = !1, this.opacity = 1, this.transparent = !1, this.alphaHash = !1, this.blendSrc = U, this.blendDst = N, this.blendEquation = R, this.blendSrcAlpha = null, this.blendDstAlpha = null, this.blendEquationAlpha = null, this.blendColor = new nS(0, 0, 0), this.blendAlpha = 0, this.depthFunc = Z, this.depthTest = !0, this.depthWrite = !0, this.stencilWriteMask = 255, this.stencilFunc = ir, this.stencilRef = 0, this.stencilFuncMask = 255, this.stencilFail = tJ, this.stencilZFail = tJ, this.stencilZPass = tJ, this.stencilWrite = !1, this.clippingPlanes = null, this.clipIntersection = !1, this.clipShadows = !1, this.shadowSide = null, this.colorWrite = !0, this.precision = null, this.polygonOffset = !1, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.dithering = !1, this.alphaToCoverage = !1, this.premultipliedAlpha = !1, this.forceSinglePass = !1, this.visible = !0, this.toneMapped = !0, this.userData = {}, this.version = 0, this._alphaTest = 0 } get alphaTest() { return this._alphaTest } set alphaTest(e) { this._alphaTest > 0 != e > 0 && this.version++, this._alphaTest = e } onBeforeRender() { } onBeforeCompile() { } customProgramCacheKey() { return this.onBeforeCompile.toString() } setValues(e) { if (void 0 !== e) for (let t in e) { let i = e[t]; if (void 0 === i) { console.warn(`THREE.Material: parameter '${t}' has value of undefined.`); continue } let r = this[t]; if (void 0 === r) { console.warn(`THREE.Material: '${t}' is not a property of THREE.${this.type}.`); continue } r && r.isColor ? r.set(i) : r && r.isVector3 && i && i.isVector3 ? r.copy(i) : this[t] = i } } toJSON(e) { let t = void 0 === e || "string" == typeof e; t && (e = { textures: {}, images: {} }); let i = { metadata: { version: 4.6, type: "Material", generator: "Material.toJSON" } }; function r(e) { let t = []; for (let i in e) { let r = e[i]; delete r.metadata, t.push(r) } return t } if (i.uuid = this.uuid, i.type = this.type, "" !== this.name && (i.name = this.name), this.color && this.color.isColor && (i.color = this.color.getHex()), void 0 !== this.roughness && (i.roughness = this.roughness), void 0 !== this.metalness && (i.metalness = this.metalness), void 0 !== this.sheen && (i.sheen = this.sheen), this.sheenColor && this.sheenColor.isColor && (i.sheenColor = this.sheenColor.getHex()), void 0 !== this.sheenRoughness && (i.sheenRoughness = this.sheenRoughness), this.emissive && this.emissive.isColor && (i.emissive = this.emissive.getHex()), void 0 !== this.emissiveIntensity && 1 !== this.emissiveIntensity && (i.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (i.specular = this.specular.getHex()), void 0 !== this.specularIntensity && (i.specularIntensity = this.specularIntensity), this.specularColor && this.specularColor.isColor && (i.specularColor = this.specularColor.getHex()), void 0 !== this.shininess && (i.shininess = this.shininess), void 0 !== this.clearcoat && (i.clearcoat = this.clearcoat), void 0 !== this.clearcoatRoughness && (i.clearcoatRoughness = this.clearcoatRoughness), this.clearcoatMap && this.clearcoatMap.isTexture && (i.clearcoatMap = this.clearcoatMap.toJSON(e).uuid), this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (i.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(e).uuid), this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (i.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(e).uuid, i.clearcoatNormalScale = this.clearcoatNormalScale.toArray()), void 0 !== this.dispersion && (i.dispersion = this.dispersion), void 0 !== this.iridescence && (i.iridescence = this.iridescence), void 0 !== this.iridescenceIOR && (i.iridescenceIOR = this.iridescenceIOR), void 0 !== this.iridescenceThicknessRange && (i.iridescenceThicknessRange = this.iridescenceThicknessRange), this.iridescenceMap && this.iridescenceMap.isTexture && (i.iridescenceMap = this.iridescenceMap.toJSON(e).uuid), this.iridescenceThicknessMap && this.iridescenceThicknessMap.isTexture && (i.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON(e).uuid), void 0 !== this.anisotropy && (i.anisotropy = this.anisotropy), void 0 !== this.anisotropyRotation && (i.anisotropyRotation = this.anisotropyRotation), this.anisotropyMap && this.anisotropyMap.isTexture && (i.anisotropyMap = this.anisotropyMap.toJSON(e).uuid), this.map && this.map.isTexture && (i.map = this.map.toJSON(e).uuid), this.matcap && this.matcap.isTexture && (i.matcap = this.matcap.toJSON(e).uuid), this.alphaMap && this.alphaMap.isTexture && (i.alphaMap = this.alphaMap.toJSON(e).uuid), this.lightMap && this.lightMap.isTexture && (i.lightMap = this.lightMap.toJSON(e).uuid, i.lightMapIntensity = this.lightMapIntensity), this.aoMap && this.aoMap.isTexture && (i.aoMap = this.aoMap.toJSON(e).uuid, i.aoMapIntensity = this.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (i.bumpMap = this.bumpMap.toJSON(e).uuid, i.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (i.normalMap = this.normalMap.toJSON(e).uuid, i.normalMapType = this.normalMapType, i.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (i.displacementMap = this.displacementMap.toJSON(e).uuid, i.displacementScale = this.displacementScale, i.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (i.roughnessMap = this.roughnessMap.toJSON(e).uuid), this.metalnessMap && this.metalnessMap.isTexture && (i.metalnessMap = this.metalnessMap.toJSON(e).uuid), this.emissiveMap && this.emissiveMap.isTexture && (i.emissiveMap = this.emissiveMap.toJSON(e).uuid), this.specularMap && this.specularMap.isTexture && (i.specularMap = this.specularMap.toJSON(e).uuid), this.specularIntensityMap && this.specularIntensityMap.isTexture && (i.specularIntensityMap = this.specularIntensityMap.toJSON(e).uuid), this.specularColorMap && this.specularColorMap.isTexture && (i.specularColorMap = this.specularColorMap.toJSON(e).uuid), this.envMap && this.envMap.isTexture && (i.envMap = this.envMap.toJSON(e).uuid, void 0 !== this.combine && (i.combine = this.combine)), void 0 !== this.envMapRotation && (i.envMapRotation = this.envMapRotation.toArray()), void 0 !== this.envMapIntensity && (i.envMapIntensity = this.envMapIntensity), void 0 !== this.reflectivity && (i.reflectivity = this.reflectivity), void 0 !== this.refractionRatio && (i.refractionRatio = this.refractionRatio), this.gradientMap && this.gradientMap.isTexture && (i.gradientMap = this.gradientMap.toJSON(e).uuid), void 0 !== this.transmission && (i.transmission = this.transmission), this.transmissionMap && this.transmissionMap.isTexture && (i.transmissionMap = this.transmissionMap.toJSON(e).uuid), void 0 !== this.thickness && (i.thickness = this.thickness), this.thicknessMap && this.thicknessMap.isTexture && (i.thicknessMap = this.thicknessMap.toJSON(e).uuid), void 0 !== this.attenuationDistance && this.attenuationDistance !== 1 / 0 && (i.attenuationDistance = this.attenuationDistance), void 0 !== this.attenuationColor && (i.attenuationColor = this.attenuationColor.getHex()), void 0 !== this.size && (i.size = this.size), null !== this.shadowSide && (i.shadowSide = this.shadowSide), void 0 !== this.sizeAttenuation && (i.sizeAttenuation = this.sizeAttenuation), this.blending !== E && (i.blending = this.blending), this.side !== x && (i.side = this.side), !0 === this.vertexColors && (i.vertexColors = !0), this.opacity < 1 && (i.opacity = this.opacity), !0 === this.transparent && (i.transparent = !0), this.blendSrc !== U && (i.blendSrc = this.blendSrc), this.blendDst !== N && (i.blendDst = this.blendDst), this.blendEquation !== R && (i.blendEquation = this.blendEquation), null !== this.blendSrcAlpha && (i.blendSrcAlpha = this.blendSrcAlpha), null !== this.blendDstAlpha && (i.blendDstAlpha = this.blendDstAlpha), null !== this.blendEquationAlpha && (i.blendEquationAlpha = this.blendEquationAlpha), this.blendColor && this.blendColor.isColor && (i.blendColor = this.blendColor.getHex()), 0 !== this.blendAlpha && (i.blendAlpha = this.blendAlpha), this.depthFunc !== Z && (i.depthFunc = this.depthFunc), !1 === this.depthTest && (i.depthTest = this.depthTest), !1 === this.depthWrite && (i.depthWrite = this.depthWrite), !1 === this.colorWrite && (i.colorWrite = this.colorWrite), 255 !== this.stencilWriteMask && (i.stencilWriteMask = this.stencilWriteMask), this.stencilFunc !== ir && (i.stencilFunc = this.stencilFunc), 0 !== this.stencilRef && (i.stencilRef = this.stencilRef), 255 !== this.stencilFuncMask && (i.stencilFuncMask = this.stencilFuncMask), this.stencilFail !== tJ && (i.stencilFail = this.stencilFail), this.stencilZFail !== tJ && (i.stencilZFail = this.stencilZFail), this.stencilZPass !== tJ && (i.stencilZPass = this.stencilZPass), !0 === this.stencilWrite && (i.stencilWrite = this.stencilWrite), void 0 !== this.rotation && 0 !== this.rotation && (i.rotation = this.rotation), !0 === this.polygonOffset && (i.polygonOffset = !0), 0 !== this.polygonOffsetFactor && (i.polygonOffsetFactor = this.polygonOffsetFactor), 0 !== this.polygonOffsetUnits && (i.polygonOffsetUnits = this.polygonOffsetUnits), void 0 !== this.linewidth && 1 !== this.linewidth && (i.linewidth = this.linewidth), void 0 !== this.dashSize && (i.dashSize = this.dashSize), void 0 !== this.gapSize && (i.gapSize = this.gapSize), void 0 !== this.scale && (i.scale = this.scale), !0 === this.dithering && (i.dithering = !0), this.alphaTest > 0 && (i.alphaTest = this.alphaTest), !0 === this.alphaHash && (i.alphaHash = !0), !0 === this.alphaToCoverage && (i.alphaToCoverage = !0), !0 === this.premultipliedAlpha && (i.premultipliedAlpha = !0), !0 === this.forceSinglePass && (i.forceSinglePass = !0), !0 === this.wireframe && (i.wireframe = !0), this.wireframeLinewidth > 1 && (i.wireframeLinewidth = this.wireframeLinewidth), "round" !== this.wireframeLinecap && (i.wireframeLinecap = this.wireframeLinecap), "round" !== this.wireframeLinejoin && (i.wireframeLinejoin = this.wireframeLinejoin), !0 === this.flatShading && (i.flatShading = !0), !1 === this.visible && (i.visible = !1), !1 === this.toneMapped && (i.toneMapped = !1), !1 === this.fog && (i.fog = !1), Object.keys(this.userData).length > 0 && (i.userData = this.userData), t) { let t = r(e.textures), n = r(e.images); t.length > 0 && (i.textures = t), n.length > 0 && (i.images = n) } return i } clone() { return new this.constructor().copy(this) } copy(e) { this.name = e.name, this.blending = e.blending, this.side = e.side, this.vertexColors = e.vertexColors, this.opacity = e.opacity, this.transparent = e.transparent, this.blendSrc = e.blendSrc, this.blendDst = e.blendDst, this.blendEquation = e.blendEquation, this.blendSrcAlpha = e.blendSrcAlpha, this.blendDstAlpha = e.blendDstAlpha, this.blendEquationAlpha = e.blendEquationAlpha, this.blendColor.copy(e.blendColor), this.blendAlpha = e.blendAlpha, this.depthFunc = e.depthFunc, this.depthTest = e.depthTest, this.depthWrite = e.depthWrite, this.stencilWriteMask = e.stencilWriteMask, this.stencilFunc = e.stencilFunc, this.stencilRef = e.stencilRef, this.stencilFuncMask = e.stencilFuncMask, this.stencilFail = e.stencilFail, this.stencilZFail = e.stencilZFail, this.stencilZPass = e.stencilZPass, this.stencilWrite = e.stencilWrite; let t = e.clippingPlanes, i = null; if (null !== t) { let e = t.length; i = Array(e); for (let r = 0; r !== e; ++r)i[r] = t[r].clone() } return this.clippingPlanes = i, this.clipIntersection = e.clipIntersection, this.clipShadows = e.clipShadows, this.shadowSide = e.shadowSide, this.colorWrite = e.colorWrite, this.precision = e.precision, this.polygonOffset = e.polygonOffset, this.polygonOffsetFactor = e.polygonOffsetFactor, this.polygonOffsetUnits = e.polygonOffsetUnits, this.dithering = e.dithering, this.alphaTest = e.alphaTest, this.alphaHash = e.alphaHash, this.alphaToCoverage = e.alphaToCoverage, this.premultipliedAlpha = e.premultipliedAlpha, this.forceSinglePass = e.forceSinglePass, this.visible = e.visible, this.toneMapped = e.toneMapped, this.userData = JSON.parse(JSON.stringify(e.userData)), this } dispose() { this.dispatchEvent({ type: "dispose" }) } set needsUpdate(e) { !0 === e && this.version++ } onBuild() { console.warn("Material: onBuild() has been removed.") } } class nb extends nE { constructor(e) { super(), this.isMeshBasicMaterial = !0, this.type = "MeshBasicMaterial", this.color = new nS(0xffffff), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.envMapRotation = new rK, this.combine = ei, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.fog = !0, this.setValues(e) } copy(e) { return super.copy(e), this.color.copy(e.color), this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.envMapRotation.copy(e.envMapRotation), this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.fog = e.fog, this } } let nT = function () { let e = new ArrayBuffer(4), t = new Float32Array(e), i = new Uint32Array(e), r = new Uint32Array(512), n = new Uint32Array(512); for (let e = 0; e < 256; ++e) { let t = e - 127; t < -27 ? (r[e] = 0, r[256 | e] = 32768, n[e] = 24, n[256 | e] = 24) : t < -14 ? (r[e] = 1024 >> -t - 14, r[256 | e] = 1024 >> -t - 14 | 32768, n[e] = -t - 1, n[256 | e] = -t - 1) : t <= 15 ? (r[e] = t + 15 << 10, r[256 | e] = t + 15 << 10 | 32768, n[e] = 13, n[256 | e] = 13) : t < 128 ? (r[e] = 31744, r[256 | e] = 64512, n[e] = 24, n[256 | e] = 24) : (r[e] = 31744, r[256 | e] = 64512, n[e] = 13, n[256 | e] = 13) } let s = new Uint32Array(2048), a = new Uint32Array(64), o = new Uint32Array(64); for (let e = 1; e < 1024; ++e) { let t = e << 13, i = 0; for (; (8388608 & t) == 0;)t <<= 1, i -= 8388608; t &= -8388609, i += 0x38800000, s[e] = t | i } for (let e = 1024; e < 2048; ++e)s[e] = 0x38000000 + (e - 1024 << 13); for (let e = 1; e < 31; ++e)a[e] = e << 23; a[31] = 0x47800000, a[32] = 0x80000000; for (let e = 33; e < 63; ++e)a[e] = 0x80000000 + (e - 32 << 23); a[63] = 0xc7800000; for (let e = 1; e < 64; ++e)32 !== e && (o[e] = 1024); return { floatView: t, uint32View: i, baseTable: r, shiftTable: n, mantissaTable: s, exponentTable: a, offsetTable: o } }(); function nw(e) { Math.abs(e) > 65504 && console.warn("THREE.DataUtils.toHalfFloat(): Value out of range."), e = iO(e, -65504, 65504), nT.floatView[0] = e; let t = nT.uint32View[0], i = t >> 23 & 511; return nT.baseTable[i] + ((8388607 & t) >> nT.shiftTable[i]) } function nM(e) { let t = e >> 10; return nT.uint32View[0] = nT.mantissaTable[nT.offsetTable[t] + (1023 & e)] + nT.exponentTable[t], nT.floatView[0] } class nR { static toHalfFloat(e) { return nw(e) } static fromHalfFloat(e) { return nM(e) } } let nC = new rl, nI = new iz, nL = 0; class nP { constructor(e, t, i = !1) { if (Array.isArray(e)) throw TypeError("THREE.BufferAttribute: array should be a Typed Array."); this.isBufferAttribute = !0, Object.defineProperty(this, "id", { value: nL++ }), this.name = "", this.array = e, this.itemSize = t, this.count = void 0 !== e ? e.length / t : 0, this.normalized = i, this.usage = ip, this.updateRanges = [], this.gpuType = ez, this.version = 0 } onUploadCallback() { } set needsUpdate(e) { !0 === e && this.version++ } setUsage(e) { return this.usage = e, this } addUpdateRange(e, t) { this.updateRanges.push({ start: e, count: t }) } clearUpdateRanges() { this.updateRanges.length = 0 } copy(e) { return this.name = e.name, this.array = new e.array.constructor(e.array), this.itemSize = e.itemSize, this.count = e.count, this.normalized = e.normalized, this.usage = e.usage, this.gpuType = e.gpuType, this } copyAt(e, t, i) { e *= this.itemSize, i *= t.itemSize; for (let r = 0, n = this.itemSize; r < n; r++)this.array[e + r] = t.array[i + r]; return this } copyArray(e) { return this.array.set(e), this } applyMatrix3(e) { if (2 === this.itemSize) for (let t = 0, i = this.count; t < i; t++)nI.fromBufferAttribute(this, t), nI.applyMatrix3(e), this.setXY(t, nI.x, nI.y); else if (3 === this.itemSize) for (let t = 0, i = this.count; t < i; t++)nC.fromBufferAttribute(this, t), nC.applyMatrix3(e), this.setXYZ(t, nC.x, nC.y, nC.z); return this } applyMatrix4(e) { for (let t = 0, i = this.count; t < i; t++)nC.fromBufferAttribute(this, t), nC.applyMatrix4(e), this.setXYZ(t, nC.x, nC.y, nC.z); return this } applyNormalMatrix(e) { for (let t = 0, i = this.count; t < i; t++)nC.fromBufferAttribute(this, t), nC.applyNormalMatrix(e), this.setXYZ(t, nC.x, nC.y, nC.z); return this } transformDirection(e) { for (let t = 0, i = this.count; t < i; t++)nC.fromBufferAttribute(this, t), nC.transformDirection(e), this.setXYZ(t, nC.x, nC.y, nC.z); return this } set(e, t = 0) { return this.array.set(e, t), this } getComponent(e, t) { let i = this.array[e * this.itemSize + t]; return this.normalized && (i = iU(i, this.array)), i } setComponent(e, t, i) { return this.normalized && (i = iN(i, this.array)), this.array[e * this.itemSize + t] = i, this } getX(e) { let t = this.array[e * this.itemSize]; return this.normalized && (t = iU(t, this.array)), t } setX(e, t) { return this.normalized && (t = iN(t, this.array)), this.array[e * this.itemSize] = t, this } getY(e) { let t = this.array[e * this.itemSize + 1]; return this.normalized && (t = iU(t, this.array)), t } setY(e, t) { return this.normalized && (t = iN(t, this.array)), this.array[e * this.itemSize + 1] = t, this } getZ(e) { let t = this.array[e * this.itemSize + 2]; return this.normalized && (t = iU(t, this.array)), t } setZ(e, t) { return this.normalized && (t = iN(t, this.array)), this.array[e * this.itemSize + 2] = t, this } getW(e) { let t = this.array[e * this.itemSize + 3]; return this.normalized && (t = iU(t, this.array)), t } setW(e, t) { return this.normalized && (t = iN(t, this.array)), this.array[e * this.itemSize + 3] = t, this } setXY(e, t, i) { return e *= this.itemSize, this.normalized && (t = iN(t, this.array), i = iN(i, this.array)), this.array[e + 0] = t, this.array[e + 1] = i, this } setXYZ(e, t, i, r) { return e *= this.itemSize, this.normalized && (t = iN(t, this.array), i = iN(i, this.array), r = iN(r, this.array)), this.array[e + 0] = t, this.array[e + 1] = i, this.array[e + 2] = r, this } setXYZW(e, t, i, r, n) { return e *= this.itemSize, this.normalized && (t = iN(t, this.array), i = iN(i, this.array), r = iN(r, this.array), n = iN(n, this.array)), this.array[e + 0] = t, this.array[e + 1] = i, this.array[e + 2] = r, this.array[e + 3] = n, this } onUpload(e) { return this.onUploadCallback = e, this } clone() { return new this.constructor(this.array, this.itemSize).copy(this) } toJSON() { let e = { itemSize: this.itemSize, type: this.array.constructor.name, array: Array.from(this.array), normalized: this.normalized }; return "" !== this.name && (e.name = this.name), this.usage !== ip && (e.usage = this.usage), e } } class nD extends nP { constructor(e, t, i) { super(new Int8Array(e), t, i) } } class nO extends nP { constructor(e, t, i) { super(new Uint8Array(e), t, i) } } class nk extends nP { constructor(e, t, i) { super(new Uint8ClampedArray(e), t, i) } } class nF extends nP { constructor(e, t, i) { super(new Int16Array(e), t, i) } } class nU extends nP { constructor(e, t, i) { super(new Uint16Array(e), t, i) } } class nN extends nP { constructor(e, t, i) { super(new Int32Array(e), t, i) } } class nB extends nP { constructor(e, t, i) { super(new Uint32Array(e), t, i) } } class nz extends nP { constructor(e, t, i) { super(new Uint16Array(e), t, i), this.isFloat16BufferAttribute = !0 } getX(e) { let t = nM(this.array[e * this.itemSize]); return this.normalized && (t = iU(t, this.array)), t } setX(e, t) { return this.normalized && (t = iN(t, this.array)), this.array[e * this.itemSize] = nw(t), this } getY(e) { let t = nM(this.array[e * this.itemSize + 1]); return this.normalized && (t = iU(t, this.array)), t } setY(e, t) { return this.normalized && (t = iN(t, this.array)), this.array[e * this.itemSize + 1] = nw(t), this } getZ(e) { let t = nM(this.array[e * this.itemSize + 2]); return this.normalized && (t = iU(t, this.array)), t } setZ(e, t) { return this.normalized && (t = iN(t, this.array)), this.array[e * this.itemSize + 2] = nw(t), this } getW(e) { let t = nM(this.array[e * this.itemSize + 3]); return this.normalized && (t = iU(t, this.array)), t } setW(e, t) { return this.normalized && (t = iN(t, this.array)), this.array[e * this.itemSize + 3] = nw(t), this } setXY(e, t, i) { return e *= this.itemSize, this.normalized && (t = iN(t, this.array), i = iN(i, this.array)), this.array[e + 0] = nw(t), this.array[e + 1] = nw(i), this } setXYZ(e, t, i, r) { return e *= this.itemSize, this.normalized && (t = iN(t, this.array), i = iN(i, this.array), r = iN(r, this.array)), this.array[e + 0] = nw(t), this.array[e + 1] = nw(i), this.array[e + 2] = nw(r), this } setXYZW(e, t, i, r, n) { return e *= this.itemSize, this.normalized && (t = iN(t, this.array), i = iN(i, this.array), r = iN(r, this.array), n = iN(n, this.array)), this.array[e + 0] = nw(t), this.array[e + 1] = nw(i), this.array[e + 2] = nw(r), this.array[e + 3] = nw(n), this } } class nG extends nP { constructor(e, t, i) { super(new Float32Array(e), t, i) } } let nH = 0, nV = new rN, nW = new nt, nj = new rl, nY = new rc, nX = new rc, nK = new rl; class nq extends iR { constructor() { super(), this.isBufferGeometry = !0, Object.defineProperty(this, "id", { value: nH++ }), this.uuid = iD(), this.name = "", this.type = "BufferGeometry", this.index = null, this.indirect = null, this.attributes = {}, this.morphAttributes = {}, this.morphTargetsRelative = !1, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = { start: 0, count: 1 / 0 }, this.userData = {} } getIndex() { return this.index } setIndex(e) { return Array.isArray(e) ? this.index = new (iV(e) ? nB : nU)(e, 1) : this.index = e, this } setIndirect(e) { return this.indirect = e, this } getIndirect() { return this.indirect } getAttribute(e) { return this.attributes[e] } setAttribute(e, t) { return this.attributes[e] = t, this } deleteAttribute(e) { return delete this.attributes[e], this } hasAttribute(e) { return void 0 !== this.attributes[e] } addGroup(e, t, i = 0) { this.groups.push({ start: e, count: t, materialIndex: i }) } clearGroups() { this.groups = [] } setDrawRange(e, t) { this.drawRange.start = e, this.drawRange.count = t } applyMatrix4(e) { let t = this.attributes.position; void 0 !== t && (t.applyMatrix4(e), t.needsUpdate = !0); let i = this.attributes.normal; if (void 0 !== i) { let t = new iG().getNormalMatrix(e); i.applyNormalMatrix(t), i.needsUpdate = !0 } let r = this.attributes.tangent; return void 0 !== r && (r.transformDirection(e), r.needsUpdate = !0), null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), this } applyQuaternion(e) { return nV.makeRotationFromQuaternion(e), this.applyMatrix4(nV), this } rotateX(e) { return nV.makeRotationX(e), this.applyMatrix4(nV), this } rotateY(e) { return nV.makeRotationY(e), this.applyMatrix4(nV), this } rotateZ(e) { return nV.makeRotationZ(e), this.applyMatrix4(nV), this } translate(e, t, i) { return nV.makeTranslation(e, t, i), this.applyMatrix4(nV), this } scale(e, t, i) { return nV.makeScale(e, t, i), this.applyMatrix4(nV), this } lookAt(e) { return nW.lookAt(e), nW.updateMatrix(), this.applyMatrix4(nW.matrix), this } center() { return this.computeBoundingBox(), this.boundingBox.getCenter(nj).negate(), this.translate(nj.x, nj.y, nj.z), this } setFromPoints(e) { let t = this.getAttribute("position"); if (void 0 === t) { let t = []; for (let i = 0, r = e.length; i < r; i++) { let r = e[i]; t.push(r.x, r.y, r.z || 0) } this.setAttribute("position", new nG(t, 3)) } else { let i = Math.min(e.length, t.count); for (let r = 0; r < i; r++) { let i = e[r]; t.setXYZ(r, i.x, i.y, i.z || 0) } e.length > t.count && console.warn("THREE.BufferGeometry: Buffer size too small for points data. Use .dispose() and create a new geometry."), t.needsUpdate = !0 } return this } computeBoundingBox() { null === this.boundingBox && (this.boundingBox = new rc); let e = this.attributes.position, t = this.morphAttributes.position; if (e && e.isGLBufferAttribute) { console.error("THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box.", this), this.boundingBox.set(new rl(-1 / 0, -1 / 0, -1 / 0), new rl(Infinity, Infinity, Infinity)); return } if (void 0 !== e) { if (this.boundingBox.setFromBufferAttribute(e), t) for (let e = 0, i = t.length; e < i; e++) { let i = t[e]; nY.setFromBufferAttribute(i), this.morphTargetsRelative ? (nK.addVectors(this.boundingBox.min, nY.min), this.boundingBox.expandByPoint(nK), nK.addVectors(this.boundingBox.max, nY.max), this.boundingBox.expandByPoint(nK)) : (this.boundingBox.expandByPoint(nY.min), this.boundingBox.expandByPoint(nY.max)) } } else this.boundingBox.makeEmpty(); (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this) } computeBoundingSphere() { null === this.boundingSphere && (this.boundingSphere = new rC); let e = this.attributes.position, t = this.morphAttributes.position; if (e && e.isGLBufferAttribute) { console.error("THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere.", this), this.boundingSphere.set(new rl, 1 / 0); return } if (e) { let i = this.boundingSphere.center; if (nY.setFromBufferAttribute(e), t) for (let e = 0, i = t.length; e < i; e++) { let i = t[e]; nX.setFromBufferAttribute(i), this.morphTargetsRelative ? (nK.addVectors(nY.min, nX.min), nY.expandByPoint(nK), nK.addVectors(nY.max, nX.max), nY.expandByPoint(nK)) : (nY.expandByPoint(nX.min), nY.expandByPoint(nX.max)) } nY.getCenter(i); let r = 0; for (let t = 0, n = e.count; t < n; t++)nK.fromBufferAttribute(e, t), r = Math.max(r, i.distanceToSquared(nK)); if (t) for (let n = 0, s = t.length; n < s; n++) { let s = t[n], a = this.morphTargetsRelative; for (let t = 0, n = s.count; t < n; t++)nK.fromBufferAttribute(s, t), a && (nj.fromBufferAttribute(e, t), nK.add(nj)), r = Math.max(r, i.distanceToSquared(nK)) } this.boundingSphere.radius = Math.sqrt(r), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this) } } computeTangents() { let e = this.index, t = this.attributes; if (null === e || void 0 === t.position || void 0 === t.normal || void 0 === t.uv) { console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)"); return } let i = t.position, r = t.normal, n = t.uv; !1 === this.hasAttribute("tangent") && this.setAttribute("tangent", new nP(new Float32Array(4 * i.count), 4)); let s = this.getAttribute("tangent"), a = [], o = []; for (let e = 0; e < i.count; e++)a[e] = new rl, o[e] = new rl; let l = new rl, u = new rl, h = new rl, c = new iz, d = new iz, f = new iz, p = new rl, m = new rl, g = this.groups; 0 === g.length && (g = [{ start: 0, count: e.count }]); for (let t = 0, r = g.length; t < r; ++t) { let r = g[t], s = r.start, v = r.count; for (let t = s, r = s + v; t < r; t += 3)!function (e, t, r) { l.fromBufferAttribute(i, e), u.fromBufferAttribute(i, t), h.fromBufferAttribute(i, r), c.fromBufferAttribute(n, e), d.fromBufferAttribute(n, t), f.fromBufferAttribute(n, r), u.sub(l), h.sub(l), d.sub(c), f.sub(c); let s = 1 / (d.x * f.y - f.x * d.y); isFinite(s) && (p.copy(u).multiplyScalar(f.y).addScaledVector(h, -d.y).multiplyScalar(s), m.copy(h).multiplyScalar(d.x).addScaledVector(u, -f.x).multiplyScalar(s), a[e].add(p), a[t].add(p), a[r].add(p), o[e].add(m), o[t].add(m), o[r].add(m)) }(e.getX(t + 0), e.getX(t + 1), e.getX(t + 2)) } let v = new rl, y = new rl, x = new rl, S = new rl; function A(e) { x.fromBufferAttribute(r, e), S.copy(x); let t = a[e]; v.copy(t), v.sub(x.multiplyScalar(x.dot(t))).normalize(), y.crossVectors(S, t); let i = y.dot(o[e]); s.setXYZW(e, v.x, v.y, v.z, i < 0 ? -1 : 1) } for (let t = 0, i = g.length; t < i; ++t) { let i = g[t], r = i.start, n = i.count; for (let t = r, i = r + n; t < i; t += 3)A(e.getX(t + 0)), A(e.getX(t + 1)), A(e.getX(t + 2)) } } computeVertexNormals() { let e = this.index, t = this.getAttribute("position"); if (void 0 !== t) { let i = this.getAttribute("normal"); if (void 0 === i) i = new nP(new Float32Array(3 * t.count), 3), this.setAttribute("normal", i); else for (let e = 0, t = i.count; e < t; e++)i.setXYZ(e, 0, 0, 0); let r = new rl, n = new rl, s = new rl, a = new rl, o = new rl, l = new rl, u = new rl, h = new rl; if (e) for (let c = 0, d = e.count; c < d; c += 3) { let d = e.getX(c + 0), f = e.getX(c + 1), p = e.getX(c + 2); r.fromBufferAttribute(t, d), n.fromBufferAttribute(t, f), s.fromBufferAttribute(t, p), u.subVectors(s, n), h.subVectors(r, n), u.cross(h), a.fromBufferAttribute(i, d), o.fromBufferAttribute(i, f), l.fromBufferAttribute(i, p), a.add(u), o.add(u), l.add(u), i.setXYZ(d, a.x, a.y, a.z), i.setXYZ(f, o.x, o.y, o.z), i.setXYZ(p, l.x, l.y, l.z) } else for (let e = 0, a = t.count; e < a; e += 3)r.fromBufferAttribute(t, e + 0), n.fromBufferAttribute(t, e + 1), s.fromBufferAttribute(t, e + 2), u.subVectors(s, n), h.subVectors(r, n), u.cross(h), i.setXYZ(e + 0, u.x, u.y, u.z), i.setXYZ(e + 1, u.x, u.y, u.z), i.setXYZ(e + 2, u.x, u.y, u.z); this.normalizeNormals(), i.needsUpdate = !0 } } normalizeNormals() { let e = this.attributes.normal; for (let t = 0, i = e.count; t < i; t++)nK.fromBufferAttribute(e, t), nK.normalize(), e.setXYZ(t, nK.x, nK.y, nK.z) } toNonIndexed() { function e(e, t) { let i = e.array, r = e.itemSize, n = e.normalized, s = new i.constructor(t.length * r), a = 0, o = 0; for (let n = 0, l = t.length; n < l; n++) { a = e.isInterleavedBufferAttribute ? t[n] * e.data.stride + e.offset : t[n] * r; for (let e = 0; e < r; e++)s[o++] = i[a++] } return new nP(s, r, n) } if (null === this.index) return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."), this; let t = new nq, i = this.index.array, r = this.attributes; for (let n in r) { let s = e(r[n], i); t.setAttribute(n, s) } let n = this.morphAttributes; for (let r in n) { let s = [], a = n[r]; for (let t = 0, r = a.length; t < r; t++) { let r = e(a[t], i); s.push(r) } t.morphAttributes[r] = s } t.morphTargetsRelative = this.morphTargetsRelative; let s = this.groups; for (let e = 0, i = s.length; e < i; e++) { let i = s[e]; t.addGroup(i.start, i.count, i.materialIndex) } return t } toJSON() { let e = { metadata: { version: 4.6, type: "BufferGeometry", generator: "BufferGeometry.toJSON" } }; if (e.uuid = this.uuid, e.type = this.type, "" !== this.name && (e.name = this.name), Object.keys(this.userData).length > 0 && (e.userData = this.userData), void 0 !== this.parameters) { let t = this.parameters; for (let i in t) void 0 !== t[i] && (e[i] = t[i]); return e } e.data = { attributes: {} }; let t = this.index; null !== t && (e.data.index = { type: t.array.constructor.name, array: Array.prototype.slice.call(t.array) }); let i = this.attributes; for (let t in i) { let r = i[t]; e.data.attributes[t] = r.toJSON(e.data) } let r = {}, n = !1; for (let t in this.morphAttributes) { let i = this.morphAttributes[t], s = []; for (let t = 0, r = i.length; t < r; t++) { let r = i[t]; s.push(r.toJSON(e.data)) } s.length > 0 && (r[t] = s, n = !0) } n && (e.data.morphAttributes = r, e.data.morphTargetsRelative = this.morphTargetsRelative); let s = this.groups; s.length > 0 && (e.data.groups = JSON.parse(JSON.stringify(s))); let a = this.boundingSphere; return null !== a && (e.data.boundingSphere = { center: a.center.toArray(), radius: a.radius }), e } clone() { return new this.constructor().copy(this) } copy(e) { this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null; let t = {}; this.name = e.name; let i = e.index; null !== i && this.setIndex(i.clone(t)); let r = e.attributes; for (let e in r) { let i = r[e]; this.setAttribute(e, i.clone(t)) } let n = e.morphAttributes; for (let e in n) { let i = [], r = n[e]; for (let e = 0, n = r.length; e < n; e++)i.push(r[e].clone(t)); this.morphAttributes[e] = i } this.morphTargetsRelative = e.morphTargetsRelative; let s = e.groups; for (let e = 0, t = s.length; e < t; e++) { let t = s[e]; this.addGroup(t.start, t.count, t.materialIndex) } let a = e.boundingBox; null !== a && (this.boundingBox = a.clone()); let o = e.boundingSphere; return null !== o && (this.boundingSphere = o.clone()), this.drawRange.start = e.drawRange.start, this.drawRange.count = e.drawRange.count, this.userData = e.userData, this } dispose() { this.dispatchEvent({ type: "dispose" }) } } let nQ = new rN, nZ = new rU, n$ = new rC, nJ = new rl, n0 = new rl, n1 = new rl, n2 = new rl, n3 = new rl, n4 = new rl, n5 = new rl, n8 = new rl; class n6 extends nt { constructor(e = new nq, t = new nb) { super(), this.isMesh = !0, this.type = "Mesh", this.geometry = e, this.material = t, this.morphTargetDictionary = void 0, this.morphTargetInfluences = void 0, this.updateMorphTargets() } copy(e, t) { return super.copy(e, t), void 0 !== e.morphTargetInfluences && (this.morphTargetInfluences = e.morphTargetInfluences.slice()), void 0 !== e.morphTargetDictionary && (this.morphTargetDictionary = Object.assign({}, e.morphTargetDictionary)), this.material = Array.isArray(e.material) ? e.material.slice() : e.material, this.geometry = e.geometry, this } updateMorphTargets() { let e = this.geometry.morphAttributes, t = Object.keys(e); if (t.length > 0) { let i = e[t[0]]; if (void 0 !== i) { this.morphTargetInfluences = [], this.morphTargetDictionary = {}; for (let e = 0, t = i.length; e < t; e++) { let t = i[e].name || String(e); this.morphTargetInfluences.push(0), this.morphTargetDictionary[t] = e } } } } getVertexPosition(e, t) { let i = this.geometry, r = i.attributes.position, n = i.morphAttributes.position, s = i.morphTargetsRelative; t.fromBufferAttribute(r, e); let a = this.morphTargetInfluences; if (n && a) { n4.set(0, 0, 0); for (let i = 0, r = n.length; i < r; i++) { let r = a[i], o = n[i]; 0 !== r && (n3.fromBufferAttribute(o, e), s ? n4.addScaledVector(n3, r) : n4.addScaledVector(n3.sub(t), r)) } t.add(n4) } return t } raycast(e, t) { let i = this.geometry, r = this.material, n = this.matrixWorld; if (void 0 !== r) { if (null === i.boundingSphere && i.computeBoundingSphere(), n$.copy(i.boundingSphere), n$.applyMatrix4(n), nZ.copy(e.ray).recast(e.near), !1 === n$.containsPoint(nZ.origin) && (null === nZ.intersectSphere(n$, nJ) || nZ.origin.distanceToSquared(nJ) > (e.far - e.near) ** 2) || (nQ.copy(n).invert(), nZ.copy(e.ray).applyMatrix4(nQ), null !== i.boundingBox && !1 === nZ.intersectsBox(i.boundingBox))) return; this._computeIntersections(e, t, nZ) } } _computeIntersections(e, t, i) { let r; let n = this.geometry, s = this.material, a = n.index, o = n.attributes.position, l = n.attributes.uv, u = n.attributes.uv1, h = n.attributes.normal, c = n.groups, d = n.drawRange; if (null !== a) { if (Array.isArray(s)) for (let n = 0, o = c.length; n < o; n++) { let o = c[n], f = s[o.materialIndex], p = Math.max(o.start, d.start), m = Math.min(a.count, Math.min(o.start + o.count, d.start + d.count)); for (let n = p; n < m; n += 3)(r = n9(this, f, e, i, l, u, h, a.getX(n), a.getX(n + 1), a.getX(n + 2))) && (r.faceIndex = Math.floor(n / 3), r.face.materialIndex = o.materialIndex, t.push(r)) } else { let n = Math.max(0, d.start), o = Math.min(a.count, d.start + d.count); for (let c = n; c < o; c += 3)(r = n9(this, s, e, i, l, u, h, a.getX(c), a.getX(c + 1), a.getX(c + 2))) && (r.faceIndex = Math.floor(c / 3), t.push(r)) } } else if (void 0 !== o) { if (Array.isArray(s)) for (let n = 0, a = c.length; n < a; n++) { let a = c[n], f = s[a.materialIndex], p = Math.max(a.start, d.start), m = Math.min(o.count, Math.min(a.start + a.count, d.start + d.count)); for (let n = p; n < m; n += 3)(r = n9(this, f, e, i, l, u, h, n, n + 1, n + 2)) && (r.faceIndex = Math.floor(n / 3), r.face.materialIndex = a.materialIndex, t.push(r)) } else { let n = Math.max(0, d.start), a = Math.min(o.count, d.start + d.count); for (let o = n; o < a; o += 3)(r = n9(this, s, e, i, l, u, h, o, o + 1, o + 2)) && (r.faceIndex = Math.floor(o / 3), t.push(r)) } } } } function n9(e, t, i, r, n, s, a, o, l, u) { e.getVertexPosition(o, n0), e.getVertexPosition(l, n1), e.getVertexPosition(u, n2); let h = function (e, t, i, r, n, s, a, o) { if (null === (t.side === S ? r.intersectTriangle(a, s, n, !0, o) : r.intersectTriangle(n, s, a, t.side === x, o))) return null; n8.copy(o), n8.applyMatrix4(e.matrixWorld); let l = i.ray.origin.distanceTo(n8); return l < i.near || l > i.far ? null : { distance: l, point: n8.clone(), object: e } }(e, t, i, r, n0, n1, n2, n5); if (h) { let e = new rl; nm.getBarycoord(n5, n0, n1, n2, e), n && (h.uv = nm.getInterpolatedAttribute(n, o, l, u, e, new iz)), s && (h.uv1 = nm.getInterpolatedAttribute(s, o, l, u, e, new iz)), a && (h.normal = nm.getInterpolatedAttribute(a, o, l, u, e, new rl), h.normal.dot(r.direction) > 0 && h.normal.multiplyScalar(-1)); let t = { a: o, b: l, c: u, normal: new rl, materialIndex: 0 }; nm.getNormal(n0, n1, n2, t.normal), h.face = t, h.barycoord = e } return h } class n7 extends nq { constructor(e = 1, t = 1, i = 1, r = 1, n = 1, s = 1) { super(), this.type = "BoxGeometry", this.parameters = { width: e, height: t, depth: i, widthSegments: r, heightSegments: n, depthSegments: s }; let a = this; r = Math.floor(r), n = Math.floor(n); let o = [], l = [], u = [], h = [], c = 0, d = 0; function f(e, t, i, r, n, s, f, p, m, g, v) { let y = s / m, x = f / g, S = s / 2, A = f / 2, _ = p / 2, E = m + 1, b = g + 1, T = 0, w = 0, M = new rl; for (let s = 0; s < b; s++) { let a = s * x - A; for (let o = 0; o < E; o++) { let c = o * y - S; M[e] = c * r, M[t] = a * n, M[i] = _, l.push(M.x, M.y, M.z), M[e] = 0, M[t] = 0, M[i] = p > 0 ? 1 : -1, u.push(M.x, M.y, M.z), h.push(o / m), h.push(1 - s / g), T += 1 } } for (let e = 0; e < g; e++)for (let t = 0; t < m; t++) { let i = c + t + E * e, r = c + t + E * (e + 1), n = c + (t + 1) + E * (e + 1), s = c + (t + 1) + E * e; o.push(i, r, s), o.push(r, n, s), w += 6 } a.addGroup(d, w, v), d += w, c += T } f("z", "y", "x", -1, -1, i, t, e, s = Math.floor(s), n, 0), f("z", "y", "x", 1, -1, i, t, -e, s, n, 1), f("x", "z", "y", 1, 1, e, i, t, r, s, 2), f("x", "z", "y", 1, -1, e, i, -t, r, s, 3), f("x", "y", "z", 1, -1, e, t, i, r, n, 4), f("x", "y", "z", -1, -1, e, t, -i, r, n, 5), this.setIndex(o), this.setAttribute("position", new nG(l, 3)), this.setAttribute("normal", new nG(u, 3)), this.setAttribute("uv", new nG(h, 2)) } copy(e) { return super.copy(e), this.parameters = Object.assign({}, e.parameters), this } static fromJSON(e) { return new n7(e.width, e.height, e.depth, e.widthSegments, e.heightSegments, e.depthSegments) } } function se(e) { let t = {}; for (let i in e) for (let r in t[i] = {}, e[i]) { let n = e[i][r]; n && (n.isColor || n.isMatrix3 || n.isMatrix4 || n.isVector2 || n.isVector3 || n.isVector4 || n.isTexture || n.isQuaternion) ? n.isRenderTargetTexture ? (console.warn("UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms()."), t[i][r] = null) : t[i][r] = n.clone() : Array.isArray(n) ? t[i][r] = n.slice() : t[i][r] = n } return t } function st(e) { let t = {}; for (let i = 0; i < e.length; i++) { let r = se(e[i]); for (let e in r) t[e] = r[e] } return t } function si(e) { let t = e.getRenderTarget(); return null === t ? e.outputColorSpace : !0 === t.isXRRenderTarget ? t.texture.colorSpace : i1.workingColorSpace } let sr = { clone: se, merge: st }; class sn extends nE { constructor(e) { super(), this.isShaderMaterial = !0, this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, this.uniformsGroups = [], this.vertexShader = "void main() {\n	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}", this.fragmentShader = "void main() {\n	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}", this.linewidth = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.clipping = !1, this.forceSinglePass = !0, this.extensions = { clipCullDistance: !1, multiDraw: !1 }, this.defaultAttributeValues = { color: [1, 1, 1], uv: [0, 0], uv1: [0, 0] }, this.index0AttributeName = void 0, this.uniformsNeedUpdate = !1, this.glslVersion = null, void 0 !== e && this.setValues(e) } copy(e) { return super.copy(e), this.fragmentShader = e.fragmentShader, this.vertexShader = e.vertexShader, this.uniforms = se(e.uniforms), this.uniformsGroups = function (e) { let t = []; for (let i = 0; i < e.length; i++)t.push(e[i].clone()); return t }(e.uniformsGroups), this.defines = Object.assign({}, e.defines), this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.fog = e.fog, this.lights = e.lights, this.clipping = e.clipping, this.extensions = Object.assign({}, e.extensions), this.glslVersion = e.glslVersion, this } toJSON(e) { let t = super.toJSON(e); for (let i in t.glslVersion = this.glslVersion, t.uniforms = {}, this.uniforms) { let r = this.uniforms[i].value; r && r.isTexture ? t.uniforms[i] = { type: "t", value: r.toJSON(e).uuid } : r && r.isColor ? t.uniforms[i] = { type: "c", value: r.getHex() } : r && r.isVector2 ? t.uniforms[i] = { type: "v2", value: r.toArray() } : r && r.isVector3 ? t.uniforms[i] = { type: "v3", value: r.toArray() } : r && r.isVector4 ? t.uniforms[i] = { type: "v4", value: r.toArray() } : r && r.isMatrix3 ? t.uniforms[i] = { type: "m3", value: r.toArray() } : r && r.isMatrix4 ? t.uniforms[i] = { type: "m4", value: r.toArray() } : t.uniforms[i] = { value: r } } Object.keys(this.defines).length > 0 && (t.defines = this.defines), t.vertexShader = this.vertexShader, t.fragmentShader = this.fragmentShader, t.lights = this.lights, t.clipping = this.clipping; let i = {}; for (let e in this.extensions) !0 === this.extensions[e] && (i[e] = !0); return Object.keys(i).length > 0 && (t.extensions = i), t } } class ss extends nt { constructor() { super(), this.isCamera = !0, this.type = "Camera", this.matrixWorldInverse = new rN, this.projectionMatrix = new rN, this.projectionMatrixInverse = new rN, this.coordinateSystem = iT } copy(e, t) { return super.copy(e, t), this.matrixWorldInverse.copy(e.matrixWorldInverse), this.projectionMatrix.copy(e.projectionMatrix), this.projectionMatrixInverse.copy(e.projectionMatrixInverse), this.coordinateSystem = e.coordinateSystem, this } getWorldDirection(e) { return super.getWorldDirection(e).negate() } updateMatrixWorld(e) { super.updateMatrixWorld(e), this.matrixWorldInverse.copy(this.matrixWorld).invert() } updateWorldMatrix(e, t) { super.updateWorldMatrix(e, t), this.matrixWorldInverse.copy(this.matrixWorld).invert() } clone() { return new this.constructor().copy(this) } } let sa = new rl, so = new iz, sl = new iz; class su extends ss { constructor(e = 50, t = 1, i = .1, r = 2e3) { super(), this.isPerspectiveCamera = !0, this.type = "PerspectiveCamera", this.fov = e, this.zoom = 1, this.near = i, this.far = r, this.focus = 10, this.aspect = t, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix() } copy(e, t) { return super.copy(e, t), this.fov = e.fov, this.zoom = e.zoom, this.near = e.near, this.far = e.far, this.focus = e.focus, this.aspect = e.aspect, this.view = null === e.view ? null : Object.assign({}, e.view), this.filmGauge = e.filmGauge, this.filmOffset = e.filmOffset, this } setFocalLength(e) { let t = .5 * this.getFilmHeight() / e; this.fov = 2 * iP * Math.atan(t), this.updateProjectionMatrix() } getFocalLength() { let e = Math.tan(.5 * iL * this.fov); return .5 * this.getFilmHeight() / e } getEffectiveFOV() { return 2 * iP * Math.atan(Math.tan(.5 * iL * this.fov) / this.zoom) } getFilmWidth() { return this.filmGauge * Math.min(this.aspect, 1) } getFilmHeight() { return this.filmGauge / Math.max(this.aspect, 1) } getViewBounds(e, t, i) { sa.set(-1, -1, .5).applyMatrix4(this.projectionMatrixInverse), t.set(sa.x, sa.y).multiplyScalar(-e / sa.z), sa.set(1, 1, .5).applyMatrix4(this.projectionMatrixInverse), i.set(sa.x, sa.y).multiplyScalar(-e / sa.z) } getViewSize(e, t) { return this.getViewBounds(e, so, sl), t.subVectors(sl, so) } setViewOffset(e, t, i, r, n, s) { this.aspect = e / t, null === this.view && (this.view = { enabled: !0, fullWidth: 1, fullHeight: 1, offsetX: 0, offsetY: 0, width: 1, height: 1 }), this.view.enabled = !0, this.view.fullWidth = e, this.view.fullHeight = t, this.view.offsetX = i, this.view.offsetY = r, this.view.width = n, this.view.height = s, this.updateProjectionMatrix() } clearViewOffset() { null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix() } updateProjectionMatrix() { let e = this.near, t = e * Math.tan(.5 * iL * this.fov) / this.zoom, i = 2 * t, r = this.aspect * i, n = -.5 * r, s = this.view; if (null !== this.view && this.view.enabled) { let e = s.fullWidth, a = s.fullHeight; n += s.offsetX * r / e, t -= s.offsetY * i / a, r *= s.width / e, i *= s.height / a } let a = this.filmOffset; 0 !== a && (n += e * a / this.getFilmWidth()), this.projectionMatrix.makePerspective(n, n + r, t, t - i, e, this.far, this.coordinateSystem), this.projectionMatrixInverse.copy(this.projectionMatrix).invert() } toJSON(e) { let t = super.toJSON(e); return t.object.fov = this.fov, t.object.zoom = this.zoom, t.object.near = this.near, t.object.far = this.far, t.object.focus = this.focus, t.object.aspect = this.aspect, null !== this.view && (t.object.view = Object.assign({}, this.view)), t.object.filmGauge = this.filmGauge, t.object.filmOffset = this.filmOffset, t } } class sh extends nt { constructor(e, t, i) { super(), this.type = "CubeCamera", this.renderTarget = i, this.coordinateSystem = null, this.activeMipmapLevel = 0; let r = new su(-90, 1, e, t); r.layers = this.layers, this.add(r); let n = new su(-90, 1, e, t); n.layers = this.layers, this.add(n); let s = new su(-90, 1, e, t); s.layers = this.layers, this.add(s); let a = new su(-90, 1, e, t); a.layers = this.layers, this.add(a); let o = new su(-90, 1, e, t); o.layers = this.layers, this.add(o); let l = new su(-90, 1, e, t); l.layers = this.layers, this.add(l) } updateCoordinateSystem() { let e = this.coordinateSystem, t = this.children.concat(), [i, r, n, s, a, o] = t; for (let e of t) this.remove(e); if (e === iT) i.up.set(0, 1, 0), i.lookAt(1, 0, 0), r.up.set(0, 1, 0), r.lookAt(-1, 0, 0), n.up.set(0, 0, -1), n.lookAt(0, 1, 0), s.up.set(0, 0, 1), s.lookAt(0, -1, 0), a.up.set(0, 1, 0), a.lookAt(0, 0, 1), o.up.set(0, 1, 0), o.lookAt(0, 0, -1); else if (e === iw) i.up.set(0, -1, 0), i.lookAt(-1, 0, 0), r.up.set(0, -1, 0), r.lookAt(1, 0, 0), n.up.set(0, 0, 1), n.lookAt(0, 1, 0), s.up.set(0, 0, -1), s.lookAt(0, -1, 0), a.up.set(0, -1, 0), a.lookAt(0, 0, 1), o.up.set(0, -1, 0), o.lookAt(0, 0, -1); else throw Error("THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: " + e); for (let e of t) this.add(e), e.updateMatrixWorld() } update(e, t) { null === this.parent && this.updateMatrixWorld(); let { renderTarget: i, activeMipmapLevel: r } = this; this.coordinateSystem !== e.coordinateSystem && (this.coordinateSystem = e.coordinateSystem, this.updateCoordinateSystem()); let [n, s, a, o, l, u] = this.children, h = e.getRenderTarget(), c = e.getActiveCubeFace(), d = e.getActiveMipmapLevel(), f = e.xr.enabled; e.xr.enabled = !1; let p = i.texture.generateMipmaps; i.texture.generateMipmaps = !1, e.setRenderTarget(i, 0, r), e.render(t, n), e.setRenderTarget(i, 1, r), e.render(t, s), e.setRenderTarget(i, 2, r), e.render(t, a), e.setRenderTarget(i, 3, r), e.render(t, o), e.setRenderTarget(i, 4, r), e.render(t, l), i.texture.generateMipmaps = p, e.setRenderTarget(i, 5, r), e.render(t, u), e.setRenderTarget(h, c, d), e.xr.enabled = f, i.texture.needsPMREMUpdate = !0 } } class sc extends i7 { constructor(e, t, i, r, n, s, a, o, l, u) { super(e = void 0 !== e ? e : [], t = void 0 !== t ? t : eg, i, r, n, s, a, o, l, u), this.isCubeTexture = !0, this.flipY = !1 } get images() { return this.image } set images(e) { this.image = e } } class sd extends ri {
      constructor(e = 1, t = {}) { super(e, e, t), this.isWebGLCubeRenderTarget = !0; let i = { width: e, height: e, depth: 1 }; this.texture = new sc([i, i, i, i, i, i], t.mapping, t.wrapS, t.wrapT, t.magFilter, t.minFilter, t.format, t.type, t.anisotropy, t.colorSpace), this.texture.isRenderTargetTexture = !0, this.texture.generateMipmaps = void 0 !== t.generateMipmaps && t.generateMipmaps, this.texture.minFilter = void 0 !== t.minFilter ? t.minFilter : eC } fromEquirectangularTexture(e, t) {
        this.texture.type = t.type, this.texture.colorSpace = t.colorSpace, this.texture.generateMipmaps = t.generateMipmaps, this.texture.minFilter = t.minFilter, this.texture.magFilter = t.magFilter; let i = {
          uniforms: { tEquirect: { value: null } }, vertexShader: `

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`, fragmentShader: `

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`}, r = new n7(5, 5, 5), n = new sn({ name: "CubemapFromEquirect", uniforms: se(i.uniforms), vertexShader: i.vertexShader, fragmentShader: i.fragmentShader, side: S, blending: _ }); n.uniforms.tEquirect.value = t; let s = new n6(r, n), a = t.minFilter; return t.minFilter === eP && (t.minFilter = eC), new sh(1, 10, this).update(e, s), t.minFilter = a, s.geometry.dispose(), s.material.dispose(), this
      } clear(e, t, i, r) { let n = e.getRenderTarget(); for (let n = 0; n < 6; n++)e.setRenderTarget(this, n), e.clear(t, i, r); e.setRenderTarget(n) }
    } class sf extends nt { constructor() { super(), this.isGroup = !0, this.type = "Group" } } let sp = { type: "move" }; class sm { constructor() { this._targetRay = null, this._grip = null, this._hand = null } getHandSpace() { return null === this._hand && (this._hand = new sf, this._hand.matrixAutoUpdate = !1, this._hand.visible = !1, this._hand.joints = {}, this._hand.inputState = { pinching: !1 }), this._hand } getTargetRaySpace() { return null === this._targetRay && (this._targetRay = new sf, this._targetRay.matrixAutoUpdate = !1, this._targetRay.visible = !1, this._targetRay.hasLinearVelocity = !1, this._targetRay.linearVelocity = new rl, this._targetRay.hasAngularVelocity = !1, this._targetRay.angularVelocity = new rl), this._targetRay } getGripSpace() { return null === this._grip && (this._grip = new sf, this._grip.matrixAutoUpdate = !1, this._grip.visible = !1, this._grip.hasLinearVelocity = !1, this._grip.linearVelocity = new rl, this._grip.hasAngularVelocity = !1, this._grip.angularVelocity = new rl), this._grip } dispatchEvent(e) { return null !== this._targetRay && this._targetRay.dispatchEvent(e), null !== this._grip && this._grip.dispatchEvent(e), null !== this._hand && this._hand.dispatchEvent(e), this } connect(e) { if (e && e.hand) { let t = this._hand; if (t) for (let i of e.hand.values()) this._getHandJoint(t, i) } return this.dispatchEvent({ type: "connected", data: e }), this } disconnect(e) { return this.dispatchEvent({ type: "disconnected", data: e }), null !== this._targetRay && (this._targetRay.visible = !1), null !== this._grip && (this._grip.visible = !1), null !== this._hand && (this._hand.visible = !1), this } update(e, t, i) { let r = null, n = null, s = null, a = this._targetRay, o = this._grip, l = this._hand; if (e && "visible-blurred" !== t.session.visibilityState) { if (l && e.hand) { for (let r of (s = !0, e.hand.values())) { let e = t.getJointPose(r, i), n = this._getHandJoint(l, r); null !== e && (n.matrix.fromArray(e.transform.matrix), n.matrix.decompose(n.position, n.rotation, n.scale), n.matrixWorldNeedsUpdate = !0, n.jointRadius = e.radius), n.visible = null !== e } let r = l.joints["index-finger-tip"], n = l.joints["thumb-tip"], a = r.position.distanceTo(n.position); l.inputState.pinching && a > .025 ? (l.inputState.pinching = !1, this.dispatchEvent({ type: "pinchend", handedness: e.handedness, target: this })) : !l.inputState.pinching && a <= .015 && (l.inputState.pinching = !0, this.dispatchEvent({ type: "pinchstart", handedness: e.handedness, target: this })) } else null !== o && e.gripSpace && null !== (n = t.getPose(e.gripSpace, i)) && (o.matrix.fromArray(n.transform.matrix), o.matrix.decompose(o.position, o.rotation, o.scale), o.matrixWorldNeedsUpdate = !0, n.linearVelocity ? (o.hasLinearVelocity = !0, o.linearVelocity.copy(n.linearVelocity)) : o.hasLinearVelocity = !1, n.angularVelocity ? (o.hasAngularVelocity = !0, o.angularVelocity.copy(n.angularVelocity)) : o.hasAngularVelocity = !1); null !== a && (null === (r = t.getPose(e.targetRaySpace, i)) && null !== n && (r = n), null !== r && (a.matrix.fromArray(r.transform.matrix), a.matrix.decompose(a.position, a.rotation, a.scale), a.matrixWorldNeedsUpdate = !0, r.linearVelocity ? (a.hasLinearVelocity = !0, a.linearVelocity.copy(r.linearVelocity)) : a.hasLinearVelocity = !1, r.angularVelocity ? (a.hasAngularVelocity = !0, a.angularVelocity.copy(r.angularVelocity)) : a.hasAngularVelocity = !1, this.dispatchEvent(sp))) } return null !== a && (a.visible = null !== r), null !== o && (o.visible = null !== n), null !== l && (l.visible = null !== s), this } _getHandJoint(e, t) { if (void 0 === e.joints[t.jointName]) { let i = new sf; i.matrixAutoUpdate = !1, i.visible = !1, e.joints[t.jointName] = i, e.add(i) } return e.joints[t.jointName] } } class sg { constructor(e, t = 25e-5) { this.isFogExp2 = !0, this.name = "", this.color = new nS(e), this.density = t } clone() { return new sg(this.color, this.density) } toJSON() { return { type: "FogExp2", name: this.name, color: this.color.getHex(), density: this.density } } } class sv { constructor(e, t = 1, i = 1e3) { this.isFog = !0, this.name = "", this.color = new nS(e), this.near = t, this.far = i } clone() { return new sv(this.color, this.near, this.far) } toJSON() { return { type: "Fog", name: this.name, color: this.color.getHex(), near: this.near, far: this.far } } } class sy extends nt { constructor() { super(), this.isScene = !0, this.type = "Scene", this.background = null, this.environment = null, this.fog = null, this.backgroundBlurriness = 0, this.backgroundIntensity = 1, this.backgroundRotation = new rK, this.environmentIntensity = 1, this.environmentRotation = new rK, this.overrideMaterial = null, "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this })) } copy(e, t) { return super.copy(e, t), null !== e.background && (this.background = e.background.clone()), null !== e.environment && (this.environment = e.environment.clone()), null !== e.fog && (this.fog = e.fog.clone()), this.backgroundBlurriness = e.backgroundBlurriness, this.backgroundIntensity = e.backgroundIntensity, this.backgroundRotation.copy(e.backgroundRotation), this.environmentIntensity = e.environmentIntensity, this.environmentRotation.copy(e.environmentRotation), null !== e.overrideMaterial && (this.overrideMaterial = e.overrideMaterial.clone()), this.matrixAutoUpdate = e.matrixAutoUpdate, this } toJSON(e) { let t = super.toJSON(e); return null !== this.fog && (t.object.fog = this.fog.toJSON()), this.backgroundBlurriness > 0 && (t.object.backgroundBlurriness = this.backgroundBlurriness), 1 !== this.backgroundIntensity && (t.object.backgroundIntensity = this.backgroundIntensity), t.object.backgroundRotation = this.backgroundRotation.toArray(), 1 !== this.environmentIntensity && (t.object.environmentIntensity = this.environmentIntensity), t.object.environmentRotation = this.environmentRotation.toArray(), t } } class sx { constructor(e, t) { this.isInterleavedBuffer = !0, this.array = e, this.stride = t, this.count = void 0 !== e ? e.length / t : 0, this.usage = ip, this.updateRanges = [], this.version = 0, this.uuid = iD() } onUploadCallback() { } set needsUpdate(e) { !0 === e && this.version++ } setUsage(e) { return this.usage = e, this } addUpdateRange(e, t) { this.updateRanges.push({ start: e, count: t }) } clearUpdateRanges() { this.updateRanges.length = 0 } copy(e) { return this.array = new e.array.constructor(e.array), this.count = e.count, this.stride = e.stride, this.usage = e.usage, this } copyAt(e, t, i) { e *= this.stride, i *= t.stride; for (let r = 0, n = this.stride; r < n; r++)this.array[e + r] = t.array[i + r]; return this } set(e, t = 0) { return this.array.set(e, t), this } clone(e) { void 0 === e.arrayBuffers && (e.arrayBuffers = {}), void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = iD()), void 0 === e.arrayBuffers[this.array.buffer._uuid] && (e.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer); let t = new this.array.constructor(e.arrayBuffers[this.array.buffer._uuid]), i = new this.constructor(t, this.stride); return i.setUsage(this.usage), i } onUpload(e) { return this.onUploadCallback = e, this } toJSON(e) { return void 0 === e.arrayBuffers && (e.arrayBuffers = {}), void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = iD()), void 0 === e.arrayBuffers[this.array.buffer._uuid] && (e.arrayBuffers[this.array.buffer._uuid] = Array.from(new Uint32Array(this.array.buffer))), { uuid: this.uuid, buffer: this.array.buffer._uuid, type: this.array.constructor.name, stride: this.stride } } } let sS = new rl; class sA { constructor(e, t, i, r = !1) { this.isInterleavedBufferAttribute = !0, this.name = "", this.data = e, this.itemSize = t, this.offset = i, this.normalized = r } get count() { return this.data.count } get array() { return this.data.array } set needsUpdate(e) { this.data.needsUpdate = e } applyMatrix4(e) { for (let t = 0, i = this.data.count; t < i; t++)sS.fromBufferAttribute(this, t), sS.applyMatrix4(e), this.setXYZ(t, sS.x, sS.y, sS.z); return this } applyNormalMatrix(e) { for (let t = 0, i = this.count; t < i; t++)sS.fromBufferAttribute(this, t), sS.applyNormalMatrix(e), this.setXYZ(t, sS.x, sS.y, sS.z); return this } transformDirection(e) { for (let t = 0, i = this.count; t < i; t++)sS.fromBufferAttribute(this, t), sS.transformDirection(e), this.setXYZ(t, sS.x, sS.y, sS.z); return this } getComponent(e, t) { let i = this.array[e * this.data.stride + this.offset + t]; return this.normalized && (i = iU(i, this.array)), i } setComponent(e, t, i) { return this.normalized && (i = iN(i, this.array)), this.data.array[e * this.data.stride + this.offset + t] = i, this } setX(e, t) { return this.normalized && (t = iN(t, this.array)), this.data.array[e * this.data.stride + this.offset] = t, this } setY(e, t) { return this.normalized && (t = iN(t, this.array)), this.data.array[e * this.data.stride + this.offset + 1] = t, this } setZ(e, t) { return this.normalized && (t = iN(t, this.array)), this.data.array[e * this.data.stride + this.offset + 2] = t, this } setW(e, t) { return this.normalized && (t = iN(t, this.array)), this.data.array[e * this.data.stride + this.offset + 3] = t, this } getX(e) { let t = this.data.array[e * this.data.stride + this.offset]; return this.normalized && (t = iU(t, this.array)), t } getY(e) { let t = this.data.array[e * this.data.stride + this.offset + 1]; return this.normalized && (t = iU(t, this.array)), t } getZ(e) { let t = this.data.array[e * this.data.stride + this.offset + 2]; return this.normalized && (t = iU(t, this.array)), t } getW(e) { let t = this.data.array[e * this.data.stride + this.offset + 3]; return this.normalized && (t = iU(t, this.array)), t } setXY(e, t, i) { return e = e * this.data.stride + this.offset, this.normalized && (t = iN(t, this.array), i = iN(i, this.array)), this.data.array[e + 0] = t, this.data.array[e + 1] = i, this } setXYZ(e, t, i, r) { return e = e * this.data.stride + this.offset, this.normalized && (t = iN(t, this.array), i = iN(i, this.array), r = iN(r, this.array)), this.data.array[e + 0] = t, this.data.array[e + 1] = i, this.data.array[e + 2] = r, this } setXYZW(e, t, i, r, n) { return e = e * this.data.stride + this.offset, this.normalized && (t = iN(t, this.array), i = iN(i, this.array), r = iN(r, this.array), n = iN(n, this.array)), this.data.array[e + 0] = t, this.data.array[e + 1] = i, this.data.array[e + 2] = r, this.data.array[e + 3] = n, this } clone(e) { if (void 0 !== e) return void 0 === e.interleavedBuffers && (e.interleavedBuffers = {}), void 0 === e.interleavedBuffers[this.data.uuid] && (e.interleavedBuffers[this.data.uuid] = this.data.clone(e)), new sA(e.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized); { console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data."); let e = []; for (let t = 0; t < this.count; t++) { let i = t * this.data.stride + this.offset; for (let t = 0; t < this.itemSize; t++)e.push(this.data.array[i + t]) } return new nP(new this.array.constructor(e), this.itemSize, this.normalized) } } toJSON(e) { if (void 0 !== e) return void 0 === e.interleavedBuffers && (e.interleavedBuffers = {}), void 0 === e.interleavedBuffers[this.data.uuid] && (e.interleavedBuffers[this.data.uuid] = this.data.toJSON(e)), { isInterleavedBufferAttribute: !0, itemSize: this.itemSize, data: this.data.uuid, offset: this.offset, normalized: this.normalized }; { console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data."); let e = []; for (let t = 0; t < this.count; t++) { let i = t * this.data.stride + this.offset; for (let t = 0; t < this.itemSize; t++)e.push(this.data.array[i + t]) } return { itemSize: this.itemSize, type: this.array.constructor.name, array: e, normalized: this.normalized } } } } class s_ extends nE { constructor(e) { super(), this.isSpriteMaterial = !0, this.type = "SpriteMaterial", this.color = new nS(0xffffff), this.map = null, this.alphaMap = null, this.rotation = 0, this.sizeAttenuation = !0, this.transparent = !0, this.fog = !0, this.setValues(e) } copy(e) { return super.copy(e), this.color.copy(e.color), this.map = e.map, this.alphaMap = e.alphaMap, this.rotation = e.rotation, this.sizeAttenuation = e.sizeAttenuation, this.fog = e.fog, this } } let sE = new rl, sb = new rl, sT = new rl, sw = new iz, sM = new iz, sR = new rN, sC = new rl, sI = new rl, sL = new rl, sP = new iz, sD = new iz, sO = new iz; class sk extends nt { constructor(e = new s_) { if (super(), this.isSprite = !0, this.type = "Sprite", void 0 === n) { n = new nq; let e = new sx(new Float32Array([-.5, -.5, 0, 0, 0, .5, -.5, 0, 1, 0, .5, .5, 0, 1, 1, -.5, .5, 0, 0, 1]), 5); n.setIndex([0, 1, 2, 0, 2, 3]), n.setAttribute("position", new sA(e, 3, 0, !1)), n.setAttribute("uv", new sA(e, 2, 3, !1)) } this.geometry = n, this.material = e, this.center = new iz(.5, .5) } raycast(e, t) { let i, r; null === e.camera && console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'), sb.setFromMatrixScale(this.matrixWorld), sR.copy(e.camera.matrixWorld), this.modelViewMatrix.multiplyMatrices(e.camera.matrixWorldInverse, this.matrixWorld), sT.setFromMatrixPosition(this.modelViewMatrix), e.camera.isPerspectiveCamera && !1 === this.material.sizeAttenuation && sb.multiplyScalar(-sT.z); let n = this.material.rotation; 0 !== n && (r = Math.cos(n), i = Math.sin(n)); let s = this.center; sF(sC.set(-.5, -.5, 0), sT, s, sb, i, r), sF(sI.set(.5, -.5, 0), sT, s, sb, i, r), sF(sL.set(.5, .5, 0), sT, s, sb, i, r), sP.set(0, 0), sD.set(1, 0), sO.set(1, 1); let a = e.ray.intersectTriangle(sC, sI, sL, !1, sE); if (null === a && (sF(sI.set(-.5, .5, 0), sT, s, sb, i, r), sD.set(0, 1), null === (a = e.ray.intersectTriangle(sC, sL, sI, !1, sE)))) return; let o = e.ray.origin.distanceTo(sE); o < e.near || o > e.far || t.push({ distance: o, point: sE.clone(), uv: nm.getInterpolation(sE, sC, sI, sL, sP, sD, sO, new iz), face: null, object: this }) } copy(e, t) { return super.copy(e, t), void 0 !== e.center && this.center.copy(e.center), this.material = e.material, this } } function sF(e, t, i, r, n, s) { sw.subVectors(e, i).addScalar(.5).multiply(r), void 0 !== n ? (sM.x = s * sw.x - n * sw.y, sM.y = n * sw.x + s * sw.y) : sM.copy(sw), e.copy(t), e.x += sM.x, e.y += sM.y, e.applyMatrix4(sR) } let sU = new rl, sN = new rl; class sB extends nt { constructor() { super(), this.isLOD = !0, this._currentLevel = 0, this.type = "LOD", Object.defineProperties(this, { levels: { enumerable: !0, value: [] } }), this.autoUpdate = !0 } copy(e) { super.copy(e, !1); let t = e.levels; for (let e = 0, i = t.length; e < i; e++) { let i = t[e]; this.addLevel(i.object.clone(), i.distance, i.hysteresis) } return this.autoUpdate = e.autoUpdate, this } addLevel(e, t = 0, i = 0) { let r; t = Math.abs(t); let n = this.levels; for (r = 0; r < n.length && !(t < n[r].distance); r++); return n.splice(r, 0, { distance: t, hysteresis: i, object: e }), this.add(e), this } removeLevel(e) { let t = this.levels; for (let i = 0; i < t.length; i++)if (t[i].distance === e) { let e = t.splice(i, 1); return this.remove(e[0].object), !0 } return !1 } getCurrentLevel() { return this._currentLevel } getObjectForDistance(e) { let t = this.levels; if (t.length > 0) { let i, r; for (i = 1, r = t.length; i < r; i++) { let r = t[i].distance; if (t[i].object.visible && (r -= r * t[i].hysteresis), e < r) break } return t[i - 1].object } return null } raycast(e, t) { if (this.levels.length > 0) { sU.setFromMatrixPosition(this.matrixWorld); let i = e.ray.origin.distanceTo(sU); this.getObjectForDistance(i).raycast(e, t) } } update(e) { let t = this.levels; if (t.length > 1) { let i, r; sU.setFromMatrixPosition(e.matrixWorld), sN.setFromMatrixPosition(this.matrixWorld); let n = sU.distanceTo(sN) / e.zoom; for (i = 1, t[0].object.visible = !0, r = t.length; i < r; i++) { let e = t[i].distance; if (t[i].object.visible && (e -= e * t[i].hysteresis), n >= e) t[i - 1].object.visible = !1, t[i].object.visible = !0; else break } for (this._currentLevel = i - 1; i < r; i++)t[i].object.visible = !1 } } toJSON(e) { let t = super.toJSON(e); !1 === this.autoUpdate && (t.object.autoUpdate = !1), t.object.levels = []; let i = this.levels; for (let e = 0, r = i.length; e < r; e++) { let r = i[e]; t.object.levels.push({ object: r.object.uuid, distance: r.distance, hysteresis: r.hysteresis }) } return t } } let sz = new rl, sG = new re, sH = new re, sV = new rl, sW = new rN, sj = new rl, sY = new rC, sX = new rN, sK = new rU; class sq extends n6 { constructor(e, t) { super(e, t), this.isSkinnedMesh = !0, this.type = "SkinnedMesh", this.bindMode = ef, this.bindMatrix = new rN, this.bindMatrixInverse = new rN, this.boundingBox = null, this.boundingSphere = null } computeBoundingBox() { let e = this.geometry; null === this.boundingBox && (this.boundingBox = new rc), this.boundingBox.makeEmpty(); let t = e.getAttribute("position"); for (let e = 0; e < t.count; e++)this.getVertexPosition(e, sj), this.boundingBox.expandByPoint(sj) } computeBoundingSphere() { let e = this.geometry; null === this.boundingSphere && (this.boundingSphere = new rC), this.boundingSphere.makeEmpty(); let t = e.getAttribute("position"); for (let e = 0; e < t.count; e++)this.getVertexPosition(e, sj), this.boundingSphere.expandByPoint(sj) } copy(e, t) { return super.copy(e, t), this.bindMode = e.bindMode, this.bindMatrix.copy(e.bindMatrix), this.bindMatrixInverse.copy(e.bindMatrixInverse), this.skeleton = e.skeleton, null !== e.boundingBox && (this.boundingBox = e.boundingBox.clone()), null !== e.boundingSphere && (this.boundingSphere = e.boundingSphere.clone()), this } raycast(e, t) { let i = this.material, r = this.matrixWorld; if (void 0 !== i && (null === this.boundingSphere && this.computeBoundingSphere(), sY.copy(this.boundingSphere), sY.applyMatrix4(r), !1 !== e.ray.intersectsSphere(sY))) { if (sX.copy(r).invert(), sK.copy(e.ray).applyMatrix4(sX), null !== this.boundingBox && !1 === sK.intersectsBox(this.boundingBox)) return; this._computeIntersections(e, t, sK) } } getVertexPosition(e, t) { return super.getVertexPosition(e, t), this.applyBoneTransform(e, t), t } bind(e, t) { this.skeleton = e, void 0 === t && (this.updateMatrixWorld(!0), this.skeleton.calculateInverses(), t = this.matrixWorld), this.bindMatrix.copy(t), this.bindMatrixInverse.copy(t).invert() } pose() { this.skeleton.pose() } normalizeSkinWeights() { let e = new re, t = this.geometry.attributes.skinWeight; for (let i = 0, r = t.count; i < r; i++) { e.fromBufferAttribute(t, i); let r = 1 / e.manhattanLength(); r !== 1 / 0 ? e.multiplyScalar(r) : e.set(1, 0, 0, 0), t.setXYZW(i, e.x, e.y, e.z, e.w) } } updateMatrixWorld(e) { super.updateMatrixWorld(e), this.bindMode === ef ? this.bindMatrixInverse.copy(this.matrixWorld).invert() : this.bindMode === ep ? this.bindMatrixInverse.copy(this.bindMatrix).invert() : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode) } applyBoneTransform(e, t) { let i = this.skeleton, r = this.geometry; sG.fromBufferAttribute(r.attributes.skinIndex, e), sH.fromBufferAttribute(r.attributes.skinWeight, e), sz.copy(t).applyMatrix4(this.bindMatrix), t.set(0, 0, 0); for (let e = 0; e < 4; e++) { let r = sH.getComponent(e); if (0 !== r) { let n = sG.getComponent(e); sW.multiplyMatrices(i.bones[n].matrixWorld, i.boneInverses[n]), t.addScaledVector(sV.copy(sz).applyMatrix4(sW), r) } } return t.applyMatrix4(this.bindMatrixInverse) } } class sQ extends nt { constructor() { super(), this.isBone = !0, this.type = "Bone" } } class sZ extends i7 { constructor(e = null, t = 1, i = 1, r, n, s, a, o, l = eb, u = eb, h, c) { super(null, s, a, o, l, u, r, n, h, c), this.isDataTexture = !0, this.image = { data: e, width: t, height: i }, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1 } } let s$ = new rN, sJ = new rN; class s0 { constructor(e = [], t = []) { this.uuid = iD(), this.bones = e.slice(0), this.boneInverses = t, this.boneMatrices = null, this.boneTexture = null, this.init() } init() { let e = this.bones, t = this.boneInverses; if (this.boneMatrices = new Float32Array(16 * e.length), 0 === t.length) this.calculateInverses(); else if (e.length !== t.length) { console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."), this.boneInverses = []; for (let e = 0, t = this.bones.length; e < t; e++)this.boneInverses.push(new rN) } } calculateInverses() { this.boneInverses.length = 0; for (let e = 0, t = this.bones.length; e < t; e++) { let t = new rN; this.bones[e] && t.copy(this.bones[e].matrixWorld).invert(), this.boneInverses.push(t) } } pose() { for (let e = 0, t = this.bones.length; e < t; e++) { let t = this.bones[e]; t && t.matrixWorld.copy(this.boneInverses[e]).invert() } for (let e = 0, t = this.bones.length; e < t; e++) { let t = this.bones[e]; t && (t.parent && t.parent.isBone ? (t.matrix.copy(t.parent.matrixWorld).invert(), t.matrix.multiply(t.matrixWorld)) : t.matrix.copy(t.matrixWorld), t.matrix.decompose(t.position, t.quaternion, t.scale)) } } update() { let e = this.bones, t = this.boneInverses, i = this.boneMatrices, r = this.boneTexture; for (let r = 0, n = e.length; r < n; r++) { let n = e[r] ? e[r].matrixWorld : sJ; s$.multiplyMatrices(n, t[r]), s$.toArray(i, 16 * r) } null !== r && (r.needsUpdate = !0) } clone() { return new s0(this.bones, this.boneInverses) } computeBoneTexture() { let e = Math.sqrt(4 * this.bones.length), t = new Float32Array((e = Math.max(e = 4 * Math.ceil(e / 4), 4)) * e * 4); t.set(this.boneMatrices); let i = new sZ(t, e, e, eK, ez); return i.needsUpdate = !0, this.boneMatrices = t, this.boneTexture = i, this } getBoneByName(e) { for (let t = 0, i = this.bones.length; t < i; t++) { let i = this.bones[t]; if (i.name === e) return i } } dispose() { null !== this.boneTexture && (this.boneTexture.dispose(), this.boneTexture = null) } fromJSON(e, t) { this.uuid = e.uuid; for (let i = 0, r = e.bones.length; i < r; i++) { let r = e.bones[i], n = t[r]; void 0 === n && (console.warn("THREE.Skeleton: No bone found with UUID:", r), n = new sQ), this.bones.push(n), this.boneInverses.push(new rN().fromArray(e.boneInverses[i])) } return this.init(), this } toJSON() { let e = { metadata: { version: 4.6, type: "Skeleton", generator: "Skeleton.toJSON" }, bones: [], boneInverses: [] }; e.uuid = this.uuid; let t = this.bones, i = this.boneInverses; for (let r = 0, n = t.length; r < n; r++) { let n = t[r]; e.bones.push(n.uuid); let s = i[r]; e.boneInverses.push(s.toArray()) } return e } } class s1 extends nP { constructor(e, t, i, r = 1) { super(e, t, i), this.isInstancedBufferAttribute = !0, this.meshPerAttribute = r } copy(e) { return super.copy(e), this.meshPerAttribute = e.meshPerAttribute, this } toJSON() { let e = super.toJSON(); return e.meshPerAttribute = this.meshPerAttribute, e.isInstancedBufferAttribute = !0, e } } let s2 = new rN, s3 = new rN, s4 = [], s5 = new rc, s8 = new rN, s6 = new n6, s9 = new rC; class s7 extends n6 { constructor(e, t, i) { super(e, t), this.isInstancedMesh = !0, this.instanceMatrix = new s1(new Float32Array(16 * i), 16), this.instanceColor = null, this.morphTexture = null, this.count = i, this.boundingBox = null, this.boundingSphere = null; for (let e = 0; e < i; e++)this.setMatrixAt(e, s8) } computeBoundingBox() { let e = this.geometry, t = this.count; null === this.boundingBox && (this.boundingBox = new rc), null === e.boundingBox && e.computeBoundingBox(), this.boundingBox.makeEmpty(); for (let i = 0; i < t; i++)this.getMatrixAt(i, s2), s5.copy(e.boundingBox).applyMatrix4(s2), this.boundingBox.union(s5) } computeBoundingSphere() { let e = this.geometry, t = this.count; null === this.boundingSphere && (this.boundingSphere = new rC), null === e.boundingSphere && e.computeBoundingSphere(), this.boundingSphere.makeEmpty(); for (let i = 0; i < t; i++)this.getMatrixAt(i, s2), s9.copy(e.boundingSphere).applyMatrix4(s2), this.boundingSphere.union(s9) } copy(e, t) { return super.copy(e, t), this.instanceMatrix.copy(e.instanceMatrix), null !== e.morphTexture && (this.morphTexture = e.morphTexture.clone()), null !== e.instanceColor && (this.instanceColor = e.instanceColor.clone()), this.count = e.count, null !== e.boundingBox && (this.boundingBox = e.boundingBox.clone()), null !== e.boundingSphere && (this.boundingSphere = e.boundingSphere.clone()), this } getColorAt(e, t) { t.fromArray(this.instanceColor.array, 3 * e) } getMatrixAt(e, t) { t.fromArray(this.instanceMatrix.array, 16 * e) } getMorphAt(e, t) { let i = t.morphTargetInfluences, r = this.morphTexture.source.data.data, n = e * (i.length + 1) + 1; for (let e = 0; e < i.length; e++)i[e] = r[n + e] } raycast(e, t) { let i = this.matrixWorld, r = this.count; if (s6.geometry = this.geometry, s6.material = this.material, void 0 !== s6.material && (null === this.boundingSphere && this.computeBoundingSphere(), s9.copy(this.boundingSphere), s9.applyMatrix4(i), !1 !== e.ray.intersectsSphere(s9))) for (let n = 0; n < r; n++) { this.getMatrixAt(n, s2), s3.multiplyMatrices(i, s2), s6.matrixWorld = s3, s6.raycast(e, s4); for (let e = 0, i = s4.length; e < i; e++) { let i = s4[e]; i.instanceId = n, i.object = this, t.push(i) } s4.length = 0 } } setColorAt(e, t) { null === this.instanceColor && (this.instanceColor = new s1(new Float32Array(3 * this.instanceMatrix.count).fill(1), 3)), t.toArray(this.instanceColor.array, 3 * e) } setMatrixAt(e, t) { t.toArray(this.instanceMatrix.array, 16 * e) } setMorphAt(e, t) { let i = t.morphTargetInfluences, r = i.length + 1; null === this.morphTexture && (this.morphTexture = new sZ(new Float32Array(r * this.count), r, this.count, eJ, ez)); let n = this.morphTexture.source.data.data, s = 0; for (let e = 0; e < i.length; e++)s += i[e]; let a = this.geometry.morphTargetsRelative ? 1 : 1 - s, o = r * e; n[o] = a, n.set(i, o + 1) } updateMorphTargets() { } dispose() { this.dispatchEvent({ type: "dispose" }), null !== this.morphTexture && (this.morphTexture.dispose(), this.morphTexture = null) } } let ae = new rl, at = new rl, ai = new iG; class ar { constructor(e = new rl(1, 0, 0), t = 0) { this.isPlane = !0, this.normal = e, this.constant = t } set(e, t) { return this.normal.copy(e), this.constant = t, this } setComponents(e, t, i, r) { return this.normal.set(e, t, i), this.constant = r, this } setFromNormalAndCoplanarPoint(e, t) { return this.normal.copy(e), this.constant = -t.dot(this.normal), this } setFromCoplanarPoints(e, t, i) { let r = ae.subVectors(i, t).cross(at.subVectors(e, t)).normalize(); return this.setFromNormalAndCoplanarPoint(r, e), this } copy(e) { return this.normal.copy(e.normal), this.constant = e.constant, this } normalize() { let e = 1 / this.normal.length(); return this.normal.multiplyScalar(e), this.constant *= e, this } negate() { return this.constant *= -1, this.normal.negate(), this } distanceToPoint(e) { return this.normal.dot(e) + this.constant } distanceToSphere(e) { return this.distanceToPoint(e.center) - e.radius } projectPoint(e, t) { return t.copy(e).addScaledVector(this.normal, -this.distanceToPoint(e)) } intersectLine(e, t) { let i = e.delta(ae), r = this.normal.dot(i); if (0 === r) return 0 === this.distanceToPoint(e.start) ? t.copy(e.start) : null; let n = -(e.start.dot(this.normal) + this.constant) / r; return n < 0 || n > 1 ? null : t.copy(e.start).addScaledVector(i, n) } intersectsLine(e) { let t = this.distanceToPoint(e.start), i = this.distanceToPoint(e.end); return t < 0 && i > 0 || i < 0 && t > 0 } intersectsBox(e) { return e.intersectsPlane(this) } intersectsSphere(e) { return e.intersectsPlane(this) } coplanarPoint(e) { return e.copy(this.normal).multiplyScalar(-this.constant) } applyMatrix4(e, t) { let i = t || ai.getNormalMatrix(e), r = this.coplanarPoint(ae).applyMatrix4(e), n = this.normal.applyMatrix3(i).normalize(); return this.constant = -r.dot(n), this } translate(e) { return this.constant -= e.dot(this.normal), this } equals(e) { return e.normal.equals(this.normal) && e.constant === this.constant } clone() { return new this.constructor().copy(this) } } let an = new rC, as = new rl; class aa { constructor(e = new ar, t = new ar, i = new ar, r = new ar, n = new ar, s = new ar) { this.planes = [e, t, i, r, n, s] } set(e, t, i, r, n, s) { let a = this.planes; return a[0].copy(e), a[1].copy(t), a[2].copy(i), a[3].copy(r), a[4].copy(n), a[5].copy(s), this } copy(e) { let t = this.planes; for (let i = 0; i < 6; i++)t[i].copy(e.planes[i]); return this } setFromProjectionMatrix(e, t = iT) { let i = this.planes, r = e.elements, n = r[0], s = r[1], a = r[2], o = r[3], l = r[4], u = r[5], h = r[6], c = r[7], d = r[8], f = r[9], p = r[10], m = r[11], g = r[12], v = r[13], y = r[14], x = r[15]; if (i[0].setComponents(o - n, c - l, m - d, x - g).normalize(), i[1].setComponents(o + n, c + l, m + d, x + g).normalize(), i[2].setComponents(o + s, c + u, m + f, x + v).normalize(), i[3].setComponents(o - s, c - u, m - f, x - v).normalize(), i[4].setComponents(o - a, c - h, m - p, x - y).normalize(), t === iT) i[5].setComponents(o + a, c + h, m + p, x + y).normalize(); else if (t === iw) i[5].setComponents(a, h, p, y).normalize(); else throw Error("THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: " + t); return this } intersectsObject(e) { if (void 0 !== e.boundingSphere) null === e.boundingSphere && e.computeBoundingSphere(), an.copy(e.boundingSphere).applyMatrix4(e.matrixWorld); else { let t = e.geometry; null === t.boundingSphere && t.computeBoundingSphere(), an.copy(t.boundingSphere).applyMatrix4(e.matrixWorld) } return this.intersectsSphere(an) } intersectsSprite(e) { return an.center.set(0, 0, 0), an.radius = .7071067811865476, an.applyMatrix4(e.matrixWorld), this.intersectsSphere(an) } intersectsSphere(e) { let t = this.planes, i = e.center, r = -e.radius; for (let e = 0; e < 6; e++)if (t[e].distanceToPoint(i) < r) return !1; return !0 } intersectsBox(e) { let t = this.planes; for (let i = 0; i < 6; i++) { let r = t[i]; if (as.x = r.normal.x > 0 ? e.max.x : e.min.x, as.y = r.normal.y > 0 ? e.max.y : e.min.y, as.z = r.normal.z > 0 ? e.max.z : e.min.z, 0 > r.distanceToPoint(as)) return !1 } return !0 } containsPoint(e) { let t = this.planes; for (let i = 0; i < 6; i++)if (0 > t[i].distanceToPoint(e)) return !1; return !0 } clone() { return new this.constructor().copy(this) } } function ao(e, t) { return e - t } function al(e, t) { return e.z - t.z } function au(e, t) { return t.z - e.z } class ah { constructor() { this.index = 0, this.pool = [], this.list = [] } push(e, t, i, r) { let n = this.pool, s = this.list; this.index >= n.length && n.push({ start: -1, count: -1, z: -1, index: -1 }); let a = n[this.index]; s.push(a), this.index++, a.start = e, a.count = t, a.z = i, a.index = r } reset() { this.list.length = 0, this.index = 0 } } let ac = new rN, ad = new nS(1, 1, 1), af = new aa, ap = new rc, am = new rC, ag = new rl, av = new rl, ay = new rl, ax = new ah, aS = new n6, aA = []; function a_(e, t) { if (e.constructor !== t.constructor) { let i = Math.min(e.length, t.length); for (let r = 0; r < i; r++)t[r] = e[r] } else { let i = Math.min(e.length, t.length); t.set(new e.constructor(e.buffer, 0, i)) } } class aE extends n6 { constructor(e, t, i = 2 * t, r) { super(new nq, r), this.isBatchedMesh = !0, this.perObjectFrustumCulled = !0, this.sortObjects = !0, this.boundingBox = null, this.boundingSphere = null, this.customSort = null, this._instanceInfo = [], this._geometryInfo = [], this._availableInstanceIds = [], this._availableGeometryIds = [], this._nextIndexStart = 0, this._nextVertexStart = 0, this._geometryCount = 0, this._visibilityChanged = !0, this._geometryInitialized = !1, this._maxInstanceCount = e, this._maxVertexCount = t, this._maxIndexCount = i, this._multiDrawCounts = new Int32Array(e), this._multiDrawStarts = new Int32Array(e), this._multiDrawCount = 0, this._multiDrawInstances = null, this._matricesTexture = null, this._indirectTexture = null, this._colorsTexture = null, this._initMatricesTexture(), this._initIndirectTexture() } get maxInstanceCount() { return this._maxInstanceCount } get instanceCount() { return this._instanceInfo.length - this._availableInstanceIds.length } get unusedVertexCount() { return this._maxVertexCount - this._nextVertexStart } get unusedIndexCount() { return this._maxIndexCount - this._nextIndexStart } _initMatricesTexture() { let e = Math.sqrt(4 * this._maxInstanceCount), t = new sZ(new Float32Array((e = Math.max(e = 4 * Math.ceil(e / 4), 4)) * e * 4), e, e, eK, ez); this._matricesTexture = t } _initIndirectTexture() { let e = Math.sqrt(this._maxInstanceCount), t = new sZ(new Uint32Array((e = Math.ceil(e)) * e), e, e, e0, eB); this._indirectTexture = t } _initColorsTexture() { let e = Math.sqrt(this._maxInstanceCount), t = new sZ(new Float32Array((e = Math.ceil(e)) * e * 4).fill(1), e, e, eK, ez); t.colorSpace = i1.workingColorSpace, this._colorsTexture = t } _initializeGeometry(e) { let t = this.geometry, i = this._maxVertexCount, r = this._maxIndexCount; if (!1 === this._geometryInitialized) { for (let r in e.attributes) { let { array: n, itemSize: s, normalized: a } = e.getAttribute(r), o = new nP(new n.constructor(i * s), s, a); t.setAttribute(r, o) } if (null !== e.getIndex()) { let e = i > 65535 ? new Uint32Array(r) : new Uint16Array(r); t.setIndex(new nP(e, 1)) } this._geometryInitialized = !0 } } _validateGeometry(e) { let t = this.geometry; if (!!e.getIndex() != !!t.getIndex()) throw Error('THREE.BatchedMesh: All geometries must consistently have "index".'); for (let i in t.attributes) { if (!e.hasAttribute(i)) throw Error(`THREE.BatchedMesh: Added geometry missing "${i}". All geometries must have consistent attributes.`); let r = e.getAttribute(i), n = t.getAttribute(i); if (r.itemSize !== n.itemSize || r.normalized !== n.normalized) throw Error("THREE.BatchedMesh: All attributes must have a consistent itemSize and normalized value.") } } validateInstanceId(e) { let t = this._instanceInfo; if (e < 0 || e >= t.length || !1 === t[e].active) throw Error(`THREE.BatchedMesh: Invalid instanceId ${e}. Instance is either out of range or has been deleted.`) } validateGeometryId(e) { let t = this._geometryInfo; if (e < 0 || e >= t.length || !1 === t[e].active) throw Error(`THREE.BatchedMesh: Invalid geometryId ${e}. Geometry is either out of range or has been deleted.`) } setCustomSort(e) { return this.customSort = e, this } computeBoundingBox() { null === this.boundingBox && (this.boundingBox = new rc); let e = this.boundingBox, t = this._instanceInfo; e.makeEmpty(); for (let i = 0, r = t.length; i < r; i++) { if (!1 === t[i].active) continue; let r = t[i].geometryIndex; this.getMatrixAt(i, ac), this.getBoundingBoxAt(r, ap).applyMatrix4(ac), e.union(ap) } } computeBoundingSphere() { null === this.boundingSphere && (this.boundingSphere = new rC); let e = this.boundingSphere, t = this._instanceInfo; e.makeEmpty(); for (let i = 0, r = t.length; i < r; i++) { if (!1 === t[i].active) continue; let r = t[i].geometryIndex; this.getMatrixAt(i, ac), this.getBoundingSphereAt(r, am).applyMatrix4(ac), e.union(am) } } addInstance(e) { if (this._instanceInfo.length >= this.maxInstanceCount && 0 === this._availableInstanceIds.length) throw Error("THREE.BatchedMesh: Maximum item count reached."); let t = { visible: !0, active: !0, geometryIndex: e }, i = null; this._availableInstanceIds.length > 0 ? (this._availableInstanceIds.sort(ao), i = this._availableInstanceIds.shift(), this._instanceInfo[i] = t) : (i = this._instanceInfo.length, this._instanceInfo.push(t)); let r = this._matricesTexture; ac.identity().toArray(r.image.data, 16 * i), r.needsUpdate = !0; let n = this._colorsTexture; return n && (ad.toArray(n.image.data, 4 * i), n.needsUpdate = !0), this._visibilityChanged = !0, i } addGeometry(e, t = -1, i = -1) { let r; this._initializeGeometry(e), this._validateGeometry(e); let n = { vertexStart: -1, vertexCount: -1, reservedVertexCount: -1, indexStart: -1, indexCount: -1, reservedIndexCount: -1, start: -1, count: -1, boundingBox: null, boundingSphere: null, active: !0 }, s = this._geometryInfo; n.vertexStart = this._nextVertexStart, n.reservedVertexCount = -1 === t ? e.getAttribute("position").count : t; let a = e.getIndex(); if (null !== a && (n.indexStart = this._nextIndexStart, n.reservedIndexCount = -1 === i ? a.count : i), -1 !== n.indexStart && n.indexStart + n.reservedIndexCount > this._maxIndexCount || n.vertexStart + n.reservedVertexCount > this._maxVertexCount) throw Error("THREE.BatchedMesh: Reserved space request exceeds the maximum buffer size."); return this._availableGeometryIds.length > 0 ? (this._availableGeometryIds.sort(ao), s[r = this._availableGeometryIds.shift()] = n) : (r = this._geometryCount, this._geometryCount++, s.push(n)), this.setGeometryAt(r, e), this._nextIndexStart = n.indexStart + n.reservedIndexCount, this._nextVertexStart = n.vertexStart + n.reservedVertexCount, r } setGeometryAt(e, t) { if (e >= this._geometryCount) throw Error("THREE.BatchedMesh: Maximum geometry count reached."); this._validateGeometry(t); let i = this.geometry, r = null !== i.getIndex(), n = i.getIndex(), s = t.getIndex(), a = this._geometryInfo[e]; if (r && s.count > a.reservedIndexCount || t.attributes.position.count > a.reservedVertexCount) throw Error("THREE.BatchedMesh: Reserved space not large enough for provided geometry."); let o = a.vertexStart, l = a.reservedVertexCount; for (let e in a.vertexCount = t.getAttribute("position").count, i.attributes) { let r = t.getAttribute(e), n = i.getAttribute(e); !function (e, t, i = 0) { let r = t.itemSize; if (e.isInterleavedBufferAttribute || e.array.constructor !== t.array.constructor) { let n = e.count; for (let s = 0; s < n; s++)for (let n = 0; n < r; n++)t.setComponent(s + i, n, e.getComponent(s, n)) } else t.array.set(e.array, i * r); t.needsUpdate = !0 }(r, n, o); let s = r.itemSize; for (let e = r.count; e < l; e++) { let t = o + e; for (let e = 0; e < s; e++)n.setComponent(t, e, 0) } n.needsUpdate = !0, n.addUpdateRange(o * s, l * s) } if (r) { let e = a.indexStart, i = a.reservedIndexCount; a.indexCount = t.getIndex().count; for (let t = 0; t < s.count; t++)n.setX(e + t, o + s.getX(t)); for (let t = s.count; t < i; t++)n.setX(e + t, o); n.needsUpdate = !0, n.addUpdateRange(e, a.reservedIndexCount) } return a.start = r ? a.indexStart : a.vertexStart, a.count = r ? a.indexCount : a.vertexCount, a.boundingBox = null, null !== t.boundingBox && (a.boundingBox = t.boundingBox.clone()), a.boundingSphere = null, null !== t.boundingSphere && (a.boundingSphere = t.boundingSphere.clone()), this._visibilityChanged = !0, e } deleteGeometry(e) { let t = this._geometryInfo; if (e >= t.length || !1 === t[e].active) return this; let i = this._instanceInfo; for (let t = 0, r = i.length; t < r; t++)i[t].active && i[t].geometryIndex === e && this.deleteInstance(t); return t[e].active = !1, this._availableGeometryIds.push(e), this._visibilityChanged = !0, this } deleteInstance(e) { return this.validateInstanceId(e), this._instanceInfo[e].active = !1, this._availableInstanceIds.push(e), this._visibilityChanged = !0, this } optimize() { let e = 0, t = 0, i = this._geometryInfo, r = i.map((e, t) => t).sort((e, t) => i[e].vertexStart - i[t].vertexStart), n = this.geometry; for (let s = 0, a = i.length; s < a; s++) { let a = i[r[s]]; if (!1 !== a.active) { if (null !== n.index) { if (a.indexStart !== t) { let { indexStart: i, vertexStart: r, reservedIndexCount: s } = a, o = n.index, l = o.array, u = e - r; for (let e = i; e < i + s; e++)l[e] = l[e] + u; o.array.copyWithin(t, i, i + s), o.addUpdateRange(t, s), a.indexStart = t } t += a.reservedIndexCount } if (a.vertexStart !== e) { let { vertexStart: t, reservedVertexCount: i } = a, r = n.attributes; for (let n in r) { let s = r[n], { array: a, itemSize: o } = s; a.copyWithin(e * o, t * o, (t + i) * o), s.addUpdateRange(e * o, i * o) } a.vertexStart = e } e += a.reservedVertexCount, a.start = n.index ? a.indexStart : a.vertexStart, this._nextIndexStart = n.index ? a.indexStart + a.reservedIndexCount : 0, this._nextVertexStart = a.vertexStart + a.reservedVertexCount } } return this } getBoundingBoxAt(e, t) { if (e >= this._geometryCount) return null; let i = this.geometry, r = this._geometryInfo[e]; if (null === r.boundingBox) { let e = new rc, t = i.index, n = i.attributes.position; for (let i = r.start, s = r.start + r.count; i < s; i++) { let r = i; t && (r = t.getX(r)), e.expandByPoint(ag.fromBufferAttribute(n, r)) } r.boundingBox = e } return t.copy(r.boundingBox), t } getBoundingSphereAt(e, t) { if (e >= this._geometryCount) return null; let i = this.geometry, r = this._geometryInfo[e]; if (null === r.boundingSphere) { let t = new rC; this.getBoundingBoxAt(e, ap), ap.getCenter(t.center); let n = i.index, s = i.attributes.position, a = 0; for (let e = r.start, i = r.start + r.count; e < i; e++) { let i = e; n && (i = n.getX(i)), ag.fromBufferAttribute(s, i), a = Math.max(a, t.center.distanceToSquared(ag)) } t.radius = Math.sqrt(a), r.boundingSphere = t } return t.copy(r.boundingSphere), t } setMatrixAt(e, t) { this.validateInstanceId(e); let i = this._matricesTexture, r = this._matricesTexture.image.data; return t.toArray(r, 16 * e), i.needsUpdate = !0, this } getMatrixAt(e, t) { return this.validateInstanceId(e), t.fromArray(this._matricesTexture.image.data, 16 * e) } setColorAt(e, t) { return this.validateInstanceId(e), null === this._colorsTexture && this._initColorsTexture(), t.toArray(this._colorsTexture.image.data, 4 * e), this._colorsTexture.needsUpdate = !0, this } getColorAt(e, t) { return this.validateInstanceId(e), t.fromArray(this._colorsTexture.image.data, 4 * e) } setVisibleAt(e, t) { return this.validateInstanceId(e), this._instanceInfo[e].visible === t || (this._instanceInfo[e].visible = t, this._visibilityChanged = !0), this } getVisibleAt(e) { return this.validateInstanceId(e), this._instanceInfo[e].visible } setGeometryIdAt(e, t) { return this.validateInstanceId(e), this.validateGeometryId(t), this._instanceInfo[e].geometryIndex = t, this } getGeometryIdAt(e) { return this.validateInstanceId(e), this._instanceInfo[e].geometryIndex } getGeometryRangeAt(e, t = {}) { this.validateGeometryId(e); let i = this._geometryInfo[e]; return t.vertexStart = i.vertexStart, t.vertexCount = i.vertexCount, t.reservedVertexCount = i.reservedVertexCount, t.indexStart = i.indexStart, t.indexCount = i.indexCount, t.reservedIndexCount = i.reservedIndexCount, t.start = i.start, t.count = i.count, t } setInstanceCount(e) { let t = this._availableInstanceIds, i = this._instanceInfo; for (t.sort(ao); t[t.length - 1] === i.length;)i.pop(), t.pop(); if (e < i.length) throw Error(`BatchedMesh: Instance ids outside the range ${e} are being used. Cannot shrink instance count.`); let r = new Int32Array(e), n = new Int32Array(e); a_(this._multiDrawCounts, r), a_(this._multiDrawStarts, n), this._multiDrawCounts = r, this._multiDrawStarts = n, this._maxInstanceCount = e; let s = this._indirectTexture, a = this._matricesTexture, o = this._colorsTexture; s.dispose(), this._initIndirectTexture(), a_(s.image.data, this._indirectTexture.image.data), a.dispose(), this._initMatricesTexture(), a_(a.image.data, this._matricesTexture.image.data), o && (o.dispose(), this._initColorsTexture(), a_(o.image.data, this._colorsTexture.image.data)) } setGeometrySize(e, t) { let i = [...this._geometryInfo].filter(e => e.active); if (Math.max(...i.map(e => e.vertexStart + e.reservedVertexCount)) > e) throw Error(`BatchedMesh: Geometry vertex values are being used outside the range ${t}. Cannot shrink further.`); if (this.geometry.index && Math.max(...i.map(e => e.indexStart + e.reservedIndexCount)) > t) throw Error(`BatchedMesh: Geometry index values are being used outside the range ${t}. Cannot shrink further.`); let r = this.geometry; r.dispose(), this._maxVertexCount = e, this._maxIndexCount = t, this._geometryInitialized && (this._geometryInitialized = !1, this.geometry = new nq, this._initializeGeometry(r)); let n = this.geometry; for (let e in r.index && a_(r.index.array, n.index.array), r.attributes) a_(r.attributes[e].array, n.attributes[e].array) } raycast(e, t) { let i = this._instanceInfo, r = this._geometryInfo, n = this.matrixWorld, s = this.geometry; aS.material = this.material, aS.geometry.index = s.index, aS.geometry.attributes = s.attributes, null === aS.geometry.boundingBox && (aS.geometry.boundingBox = new rc), null === aS.geometry.boundingSphere && (aS.geometry.boundingSphere = new rC); for (let s = 0, a = i.length; s < a; s++) { if (!i[s].visible || !i[s].active) continue; let a = i[s].geometryIndex, o = r[a]; aS.geometry.setDrawRange(o.start, o.count), this.getMatrixAt(s, aS.matrixWorld).premultiply(n), this.getBoundingBoxAt(a, aS.geometry.boundingBox), this.getBoundingSphereAt(a, aS.geometry.boundingSphere), aS.raycast(e, aA); for (let e = 0, i = aA.length; e < i; e++) { let i = aA[e]; i.object = this, i.batchId = s, t.push(i) } aA.length = 0 } aS.material = null, aS.geometry.index = null, aS.geometry.attributes = {}, aS.geometry.setDrawRange(0, 1 / 0) } copy(e) { return super.copy(e), this.geometry = e.geometry.clone(), this.perObjectFrustumCulled = e.perObjectFrustumCulled, this.sortObjects = e.sortObjects, this.boundingBox = null !== e.boundingBox ? e.boundingBox.clone() : null, this.boundingSphere = null !== e.boundingSphere ? e.boundingSphere.clone() : null, this._geometryInfo = e._geometryInfo.map(e => ({ ...e, boundingBox: null !== e.boundingBox ? e.boundingBox.clone() : null, boundingSphere: null !== e.boundingSphere ? e.boundingSphere.clone() : null })), this._instanceInfo = e._instanceInfo.map(e => ({ ...e })), this._maxInstanceCount = e._maxInstanceCount, this._maxVertexCount = e._maxVertexCount, this._maxIndexCount = e._maxIndexCount, this._geometryInitialized = e._geometryInitialized, this._geometryCount = e._geometryCount, this._multiDrawCounts = e._multiDrawCounts.slice(), this._multiDrawStarts = e._multiDrawStarts.slice(), this._matricesTexture = e._matricesTexture.clone(), this._matricesTexture.image.data = this._matricesTexture.image.data.slice(), null !== this._colorsTexture && (this._colorsTexture = e._colorsTexture.clone(), this._colorsTexture.image.data = this._colorsTexture.image.data.slice()), this } dispose() { this.geometry.dispose(), this._matricesTexture.dispose(), this._matricesTexture = null, this._indirectTexture.dispose(), this._indirectTexture = null, null !== this._colorsTexture && (this._colorsTexture.dispose(), this._colorsTexture = null) } onBeforeRender(e, t, i, r, n) { if (!this._visibilityChanged && !this.perObjectFrustumCulled && !this.sortObjects) return; let s = r.getIndex(), a = null === s ? 1 : s.array.BYTES_PER_ELEMENT, o = this._instanceInfo, l = this._multiDrawStarts, u = this._multiDrawCounts, h = this._geometryInfo, c = this.perObjectFrustumCulled, d = this._indirectTexture, f = d.image.data; c && (ac.multiplyMatrices(i.projectionMatrix, i.matrixWorldInverse).multiply(this.matrixWorld), af.setFromProjectionMatrix(ac, e.coordinateSystem)); let p = 0; if (this.sortObjects) { ac.copy(this.matrixWorld).invert(), ag.setFromMatrixPosition(i.matrixWorld).applyMatrix4(ac), av.set(0, 0, -1).transformDirection(i.matrixWorld).transformDirection(ac); for (let e = 0, t = o.length; e < t; e++)if (o[e].visible && o[e].active) { let t = o[e].geometryIndex; this.getMatrixAt(e, ac), this.getBoundingSphereAt(t, am).applyMatrix4(ac); let i = !1; if (c && (i = !af.intersectsSphere(am)), !i) { let i = h[t], r = ay.subVectors(am.center, ag).dot(av); ax.push(i.start, i.count, r, e) } } let e = ax.list, t = this.customSort; null === t ? e.sort(n.transparent ? au : al) : t.call(this, e, i); for (let t = 0, i = e.length; t < i; t++) { let i = e[t]; l[p] = i.start * a, u[p] = i.count, f[p] = i.index, p++ } ax.reset() } else for (let e = 0, t = o.length; e < t; e++)if (o[e].visible && o[e].active) { let t = o[e].geometryIndex, i = !1; if (c && (this.getMatrixAt(e, ac), this.getBoundingSphereAt(t, am).applyMatrix4(ac), i = !af.intersectsSphere(am)), !i) { let i = h[t]; l[p] = i.start * a, u[p] = i.count, f[p] = e, p++ } } d.needsUpdate = !0, this._multiDrawCount = p, this._visibilityChanged = !1 } onBeforeShadow(e, t, i, r, n, s) { this.onBeforeRender(e, null, r, n, s) } } class ab extends nE { constructor(e) { super(), this.isLineBasicMaterial = !0, this.type = "LineBasicMaterial", this.color = new nS(0xffffff), this.map = null, this.linewidth = 1, this.linecap = "round", this.linejoin = "round", this.fog = !0, this.setValues(e) } copy(e) { return super.copy(e), this.color.copy(e.color), this.map = e.map, this.linewidth = e.linewidth, this.linecap = e.linecap, this.linejoin = e.linejoin, this.fog = e.fog, this } } let aT = new rl, aw = new rl, aM = new rN, aR = new rU, aC = new rC, aI = new rl, aL = new rl; class aP extends nt { constructor(e = new nq, t = new ab) { super(), this.isLine = !0, this.type = "Line", this.geometry = e, this.material = t, this.morphTargetDictionary = void 0, this.morphTargetInfluences = void 0, this.updateMorphTargets() } copy(e, t) { return super.copy(e, t), this.material = Array.isArray(e.material) ? e.material.slice() : e.material, this.geometry = e.geometry, this } computeLineDistances() { let e = this.geometry; if (null === e.index) { let t = e.attributes.position, i = [0]; for (let e = 1, r = t.count; e < r; e++)aT.fromBufferAttribute(t, e - 1), aw.fromBufferAttribute(t, e), i[e] = i[e - 1], i[e] += aT.distanceTo(aw); e.setAttribute("lineDistance", new nG(i, 1)) } else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."); return this } raycast(e, t) { let i = this.geometry, r = this.matrixWorld, n = e.params.Line.threshold, s = i.drawRange; if (null === i.boundingSphere && i.computeBoundingSphere(), aC.copy(i.boundingSphere), aC.applyMatrix4(r), aC.radius += n, !1 === e.ray.intersectsSphere(aC)) return; aM.copy(r).invert(), aR.copy(e.ray).applyMatrix4(aM); let a = n / ((this.scale.x + this.scale.y + this.scale.z) / 3), o = a * a, l = this.isLineSegments ? 2 : 1, u = i.index, h = i.attributes.position; if (null !== u) { let i = Math.max(0, s.start), r = Math.min(u.count, s.start + s.count); for (let n = i, s = r - 1; n < s; n += l) { let i = aD(this, e, aR, o, u.getX(n), u.getX(n + 1), n); i && t.push(i) } if (this.isLineLoop) { let n = aD(this, e, aR, o, u.getX(r - 1), u.getX(i), r - 1); n && t.push(n) } } else { let i = Math.max(0, s.start), r = Math.min(h.count, s.start + s.count); for (let n = i, s = r - 1; n < s; n += l) { let i = aD(this, e, aR, o, n, n + 1, n); i && t.push(i) } if (this.isLineLoop) { let n = aD(this, e, aR, o, r - 1, i, r - 1); n && t.push(n) } } } updateMorphTargets() { let e = this.geometry.morphAttributes, t = Object.keys(e); if (t.length > 0) { let i = e[t[0]]; if (void 0 !== i) { this.morphTargetInfluences = [], this.morphTargetDictionary = {}; for (let e = 0, t = i.length; e < t; e++) { let t = i[e].name || String(e); this.morphTargetInfluences.push(0), this.morphTargetDictionary[t] = e } } } } } function aD(e, t, i, r, n, s, a) { let o = e.geometry.attributes.position; if (aT.fromBufferAttribute(o, n), aw.fromBufferAttribute(o, s), i.distanceSqToSegment(aT, aw, aI, aL) > r) return; aI.applyMatrix4(e.matrixWorld); let l = t.ray.origin.distanceTo(aI); if (!(l < t.near) && !(l > t.far)) return { distance: l, point: aL.clone().applyMatrix4(e.matrixWorld), index: a, face: null, faceIndex: null, barycoord: null, object: e } } let aO = new rl, ak = new rl; class aF extends aP { constructor(e, t) { super(e, t), this.isLineSegments = !0, this.type = "LineSegments" } computeLineDistances() { let e = this.geometry; if (null === e.index) { let t = e.attributes.position, i = []; for (let e = 0, r = t.count; e < r; e += 2)aO.fromBufferAttribute(t, e), ak.fromBufferAttribute(t, e + 1), i[e] = 0 === e ? 0 : i[e - 1], i[e + 1] = i[e] + aO.distanceTo(ak); e.setAttribute("lineDistance", new nG(i, 1)) } else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."); return this } } class aU extends aP { constructor(e, t) { super(e, t), this.isLineLoop = !0, this.type = "LineLoop" } } class aN extends nE { constructor(e) { super(), this.isPointsMaterial = !0, this.type = "PointsMaterial", this.color = new nS(0xffffff), this.map = null, this.alphaMap = null, this.size = 1, this.sizeAttenuation = !0, this.fog = !0, this.setValues(e) } copy(e) { return super.copy(e), this.color.copy(e.color), this.map = e.map, this.alphaMap = e.alphaMap, this.size = e.size, this.sizeAttenuation = e.sizeAttenuation, this.fog = e.fog, this } } let aB = new rN, az = new rU, aG = new rC, aH = new rl; class aV extends nt { constructor(e = new nq, t = new aN) { super(), this.isPoints = !0, this.type = "Points", this.geometry = e, this.material = t, this.morphTargetDictionary = void 0, this.morphTargetInfluences = void 0, this.updateMorphTargets() } copy(e, t) { return super.copy(e, t), this.material = Array.isArray(e.material) ? e.material.slice() : e.material, this.geometry = e.geometry, this } raycast(e, t) { let i = this.geometry, r = this.matrixWorld, n = e.params.Points.threshold, s = i.drawRange; if (null === i.boundingSphere && i.computeBoundingSphere(), aG.copy(i.boundingSphere), aG.applyMatrix4(r), aG.radius += n, !1 === e.ray.intersectsSphere(aG)) return; aB.copy(r).invert(), az.copy(e.ray).applyMatrix4(aB); let a = n / ((this.scale.x + this.scale.y + this.scale.z) / 3), o = a * a, l = i.index, u = i.attributes.position; if (null !== l) { let i = Math.max(0, s.start), n = Math.min(l.count, s.start + s.count); for (let s = i; s < n; s++) { let i = l.getX(s); aH.fromBufferAttribute(u, i), aW(aH, i, o, r, e, t, this) } } else { let i = Math.max(0, s.start), n = Math.min(u.count, s.start + s.count); for (let s = i; s < n; s++)aH.fromBufferAttribute(u, s), aW(aH, s, o, r, e, t, this) } } updateMorphTargets() { let e = this.geometry.morphAttributes, t = Object.keys(e); if (t.length > 0) { let i = e[t[0]]; if (void 0 !== i) { this.morphTargetInfluences = [], this.morphTargetDictionary = {}; for (let e = 0, t = i.length; e < t; e++) { let t = i[e].name || String(e); this.morphTargetInfluences.push(0), this.morphTargetDictionary[t] = e } } } } } function aW(e, t, i, r, n, s, a) { let o = az.distanceSqToPoint(e); if (o < i) { let i = new rl; az.closestPointToPoint(e, i), i.applyMatrix4(r); let l = n.ray.origin.distanceTo(i); if (l < n.near || l > n.far) return; s.push({ distance: l, distanceToRay: Math.sqrt(o), point: i, index: t, face: null, faceIndex: null, barycoord: null, object: a }) } } class aj extends i7 { constructor(e, t, i, r, n, s, a, o, l) { super(e, t, i, r, n, s, a, o, l), this.isVideoTexture = !0, this.minFilter = void 0 !== s ? s : eC, this.magFilter = void 0 !== n ? n : eC, this.generateMipmaps = !1; let u = this; "requestVideoFrameCallback" in e && e.requestVideoFrameCallback(function t() { u.needsUpdate = !0, e.requestVideoFrameCallback(t) }) } clone() { return new this.constructor(this.image).copy(this) } update() { let e = this.image; !1 == "requestVideoFrameCallback" in e && e.readyState >= e.HAVE_CURRENT_DATA && (this.needsUpdate = !0) } } class aY extends aj { constructor(e, t, i, r, n, s, a, o) { super({}, e, t, i, r, n, s, a, o), this.isVideoFrameTexture = !0 } update() { } clone() { return new this.constructor().copy(this) } setFrame(e) { this.image = e, this.needsUpdate = !0 } } class aX extends i7 { constructor(e, t) { super({ width: e, height: t }), this.isFramebufferTexture = !0, this.magFilter = eb, this.minFilter = eb, this.generateMipmaps = !1, this.needsUpdate = !0 } } class aK extends i7 { constructor(e, t, i, r, n, s, a, o, l, u, h, c) { super(null, s, a, o, l, u, r, n, h, c), this.isCompressedTexture = !0, this.image = { width: t, height: i }, this.mipmaps = e, this.flipY = !1, this.generateMipmaps = !1 } } class aq extends aK { constructor(e, t, i, r, n, s) { super(e, t, i, n, s), this.isCompressedArrayTexture = !0, this.image.depth = r, this.wrapR = e_, this.layerUpdates = new Set } addLayerUpdate(e) { this.layerUpdates.add(e) } clearLayerUpdates() { this.layerUpdates.clear() } } class aQ extends aK { constructor(e, t, i) { super(void 0, e[0].width, e[0].height, t, i, eg), this.isCompressedCubeTexture = !0, this.isCubeTexture = !0, this.image = e } } class aZ extends i7 { constructor(e, t, i, r, n, s, a, o, l) { super(e, t, i, r, n, s, a, o, l), this.isCanvasTexture = !0, this.needsUpdate = !0 } } class a$ extends i7 { constructor(e, t, i, r, n, s, a, o, l, u = eZ) { if (u !== eZ && u !== e$) throw Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat"); void 0 === i && u === eZ && (i = eB), void 0 === i && u === e$ && (i = eW), super(null, r, n, s, a, o, u, i, l), this.isDepthTexture = !0, this.image = { width: e, height: t }, this.magFilter = void 0 !== a ? a : eb, this.minFilter = void 0 !== o ? o : eb, this.flipY = !1, this.generateMipmaps = !1, this.compareFunction = null } copy(e) { return super.copy(e), this.source = new i8(Object.assign({}, e.image)), this.compareFunction = e.compareFunction, this } toJSON(e) { let t = super.toJSON(e); return null !== this.compareFunction && (t.compareFunction = this.compareFunction), t } } class aJ { constructor() { this.type = "Curve", this.arcLengthDivisions = 200, this.needsUpdate = !1, this.cacheArcLengths = null } getPoint() { console.warn("THREE.Curve: .getPoint() not implemented.") } getPointAt(e, t) { let i = this.getUtoTmapping(e); return this.getPoint(i, t) } getPoints(e = 5) { let t = []; for (let i = 0; i <= e; i++)t.push(this.getPoint(i / e)); return t } getSpacedPoints(e = 5) { let t = []; for (let i = 0; i <= e; i++)t.push(this.getPointAt(i / e)); return t } getLength() { let e = this.getLengths(); return e[e.length - 1] } getLengths(e = this.arcLengthDivisions) { if (this.cacheArcLengths && this.cacheArcLengths.length === e + 1 && !this.needsUpdate) return this.cacheArcLengths; this.needsUpdate = !1; let t = [], i, r = this.getPoint(0), n = 0; t.push(0); for (let s = 1; s <= e; s++)t.push(n += (i = this.getPoint(s / e)).distanceTo(r)), r = i; return this.cacheArcLengths = t, t } updateArcLengths() { this.needsUpdate = !0, this.getLengths() } getUtoTmapping(e, t = null) { let i; let r = this.getLengths(), n = 0, s = r.length; i = t || e * r[s - 1]; let a = 0, o = s - 1, l; for (; a <= o;)if ((l = r[n = Math.floor(a + (o - a) / 2)] - i) < 0) a = n + 1; else if (l > 0) o = n - 1; else { o = n; break } if (r[n = o] === i) return n / (s - 1); let u = r[n], h = r[n + 1]; return (n + (i - u) / (h - u)) / (s - 1) } getTangent(e, t) { let i = e - 1e-4, r = e + 1e-4; i < 0 && (i = 0), r > 1 && (r = 1); let n = this.getPoint(i), s = this.getPoint(r), a = t || (n.isVector2 ? new iz : new rl); return a.copy(s).sub(n).normalize(), a } getTangentAt(e, t) { let i = this.getUtoTmapping(e); return this.getTangent(i, t) } computeFrenetFrames(e, t = !1) { let i = new rl, r = [], n = [], s = [], a = new rl, o = new rN; for (let t = 0; t <= e; t++) { let i = t / e; r[t] = this.getTangentAt(i, new rl) } n[0] = new rl, s[0] = new rl; let l = Number.MAX_VALUE, u = Math.abs(r[0].x), h = Math.abs(r[0].y), c = Math.abs(r[0].z); u <= l && (l = u, i.set(1, 0, 0)), h <= l && (l = h, i.set(0, 1, 0)), c <= l && i.set(0, 0, 1), a.crossVectors(r[0], i).normalize(), n[0].crossVectors(r[0], a), s[0].crossVectors(r[0], n[0]); for (let t = 1; t <= e; t++) { if (n[t] = n[t - 1].clone(), s[t] = s[t - 1].clone(), a.crossVectors(r[t - 1], r[t]), a.length() > Number.EPSILON) { a.normalize(); let e = Math.acos(iO(r[t - 1].dot(r[t]), -1, 1)); n[t].applyMatrix4(o.makeRotationAxis(a, e)) } s[t].crossVectors(r[t], n[t]) } if (!0 === t) { let t = Math.acos(iO(n[0].dot(n[e]), -1, 1)); t /= e, r[0].dot(a.crossVectors(n[0], n[e])) > 0 && (t = -t); for (let i = 1; i <= e; i++)n[i].applyMatrix4(o.makeRotationAxis(r[i], t * i)), s[i].crossVectors(r[i], n[i]) } return { tangents: r, normals: n, binormals: s } } clone() { return new this.constructor().copy(this) } copy(e) { return this.arcLengthDivisions = e.arcLengthDivisions, this } toJSON() { let e = { metadata: { version: 4.6, type: "Curve", generator: "Curve.toJSON" } }; return e.arcLengthDivisions = this.arcLengthDivisions, e.type = this.type, e } fromJSON(e) { return this.arcLengthDivisions = e.arcLengthDivisions, this } } class a0 extends aJ { constructor(e = 0, t = 0, i = 1, r = 1, n = 0, s = 2 * Math.PI, a = !1, o = 0) { super(), this.isEllipseCurve = !0, this.type = "EllipseCurve", this.aX = e, this.aY = t, this.xRadius = i, this.yRadius = r, this.aStartAngle = n, this.aEndAngle = s, this.aClockwise = a, this.aRotation = o } getPoint(e, t = new iz) { let i = 2 * Math.PI, r = this.aEndAngle - this.aStartAngle, n = Math.abs(r) < Number.EPSILON; for (; r < 0;)r += i; for (; r > i;)r -= i; r < Number.EPSILON && (r = n ? 0 : i), !0 !== this.aClockwise || n || (r === i ? r = -i : r -= i); let s = this.aStartAngle + e * r, a = this.aX + this.xRadius * Math.cos(s), o = this.aY + this.yRadius * Math.sin(s); if (0 !== this.aRotation) { let e = Math.cos(this.aRotation), t = Math.sin(this.aRotation), i = a - this.aX, r = o - this.aY; a = i * e - r * t + this.aX, o = i * t + r * e + this.aY } return t.set(a, o) } copy(e) { return super.copy(e), this.aX = e.aX, this.aY = e.aY, this.xRadius = e.xRadius, this.yRadius = e.yRadius, this.aStartAngle = e.aStartAngle, this.aEndAngle = e.aEndAngle, this.aClockwise = e.aClockwise, this.aRotation = e.aRotation, this } toJSON() { let e = super.toJSON(); return e.aX = this.aX, e.aY = this.aY, e.xRadius = this.xRadius, e.yRadius = this.yRadius, e.aStartAngle = this.aStartAngle, e.aEndAngle = this.aEndAngle, e.aClockwise = this.aClockwise, e.aRotation = this.aRotation, e } fromJSON(e) { return super.fromJSON(e), this.aX = e.aX, this.aY = e.aY, this.xRadius = e.xRadius, this.yRadius = e.yRadius, this.aStartAngle = e.aStartAngle, this.aEndAngle = e.aEndAngle, this.aClockwise = e.aClockwise, this.aRotation = e.aRotation, this } } class a1 extends a0 { constructor(e, t, i, r, n, s) { super(e, t, i, i, r, n, s), this.isArcCurve = !0, this.type = "ArcCurve" } } function a2() { let e = 0, t = 0, i = 0, r = 0; function n(n, s, a, o) { e = n, t = a, i = -3 * n + 3 * s - 2 * a - o, r = 2 * n - 2 * s + a + o } return { initCatmullRom: function (e, t, i, r, s) { n(t, i, s * (i - e), s * (r - t)) }, initNonuniformCatmullRom: function (e, t, i, r, s, a, o) { let l = (t - e) / s - (i - e) / (s + a) + (i - t) / a, u = (i - t) / a - (r - t) / (a + o) + (r - i) / o; n(t, i, l *= a, u *= a) }, calc: function (n) { let s = n * n; return e + t * n + i * s + s * n * r } } } let a3 = new rl, a4 = new a2, a5 = new a2, a8 = new a2; class a6 extends aJ { constructor(e = [], t = !1, i = "centripetal", r = .5) { super(), this.isCatmullRomCurve3 = !0, this.type = "CatmullRomCurve3", this.points = e, this.closed = t, this.curveType = i, this.tension = r } getPoint(e, t = new rl) { let i, r; let n = this.points, s = n.length, a = (s - (this.closed ? 0 : 1)) * e, o = Math.floor(a), l = a - o; this.closed ? o += o > 0 ? 0 : (Math.floor(Math.abs(o) / s) + 1) * s : 0 === l && o === s - 1 && (o = s - 2, l = 1), this.closed || o > 0 ? i = n[(o - 1) % s] : (a3.subVectors(n[0], n[1]).add(n[0]), i = a3); let u = n[o % s], h = n[(o + 1) % s]; if (this.closed || o + 2 < s ? r = n[(o + 2) % s] : (a3.subVectors(n[s - 1], n[s - 2]).add(n[s - 1]), r = a3), "centripetal" === this.curveType || "chordal" === this.curveType) { let e = "chordal" === this.curveType ? .5 : .25, t = Math.pow(i.distanceToSquared(u), e), n = Math.pow(u.distanceToSquared(h), e), s = Math.pow(h.distanceToSquared(r), e); n < 1e-4 && (n = 1), t < 1e-4 && (t = n), s < 1e-4 && (s = n), a4.initNonuniformCatmullRom(i.x, u.x, h.x, r.x, t, n, s), a5.initNonuniformCatmullRom(i.y, u.y, h.y, r.y, t, n, s), a8.initNonuniformCatmullRom(i.z, u.z, h.z, r.z, t, n, s) } else "catmullrom" === this.curveType && (a4.initCatmullRom(i.x, u.x, h.x, r.x, this.tension), a5.initCatmullRom(i.y, u.y, h.y, r.y, this.tension), a8.initCatmullRom(i.z, u.z, h.z, r.z, this.tension)); return t.set(a4.calc(l), a5.calc(l), a8.calc(l)), t } copy(e) { super.copy(e), this.points = []; for (let t = 0, i = e.points.length; t < i; t++) { let i = e.points[t]; this.points.push(i.clone()) } return this.closed = e.closed, this.curveType = e.curveType, this.tension = e.tension, this } toJSON() { let e = super.toJSON(); e.points = []; for (let t = 0, i = this.points.length; t < i; t++) { let i = this.points[t]; e.points.push(i.toArray()) } return e.closed = this.closed, e.curveType = this.curveType, e.tension = this.tension, e } fromJSON(e) { super.fromJSON(e), this.points = []; for (let t = 0, i = e.points.length; t < i; t++) { let i = e.points[t]; this.points.push(new rl().fromArray(i)) } return this.closed = e.closed, this.curveType = e.curveType, this.tension = e.tension, this } } function a9(e, t, i, r, n) { let s = (r - t) * .5, a = (n - i) * .5, o = e * e; return e * o * (2 * i - 2 * r + s + a) + (-3 * i + 3 * r - 2 * s - a) * o + s * e + i } function a7(e, t, i, r) { return function (e, t) { let i = 1 - e; return i * i * t }(e, t) + 2 * (1 - e) * e * i + e * e * r } function oe(e, t, i, r, n) { return function (e, t) { let i = 1 - e; return i * i * i * t }(e, t) + function (e, t) { let i = 1 - e; return 3 * i * i * e * t }(e, i) + 3 * (1 - e) * e * e * r + e * e * e * n } class ot extends aJ { constructor(e = new iz, t = new iz, i = new iz, r = new iz) { super(), this.isCubicBezierCurve = !0, this.type = "CubicBezierCurve", this.v0 = e, this.v1 = t, this.v2 = i, this.v3 = r } getPoint(e, t = new iz) { let i = this.v0, r = this.v1, n = this.v2, s = this.v3; return t.set(oe(e, i.x, r.x, n.x, s.x), oe(e, i.y, r.y, n.y, s.y)), t } copy(e) { return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this.v3.copy(e.v3), this } toJSON() { let e = super.toJSON(); return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e.v3 = this.v3.toArray(), e } fromJSON(e) { return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this.v3.fromArray(e.v3), this } } class oi extends aJ { constructor(e = new rl, t = new rl, i = new rl, r = new rl) { super(), this.isCubicBezierCurve3 = !0, this.type = "CubicBezierCurve3", this.v0 = e, this.v1 = t, this.v2 = i, this.v3 = r } getPoint(e, t = new rl) { let i = this.v0, r = this.v1, n = this.v2, s = this.v3; return t.set(oe(e, i.x, r.x, n.x, s.x), oe(e, i.y, r.y, n.y, s.y), oe(e, i.z, r.z, n.z, s.z)), t } copy(e) { return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this.v3.copy(e.v3), this } toJSON() { let e = super.toJSON(); return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e.v3 = this.v3.toArray(), e } fromJSON(e) { return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this.v3.fromArray(e.v3), this } } class or extends aJ { constructor(e = new iz, t = new iz) { super(), this.isLineCurve = !0, this.type = "LineCurve", this.v1 = e, this.v2 = t } getPoint(e, t = new iz) { return 1 === e ? t.copy(this.v2) : (t.copy(this.v2).sub(this.v1), t.multiplyScalar(e).add(this.v1)), t } getPointAt(e, t) { return this.getPoint(e, t) } getTangent(e, t = new iz) { return t.subVectors(this.v2, this.v1).normalize() } getTangentAt(e, t) { return this.getTangent(e, t) } copy(e) { return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this } toJSON() { let e = super.toJSON(); return e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e } fromJSON(e) { return super.fromJSON(e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this } } class on extends aJ { constructor(e = new rl, t = new rl) { super(), this.isLineCurve3 = !0, this.type = "LineCurve3", this.v1 = e, this.v2 = t } getPoint(e, t = new rl) { return 1 === e ? t.copy(this.v2) : (t.copy(this.v2).sub(this.v1), t.multiplyScalar(e).add(this.v1)), t } getPointAt(e, t) { return this.getPoint(e, t) } getTangent(e, t = new rl) { return t.subVectors(this.v2, this.v1).normalize() } getTangentAt(e, t) { return this.getTangent(e, t) } copy(e) { return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this } toJSON() { let e = super.toJSON(); return e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e } fromJSON(e) { return super.fromJSON(e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this } } class os extends aJ { constructor(e = new iz, t = new iz, i = new iz) { super(), this.isQuadraticBezierCurve = !0, this.type = "QuadraticBezierCurve", this.v0 = e, this.v1 = t, this.v2 = i } getPoint(e, t = new iz) { let i = this.v0, r = this.v1, n = this.v2; return t.set(a7(e, i.x, r.x, n.x), a7(e, i.y, r.y, n.y)), t } copy(e) { return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this } toJSON() { let e = super.toJSON(); return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e } fromJSON(e) { return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this } } class oa extends aJ { constructor(e = new rl, t = new rl, i = new rl) { super(), this.isQuadraticBezierCurve3 = !0, this.type = "QuadraticBezierCurve3", this.v0 = e, this.v1 = t, this.v2 = i } getPoint(e, t = new rl) { let i = this.v0, r = this.v1, n = this.v2; return t.set(a7(e, i.x, r.x, n.x), a7(e, i.y, r.y, n.y), a7(e, i.z, r.z, n.z)), t } copy(e) { return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this } toJSON() { let e = super.toJSON(); return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e } fromJSON(e) { return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this } } class oo extends aJ { constructor(e = []) { super(), this.isSplineCurve = !0, this.type = "SplineCurve", this.points = e } getPoint(e, t = new iz) { let i = this.points, r = (i.length - 1) * e, n = Math.floor(r), s = r - n, a = i[0 === n ? n : n - 1], o = i[n], l = i[n > i.length - 2 ? i.length - 1 : n + 1], u = i[n > i.length - 3 ? i.length - 1 : n + 2]; return t.set(a9(s, a.x, o.x, l.x, u.x), a9(s, a.y, o.y, l.y, u.y)), t } copy(e) { super.copy(e), this.points = []; for (let t = 0, i = e.points.length; t < i; t++) { let i = e.points[t]; this.points.push(i.clone()) } return this } toJSON() { let e = super.toJSON(); e.points = []; for (let t = 0, i = this.points.length; t < i; t++) { let i = this.points[t]; e.points.push(i.toArray()) } return e } fromJSON(e) { super.fromJSON(e), this.points = []; for (let t = 0, i = e.points.length; t < i; t++) { let i = e.points[t]; this.points.push(new iz().fromArray(i)) } return this } } var ol = Object.freeze({ __proto__: null, ArcCurve: a1, CatmullRomCurve3: a6, CubicBezierCurve: ot, CubicBezierCurve3: oi, EllipseCurve: a0, LineCurve: or, LineCurve3: on, QuadraticBezierCurve: os, QuadraticBezierCurve3: oa, SplineCurve: oo }); class ou extends aJ { constructor() { super(), this.type = "CurvePath", this.curves = [], this.autoClose = !1 } add(e) { this.curves.push(e) } closePath() { let e = this.curves[0].getPoint(0), t = this.curves[this.curves.length - 1].getPoint(1); if (!e.equals(t)) { let i = !0 === e.isVector2 ? "LineCurve" : "LineCurve3"; this.curves.push(new ol[i](t, e)) } return this } getPoint(e, t) { let i = e * this.getLength(), r = this.getCurveLengths(), n = 0; for (; n < r.length;) { if (r[n] >= i) { let e = r[n] - i, s = this.curves[n], a = s.getLength(), o = 0 === a ? 0 : 1 - e / a; return s.getPointAt(o, t) } n++ } return null } getLength() { let e = this.getCurveLengths(); return e[e.length - 1] } updateArcLengths() { this.needsUpdate = !0, this.cacheLengths = null, this.getCurveLengths() } getCurveLengths() { if (this.cacheLengths && this.cacheLengths.length === this.curves.length) return this.cacheLengths; let e = [], t = 0; for (let i = 0, r = this.curves.length; i < r; i++)e.push(t += this.curves[i].getLength()); return this.cacheLengths = e, e } getSpacedPoints(e = 40) { let t = []; for (let i = 0; i <= e; i++)t.push(this.getPoint(i / e)); return this.autoClose && t.push(t[0]), t } getPoints(e = 12) { let t; let i = []; for (let r = 0, n = this.curves; r < n.length; r++) { let s = n[r], a = s.isEllipseCurve ? 2 * e : s.isLineCurve || s.isLineCurve3 ? 1 : s.isSplineCurve ? e * s.points.length : e, o = s.getPoints(a); for (let e = 0; e < o.length; e++) { let r = o[e]; t && t.equals(r) || (i.push(r), t = r) } } return this.autoClose && i.length > 1 && !i[i.length - 1].equals(i[0]) && i.push(i[0]), i } copy(e) { super.copy(e), this.curves = []; for (let t = 0, i = e.curves.length; t < i; t++) { let i = e.curves[t]; this.curves.push(i.clone()) } return this.autoClose = e.autoClose, this } toJSON() { let e = super.toJSON(); e.autoClose = this.autoClose, e.curves = []; for (let t = 0, i = this.curves.length; t < i; t++) { let i = this.curves[t]; e.curves.push(i.toJSON()) } return e } fromJSON(e) { super.fromJSON(e), this.autoClose = e.autoClose, this.curves = []; for (let t = 0, i = e.curves.length; t < i; t++) { let i = e.curves[t]; this.curves.push(new ol[i.type]().fromJSON(i)) } return this } } class oh extends ou { constructor(e) { super(), this.type = "Path", this.currentPoint = new iz, e && this.setFromPoints(e) } setFromPoints(e) { this.moveTo(e[0].x, e[0].y); for (let t = 1, i = e.length; t < i; t++)this.lineTo(e[t].x, e[t].y); return this } moveTo(e, t) { return this.currentPoint.set(e, t), this } lineTo(e, t) { let i = new or(this.currentPoint.clone(), new iz(e, t)); return this.curves.push(i), this.currentPoint.set(e, t), this } quadraticCurveTo(e, t, i, r) { let n = new os(this.currentPoint.clone(), new iz(e, t), new iz(i, r)); return this.curves.push(n), this.currentPoint.set(i, r), this } bezierCurveTo(e, t, i, r, n, s) { let a = new ot(this.currentPoint.clone(), new iz(e, t), new iz(i, r), new iz(n, s)); return this.curves.push(a), this.currentPoint.set(n, s), this } splineThru(e) { let t = new oo([this.currentPoint.clone()].concat(e)); return this.curves.push(t), this.currentPoint.copy(e[e.length - 1]), this } arc(e, t, i, r, n, s) { let a = this.currentPoint.x, o = this.currentPoint.y; return this.absarc(e + a, t + o, i, r, n, s), this } absarc(e, t, i, r, n, s) { return this.absellipse(e, t, i, i, r, n, s), this } ellipse(e, t, i, r, n, s, a, o) { let l = this.currentPoint.x, u = this.currentPoint.y; return this.absellipse(e + l, t + u, i, r, n, s, a, o), this } absellipse(e, t, i, r, n, s, a, o) { let l = new a0(e, t, i, r, n, s, a, o); if (this.curves.length > 0) { let e = l.getPoint(0); e.equals(this.currentPoint) || this.lineTo(e.x, e.y) } this.curves.push(l); let u = l.getPoint(1); return this.currentPoint.copy(u), this } copy(e) { return super.copy(e), this.currentPoint.copy(e.currentPoint), this } toJSON() { let e = super.toJSON(); return e.currentPoint = this.currentPoint.toArray(), e } fromJSON(e) { return super.fromJSON(e), this.currentPoint.fromArray(e.currentPoint), this } } class oc extends nq { constructor(e = [new iz(0, -.5), new iz(.5, 0), new iz(0, .5)], t = 12, i = 0, r = 2 * Math.PI) { super(), this.type = "LatheGeometry", this.parameters = { points: e, segments: t, phiStart: i, phiLength: r }, t = Math.floor(t), r = iO(r, 0, 2 * Math.PI); let n = [], s = [], a = [], o = [], l = [], u = 1 / t, h = new rl, c = new iz, d = new rl, f = new rl, p = new rl, m = 0, g = 0; for (let t = 0; t <= e.length - 1; t++)switch (t) { case 0: m = e[t + 1].x - e[t].x, g = e[t + 1].y - e[t].y, d.x = 1 * g, d.y = -m, d.z = 0 * g, p.copy(d), d.normalize(), o.push(d.x, d.y, d.z); break; case e.length - 1: o.push(p.x, p.y, p.z); break; default: m = e[t + 1].x - e[t].x, g = e[t + 1].y - e[t].y, d.x = 1 * g, d.y = -m, d.z = 0 * g, f.copy(d), d.x += p.x, d.y += p.y, d.z += p.z, d.normalize(), o.push(d.x, d.y, d.z), p.copy(f) }for (let n = 0; n <= t; n++) { let d = i + n * u * r, f = Math.sin(d), p = Math.cos(d); for (let i = 0; i <= e.length - 1; i++) { h.x = e[i].x * f, h.y = e[i].y, h.z = e[i].x * p, s.push(h.x, h.y, h.z), c.x = n / t, c.y = i / (e.length - 1), a.push(c.x, c.y); let r = o[3 * i + 0] * f, u = o[3 * i + 1], d = o[3 * i + 0] * p; l.push(r, u, d) } } for (let i = 0; i < t; i++)for (let t = 0; t < e.length - 1; t++) { let r = t + i * e.length, s = r + e.length, a = r + e.length + 1, o = r + 1; n.push(r, s, o), n.push(a, o, s) } this.setIndex(n), this.setAttribute("position", new nG(s, 3)), this.setAttribute("uv", new nG(a, 2)), this.setAttribute("normal", new nG(l, 3)) } copy(e) { return super.copy(e), this.parameters = Object.assign({}, e.parameters), this } static fromJSON(e) { return new oc(e.points, e.segments, e.phiStart, e.phiLength) } } class od extends oc { constructor(e = 1, t = 1, i = 4, r = 8) { let n = new oh; n.absarc(0, -t / 2, e, 1.5 * Math.PI, 0), n.absarc(0, t / 2, e, 0, .5 * Math.PI), super(n.getPoints(i), r), this.type = "CapsuleGeometry", this.parameters = { radius: e, length: t, capSegments: i, radialSegments: r } } static fromJSON(e) { return new od(e.radius, e.length, e.capSegments, e.radialSegments) } } class of extends nq { constructor(e = 1, t = 32, i = 0, r = 2 * Math.PI) { super(), this.type = "CircleGeometry", this.parameters = { radius: e, segments: t, thetaStart: i, thetaLength: r }, t = Math.max(3, t); let n = [], s = [], a = [], o = [], l = new rl, u = new iz; s.push(0, 0, 0), a.push(0, 0, 1), o.push(.5, .5); for (let n = 0, h = 3; n <= t; n++, h += 3) { let c = i + n / t * r; l.x = e * Math.cos(c), l.y = e * Math.sin(c), s.push(l.x, l.y, l.z), a.push(0, 0, 1), u.x = (s[h] / e + 1) / 2, u.y = (s[h + 1] / e + 1) / 2, o.push(u.x, u.y) } for (let e = 1; e <= t; e++)n.push(e, e + 1, 0); this.setIndex(n), this.setAttribute("position", new nG(s, 3)), this.setAttribute("normal", new nG(a, 3)), this.setAttribute("uv", new nG(o, 2)) } copy(e) { return super.copy(e), this.parameters = Object.assign({}, e.parameters), this } static fromJSON(e) { return new of(e.radius, e.segments, e.thetaStart, e.thetaLength) } } class op extends nq { constructor(e = 1, t = 1, i = 1, r = 32, n = 1, s = !1, a = 0, o = 2 * Math.PI) { super(), this.type = "CylinderGeometry", this.parameters = { radiusTop: e, radiusBottom: t, height: i, radialSegments: r, heightSegments: n, openEnded: s, thetaStart: a, thetaLength: o }; let l = this; r = Math.floor(r), n = Math.floor(n); let u = [], h = [], c = [], d = [], f = 0, p = [], m = i / 2, g = 0; function v(i) { let n = f, s = new iz, p = new rl, v = 0, y = !0 === i ? e : t, x = !0 === i ? 1 : -1; for (let e = 1; e <= r; e++)h.push(0, m * x, 0), c.push(0, x, 0), d.push(.5, .5), f++; let S = f; for (let e = 0; e <= r; e++) { let t = e / r * o + a, i = Math.cos(t), n = Math.sin(t); p.x = y * n, p.y = m * x, p.z = y * i, h.push(p.x, p.y, p.z), c.push(0, x, 0), s.x = .5 * i + .5, s.y = .5 * n * x + .5, d.push(s.x, s.y), f++ } for (let e = 0; e < r; e++) { let t = n + e, r = S + e; !0 === i ? u.push(r, r + 1, t) : u.push(r + 1, r, t), v += 3 } l.addGroup(g, v, !0 === i ? 1 : 2), g += v } (function () { let s = new rl, v = new rl, y = 0, x = (t - e) / i; for (let l = 0; l <= n; l++) { let u = [], g = l / n, y = g * (t - e) + e; for (let e = 0; e <= r; e++) { let t = e / r, n = t * o + a, l = Math.sin(n), p = Math.cos(n); v.x = y * l, v.y = -g * i + m, v.z = y * p, h.push(v.x, v.y, v.z), s.set(l, x, p).normalize(), c.push(s.x, s.y, s.z), d.push(t, 1 - g), u.push(f++) } p.push(u) } for (let i = 0; i < r; i++)for (let r = 0; r < n; r++) { let s = p[r][i], a = p[r + 1][i], o = p[r + 1][i + 1], l = p[r][i + 1]; (e > 0 || 0 !== r) && (u.push(s, a, l), y += 3), (t > 0 || r !== n - 1) && (u.push(a, o, l), y += 3) } l.addGroup(g, y, 0), g += y })(), !1 === s && (e > 0 && v(!0), t > 0 && v(!1)), this.setIndex(u), this.setAttribute("position", new nG(h, 3)), this.setAttribute("normal", new nG(c, 3)), this.setAttribute("uv", new nG(d, 2)) } copy(e) { return super.copy(e), this.parameters = Object.assign({}, e.parameters), this } static fromJSON(e) { return new op(e.radiusTop, e.radiusBottom, e.height, e.radialSegments, e.heightSegments, e.openEnded, e.thetaStart, e.thetaLength) } } class om extends op { constructor(e = 1, t = 1, i = 32, r = 1, n = !1, s = 0, a = 2 * Math.PI) { super(0, e, t, i, r, n, s, a), this.type = "ConeGeometry", this.parameters = { radius: e, height: t, radialSegments: i, heightSegments: r, openEnded: n, thetaStart: s, thetaLength: a } } static fromJSON(e) { return new om(e.radius, e.height, e.radialSegments, e.heightSegments, e.openEnded, e.thetaStart, e.thetaLength) } } class og extends nq { constructor(e = [], t = [], i = 1, r = 0) { super(), this.type = "PolyhedronGeometry", this.parameters = { vertices: e, indices: t, radius: i, detail: r }; let n = [], s = []; function a(e) { n.push(e.x, e.y, e.z) } function o(t, i) { let r = 3 * t; i.x = e[r + 0], i.y = e[r + 1], i.z = e[r + 2] } function l(e, t, i, r) { r < 0 && 1 === e.x && (s[t] = e.x - 1), 0 === i.x && 0 === i.z && (s[t] = r / 2 / Math.PI + .5) } function u(e) { return Math.atan2(e.z, -e.x) } (function (e) { let i = new rl, r = new rl, n = new rl; for (let s = 0; s < t.length; s += 3)o(t[s + 0], i), o(t[s + 1], r), o(t[s + 2], n), function (e, t, i, r) { let n = r + 1, s = []; for (let r = 0; r <= n; r++) { s[r] = []; let a = e.clone().lerp(i, r / n), o = t.clone().lerp(i, r / n), l = n - r; for (let e = 0; e <= l; e++)0 === e && r === n ? s[r][e] = a : s[r][e] = a.clone().lerp(o, e / l) } for (let e = 0; e < n; e++)for (let t = 0; t < 2 * (n - e) - 1; t++) { let i = Math.floor(t / 2); t % 2 == 0 ? (a(s[e][i + 1]), a(s[e + 1][i]), a(s[e][i])) : (a(s[e][i + 1]), a(s[e + 1][i + 1]), a(s[e + 1][i])) } }(i, r, n, e) })(r), function (e) { let t = new rl; for (let i = 0; i < n.length; i += 3)t.x = n[i + 0], t.y = n[i + 1], t.z = n[i + 2], t.normalize().multiplyScalar(e), n[i + 0] = t.x, n[i + 1] = t.y, n[i + 2] = t.z }(i), function () { let e = new rl; for (let t = 0; t < n.length; t += 3) { e.x = n[t + 0], e.y = n[t + 1], e.z = n[t + 2]; let i = u(e) / 2 / Math.PI + .5, r = Math.atan2(-e.y, Math.sqrt(e.x * e.x + e.z * e.z)) / Math.PI + .5; s.push(i, 1 - r) } (function () { let e = new rl, t = new rl, i = new rl, r = new rl, a = new iz, o = new iz, h = new iz; for (let c = 0, d = 0; c < n.length; c += 9, d += 6) { e.set(n[c + 0], n[c + 1], n[c + 2]), t.set(n[c + 3], n[c + 4], n[c + 5]), i.set(n[c + 6], n[c + 7], n[c + 8]), a.set(s[d + 0], s[d + 1]), o.set(s[d + 2], s[d + 3]), h.set(s[d + 4], s[d + 5]), r.copy(e).add(t).add(i).divideScalar(3); let f = u(r); l(a, d + 0, e, f), l(o, d + 2, t, f), l(h, d + 4, i, f) } })(), function () { for (let e = 0; e < s.length; e += 6) { let t = s[e + 0], i = s[e + 2], r = s[e + 4], n = Math.max(t, i, r), a = Math.min(t, i, r); n > .9 && a < .1 && (t < .2 && (s[e + 0] += 1), i < .2 && (s[e + 2] += 1), r < .2 && (s[e + 4] += 1)) } }() }(), this.setAttribute("position", new nG(n, 3)), this.setAttribute("normal", new nG(n.slice(), 3)), this.setAttribute("uv", new nG(s, 2)), 0 === r ? this.computeVertexNormals() : this.normalizeNormals() } copy(e) { return super.copy(e), this.parameters = Object.assign({}, e.parameters), this } static fromJSON(e) { return new og(e.vertices, e.indices, e.radius, e.details) } } class ov extends og { constructor(e = 1, t = 0) { let i = (1 + Math.sqrt(5)) / 2, r = 1 / i; super([-1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, 1, 1, 1, -1, 1, 1, 1, 0, -r, -i, 0, -r, i, 0, r, -i, 0, r, i, -r, -i, 0, -r, i, 0, r, -i, 0, r, i, 0, -i, 0, -r, i, 0, -r, -i, 0, r, i, 0, r], [3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9], e, t), this.type = "DodecahedronGeometry", this.parameters = { radius: e, detail: t } } static fromJSON(e) { return new ov(e.radius, e.detail) } } let oy = new rl, ox = new rl, oS = new rl, oA = new nm; class o_ extends nq { constructor(e = null, t = 1) { if (super(), this.type = "EdgesGeometry", this.parameters = { geometry: e, thresholdAngle: t }, null !== e) { let i = Math.cos(iL * t), r = e.getIndex(), n = e.getAttribute("position"), s = r ? r.count : n.count, a = [0, 0, 0], o = ["a", "b", "c"], l = [, , ,], u = {}, h = []; for (let e = 0; e < s; e += 3) { r ? (a[0] = r.getX(e), a[1] = r.getX(e + 1), a[2] = r.getX(e + 2)) : (a[0] = e, a[1] = e + 1, a[2] = e + 2); let { a: t, b: s, c } = oA; if (t.fromBufferAttribute(n, a[0]), s.fromBufferAttribute(n, a[1]), c.fromBufferAttribute(n, a[2]), oA.getNormal(oS), l[0] = `${Math.round(1e4 * t.x)},${Math.round(1e4 * t.y)},${Math.round(1e4 * t.z)}`, l[1] = `${Math.round(1e4 * s.x)},${Math.round(1e4 * s.y)},${Math.round(1e4 * s.z)}`, l[2] = `${Math.round(1e4 * c.x)},${Math.round(1e4 * c.y)},${Math.round(1e4 * c.z)}`, l[0] !== l[1] && l[1] !== l[2] && l[2] !== l[0]) for (let e = 0; e < 3; e++) { let t = (e + 1) % 3, r = l[e], n = l[t], s = oA[o[e]], c = oA[o[t]], d = `${r}_${n}`, f = `${n}_${r}`; f in u && u[f] ? (oS.dot(u[f].normal) <= i && (h.push(s.x, s.y, s.z), h.push(c.x, c.y, c.z)), u[f] = null) : d in u || (u[d] = { index0: a[e], index1: a[t], normal: oS.clone() }) } } for (let e in u) if (u[e]) { let { index0: t, index1: i } = u[e]; oy.fromBufferAttribute(n, t), ox.fromBufferAttribute(n, i), h.push(oy.x, oy.y, oy.z), h.push(ox.x, ox.y, ox.z) } this.setAttribute("position", new nG(h, 3)) } } copy(e) { return super.copy(e), this.parameters = Object.assign({}, e.parameters), this } } class oE extends oh { constructor(e) { super(e), this.uuid = iD(), this.type = "Shape", this.holes = [] } getPointsHoles(e) { let t = []; for (let i = 0, r = this.holes.length; i < r; i++)t[i] = this.holes[i].getPoints(e); return t } extractPoints(e) { return { shape: this.getPoints(e), holes: this.getPointsHoles(e) } } copy(e) { super.copy(e), this.holes = []; for (let t = 0, i = e.holes.length; t < i; t++) { let i = e.holes[t]; this.holes.push(i.clone()) } return this } toJSON() { let e = super.toJSON(); e.uuid = this.uuid, e.holes = []; for (let t = 0, i = this.holes.length; t < i; t++) { let i = this.holes[t]; e.holes.push(i.toJSON()) } return e } fromJSON(e) { super.fromJSON(e), this.uuid = e.uuid, this.holes = []; for (let t = 0, i = e.holes.length; t < i; t++) { let i = e.holes[t]; this.holes.push(new oh().fromJSON(i)) } return this } } class ob { static triangulate(e, t, i = 2) { let r, n, s, a, o, l, u; let h = t && t.length, c = h ? t[0] * i : e.length, d = oT(e, 0, c, i, !0), f = []; if (!d || d.next === d.prev) return f; if (h && (d = function (e, t, i, r) { let n, s, a, o, l; let u = []; for (n = 0, s = t.length; n < s; n++)a = t[n] * r, o = n < s - 1 ? t[n + 1] * r : e.length, (l = oT(e, a, o, r, !1)) === l.next && (l.steiner = !0), u.push(function (e) { let t = e, i = e; do (t.x < i.x || t.x === i.x && t.y < i.y) && (i = t), t = t.next; while (t !== e); return i }(l)); for (u.sort(oM), n = 0; n < u.length; n++)i = function (e, t) { let i = function (e, t) { let i = t, r = -1 / 0, n, s = e.x, a = e.y; do { if (a <= i.y && a >= i.next.y && i.next.y !== i.y) { let e = i.x + (a - i.y) * (i.next.x - i.x) / (i.next.y - i.y); if (e <= s && e > r && (r = e, n = i.x < i.next.x ? i : i.next, e === s)) return n } i = i.next } while (i !== t); if (!n) return null; let o = n, l = n.x, u = n.y, h = 1 / 0, c; i = n; do { var d, f; s >= i.x && i.x >= l && s !== i.x && oC(a < u ? s : r, a, l, u, a < u ? r : s, a, i.x, i.y) && (c = Math.abs(a - i.y) / (s - i.x), ok(i, e) && (c < h || c === h && (i.x > n.x || i.x === n.x && (d = n, f = i, 0 > oI(d.prev, d, f.prev) && 0 > oI(f.next, d, d.next)))) && (n = i, h = c)), i = i.next } while (i !== o); return n }(e, t); if (!i) return t; let r = oF(i, e); return ow(r, r.next), ow(i, i.next) }(u[n], i); return i }(e, t, d, i)), e.length > 80 * i) { r = s = e[0], n = a = e[1]; for (let t = i; t < c; t += i)o = e[t], l = e[t + 1], o < r && (r = o), l < n && (n = l), o > s && (s = o), l > a && (a = l); u = 0 !== (u = Math.max(s - r, a - n)) ? 32767 / u : 0 } return function e(t, i, r, n, s, a, o) { if (!t) return; !o && a && function (e, t, i, r) { let n = e; do 0 === n.z && (n.z = oR(n.x, n.y, t, i, r)), n.prevZ = n.prev, n.nextZ = n.next, n = n.next; while (n !== e); n.prevZ.nextZ = null, n.prevZ = null, function (e) { let t, i, r, n, s, a, o, l, u = 1; do { for (i = e, e = null, s = null, a = 0; i;) { for (a++, r = i, o = 0, t = 0; t < u && (o++, r = r.nextZ); t++); for (l = u; o > 0 || l > 0 && r;)0 !== o && (0 === l || !r || i.z <= r.z) ? (n = i, i = i.nextZ, o--) : (n = r, r = r.nextZ, l--), s ? s.nextZ = n : e = n, n.prevZ = s, s = n; i = r } s.nextZ = null, u *= 2 } while (a > 1) }(n) }(t, n, s, a); let l = t, u, h; for (; t.prev !== t.next;) { if (u = t.prev, h = t.next, a ? function (e, t, i, r) { let n = e.prev, s = e.next; if (oI(n, e, s) >= 0) return !1; let a = n.x, o = e.x, l = s.x, u = n.y, h = e.y, c = s.y, d = a < o ? a < l ? a : l : o < l ? o : l, f = u < h ? u < c ? u : c : h < c ? h : c, p = a > o ? a > l ? a : l : o > l ? o : l, m = u > h ? u > c ? u : c : h > c ? h : c, g = oR(d, f, t, i, r), v = oR(p, m, t, i, r), y = e.prevZ, x = e.nextZ; for (; y && y.z >= g && x && x.z <= v;) { if (y.x >= d && y.x <= p && y.y >= f && y.y <= m && y !== n && y !== s && oC(a, u, o, h, l, c, y.x, y.y) && oI(y.prev, y, y.next) >= 0 || (y = y.prevZ, x.x >= d && x.x <= p && x.y >= f && x.y <= m && x !== n && x !== s && oC(a, u, o, h, l, c, x.x, x.y) && oI(x.prev, x, x.next) >= 0)) return !1; x = x.nextZ } for (; y && y.z >= g;) { if (y.x >= d && y.x <= p && y.y >= f && y.y <= m && y !== n && y !== s && oC(a, u, o, h, l, c, y.x, y.y) && oI(y.prev, y, y.next) >= 0) return !1; y = y.prevZ } for (; x && x.z <= v;) { if (x.x >= d && x.x <= p && x.y >= f && x.y <= m && x !== n && x !== s && oC(a, u, o, h, l, c, x.x, x.y) && oI(x.prev, x, x.next) >= 0) return !1; x = x.nextZ } return !0 }(t, n, s, a) : function (e) { let t = e.prev, i = e.next; if (oI(t, e, i) >= 0) return !1; let r = t.x, n = e.x, s = i.x, a = t.y, o = e.y, l = i.y, u = r < n ? r < s ? r : s : n < s ? n : s, h = a < o ? a < l ? a : l : o < l ? o : l, c = r > n ? r > s ? r : s : n > s ? n : s, d = a > o ? a > l ? a : l : o > l ? o : l, f = i.next; for (; f !== t;) { if (f.x >= u && f.x <= c && f.y >= h && f.y <= d && oC(r, a, n, o, s, l, f.x, f.y) && oI(f.prev, f, f.next) >= 0) return !1; f = f.next } return !0 }(t)) { i.push(u.i / r | 0), i.push(t.i / r | 0), i.push(h.i / r | 0), oN(t), t = h.next, l = h.next; continue } if ((t = h) === l) { o ? 1 === o ? e(t = function (e, t, i) { let r = e; do { let n = r.prev, s = r.next.next; !oL(n, s) && oP(n, r, r.next, s) && ok(n, s) && ok(s, n) && (t.push(n.i / i | 0), t.push(r.i / i | 0), t.push(s.i / i | 0), oN(r), oN(r.next), r = e = s), r = r.next } while (r !== e); return ow(r) }(ow(t), i, r), i, r, n, s, a, 2) : 2 === o && function (t, i, r, n, s, a) { let o = t; do { let t = o.next.next; for (; t !== o.prev;) { var l, u; if (o.i !== t.i && (l = o, u = t, l.next.i !== u.i && l.prev.i !== u.i && !function (e, t) { let i = e; do { if (i.i !== e.i && i.next.i !== e.i && i.i !== t.i && i.next.i !== t.i && oP(i, i.next, e, t)) return !0; i = i.next } while (i !== e); return !1 }(l, u) && (ok(l, u) && ok(u, l) && function (e, t) { let i = e, r = !1, n = (e.x + t.x) / 2, s = (e.y + t.y) / 2; do i.y > s != i.next.y > s && i.next.y !== i.y && n < (i.next.x - i.x) * (s - i.y) / (i.next.y - i.y) + i.x && (r = !r), i = i.next; while (i !== e); return r }(l, u) && (oI(l.prev, l, u.prev) || oI(l, u.prev, u)) || oL(l, u) && oI(l.prev, l, l.next) > 0 && oI(u.prev, u, u.next) > 0))) { let l = oF(o, t); o = ow(o, o.next), l = ow(l, l.next), e(o, i, r, n, s, a, 0), e(l, i, r, n, s, a, 0); return } t = t.next } o = o.next } while (o !== t) }(t, i, r, n, s, a) : e(ow(t), i, r, n, s, a, 1); break } } }(d, f, i, r, n, u, 0), f } } function oT(e, t, i, r, n) { let s, a; if (n === function (e, t, i, r) { let n = 0; for (let s = t, a = i - r; s < i; s += r)n += (e[a] - e[s]) * (e[s + 1] + e[a + 1]), a = s; return n }(e, t, i, r) > 0) for (s = t; s < i; s += r)a = oU(s, e[s], e[s + 1], a); else for (s = i - r; s >= t; s -= r)a = oU(s, e[s], e[s + 1], a); return a && oL(a, a.next) && (oN(a), a = a.next), a } function ow(e, t) { if (!e) return e; t || (t = e); let i = e, r; do if (r = !1, !i.steiner && (oL(i, i.next) || 0 === oI(i.prev, i, i.next))) { if (oN(i), (i = t = i.prev) === i.next) break; r = !0 } else i = i.next; while (r || i !== t); return t } function oM(e, t) { return e.x - t.x } function oR(e, t, i, r, n) { return (e = ((e = ((e = ((e = ((e = (e - i) * n | 0) | e << 8) & 0xff00ff) | e << 4) & 0xf0f0f0f) | e << 2) & 0x33333333) | e << 1) & 0x55555555) | (t = ((t = ((t = ((t = ((t = (t - r) * n | 0) | t << 8) & 0xff00ff) | t << 4) & 0xf0f0f0f) | t << 2) & 0x33333333) | t << 1) & 0x55555555) << 1 } function oC(e, t, i, r, n, s, a, o) { return (n - a) * (t - o) >= (e - a) * (s - o) && (e - a) * (r - o) >= (i - a) * (t - o) && (i - a) * (s - o) >= (n - a) * (r - o) } function oI(e, t, i) { return (t.y - e.y) * (i.x - t.x) - (t.x - e.x) * (i.y - t.y) } function oL(e, t) { return e.x === t.x && e.y === t.y } function oP(e, t, i, r) { let n = oO(oI(e, t, i)), s = oO(oI(e, t, r)), a = oO(oI(i, r, e)), o = oO(oI(i, r, t)); return !!(n !== s && a !== o || 0 === n && oD(e, i, t) || 0 === s && oD(e, r, t) || 0 === a && oD(i, e, r) || 0 === o && oD(i, t, r)) } function oD(e, t, i) { return t.x <= Math.max(e.x, i.x) && t.x >= Math.min(e.x, i.x) && t.y <= Math.max(e.y, i.y) && t.y >= Math.min(e.y, i.y) } function oO(e) { return e > 0 ? 1 : e < 0 ? -1 : 0 } function ok(e, t) { return 0 > oI(e.prev, e, e.next) ? oI(e, t, e.next) >= 0 && oI(e, e.prev, t) >= 0 : 0 > oI(e, t, e.prev) || 0 > oI(e, e.next, t) } function oF(e, t) { let i = new oB(e.i, e.x, e.y), r = new oB(t.i, t.x, t.y), n = e.next, s = t.prev; return e.next = t, t.prev = e, i.next = n, n.prev = i, r.next = i, i.prev = r, s.next = r, r.prev = s, r } function oU(e, t, i, r) { let n = new oB(e, t, i); return r ? (n.next = r.next, n.prev = r, r.next.prev = n, r.next = n) : (n.prev = n, n.next = n), n } function oN(e) { e.next.prev = e.prev, e.prev.next = e.next, e.prevZ && (e.prevZ.nextZ = e.nextZ), e.nextZ && (e.nextZ.prevZ = e.prevZ) } function oB(e, t, i) { this.i = e, this.x = t, this.y = i, this.prev = null, this.next = null, this.z = 0, this.prevZ = null, this.nextZ = null, this.steiner = !1 } class oz { static area(e) { let t = e.length, i = 0; for (let r = t - 1, n = 0; n < t; r = n++)i += e[r].x * e[n].y - e[n].x * e[r].y; return .5 * i } static isClockWise(e) { return 0 > oz.area(e) } static triangulateShape(e, t) { let i = [], r = [], n = []; oG(e), oH(i, e); let s = e.length; t.forEach(oG); for (let e = 0; e < t.length; e++)r.push(s), s += t[e].length, oH(i, t[e]); let a = ob.triangulate(i, r); for (let e = 0; e < a.length; e += 3)n.push(a.slice(e, e + 3)); return n } } function oG(e) { let t = e.length; t > 2 && e[t - 1].equals(e[0]) && e.pop() } function oH(e, t) { for (let i = 0; i < t.length; i++)e.push(t[i].x), e.push(t[i].y) } class oV extends nq { constructor(e = new oE([new iz(.5, .5), new iz(-.5, .5), new iz(-.5, -.5), new iz(.5, -.5)]), t = {}) { super(), this.type = "ExtrudeGeometry", this.parameters = { shapes: e, options: t }, e = Array.isArray(e) ? e : [e]; let i = this, r = [], n = []; for (let s = 0, a = e.length; s < a; s++)!function (e) { let s, a, o, l; let u = [], h = void 0 !== t.curveSegments ? t.curveSegments : 12, c = void 0 !== t.steps ? t.steps : 1, d = void 0 !== t.depth ? t.depth : 1, f = void 0 === t.bevelEnabled || t.bevelEnabled, p = void 0 !== t.bevelThickness ? t.bevelThickness : .2, m = void 0 !== t.bevelSize ? t.bevelSize : p - .1, g = void 0 !== t.bevelOffset ? t.bevelOffset : 0, v = void 0 !== t.bevelSegments ? t.bevelSegments : 3, y = t.extrudePath, x = void 0 !== t.UVGenerator ? t.UVGenerator : oW, S, A = !1; y && (S = y.getSpacedPoints(c), A = !0, f = !1, s = y.computeFrenetFrames(c, !1), a = new rl, o = new rl, l = new rl), f || (v = 0, p = 0, m = 0, g = 0); let _ = e.extractPoints(h), E = _.shape, b = _.holes; if (!oz.isClockWise(E)) { E = E.reverse(); for (let e = 0, t = b.length; e < t; e++) { let t = b[e]; oz.isClockWise(t) && (b[e] = t.reverse()) } } let T = oz.triangulateShape(E, b), w = E; for (let e = 0, t = b.length; e < t; e++) { let t = b[e]; E = E.concat(t) } function M(e, t, i) { return t || console.error("THREE.ExtrudeGeometry: vec does not exist"), e.clone().addScaledVector(t, i) } let R = E.length, C = T.length; function I(e, t, i) { let r, n, s; let a = e.x - t.x, o = e.y - t.y, l = i.x - e.x, u = i.y - e.y, h = a * a + o * o; if (Math.abs(a * u - o * l) > Number.EPSILON) { let c = Math.sqrt(h), d = Math.sqrt(l * l + u * u), f = t.x - o / c, p = t.y + a / c, m = ((i.x - u / d - f) * u - (i.y + l / d - p) * l) / (a * u - o * l), g = (r = f + a * m - e.x) * r + (n = p + o * m - e.y) * n; if (g <= 2) return new iz(r, n); s = Math.sqrt(g / 2) } else { let e = !1; a > Number.EPSILON ? l > Number.EPSILON && (e = !0) : a < -Number.EPSILON ? l < -Number.EPSILON && (e = !0) : Math.sign(o) === Math.sign(u) && (e = !0), e ? (r = -o, n = a, s = Math.sqrt(h)) : (r = a, n = o, s = Math.sqrt(h / 2)) } return new iz(r / s, n / s) } let L = []; for (let e = 0, t = w.length, i = t - 1, r = e + 1; e < t; e++, i++, r++)i === t && (i = 0), r === t && (r = 0), L[e] = I(w[e], w[i], w[r]); let P = [], D, O = L.concat(); for (let e = 0, t = b.length; e < t; e++) { let t = b[e]; D = []; for (let e = 0, i = t.length, r = i - 1, n = e + 1; e < i; e++, r++, n++)r === i && (r = 0), n === i && (n = 0), D[e] = I(t[e], t[r], t[n]); P.push(D), O = O.concat(D) } for (let e = 0; e < v; e++) { let t = e / v, i = p * Math.cos(t * Math.PI / 2), r = m * Math.sin(t * Math.PI / 2) + g; for (let e = 0, t = w.length; e < t; e++) { let t = M(w[e], L[e], r); U(t.x, t.y, -i) } for (let e = 0, t = b.length; e < t; e++) { let t = b[e]; D = P[e]; for (let e = 0, n = t.length; e < n; e++) { let n = M(t[e], D[e], r); U(n.x, n.y, -i) } } } let k = m + g; for (let e = 0; e < R; e++) { let t = f ? M(E[e], O[e], k) : E[e]; A ? (o.copy(s.normals[0]).multiplyScalar(t.x), a.copy(s.binormals[0]).multiplyScalar(t.y), l.copy(S[0]).add(o).add(a), U(l.x, l.y, l.z)) : U(t.x, t.y, 0) } for (let e = 1; e <= c; e++)for (let t = 0; t < R; t++) { let i = f ? M(E[t], O[t], k) : E[t]; A ? (o.copy(s.normals[e]).multiplyScalar(i.x), a.copy(s.binormals[e]).multiplyScalar(i.y), l.copy(S[e]).add(o).add(a), U(l.x, l.y, l.z)) : U(i.x, i.y, d / c * e) } for (let e = v - 1; e >= 0; e--) { let t = e / v, i = p * Math.cos(t * Math.PI / 2), r = m * Math.sin(t * Math.PI / 2) + g; for (let e = 0, t = w.length; e < t; e++) { let t = M(w[e], L[e], r); U(t.x, t.y, d + i) } for (let e = 0, t = b.length; e < t; e++) { let t = b[e]; D = P[e]; for (let e = 0, n = t.length; e < n; e++) { let n = M(t[e], D[e], r); A ? U(n.x, n.y + S[c - 1].y, S[c - 1].x + i) : U(n.x, n.y, d + i) } } } function F(e, t) { let n = e.length; for (; --n >= 0;) { let s = n, a = n - 1; a < 0 && (a = e.length - 1); for (let e = 0, n = c + 2 * v; e < n; e++) { let n = R * e, o = R * (e + 1); !function (e, t, n, s) { B(e), B(t), B(s), B(t), B(n), B(s); let a = r.length / 3, o = x.generateSideWallUV(i, r, a - 6, a - 3, a - 2, a - 1); z(o[0]), z(o[1]), z(o[3]), z(o[1]), z(o[2]), z(o[3]) }(t + s + n, t + a + n, t + a + o, t + s + o) } } } function U(e, t, i) { u.push(e), u.push(t), u.push(i) } function N(e, t, n) { B(e), B(t), B(n); let s = r.length / 3, a = x.generateTopUV(i, r, s - 3, s - 2, s - 1); z(a[0]), z(a[1]), z(a[2]) } function B(e) { r.push(u[3 * e + 0]), r.push(u[3 * e + 1]), r.push(u[3 * e + 2]) } function z(e) { n.push(e.x), n.push(e.y) } (function () { let e = r.length / 3; if (f) { let e = 0 * R; for (let t = 0; t < C; t++) { let i = T[t]; N(i[2] + e, i[1] + e, i[0] + e) } e = R * (c + 2 * v); for (let t = 0; t < C; t++) { let i = T[t]; N(i[0] + e, i[1] + e, i[2] + e) } } else { for (let e = 0; e < C; e++) { let t = T[e]; N(t[2], t[1], t[0]) } for (let e = 0; e < C; e++) { let t = T[e]; N(t[0] + R * c, t[1] + R * c, t[2] + R * c) } } i.addGroup(e, r.length / 3 - e, 0) })(), function () { let e = r.length / 3, t = 0; F(w, 0), t += w.length; for (let e = 0, i = b.length; e < i; e++) { let i = b[e]; F(i, t), t += i.length } i.addGroup(e, r.length / 3 - e, 1) }() }(e[s]); this.setAttribute("position", new nG(r, 3)), this.setAttribute("uv", new nG(n, 2)), this.computeVertexNormals() } copy(e) { return super.copy(e), this.parameters = Object.assign({}, e.parameters), this } toJSON() { let e = super.toJSON(); return function (e, t, i) { if (i.shapes = [], Array.isArray(e)) for (let t = 0, r = e.length; t < r; t++) { let r = e[t]; i.shapes.push(r.uuid) } else i.shapes.push(e.uuid); return i.options = Object.assign({}, t), void 0 !== t.extrudePath && (i.options.extrudePath = t.extrudePath.toJSON()), i }(this.parameters.shapes, this.parameters.options, e) } static fromJSON(e, t) { let i = []; for (let r = 0, n = e.shapes.length; r < n; r++) { let n = t[e.shapes[r]]; i.push(n) } let r = e.options.extrudePath; return void 0 !== r && (e.options.extrudePath = new ol[r.type]().fromJSON(r)), new oV(i, e.options) } } let oW = { generateTopUV: function (e, t, i, r, n) { let s = t[3 * i], a = t[3 * i + 1], o = t[3 * r], l = t[3 * r + 1], u = t[3 * n], h = t[3 * n + 1]; return [new iz(s, a), new iz(o, l), new iz(u, h)] }, generateSideWallUV: function (e, t, i, r, n, s) { let a = t[3 * i], o = t[3 * i + 1], l = t[3 * i + 2], u = t[3 * r], h = t[3 * r + 1], c = t[3 * r + 2], d = t[3 * n], f = t[3 * n + 1], p = t[3 * n + 2], m = t[3 * s], g = t[3 * s + 1], v = t[3 * s + 2]; return Math.abs(o - h) < Math.abs(a - u) ? [new iz(a, 1 - l), new iz(u, 1 - c), new iz(d, 1 - p), new iz(m, 1 - v)] : [new iz(o, 1 - l), new iz(h, 1 - c), new iz(f, 1 - p), new iz(g, 1 - v)] } }; class oj extends og { constructor(e = 1, t = 0) { let i = (1 + Math.sqrt(5)) / 2; super([-1, i, 0, 1, i, 0, -1, -i, 0, 1, -i, 0, 0, -1, i, 0, 1, i, 0, -1, -i, 0, 1, -i, i, 0, -1, i, 0, 1, -i, 0, -1, -i, 0, 1], [0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1], e, t), this.type = "IcosahedronGeometry", this.parameters = { radius: e, detail: t } } static fromJSON(e) { return new oj(e.radius, e.detail) } } class oY extends og { constructor(e = 1, t = 0) { super([1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1], [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2], e, t), this.type = "OctahedronGeometry", this.parameters = { radius: e, detail: t } } static fromJSON(e) { return new oY(e.radius, e.detail) } } class oX extends nq { constructor(e = 1, t = 1, i = 1, r = 1) { super(), this.type = "PlaneGeometry", this.parameters = { width: e, height: t, widthSegments: i, heightSegments: r }; let n = e / 2, s = t / 2, a = Math.floor(i), o = Math.floor(r), l = a + 1, u = o + 1, h = e / a, c = t / o, d = [], f = [], p = [], m = []; for (let e = 0; e < u; e++) { let t = e * c - s; for (let i = 0; i < l; i++) { let r = i * h - n; f.push(r, -t, 0), p.push(0, 0, 1), m.push(i / a), m.push(1 - e / o) } } for (let e = 0; e < o; e++)for (let t = 0; t < a; t++) { let i = t + l * e, r = t + l * (e + 1), n = t + 1 + l * (e + 1), s = t + 1 + l * e; d.push(i, r, s), d.push(r, n, s) } this.setIndex(d), this.setAttribute("position", new nG(f, 3)), this.setAttribute("normal", new nG(p, 3)), this.setAttribute("uv", new nG(m, 2)) } copy(e) { return super.copy(e), this.parameters = Object.assign({}, e.parameters), this } static fromJSON(e) { return new oX(e.width, e.height, e.widthSegments, e.heightSegments) } } class oK extends nq { constructor(e = .5, t = 1, i = 32, r = 1, n = 0, s = 2 * Math.PI) { super(), this.type = "RingGeometry", this.parameters = { innerRadius: e, outerRadius: t, thetaSegments: i, phiSegments: r, thetaStart: n, thetaLength: s }, i = Math.max(3, i); let a = [], o = [], l = [], u = [], h = e, c = (t - e) / (r = Math.max(1, r)), d = new rl, f = new iz; for (let e = 0; e <= r; e++) { for (let e = 0; e <= i; e++) { let r = n + e / i * s; d.x = h * Math.cos(r), d.y = h * Math.sin(r), o.push(d.x, d.y, d.z), l.push(0, 0, 1), f.x = (d.x / t + 1) / 2, f.y = (d.y / t + 1) / 2, u.push(f.x, f.y) } h += c } for (let e = 0; e < r; e++) { let t = e * (i + 1); for (let e = 0; e < i; e++) { let r = e + t, n = r + i + 1, s = r + i + 2, o = r + 1; a.push(r, n, o), a.push(n, s, o) } } this.setIndex(a), this.setAttribute("position", new nG(o, 3)), this.setAttribute("normal", new nG(l, 3)), this.setAttribute("uv", new nG(u, 2)) } copy(e) { return super.copy(e), this.parameters = Object.assign({}, e.parameters), this } static fromJSON(e) { return new oK(e.innerRadius, e.outerRadius, e.thetaSegments, e.phiSegments, e.thetaStart, e.thetaLength) } } class oq extends nq { constructor(e = new oE([new iz(0, .5), new iz(-.5, -.5), new iz(.5, -.5)]), t = 12) { super(), this.type = "ShapeGeometry", this.parameters = { shapes: e, curveSegments: t }; let i = [], r = [], n = [], s = [], a = 0, o = 0; if (!1 === Array.isArray(e)) l(e); else for (let t = 0; t < e.length; t++)l(e[t]), this.addGroup(a, o, t), a += o, o = 0; function l(e) { let a = r.length / 3, l = e.extractPoints(t), u = l.shape, h = l.holes; !1 === oz.isClockWise(u) && (u = u.reverse()); for (let e = 0, t = h.length; e < t; e++) { let t = h[e]; !0 === oz.isClockWise(t) && (h[e] = t.reverse()) } let c = oz.triangulateShape(u, h); for (let e = 0, t = h.length; e < t; e++) { let t = h[e]; u = u.concat(t) } for (let e = 0, t = u.length; e < t; e++) { let t = u[e]; r.push(t.x, t.y, 0), n.push(0, 0, 1), s.push(t.x, t.y) } for (let e = 0, t = c.length; e < t; e++) { let t = c[e], r = t[0] + a, n = t[1] + a, s = t[2] + a; i.push(r, n, s), o += 3 } } this.setIndex(i), this.setAttribute("position", new nG(r, 3)), this.setAttribute("normal", new nG(n, 3)), this.setAttribute("uv", new nG(s, 2)) } copy(e) { return super.copy(e), this.parameters = Object.assign({}, e.parameters), this } toJSON() { let e = super.toJSON(); return function (e, t) { if (t.shapes = [], Array.isArray(e)) for (let i = 0, r = e.length; i < r; i++) { let r = e[i]; t.shapes.push(r.uuid) } else t.shapes.push(e.uuid); return t }(this.parameters.shapes, e) } static fromJSON(e, t) { let i = []; for (let r = 0, n = e.shapes.length; r < n; r++) { let n = t[e.shapes[r]]; i.push(n) } return new oq(i, e.curveSegments) } } class oQ extends nq { constructor(e = 1, t = 32, i = 16, r = 0, n = 2 * Math.PI, s = 0, a = Math.PI) { super(), this.type = "SphereGeometry", this.parameters = { radius: e, widthSegments: t, heightSegments: i, phiStart: r, phiLength: n, thetaStart: s, thetaLength: a }, t = Math.max(3, Math.floor(t)), i = Math.max(2, Math.floor(i)); let o = Math.min(s + a, Math.PI), l = 0, u = [], h = new rl, c = new rl, d = [], f = [], p = [], m = []; for (let d = 0; d <= i; d++) { let g = [], v = d / i, y = 0; 0 === d && 0 === s ? y = .5 / t : d === i && o === Math.PI && (y = -.5 / t); for (let i = 0; i <= t; i++) { let o = i / t; h.x = -e * Math.cos(r + o * n) * Math.sin(s + v * a), h.y = e * Math.cos(s + v * a), h.z = e * Math.sin(r + o * n) * Math.sin(s + v * a), f.push(h.x, h.y, h.z), c.copy(h).normalize(), p.push(c.x, c.y, c.z), m.push(o + y, 1 - v), g.push(l++) } u.push(g) } for (let e = 0; e < i; e++)for (let r = 0; r < t; r++) { let t = u[e][r + 1], n = u[e][r], a = u[e + 1][r], l = u[e + 1][r + 1]; (0 !== e || s > 0) && d.push(t, n, l), (e !== i - 1 || o < Math.PI) && d.push(n, a, l) } this.setIndex(d), this.setAttribute("position", new nG(f, 3)), this.setAttribute("normal", new nG(p, 3)), this.setAttribute("uv", new nG(m, 2)) } copy(e) { return super.copy(e), this.parameters = Object.assign({}, e.parameters), this } static fromJSON(e) { return new oQ(e.radius, e.widthSegments, e.heightSegments, e.phiStart, e.phiLength, e.thetaStart, e.thetaLength) } } class oZ extends og { constructor(e = 1, t = 0) { super([1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1], [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1], e, t), this.type = "TetrahedronGeometry", this.parameters = { radius: e, detail: t } } static fromJSON(e) { return new oZ(e.radius, e.detail) } } class o$ extends nq { constructor(e = 1, t = .4, i = 12, r = 48, n = 2 * Math.PI) { super(), this.type = "TorusGeometry", this.parameters = { radius: e, tube: t, radialSegments: i, tubularSegments: r, arc: n }, i = Math.floor(i), r = Math.floor(r); let s = [], a = [], o = [], l = [], u = new rl, h = new rl, c = new rl; for (let s = 0; s <= i; s++)for (let d = 0; d <= r; d++) { let f = d / r * n, p = s / i * Math.PI * 2; h.x = (e + t * Math.cos(p)) * Math.cos(f), h.y = (e + t * Math.cos(p)) * Math.sin(f), h.z = t * Math.sin(p), a.push(h.x, h.y, h.z), u.x = e * Math.cos(f), u.y = e * Math.sin(f), c.subVectors(h, u).normalize(), o.push(c.x, c.y, c.z), l.push(d / r), l.push(s / i) } for (let e = 1; e <= i; e++)for (let t = 1; t <= r; t++) { let i = (r + 1) * e + t - 1, n = (r + 1) * (e - 1) + t - 1, a = (r + 1) * (e - 1) + t, o = (r + 1) * e + t; s.push(i, n, o), s.push(n, a, o) } this.setIndex(s), this.setAttribute("position", new nG(a, 3)), this.setAttribute("normal", new nG(o, 3)), this.setAttribute("uv", new nG(l, 2)) } copy(e) { return super.copy(e), this.parameters = Object.assign({}, e.parameters), this } static fromJSON(e) { return new o$(e.radius, e.tube, e.radialSegments, e.tubularSegments, e.arc) } } class oJ extends nq { constructor(e = 1, t = .4, i = 64, r = 8, n = 2, s = 3) { super(), this.type = "TorusKnotGeometry", this.parameters = { radius: e, tube: t, tubularSegments: i, radialSegments: r, p: n, q: s }, i = Math.floor(i), r = Math.floor(r); let a = [], o = [], l = [], u = [], h = new rl, c = new rl, d = new rl, f = new rl, p = new rl, m = new rl, g = new rl; for (let a = 0; a <= i; ++a) { let y = a / i * n * Math.PI * 2; v(y, n, s, e, d), v(y + .01, n, s, e, f), m.subVectors(f, d), g.addVectors(f, d), p.crossVectors(m, g), g.crossVectors(p, m), p.normalize(), g.normalize(); for (let e = 0; e <= r; ++e) { let n = e / r * Math.PI * 2, s = -t * Math.cos(n), f = t * Math.sin(n); h.x = d.x + (s * g.x + f * p.x), h.y = d.y + (s * g.y + f * p.y), h.z = d.z + (s * g.z + f * p.z), o.push(h.x, h.y, h.z), c.subVectors(h, d).normalize(), l.push(c.x, c.y, c.z), u.push(a / i), u.push(e / r) } } for (let e = 1; e <= i; e++)for (let t = 1; t <= r; t++) { let i = (r + 1) * (e - 1) + (t - 1), n = (r + 1) * e + (t - 1), s = (r + 1) * e + t, o = (r + 1) * (e - 1) + t; a.push(i, n, o), a.push(n, s, o) } function v(e, t, i, r, n) { let s = Math.cos(e), a = Math.sin(e), o = i / t * e, l = Math.cos(o); n.x = r * (2 + l) * .5 * s, n.y = r * (2 + l) * a * .5, n.z = r * Math.sin(o) * .5 } this.setIndex(a), this.setAttribute("position", new nG(o, 3)), this.setAttribute("normal", new nG(l, 3)), this.setAttribute("uv", new nG(u, 2)) } copy(e) { return super.copy(e), this.parameters = Object.assign({}, e.parameters), this } static fromJSON(e) { return new oJ(e.radius, e.tube, e.tubularSegments, e.radialSegments, e.p, e.q) } } class o0 extends nq { constructor(e = new oa(new rl(-1, -1, 0), new rl(-1, 1, 0), new rl(1, 1, 0)), t = 64, i = 1, r = 8, n = !1) { super(), this.type = "TubeGeometry", this.parameters = { path: e, tubularSegments: t, radius: i, radialSegments: r, closed: n }; let s = e.computeFrenetFrames(t, n); this.tangents = s.tangents, this.normals = s.normals, this.binormals = s.binormals; let a = new rl, o = new rl, l = new iz, u = new rl, h = [], c = [], d = [], f = []; function p(n) { u = e.getPointAt(n / t, u); let l = s.normals[n], d = s.binormals[n]; for (let e = 0; e <= r; e++) { let t = e / r * Math.PI * 2, n = Math.sin(t), s = -Math.cos(t); o.x = s * l.x + n * d.x, o.y = s * l.y + n * d.y, o.z = s * l.z + n * d.z, o.normalize(), c.push(o.x, o.y, o.z), a.x = u.x + i * o.x, a.y = u.y + i * o.y, a.z = u.z + i * o.z, h.push(a.x, a.y, a.z) } } (function () { for (let e = 0; e < t; e++)p(e); p(!1 === n ? t : 0), function () { for (let e = 0; e <= t; e++)for (let i = 0; i <= r; i++)l.x = e / t, l.y = i / r, d.push(l.x, l.y) }(), function () { for (let e = 1; e <= t; e++)for (let t = 1; t <= r; t++) { let i = (r + 1) * (e - 1) + (t - 1), n = (r + 1) * e + (t - 1), s = (r + 1) * e + t, a = (r + 1) * (e - 1) + t; f.push(i, n, a), f.push(n, s, a) } }() })(), this.setIndex(f), this.setAttribute("position", new nG(h, 3)), this.setAttribute("normal", new nG(c, 3)), this.setAttribute("uv", new nG(d, 2)) } copy(e) { return super.copy(e), this.parameters = Object.assign({}, e.parameters), this } toJSON() { let e = super.toJSON(); return e.path = this.parameters.path.toJSON(), e } static fromJSON(e) { return new o0(new ol[e.path.type]().fromJSON(e.path), e.tubularSegments, e.radius, e.radialSegments, e.closed) } } class o1 extends nq { constructor(e = null) { if (super(), this.type = "WireframeGeometry", this.parameters = { geometry: e }, null !== e) { let t = [], i = new Set, r = new rl, n = new rl; if (null !== e.index) { let s = e.attributes.position, a = e.index, o = e.groups; 0 === o.length && (o = [{ start: 0, count: a.count, materialIndex: 0 }]); for (let e = 0, l = o.length; e < l; ++e) { let l = o[e], u = l.start, h = l.count; for (let e = u, o = u + h; e < o; e += 3)for (let o = 0; o < 3; o++) { let l = a.getX(e + o), u = a.getX(e + (o + 1) % 3); r.fromBufferAttribute(s, l), n.fromBufferAttribute(s, u), !0 === o2(r, n, i) && (t.push(r.x, r.y, r.z), t.push(n.x, n.y, n.z)) } } } else { let s = e.attributes.position; for (let e = 0, a = s.count / 3; e < a; e++)for (let a = 0; a < 3; a++) { let o = 3 * e + a, l = 3 * e + (a + 1) % 3; r.fromBufferAttribute(s, o), n.fromBufferAttribute(s, l), !0 === o2(r, n, i) && (t.push(r.x, r.y, r.z), t.push(n.x, n.y, n.z)) } } this.setAttribute("position", new nG(t, 3)) } } copy(e) { return super.copy(e), this.parameters = Object.assign({}, e.parameters), this } } function o2(e, t, i) { let r = `${e.x},${e.y},${e.z}-${t.x},${t.y},${t.z}`, n = `${t.x},${t.y},${t.z}-${e.x},${e.y},${e.z}`; return !0 !== i.has(r) && !0 !== i.has(n) && (i.add(r), i.add(n), !0) } var o3 = Object.freeze({ __proto__: null, BoxGeometry: n7, CapsuleGeometry: od, CircleGeometry: of, ConeGeometry: om, CylinderGeometry: op, DodecahedronGeometry: ov, EdgesGeometry: o_, ExtrudeGeometry: oV, IcosahedronGeometry: oj, LatheGeometry: oc, OctahedronGeometry: oY, PlaneGeometry: oX, PolyhedronGeometry: og, RingGeometry: oK, ShapeGeometry: oq, SphereGeometry: oQ, TetrahedronGeometry: oZ, TorusGeometry: o$, TorusKnotGeometry: oJ, TubeGeometry: o0, WireframeGeometry: o1 }); class o4 extends nE { constructor(e) { super(), this.isShadowMaterial = !0, this.type = "ShadowMaterial", this.color = new nS(0), this.transparent = !0, this.fog = !0, this.setValues(e) } copy(e) { return super.copy(e), this.color.copy(e.color), this.fog = e.fog, this } } class o5 extends sn { constructor(e) { super(e), this.isRawShaderMaterial = !0, this.type = "RawShaderMaterial" } } class o8 extends nE { constructor(e) { super(), this.isMeshStandardMaterial = !0, this.type = "MeshStandardMaterial", this.defines = { STANDARD: "" }, this.color = new nS(0xffffff), this.roughness = 1, this.metalness = 0, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new nS(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = tj, this.normalScale = new iz(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.roughnessMap = null, this.metalnessMap = null, this.alphaMap = null, this.envMap = null, this.envMapRotation = new rK, this.envMapIntensity = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.fog = !0, this.setValues(e) } copy(e) { return super.copy(e), this.defines = { STANDARD: "" }, this.color.copy(e.color), this.roughness = e.roughness, this.metalness = e.metalness, this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.roughnessMap = e.roughnessMap, this.metalnessMap = e.metalnessMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.envMapRotation.copy(e.envMapRotation), this.envMapIntensity = e.envMapIntensity, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.flatShading = e.flatShading, this.fog = e.fog, this } } class o6 extends o8 { constructor(e) { super(), this.isMeshPhysicalMaterial = !0, this.defines = { STANDARD: "", PHYSICAL: "" }, this.type = "MeshPhysicalMaterial", this.anisotropyRotation = 0, this.anisotropyMap = null, this.clearcoatMap = null, this.clearcoatRoughness = 0, this.clearcoatRoughnessMap = null, this.clearcoatNormalScale = new iz(1, 1), this.clearcoatNormalMap = null, this.ior = 1.5, Object.defineProperty(this, "reflectivity", { get: function () { return iO(2.5 * (this.ior - 1) / (this.ior + 1), 0, 1) }, set: function (e) { this.ior = (1 + .4 * e) / (1 - .4 * e) } }), this.iridescenceMap = null, this.iridescenceIOR = 1.3, this.iridescenceThicknessRange = [100, 400], this.iridescenceThicknessMap = null, this.sheenColor = new nS(0), this.sheenColorMap = null, this.sheenRoughness = 1, this.sheenRoughnessMap = null, this.transmissionMap = null, this.thickness = 0, this.thicknessMap = null, this.attenuationDistance = 1 / 0, this.attenuationColor = new nS(1, 1, 1), this.specularIntensity = 1, this.specularIntensityMap = null, this.specularColor = new nS(1, 1, 1), this.specularColorMap = null, this._anisotropy = 0, this._clearcoat = 0, this._dispersion = 0, this._iridescence = 0, this._sheen = 0, this._transmission = 0, this.setValues(e) } get anisotropy() { return this._anisotropy } set anisotropy(e) { this._anisotropy > 0 != e > 0 && this.version++, this._anisotropy = e } get clearcoat() { return this._clearcoat } set clearcoat(e) { this._clearcoat > 0 != e > 0 && this.version++, this._clearcoat = e } get iridescence() { return this._iridescence } set iridescence(e) { this._iridescence > 0 != e > 0 && this.version++, this._iridescence = e } get dispersion() { return this._dispersion } set dispersion(e) { this._dispersion > 0 != e > 0 && this.version++, this._dispersion = e } get sheen() { return this._sheen } set sheen(e) { this._sheen > 0 != e > 0 && this.version++, this._sheen = e } get transmission() { return this._transmission } set transmission(e) { this._transmission > 0 != e > 0 && this.version++, this._transmission = e } copy(e) { return super.copy(e), this.defines = { STANDARD: "", PHYSICAL: "" }, this.anisotropy = e.anisotropy, this.anisotropyRotation = e.anisotropyRotation, this.anisotropyMap = e.anisotropyMap, this.clearcoat = e.clearcoat, this.clearcoatMap = e.clearcoatMap, this.clearcoatRoughness = e.clearcoatRoughness, this.clearcoatRoughnessMap = e.clearcoatRoughnessMap, this.clearcoatNormalMap = e.clearcoatNormalMap, this.clearcoatNormalScale.copy(e.clearcoatNormalScale), this.dispersion = e.dispersion, this.ior = e.ior, this.iridescence = e.iridescence, this.iridescenceMap = e.iridescenceMap, this.iridescenceIOR = e.iridescenceIOR, this.iridescenceThicknessRange = [...e.iridescenceThicknessRange], this.iridescenceThicknessMap = e.iridescenceThicknessMap, this.sheen = e.sheen, this.sheenColor.copy(e.sheenColor), this.sheenColorMap = e.sheenColorMap, this.sheenRoughness = e.sheenRoughness, this.sheenRoughnessMap = e.sheenRoughnessMap, this.transmission = e.transmission, this.transmissionMap = e.transmissionMap, this.thickness = e.thickness, this.thicknessMap = e.thicknessMap, this.attenuationDistance = e.attenuationDistance, this.attenuationColor.copy(e.attenuationColor), this.specularIntensity = e.specularIntensity, this.specularIntensityMap = e.specularIntensityMap, this.specularColor.copy(e.specularColor), this.specularColorMap = e.specularColorMap, this } } class o9 extends nE { constructor(e) { super(), this.isMeshPhongMaterial = !0, this.type = "MeshPhongMaterial", this.color = new nS(0xffffff), this.specular = new nS(1118481), this.shininess = 30, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new nS(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = tj, this.normalScale = new iz(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.envMapRotation = new rK, this.combine = ei, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.fog = !0, this.setValues(e) } copy(e) { return super.copy(e), this.color.copy(e.color), this.specular.copy(e.specular), this.shininess = e.shininess, this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.envMapRotation.copy(e.envMapRotation), this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.flatShading = e.flatShading, this.fog = e.fog, this } } class o7 extends nE { constructor(e) { super(), this.isMeshToonMaterial = !0, this.defines = { TOON: "" }, this.type = "MeshToonMaterial", this.color = new nS(0xffffff), this.map = null, this.gradientMap = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new nS(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = tj, this.normalScale = new iz(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.fog = !0, this.setValues(e) } copy(e) { return super.copy(e), this.color.copy(e.color), this.map = e.map, this.gradientMap = e.gradientMap, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.alphaMap = e.alphaMap, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.fog = e.fog, this } } class le extends nE { constructor(e) { super(), this.isMeshNormalMaterial = !0, this.type = "MeshNormalMaterial", this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = tj, this.normalScale = new iz(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.flatShading = !1, this.setValues(e) } copy(e) { return super.copy(e), this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.flatShading = e.flatShading, this } } class lt extends nE { constructor(e) { super(), this.isMeshLambertMaterial = !0, this.type = "MeshLambertMaterial", this.color = new nS(0xffffff), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new nS(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = tj, this.normalScale = new iz(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.envMapRotation = new rK, this.combine = ei, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.fog = !0, this.setValues(e) } copy(e) { return super.copy(e), this.color.copy(e.color), this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.envMapRotation.copy(e.envMapRotation), this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.flatShading = e.flatShading, this.fog = e.fog, this } } class li extends nE { constructor(e) { super(), this.isMeshDepthMaterial = !0, this.type = "MeshDepthMaterial", this.depthPacking = tG, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.setValues(e) } copy(e) { return super.copy(e), this.depthPacking = e.depthPacking, this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this } } class lr extends nE { constructor(e) { super(), this.isMeshDistanceMaterial = !0, this.type = "MeshDistanceMaterial", this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.setValues(e) } copy(e) { return super.copy(e), this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this } } class ln extends nE { constructor(e) { super(), this.isMeshMatcapMaterial = !0, this.defines = { MATCAP: "" }, this.type = "MeshMatcapMaterial", this.color = new nS(0xffffff), this.matcap = null, this.map = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = tj, this.normalScale = new iz(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.flatShading = !1, this.fog = !0, this.setValues(e) } copy(e) { return super.copy(e), this.defines = { MATCAP: "" }, this.color.copy(e.color), this.matcap = e.matcap, this.map = e.map, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.alphaMap = e.alphaMap, this.flatShading = e.flatShading, this.fog = e.fog, this } } class ls extends ab { constructor(e) { super(), this.isLineDashedMaterial = !0, this.type = "LineDashedMaterial", this.scale = 1, this.dashSize = 3, this.gapSize = 1, this.setValues(e) } copy(e) { return super.copy(e), this.scale = e.scale, this.dashSize = e.dashSize, this.gapSize = e.gapSize, this } } function la(e, t, i) { return e && (i || e.constructor !== t) ? "number" == typeof t.BYTES_PER_ELEMENT ? new t(e) : Array.prototype.slice.call(e) : e } function lo(e) { return ArrayBuffer.isView(e) && !(e instanceof DataView) } function ll(e) { let t = e.length, i = Array(t); for (let e = 0; e !== t; ++e)i[e] = e; return i.sort(function (t, i) { return e[t] - e[i] }), i } function lu(e, t, i) { let r = e.length, n = new e.constructor(r); for (let s = 0, a = 0; a !== r; ++s) { let r = i[s] * t; for (let i = 0; i !== t; ++i)n[a++] = e[r + i] } return n } function lh(e, t, i, r) { let n = 1, s = e[0]; for (; void 0 !== s && void 0 === s[r];)s = e[n++]; if (void 0 === s) return; let a = s[r]; if (void 0 !== a) { if (Array.isArray(a)) do void 0 !== (a = s[r]) && (t.push(s.time), i.push(...a)), s = e[n++]; while (void 0 !== s); else if (void 0 !== a.toArray) do void 0 !== (a = s[r]) && (t.push(s.time), a.toArray(i, i.length)), s = e[n++]; while (void 0 !== s); else do void 0 !== (a = s[r]) && (t.push(s.time), i.push(a)), s = e[n++]; while (void 0 !== s) } } let lc = { convertArray: la, isTypedArray: lo, getKeyframeOrder: ll, sortedArray: lu, flattenJSON: lh, subclip: function (e, t, i, r, n = 30) { let s = e.clone(); s.name = t; let a = []; for (let e = 0; e < s.tracks.length; ++e) { let t = s.tracks[e], o = t.getValueSize(), l = [], u = []; for (let e = 0; e < t.times.length; ++e) { let s = t.times[e] * n; if (!(s < i) && !(s >= r)) { l.push(t.times[e]); for (let i = 0; i < o; ++i)u.push(t.values[e * o + i]) } } 0 !== l.length && (t.times = la(l, t.times.constructor), t.values = la(u, t.values.constructor), a.push(t)) } s.tracks = a; let o = 1 / 0; for (let e = 0; e < s.tracks.length; ++e)o > s.tracks[e].times[0] && (o = s.tracks[e].times[0]); for (let e = 0; e < s.tracks.length; ++e)s.tracks[e].shift(-1 * o); return s.resetDuration(), s }, makeClipAdditive: function (e, t = 0, i = e, r = 30) { r <= 0 && (r = 30); let n = i.tracks.length, s = t / r; for (let t = 0; t < n; ++t) { let r; let n = i.tracks[t], a = n.ValueTypeName; if ("bool" === a || "string" === a) continue; let o = e.tracks.find(function (e) { return e.name === n.name && e.ValueTypeName === a }); if (void 0 === o) continue; let l = 0, u = n.getValueSize(); n.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (l = u / 3); let h = 0, c = o.getValueSize(); o.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (h = c / 3); let d = n.times.length - 1; if (s <= n.times[0]) { let e = l, t = u - l; r = n.values.slice(e, t) } else if (s >= n.times[d]) { let e = d * u + l, t = e + u - l; r = n.values.slice(e, t) } else { let e = n.createInterpolant(), t = l, i = u - l; e.evaluate(s), r = e.resultBuffer.slice(t, i) } "quaternion" === a && new ro().fromArray(r).normalize().conjugate().toArray(r); let f = o.times.length; for (let e = 0; e < f; ++e) { let t = e * c + h; if ("quaternion" === a) ro.multiplyQuaternionsFlat(o.values, t, r, 0, o.values, t); else { let e = c - 2 * h; for (let i = 0; i < e; ++i)o.values[t + i] -= r[i] } } } return e.blendMode = tU, e } }; class ld { constructor(e, t, i, r) { this.parameterPositions = e, this._cachedIndex = 0, this.resultBuffer = void 0 !== r ? r : new t.constructor(i), this.sampleValues = t, this.valueSize = i, this.settings = null, this.DefaultSettings_ = {} } evaluate(e) { let t = this.parameterPositions, i = this._cachedIndex, r = t[i], n = t[i - 1]; i: { r: { let s; n: { s: if (!(e < r)) { for (let s = i + 2; ;) { if (void 0 === r) { if (e < n) break s; return i = t.length, this._cachedIndex = i, this.copySampleValue_(i - 1) } if (i === s) break; if (n = r, e < (r = t[++i])) break r } s = t.length; break n } if (!(e >= n)) { let a = t[1]; e < a && (i = 2, n = a); for (let s = i - 2; ;) { if (void 0 === n) return this._cachedIndex = 0, this.copySampleValue_(0); if (i === s) break; if (r = n, e >= (n = t[--i - 1])) break r } s = i, i = 0; break n } break i } for (; i < s;) { let r = i + s >>> 1; e < t[r] ? s = r : i = r + 1 } if (r = t[i], void 0 === (n = t[i - 1])) return this._cachedIndex = 0, this.copySampleValue_(0); if (void 0 === r) return i = t.length, this._cachedIndex = i, this.copySampleValue_(i - 1) } this._cachedIndex = i, this.intervalChanged_(i, n, r) } return this.interpolate_(i, n, e, r) } getSettings_() { return this.settings || this.DefaultSettings_ } copySampleValue_(e) { let t = this.resultBuffer, i = this.sampleValues, r = this.valueSize, n = e * r; for (let e = 0; e !== r; ++e)t[e] = i[n + e]; return t } interpolate_() { throw Error("call to abstract method") } intervalChanged_() { } } class lf extends ld { constructor(e, t, i, r) { super(e, t, i, r), this._weightPrev = -0, this._offsetPrev = -0, this._weightNext = -0, this._offsetNext = -0, this.DefaultSettings_ = { endingStart: tD, endingEnd: tD } } intervalChanged_(e, t, i) { let r = this.parameterPositions, n = e - 2, s = e + 1, a = r[n], o = r[s]; if (void 0 === a) switch (this.getSettings_().endingStart) { case tO: n = e, a = 2 * t - i; break; case tk: n = r.length - 2, a = t + r[n] - r[n + 1]; break; default: n = e, a = i }if (void 0 === o) switch (this.getSettings_().endingEnd) { case tO: s = e, o = 2 * i - t; break; case tk: s = 1, o = i + r[1] - r[0]; break; default: s = e - 1, o = t }let l = (i - t) * .5, u = this.valueSize; this._weightPrev = l / (t - a), this._weightNext = l / (o - i), this._offsetPrev = n * u, this._offsetNext = s * u } interpolate_(e, t, i, r) { let n = this.resultBuffer, s = this.sampleValues, a = this.valueSize, o = e * a, l = o - a, u = this._offsetPrev, h = this._offsetNext, c = this._weightPrev, d = this._weightNext, f = (i - t) / (r - t), p = f * f, m = p * f, g = -c * m + 2 * c * p - c * f, v = (1 + c) * m + (-1.5 - 2 * c) * p + (-.5 + c) * f + 1, y = (-1 - d) * m + (1.5 + d) * p + .5 * f, x = d * m - d * p; for (let e = 0; e !== a; ++e)n[e] = g * s[u + e] + v * s[l + e] + y * s[o + e] + x * s[h + e]; return n } } class lp extends ld { constructor(e, t, i, r) { super(e, t, i, r) } interpolate_(e, t, i, r) { let n = this.resultBuffer, s = this.sampleValues, a = this.valueSize, o = e * a, l = o - a, u = (i - t) / (r - t), h = 1 - u; for (let e = 0; e !== a; ++e)n[e] = s[l + e] * h + s[o + e] * u; return n } } class lm extends ld { constructor(e, t, i, r) { super(e, t, i, r) } interpolate_(e) { return this.copySampleValue_(e - 1) } } class lg { constructor(e, t, i, r) { if (void 0 === e) throw Error("THREE.KeyframeTrack: track name is undefined"); if (void 0 === t || 0 === t.length) throw Error("THREE.KeyframeTrack: no keyframes in track named " + e); this.name = e, this.times = la(t, this.TimeBufferType), this.values = la(i, this.ValueBufferType), this.setInterpolation(r || this.DefaultInterpolation) } static toJSON(e) { let t; let i = e.constructor; if (i.toJSON !== this.toJSON) t = i.toJSON(e); else { t = { name: e.name, times: la(e.times, Array), values: la(e.values, Array) }; let i = e.getInterpolation(); i !== e.DefaultInterpolation && (t.interpolation = i) } return t.type = e.ValueTypeName, t } InterpolantFactoryMethodDiscrete(e) { return new lm(this.times, this.values, this.getValueSize(), e) } InterpolantFactoryMethodLinear(e) { return new lp(this.times, this.values, this.getValueSize(), e) } InterpolantFactoryMethodSmooth(e) { return new lf(this.times, this.values, this.getValueSize(), e) } setInterpolation(e) { let t; switch (e) { case tI: t = this.InterpolantFactoryMethodDiscrete; break; case tL: t = this.InterpolantFactoryMethodLinear; break; case tP: t = this.InterpolantFactoryMethodSmooth }if (void 0 === t) { let t = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name; if (void 0 === this.createInterpolant) { if (e !== this.DefaultInterpolation) this.setInterpolation(this.DefaultInterpolation); else throw Error(t) } return console.warn("THREE.KeyframeTrack:", t), this } return this.createInterpolant = t, this } getInterpolation() { switch (this.createInterpolant) { case this.InterpolantFactoryMethodDiscrete: return tI; case this.InterpolantFactoryMethodLinear: return tL; case this.InterpolantFactoryMethodSmooth: return tP } } getValueSize() { return this.values.length / this.times.length } shift(e) { if (0 !== e) { let t = this.times; for (let i = 0, r = t.length; i !== r; ++i)t[i] += e } return this } scale(e) { if (1 !== e) { let t = this.times; for (let i = 0, r = t.length; i !== r; ++i)t[i] *= e } return this } trim(e, t) { let i = this.times, r = i.length, n = 0, s = r - 1; for (; n !== r && i[n] < e;)++n; for (; -1 !== s && i[s] > t;)--s; if (++s, 0 !== n || s !== r) { n >= s && (n = (s = Math.max(s, 1)) - 1); let e = this.getValueSize(); this.times = i.slice(n, s), this.values = this.values.slice(n * e, s * e) } return this } validate() { let e = !0, t = this.getValueSize(); t - Math.floor(t) != 0 && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this), e = !1); let i = this.times, r = this.values, n = i.length; 0 === n && (console.error("THREE.KeyframeTrack: Track is empty.", this), e = !1); let s = null; for (let t = 0; t !== n; t++) { let r = i[t]; if ("number" == typeof r && isNaN(r)) { console.error("THREE.KeyframeTrack: Time is not a valid number.", this, t, r), e = !1; break } if (null !== s && s > r) { console.error("THREE.KeyframeTrack: Out of order keys.", this, t, r, s), e = !1; break } s = r } if (void 0 !== r && lo(r)) for (let t = 0, i = r.length; t !== i; ++t) { let i = r[t]; if (isNaN(i)) { console.error("THREE.KeyframeTrack: Value is not a valid number.", this, t, i), e = !1; break } } return e } optimize() { let e = this.times.slice(), t = this.values.slice(), i = this.getValueSize(), r = this.getInterpolation() === tP, n = e.length - 1, s = 1; for (let a = 1; a < n; ++a) { let n = !1, o = e[a]; if (o !== e[a + 1] && (1 !== a || o !== e[0])) { if (r) n = !0; else { let e = a * i, r = e - i, s = e + i; for (let a = 0; a !== i; ++a) { let i = t[e + a]; if (i !== t[r + a] || i !== t[s + a]) { n = !0; break } } } } if (n) { if (a !== s) { e[s] = e[a]; let r = a * i, n = s * i; for (let e = 0; e !== i; ++e)t[n + e] = t[r + e] } ++s } } if (n > 0) { e[s] = e[n]; for (let e = n * i, r = s * i, a = 0; a !== i; ++a)t[r + a] = t[e + a]; ++s } return s !== e.length ? (this.times = e.slice(0, s), this.values = t.slice(0, s * i)) : (this.times = e, this.values = t), this } clone() { let e = this.times.slice(), t = this.values.slice(), i = new this.constructor(this.name, e, t); return i.createInterpolant = this.createInterpolant, i } } lg.prototype.TimeBufferType = Float32Array, lg.prototype.ValueBufferType = Float32Array, lg.prototype.DefaultInterpolation = tL; class lv extends lg { constructor(e, t, i) { super(e, t, i) } } lv.prototype.ValueTypeName = "bool", lv.prototype.ValueBufferType = Array, lv.prototype.DefaultInterpolation = tI, lv.prototype.InterpolantFactoryMethodLinear = void 0, lv.prototype.InterpolantFactoryMethodSmooth = void 0; class ly extends lg { } ly.prototype.ValueTypeName = "color"; class lx extends lg { } lx.prototype.ValueTypeName = "number"; class lS extends ld { constructor(e, t, i, r) { super(e, t, i, r) } interpolate_(e, t, i, r) { let n = this.resultBuffer, s = this.sampleValues, a = this.valueSize, o = (i - t) / (r - t), l = e * a; for (let e = l + a; l !== e; l += 4)ro.slerpFlat(n, 0, s, l - a, s, l, o); return n } } class lA extends lg { InterpolantFactoryMethodLinear(e) { return new lS(this.times, this.values, this.getValueSize(), e) } } lA.prototype.ValueTypeName = "quaternion", lA.prototype.InterpolantFactoryMethodSmooth = void 0; class l_ extends lg { constructor(e, t, i) { super(e, t, i) } } l_.prototype.ValueTypeName = "string", l_.prototype.ValueBufferType = Array, l_.prototype.DefaultInterpolation = tI, l_.prototype.InterpolantFactoryMethodLinear = void 0, l_.prototype.InterpolantFactoryMethodSmooth = void 0; class lE extends lg { } lE.prototype.ValueTypeName = "vector"; class lb { constructor(e = "", t = -1, i = [], r = tF) { this.name = e, this.tracks = i, this.duration = t, this.blendMode = r, this.uuid = iD(), this.duration < 0 && this.resetDuration() } static parse(e) { let t = [], i = e.tracks, r = 1 / (e.fps || 1); for (let e = 0, n = i.length; e !== n; ++e)t.push((function (e) { if (void 0 === e.type) throw Error("THREE.KeyframeTrack: track type undefined, can not parse"); let t = function (e) { switch (e.toLowerCase()) { case "scalar": case "double": case "float": case "number": case "integer": return lx; case "vector": case "vector2": case "vector3": case "vector4": return lE; case "color": return ly; case "quaternion": return lA; case "bool": case "boolean": return lv; case "string": return l_ }throw Error("THREE.KeyframeTrack: Unsupported typeName: " + e) }(e.type); if (void 0 === e.times) { let t = [], i = []; lh(e.keys, t, i, "value"), e.times = t, e.values = i } return void 0 !== t.parse ? t.parse(e) : new t(e.name, e.times, e.values, e.interpolation) })(i[e]).scale(r)); let n = new this(e.name, e.duration, t, e.blendMode); return n.uuid = e.uuid, n } static toJSON(e) { let t = [], i = e.tracks, r = { name: e.name, duration: e.duration, tracks: t, uuid: e.uuid, blendMode: e.blendMode }; for (let e = 0, r = i.length; e !== r; ++e)t.push(lg.toJSON(i[e])); return r } static CreateFromMorphTargetSequence(e, t, i, r) { let n = t.length, s = []; for (let e = 0; e < n; e++) { let a = [], o = []; a.push((e + n - 1) % n, e, (e + 1) % n), o.push(0, 1, 0); let l = ll(a); a = lu(a, 1, l), o = lu(o, 1, l), r || 0 !== a[0] || (a.push(n), o.push(o[0])), s.push(new lx(".morphTargetInfluences[" + t[e].name + "]", a, o).scale(1 / i)) } return new this(e, -1, s) } static findByName(e, t) { let i = e; Array.isArray(e) || (i = e.geometry && e.geometry.animations || e.animations); for (let e = 0; e < i.length; e++)if (i[e].name === t) return i[e]; return null } static CreateClipsFromMorphTargetSequences(e, t, i) { let r = {}, n = /^([\w-]*?)([\d]+)$/; for (let t = 0, i = e.length; t < i; t++) { let i = e[t], s = i.name.match(n); if (s && s.length > 1) { let e = s[1], t = r[e]; t || (r[e] = t = []), t.push(i) } } let s = []; for (let e in r) s.push(this.CreateFromMorphTargetSequence(e, r[e], t, i)); return s } static parseAnimation(e, t) { if (!e) return console.error("THREE.AnimationClip: No animation in JSONLoader data."), null; let i = function (e, t, i, r, n) { if (0 !== i.length) { let s = [], a = []; lh(i, s, a, r), 0 !== s.length && n.push(new e(t, s, a)) } }, r = [], n = e.name || "default", s = e.fps || 30, a = e.blendMode, o = e.length || -1, l = e.hierarchy || []; for (let e = 0; e < l.length; e++) { let n = l[e].keys; if (n && 0 !== n.length) { if (n[0].morphTargets) { let e; let t = {}; for (e = 0; e < n.length; e++)if (n[e].morphTargets) for (let i = 0; i < n[e].morphTargets.length; i++)t[n[e].morphTargets[i]] = -1; for (let i in t) { let t = [], s = []; for (let r = 0; r !== n[e].morphTargets.length; ++r) { let r = n[e]; t.push(r.time), s.push(r.morphTarget === i ? 1 : 0) } r.push(new lx(".morphTargetInfluence[" + i + "]", t, s)) } o = t.length * s } else { let s = ".bones[" + t[e].name + "]"; i(lE, s + ".position", n, "pos", r), i(lA, s + ".quaternion", n, "rot", r), i(lE, s + ".scale", n, "scl", r) } } } return 0 === r.length ? null : new this(n, o, r, a) } resetDuration() { let e = this.tracks, t = 0; for (let i = 0, r = e.length; i !== r; ++i) { let e = this.tracks[i]; t = Math.max(t, e.times[e.times.length - 1]) } return this.duration = t, this } trim() { for (let e = 0; e < this.tracks.length; e++)this.tracks[e].trim(0, this.duration); return this } validate() { let e = !0; for (let t = 0; t < this.tracks.length; t++)e = e && this.tracks[t].validate(); return e } optimize() { for (let e = 0; e < this.tracks.length; e++)this.tracks[e].optimize(); return this } clone() { let e = []; for (let t = 0; t < this.tracks.length; t++)e.push(this.tracks[t].clone()); return new this.constructor(this.name, this.duration, e, this.blendMode) } toJSON() { return this.constructor.toJSON(this) } } let lT = { enabled: !1, files: {}, add: function (e, t) { !1 !== this.enabled && (this.files[e] = t) }, get: function (e) { if (!1 !== this.enabled) return this.files[e] }, remove: function (e) { delete this.files[e] }, clear: function () { this.files = {} } }; class lw { constructor(e, t, i) { let r; let n = this, s = !1, a = 0, o = 0, l = []; this.onStart = void 0, this.onLoad = e, this.onProgress = t, this.onError = i, this.itemStart = function (e) { o++, !1 === s && void 0 !== n.onStart && n.onStart(e, a, o), s = !0 }, this.itemEnd = function (e) { a++, void 0 !== n.onProgress && n.onProgress(e, a, o), a === o && (s = !1, void 0 !== n.onLoad && n.onLoad()) }, this.itemError = function (e) { void 0 !== n.onError && n.onError(e) }, this.resolveURL = function (e) { return r ? r(e) : e }, this.setURLModifier = function (e) { return r = e, this }, this.addHandler = function (e, t) { return l.push(e, t), this }, this.removeHandler = function (e) { let t = l.indexOf(e); return -1 !== t && l.splice(t, 2), this }, this.getHandler = function (e) { for (let t = 0, i = l.length; t < i; t += 2) { let i = l[t], r = l[t + 1]; if (i.global && (i.lastIndex = 0), i.test(e)) return r } return null } } } let lM = new lw; class lR { constructor(e) { this.manager = void 0 !== e ? e : lM, this.crossOrigin = "anonymous", this.withCredentials = !1, this.path = "", this.resourcePath = "", this.requestHeader = {} } load() { } loadAsync(e, t) { let i = this; return new Promise(function (r, n) { i.load(e, r, t, n) }) } parse() { } setCrossOrigin(e) { return this.crossOrigin = e, this } setWithCredentials(e) { return this.withCredentials = e, this } setPath(e) { return this.path = e, this } setResourcePath(e) { return this.resourcePath = e, this } setRequestHeader(e) { return this.requestHeader = e, this } } lR.DEFAULT_MATERIAL_NAME = "__DEFAULT"; let lC = {}; class lI extends Error { constructor(e, t) { super(e), this.response = t } } class lL extends lR { constructor(e) { super(e) } load(e, t, i, r) { void 0 === e && (e = ""), void 0 !== this.path && (e = this.path + e), e = this.manager.resolveURL(e); let n = lT.get(e); if (void 0 !== n) return this.manager.itemStart(e), setTimeout(() => { t && t(n), this.manager.itemEnd(e) }, 0), n; if (void 0 !== lC[e]) { lC[e].push({ onLoad: t, onProgress: i, onError: r }); return } lC[e] = [], lC[e].push({ onLoad: t, onProgress: i, onError: r }); let s = new Request(e, { headers: new Headers(this.requestHeader), credentials: this.withCredentials ? "include" : "same-origin" }), a = this.mimeType, o = this.responseType; fetch(s).then(t => { if (200 === t.status || 0 === t.status) { if (0 === t.status && console.warn("THREE.FileLoader: HTTP Status 0 received."), "undefined" == typeof ReadableStream || void 0 === t.body || void 0 === t.body.getReader) return t; let i = lC[e], r = t.body.getReader(), n = t.headers.get("X-File-Size") || t.headers.get("Content-Length"), s = n ? parseInt(n) : 0, a = 0 !== s, o = 0; return new Response(new ReadableStream({ start(e) { (function t() { r.read().then(({ done: r, value: n }) => { if (r) e.close(); else { let r = new ProgressEvent("progress", { lengthComputable: a, loaded: o += n.byteLength, total: s }); for (let e = 0, t = i.length; e < t; e++) { let t = i[e]; t.onProgress && t.onProgress(r) } e.enqueue(n), t() } }, t => { e.error(t) }) })() } })) } throw new lI(`fetch for "${t.url}" responded with ${t.status}: ${t.statusText}`, t) }).then(e => { switch (o) { case "arraybuffer": return e.arrayBuffer(); case "blob": return e.blob(); case "document": return e.text().then(e => new DOMParser().parseFromString(e, a)); case "json": return e.json(); default: if (void 0 === a) return e.text(); { let t = /charset="?([^;"\s]*)"?/i.exec(a), i = new TextDecoder(t && t[1] ? t[1].toLowerCase() : void 0); return e.arrayBuffer().then(e => i.decode(e)) } } }).then(t => { lT.add(e, t); let i = lC[e]; delete lC[e]; for (let e = 0, r = i.length; e < r; e++) { let r = i[e]; r.onLoad && r.onLoad(t) } }).catch(t => { let i = lC[e]; if (void 0 === i) throw this.manager.itemError(e), t; delete lC[e]; for (let e = 0, r = i.length; e < r; e++) { let r = i[e]; r.onError && r.onError(t) } this.manager.itemError(e) }).finally(() => { this.manager.itemEnd(e) }), this.manager.itemStart(e) } setResponseType(e) { return this.responseType = e, this } setMimeType(e) { return this.mimeType = e, this } } class lP extends lR { constructor(e) { super(e) } load(e, t, i, r) { let n = this, s = new lL(this.manager); s.setPath(this.path), s.setRequestHeader(this.requestHeader), s.setWithCredentials(this.withCredentials), s.load(e, function (i) { try { t(n.parse(JSON.parse(i))) } catch (t) { r ? r(t) : console.error(t), n.manager.itemError(e) } }, i, r) } parse(e) { let t = []; for (let i = 0; i < e.length; i++) { let r = lb.parse(e[i]); t.push(r) } return t } } class lD extends lR { constructor(e) { super(e) } load(e, t, i, r) { let n = this, s = [], a = new aK, o = new lL(this.manager); o.setPath(this.path), o.setResponseType("arraybuffer"), o.setRequestHeader(this.requestHeader), o.setWithCredentials(n.withCredentials); let l = 0; if (Array.isArray(e)) for (let u = 0, h = e.length; u < h; ++u)!function (u) { o.load(e[u], function (e) { let i = n.parse(e, !0); s[u] = { width: i.width, height: i.height, format: i.format, mipmaps: i.mipmaps }, 6 === (l += 1) && (1 === i.mipmapCount && (a.minFilter = eC), a.image = s, a.format = i.format, a.needsUpdate = !0, t && t(a)) }, i, r) }(u); else o.load(e, function (e) { let i = n.parse(e, !0); if (i.isCubemap) { let e = i.mipmaps.length / i.mipmapCount; for (let t = 0; t < e; t++) { s[t] = { mipmaps: [] }; for (let e = 0; e < i.mipmapCount; e++)s[t].mipmaps.push(i.mipmaps[t * i.mipmapCount + e]), s[t].format = i.format, s[t].width = i.width, s[t].height = i.height } a.image = s } else a.image.width = i.width, a.image.height = i.height, a.mipmaps = i.mipmaps; 1 === i.mipmapCount && (a.minFilter = eC), a.format = i.format, a.needsUpdate = !0, t && t(a) }, i, r); return a } } class lO extends lR { constructor(e) { super(e) } load(e, t, i, r) { void 0 !== this.path && (e = this.path + e), e = this.manager.resolveURL(e); let n = this, s = lT.get(e); if (void 0 !== s) return n.manager.itemStart(e), setTimeout(function () { t && t(s), n.manager.itemEnd(e) }, 0), s; let a = iY("img"); function o() { u(), lT.add(e, this), t && t(this), n.manager.itemEnd(e) } function l(t) { u(), r && r(t), n.manager.itemError(e), n.manager.itemEnd(e) } function u() { a.removeEventListener("load", o, !1), a.removeEventListener("error", l, !1) } return a.addEventListener("load", o, !1), a.addEventListener("error", l, !1), "data:" !== e.slice(0, 5) && void 0 !== this.crossOrigin && (a.crossOrigin = this.crossOrigin), n.manager.itemStart(e), a.src = e, a } } class lk extends lR { constructor(e) { super(e) } load(e, t, i, r) { let n = new sc; n.colorSpace = tK; let s = new lO(this.manager); s.setCrossOrigin(this.crossOrigin), s.setPath(this.path); let a = 0; for (let i = 0; i < e.length; ++i)!function (i) { s.load(e[i], function (e) { n.images[i] = e, 6 == ++a && (n.needsUpdate = !0, t && t(n)) }, void 0, r) }(i); return n } } class lF extends lR { constructor(e) { super(e) } load(e, t, i, r) { let n = this, s = new sZ, a = new lL(this.manager); return a.setResponseType("arraybuffer"), a.setRequestHeader(this.requestHeader), a.setPath(this.path), a.setWithCredentials(n.withCredentials), a.load(e, function (e) { let i; try { i = n.parse(e) } catch (e) { if (void 0 !== r) r(e); else { console.error(e); return } } void 0 !== i.image ? s.image = i.image : void 0 !== i.data && (s.image.width = i.width, s.image.height = i.height, s.image.data = i.data), s.wrapS = void 0 !== i.wrapS ? i.wrapS : e_, s.wrapT = void 0 !== i.wrapT ? i.wrapT : e_, s.magFilter = void 0 !== i.magFilter ? i.magFilter : eC, s.minFilter = void 0 !== i.minFilter ? i.minFilter : eC, s.anisotropy = void 0 !== i.anisotropy ? i.anisotropy : 1, void 0 !== i.colorSpace && (s.colorSpace = i.colorSpace), void 0 !== i.flipY && (s.flipY = i.flipY), void 0 !== i.format && (s.format = i.format), void 0 !== i.type && (s.type = i.type), void 0 !== i.mipmaps && (s.mipmaps = i.mipmaps, s.minFilter = eP), 1 === i.mipmapCount && (s.minFilter = eC), void 0 !== i.generateMipmaps && (s.generateMipmaps = i.generateMipmaps), s.needsUpdate = !0, t && t(s, i) }, i, r), s } } class lU extends lR { constructor(e) { super(e) } load(e, t, i, r) { let n = new i7, s = new lO(this.manager); return s.setCrossOrigin(this.crossOrigin), s.setPath(this.path), s.load(e, function (e) { n.image = e, n.needsUpdate = !0, void 0 !== t && t(n) }, i, r), n } } class lN extends nt { constructor(e, t = 1) { super(), this.isLight = !0, this.type = "Light", this.color = new nS(e), this.intensity = t } dispose() { } copy(e, t) { return super.copy(e, t), this.color.copy(e.color), this.intensity = e.intensity, this } toJSON(e) { let t = super.toJSON(e); return t.object.color = this.color.getHex(), t.object.intensity = this.intensity, void 0 !== this.groundColor && (t.object.groundColor = this.groundColor.getHex()), void 0 !== this.distance && (t.object.distance = this.distance), void 0 !== this.angle && (t.object.angle = this.angle), void 0 !== this.decay && (t.object.decay = this.decay), void 0 !== this.penumbra && (t.object.penumbra = this.penumbra), void 0 !== this.shadow && (t.object.shadow = this.shadow.toJSON()), void 0 !== this.target && (t.object.target = this.target.uuid), t } } class lB extends lN { constructor(e, t, i) { super(e, i), this.isHemisphereLight = !0, this.type = "HemisphereLight", this.position.copy(nt.DEFAULT_UP), this.updateMatrix(), this.groundColor = new nS(t) } copy(e, t) { return super.copy(e, t), this.groundColor.copy(e.groundColor), this } } let lz = new rN, lG = new rl, lH = new rl; class lV { constructor(e) { this.camera = e, this.intensity = 1, this.bias = 0, this.normalBias = 0, this.radius = 1, this.blurSamples = 8, this.mapSize = new iz(512, 512), this.map = null, this.mapPass = null, this.matrix = new rN, this.autoUpdate = !0, this.needsUpdate = !1, this._frustum = new aa, this._frameExtents = new iz(1, 1), this._viewportCount = 1, this._viewports = [new re(0, 0, 1, 1)] } getViewportCount() { return this._viewportCount } getFrustum() { return this._frustum } updateMatrices(e) { let t = this.camera, i = this.matrix; lG.setFromMatrixPosition(e.matrixWorld), t.position.copy(lG), lH.setFromMatrixPosition(e.target.matrixWorld), t.lookAt(lH), t.updateMatrixWorld(), lz.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse), this._frustum.setFromProjectionMatrix(lz), i.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1), i.multiply(lz) } getViewport(e) { return this._viewports[e] } getFrameExtents() { return this._frameExtents } dispose() { this.map && this.map.dispose(), this.mapPass && this.mapPass.dispose() } copy(e) { return this.camera = e.camera.clone(), this.intensity = e.intensity, this.bias = e.bias, this.radius = e.radius, this.mapSize.copy(e.mapSize), this } clone() { return new this.constructor().copy(this) } toJSON() { let e = {}; return 1 !== this.intensity && (e.intensity = this.intensity), 0 !== this.bias && (e.bias = this.bias), 0 !== this.normalBias && (e.normalBias = this.normalBias), 1 !== this.radius && (e.radius = this.radius), (512 !== this.mapSize.x || 512 !== this.mapSize.y) && (e.mapSize = this.mapSize.toArray()), e.camera = this.camera.toJSON(!1).object, delete e.camera.matrix, e } } class lW extends lV { constructor() { super(new su(50, 1, .5, 500)), this.isSpotLightShadow = !0, this.focus = 1 } updateMatrices(e) { let t = this.camera, i = 2 * iP * e.angle * this.focus, r = this.mapSize.width / this.mapSize.height, n = e.distance || t.far; (i !== t.fov || r !== t.aspect || n !== t.far) && (t.fov = i, t.aspect = r, t.far = n, t.updateProjectionMatrix()), super.updateMatrices(e) } copy(e) { return super.copy(e), this.focus = e.focus, this } } class lj extends lN { constructor(e, t, i = 0, r = Math.PI / 3, n = 0, s = 2) { super(e, t), this.isSpotLight = !0, this.type = "SpotLight", this.position.copy(nt.DEFAULT_UP), this.updateMatrix(), this.target = new nt, this.distance = i, this.angle = r, this.penumbra = n, this.decay = s, this.map = null, this.shadow = new lW } get power() { return this.intensity * Math.PI } set power(e) { this.intensity = e / Math.PI } dispose() { this.shadow.dispose() } copy(e, t) { return super.copy(e, t), this.distance = e.distance, this.angle = e.angle, this.penumbra = e.penumbra, this.decay = e.decay, this.target = e.target.clone(), this.shadow = e.shadow.clone(), this } } let lY = new rN, lX = new rl, lK = new rl; class lq extends lV { constructor() { super(new su(90, 1, .5, 500)), this.isPointLightShadow = !0, this._frameExtents = new iz(4, 2), this._viewportCount = 6, this._viewports = [new re(2, 1, 1, 1), new re(0, 1, 1, 1), new re(3, 1, 1, 1), new re(1, 1, 1, 1), new re(3, 0, 1, 1), new re(1, 0, 1, 1)], this._cubeDirections = [new rl(1, 0, 0), new rl(-1, 0, 0), new rl(0, 0, 1), new rl(0, 0, -1), new rl(0, 1, 0), new rl(0, -1, 0)], this._cubeUps = [new rl(0, 1, 0), new rl(0, 1, 0), new rl(0, 1, 0), new rl(0, 1, 0), new rl(0, 0, 1), new rl(0, 0, -1)] } updateMatrices(e, t = 0) { let i = this.camera, r = this.matrix, n = e.distance || i.far; n !== i.far && (i.far = n, i.updateProjectionMatrix()), lX.setFromMatrixPosition(e.matrixWorld), i.position.copy(lX), lK.copy(i.position), lK.add(this._cubeDirections[t]), i.up.copy(this._cubeUps[t]), i.lookAt(lK), i.updateMatrixWorld(), r.makeTranslation(-lX.x, -lX.y, -lX.z), lY.multiplyMatrices(i.projectionMatrix, i.matrixWorldInverse), this._frustum.setFromProjectionMatrix(lY) } } class lQ extends lN { constructor(e, t, i = 0, r = 2) { super(e, t), this.isPointLight = !0, this.type = "PointLight", this.distance = i, this.decay = r, this.shadow = new lq } get power() { return 4 * this.intensity * Math.PI } set power(e) { this.intensity = e / (4 * Math.PI) } dispose() { this.shadow.dispose() } copy(e, t) { return super.copy(e, t), this.distance = e.distance, this.decay = e.decay, this.shadow = e.shadow.clone(), this } } class lZ extends ss { constructor(e = -1, t = 1, i = 1, r = -1, n = .1, s = 2e3) { super(), this.isOrthographicCamera = !0, this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = e, this.right = t, this.top = i, this.bottom = r, this.near = n, this.far = s, this.updateProjectionMatrix() } copy(e, t) { return super.copy(e, t), this.left = e.left, this.right = e.right, this.top = e.top, this.bottom = e.bottom, this.near = e.near, this.far = e.far, this.zoom = e.zoom, this.view = null === e.view ? null : Object.assign({}, e.view), this } setViewOffset(e, t, i, r, n, s) { null === this.view && (this.view = { enabled: !0, fullWidth: 1, fullHeight: 1, offsetX: 0, offsetY: 0, width: 1, height: 1 }), this.view.enabled = !0, this.view.fullWidth = e, this.view.fullHeight = t, this.view.offsetX = i, this.view.offsetY = r, this.view.width = n, this.view.height = s, this.updateProjectionMatrix() } clearViewOffset() { null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix() } updateProjectionMatrix() { let e = (this.right - this.left) / (2 * this.zoom), t = (this.top - this.bottom) / (2 * this.zoom), i = (this.right + this.left) / 2, r = (this.top + this.bottom) / 2, n = i - e, s = i + e, a = r + t, o = r - t; if (null !== this.view && this.view.enabled) { let e = (this.right - this.left) / this.view.fullWidth / this.zoom, t = (this.top - this.bottom) / this.view.fullHeight / this.zoom; n += e * this.view.offsetX, s = n + e * this.view.width, a -= t * this.view.offsetY, o = a - t * this.view.height } this.projectionMatrix.makeOrthographic(n, s, a, o, this.near, this.far, this.coordinateSystem), this.projectionMatrixInverse.copy(this.projectionMatrix).invert() } toJSON(e) { let t = super.toJSON(e); return t.object.zoom = this.zoom, t.object.left = this.left, t.object.right = this.right, t.object.top = this.top, t.object.bottom = this.bottom, t.object.near = this.near, t.object.far = this.far, null !== this.view && (t.object.view = Object.assign({}, this.view)), t } } class l$ extends lV { constructor() { super(new lZ(-5, 5, 5, -5, .5, 500)), this.isDirectionalLightShadow = !0 } } class lJ extends lN { constructor(e, t) { super(e, t), this.isDirectionalLight = !0, this.type = "DirectionalLight", this.position.copy(nt.DEFAULT_UP), this.updateMatrix(), this.target = new nt, this.shadow = new l$ } dispose() { this.shadow.dispose() } copy(e) { return super.copy(e), this.target = e.target.clone(), this.shadow = e.shadow.clone(), this } } class l0 extends lN { constructor(e, t) { super(e, t), this.isAmbientLight = !0, this.type = "AmbientLight" } } class l1 extends lN { constructor(e, t, i = 10, r = 10) { super(e, t), this.isRectAreaLight = !0, this.type = "RectAreaLight", this.width = i, this.height = r } get power() { return this.intensity * this.width * this.height * Math.PI } set power(e) { this.intensity = e / (this.width * this.height * Math.PI) } copy(e) { return super.copy(e), this.width = e.width, this.height = e.height, this } toJSON(e) { let t = super.toJSON(e); return t.object.width = this.width, t.object.height = this.height, t } } class l2 { constructor() { this.isSphericalHarmonics3 = !0, this.coefficients = []; for (let e = 0; e < 9; e++)this.coefficients.push(new rl) } set(e) { for (let t = 0; t < 9; t++)this.coefficients[t].copy(e[t]); return this } zero() { for (let e = 0; e < 9; e++)this.coefficients[e].set(0, 0, 0); return this } getAt(e, t) { let i = e.x, r = e.y, n = e.z, s = this.coefficients; return t.copy(s[0]).multiplyScalar(.282095), t.addScaledVector(s[1], .488603 * r), t.addScaledVector(s[2], .488603 * n), t.addScaledVector(s[3], .488603 * i), t.addScaledVector(s[4], i * r * 1.092548), t.addScaledVector(s[5], r * n * 1.092548), t.addScaledVector(s[6], .315392 * (3 * n * n - 1)), t.addScaledVector(s[7], i * n * 1.092548), t.addScaledVector(s[8], .546274 * (i * i - r * r)), t } getIrradianceAt(e, t) { let i = e.x, r = e.y, n = e.z, s = this.coefficients; return t.copy(s[0]).multiplyScalar(.886227), t.addScaledVector(s[1], 1.023328 * r), t.addScaledVector(s[2], 1.023328 * n), t.addScaledVector(s[3], 1.023328 * i), t.addScaledVector(s[4], .858086 * i * r), t.addScaledVector(s[5], .858086 * r * n), t.addScaledVector(s[6], .743125 * n * n - .247708), t.addScaledVector(s[7], .858086 * i * n), t.addScaledVector(s[8], .429043 * (i * i - r * r)), t } add(e) { for (let t = 0; t < 9; t++)this.coefficients[t].add(e.coefficients[t]); return this } addScaledSH(e, t) { for (let i = 0; i < 9; i++)this.coefficients[i].addScaledVector(e.coefficients[i], t); return this } scale(e) { for (let t = 0; t < 9; t++)this.coefficients[t].multiplyScalar(e); return this } lerp(e, t) { for (let i = 0; i < 9; i++)this.coefficients[i].lerp(e.coefficients[i], t); return this } equals(e) { for (let t = 0; t < 9; t++)if (!this.coefficients[t].equals(e.coefficients[t])) return !1; return !0 } copy(e) { return this.set(e.coefficients) } clone() { return new this.constructor().copy(this) } fromArray(e, t = 0) { let i = this.coefficients; for (let r = 0; r < 9; r++)i[r].fromArray(e, t + 3 * r); return this } toArray(e = [], t = 0) { let i = this.coefficients; for (let r = 0; r < 9; r++)i[r].toArray(e, t + 3 * r); return e } static getBasisAt(e, t) { let i = e.x, r = e.y, n = e.z; t[0] = .282095, t[1] = .488603 * r, t[2] = .488603 * n, t[3] = .488603 * i, t[4] = 1.092548 * i * r, t[5] = 1.092548 * r * n, t[6] = .315392 * (3 * n * n - 1), t[7] = 1.092548 * i * n, t[8] = .546274 * (i * i - r * r) } } class l3 extends lN { constructor(e = new l2, t = 1) { super(void 0, t), this.isLightProbe = !0, this.sh = e } copy(e) { return super.copy(e), this.sh.copy(e.sh), this } fromJSON(e) { return this.intensity = e.intensity, this.sh.fromArray(e.sh), this } toJSON(e) { let t = super.toJSON(e); return t.object.sh = this.sh.toArray(), t } } class l4 extends lR { constructor(e) { super(e), this.textures = {} } load(e, t, i, r) { let n = this, s = new lL(n.manager); s.setPath(n.path), s.setRequestHeader(n.requestHeader), s.setWithCredentials(n.withCredentials), s.load(e, function (i) { try { t(n.parse(JSON.parse(i))) } catch (t) { r ? r(t) : console.error(t), n.manager.itemError(e) } }, i, r) } parse(e) { let t = this.textures; function i(e) { return void 0 === t[e] && console.warn("THREE.MaterialLoader: Undefined texture", e), t[e] } let r = this.createMaterialFromType(e.type); if (void 0 !== e.uuid && (r.uuid = e.uuid), void 0 !== e.name && (r.name = e.name), void 0 !== e.color && void 0 !== r.color && r.color.setHex(e.color), void 0 !== e.roughness && (r.roughness = e.roughness), void 0 !== e.metalness && (r.metalness = e.metalness), void 0 !== e.sheen && (r.sheen = e.sheen), void 0 !== e.sheenColor && (r.sheenColor = new nS().setHex(e.sheenColor)), void 0 !== e.sheenRoughness && (r.sheenRoughness = e.sheenRoughness), void 0 !== e.emissive && void 0 !== r.emissive && r.emissive.setHex(e.emissive), void 0 !== e.specular && void 0 !== r.specular && r.specular.setHex(e.specular), void 0 !== e.specularIntensity && (r.specularIntensity = e.specularIntensity), void 0 !== e.specularColor && void 0 !== r.specularColor && r.specularColor.setHex(e.specularColor), void 0 !== e.shininess && (r.shininess = e.shininess), void 0 !== e.clearcoat && (r.clearcoat = e.clearcoat), void 0 !== e.clearcoatRoughness && (r.clearcoatRoughness = e.clearcoatRoughness), void 0 !== e.dispersion && (r.dispersion = e.dispersion), void 0 !== e.iridescence && (r.iridescence = e.iridescence), void 0 !== e.iridescenceIOR && (r.iridescenceIOR = e.iridescenceIOR), void 0 !== e.iridescenceThicknessRange && (r.iridescenceThicknessRange = e.iridescenceThicknessRange), void 0 !== e.transmission && (r.transmission = e.transmission), void 0 !== e.thickness && (r.thickness = e.thickness), void 0 !== e.attenuationDistance && (r.attenuationDistance = e.attenuationDistance), void 0 !== e.attenuationColor && void 0 !== r.attenuationColor && r.attenuationColor.setHex(e.attenuationColor), void 0 !== e.anisotropy && (r.anisotropy = e.anisotropy), void 0 !== e.anisotropyRotation && (r.anisotropyRotation = e.anisotropyRotation), void 0 !== e.fog && (r.fog = e.fog), void 0 !== e.flatShading && (r.flatShading = e.flatShading), void 0 !== e.blending && (r.blending = e.blending), void 0 !== e.combine && (r.combine = e.combine), void 0 !== e.side && (r.side = e.side), void 0 !== e.shadowSide && (r.shadowSide = e.shadowSide), void 0 !== e.opacity && (r.opacity = e.opacity), void 0 !== e.transparent && (r.transparent = e.transparent), void 0 !== e.alphaTest && (r.alphaTest = e.alphaTest), void 0 !== e.alphaHash && (r.alphaHash = e.alphaHash), void 0 !== e.depthFunc && (r.depthFunc = e.depthFunc), void 0 !== e.depthTest && (r.depthTest = e.depthTest), void 0 !== e.depthWrite && (r.depthWrite = e.depthWrite), void 0 !== e.colorWrite && (r.colorWrite = e.colorWrite), void 0 !== e.blendSrc && (r.blendSrc = e.blendSrc), void 0 !== e.blendDst && (r.blendDst = e.blendDst), void 0 !== e.blendEquation && (r.blendEquation = e.blendEquation), void 0 !== e.blendSrcAlpha && (r.blendSrcAlpha = e.blendSrcAlpha), void 0 !== e.blendDstAlpha && (r.blendDstAlpha = e.blendDstAlpha), void 0 !== e.blendEquationAlpha && (r.blendEquationAlpha = e.blendEquationAlpha), void 0 !== e.blendColor && void 0 !== r.blendColor && r.blendColor.setHex(e.blendColor), void 0 !== e.blendAlpha && (r.blendAlpha = e.blendAlpha), void 0 !== e.stencilWriteMask && (r.stencilWriteMask = e.stencilWriteMask), void 0 !== e.stencilFunc && (r.stencilFunc = e.stencilFunc), void 0 !== e.stencilRef && (r.stencilRef = e.stencilRef), void 0 !== e.stencilFuncMask && (r.stencilFuncMask = e.stencilFuncMask), void 0 !== e.stencilFail && (r.stencilFail = e.stencilFail), void 0 !== e.stencilZFail && (r.stencilZFail = e.stencilZFail), void 0 !== e.stencilZPass && (r.stencilZPass = e.stencilZPass), void 0 !== e.stencilWrite && (r.stencilWrite = e.stencilWrite), void 0 !== e.wireframe && (r.wireframe = e.wireframe), void 0 !== e.wireframeLinewidth && (r.wireframeLinewidth = e.wireframeLinewidth), void 0 !== e.wireframeLinecap && (r.wireframeLinecap = e.wireframeLinecap), void 0 !== e.wireframeLinejoin && (r.wireframeLinejoin = e.wireframeLinejoin), void 0 !== e.rotation && (r.rotation = e.rotation), void 0 !== e.linewidth && (r.linewidth = e.linewidth), void 0 !== e.dashSize && (r.dashSize = e.dashSize), void 0 !== e.gapSize && (r.gapSize = e.gapSize), void 0 !== e.scale && (r.scale = e.scale), void 0 !== e.polygonOffset && (r.polygonOffset = e.polygonOffset), void 0 !== e.polygonOffsetFactor && (r.polygonOffsetFactor = e.polygonOffsetFactor), void 0 !== e.polygonOffsetUnits && (r.polygonOffsetUnits = e.polygonOffsetUnits), void 0 !== e.dithering && (r.dithering = e.dithering), void 0 !== e.alphaToCoverage && (r.alphaToCoverage = e.alphaToCoverage), void 0 !== e.premultipliedAlpha && (r.premultipliedAlpha = e.premultipliedAlpha), void 0 !== e.forceSinglePass && (r.forceSinglePass = e.forceSinglePass), void 0 !== e.visible && (r.visible = e.visible), void 0 !== e.toneMapped && (r.toneMapped = e.toneMapped), void 0 !== e.userData && (r.userData = e.userData), void 0 !== e.vertexColors && ("number" == typeof e.vertexColors ? r.vertexColors = e.vertexColors > 0 : r.vertexColors = e.vertexColors), void 0 !== e.uniforms) for (let t in e.uniforms) { let n = e.uniforms[t]; switch (r.uniforms[t] = {}, n.type) { case "t": r.uniforms[t].value = i(n.value); break; case "c": r.uniforms[t].value = new nS().setHex(n.value); break; case "v2": r.uniforms[t].value = new iz().fromArray(n.value); break; case "v3": r.uniforms[t].value = new rl().fromArray(n.value); break; case "v4": r.uniforms[t].value = new re().fromArray(n.value); break; case "m3": r.uniforms[t].value = new iG().fromArray(n.value); break; case "m4": r.uniforms[t].value = new rN().fromArray(n.value); break; default: r.uniforms[t].value = n.value } } if (void 0 !== e.defines && (r.defines = e.defines), void 0 !== e.vertexShader && (r.vertexShader = e.vertexShader), void 0 !== e.fragmentShader && (r.fragmentShader = e.fragmentShader), void 0 !== e.glslVersion && (r.glslVersion = e.glslVersion), void 0 !== e.extensions) for (let t in e.extensions) r.extensions[t] = e.extensions[t]; if (void 0 !== e.lights && (r.lights = e.lights), void 0 !== e.clipping && (r.clipping = e.clipping), void 0 !== e.size && (r.size = e.size), void 0 !== e.sizeAttenuation && (r.sizeAttenuation = e.sizeAttenuation), void 0 !== e.map && (r.map = i(e.map)), void 0 !== e.matcap && (r.matcap = i(e.matcap)), void 0 !== e.alphaMap && (r.alphaMap = i(e.alphaMap)), void 0 !== e.bumpMap && (r.bumpMap = i(e.bumpMap)), void 0 !== e.bumpScale && (r.bumpScale = e.bumpScale), void 0 !== e.normalMap && (r.normalMap = i(e.normalMap)), void 0 !== e.normalMapType && (r.normalMapType = e.normalMapType), void 0 !== e.normalScale) { let t = e.normalScale; !1 === Array.isArray(t) && (t = [t, t]), r.normalScale = new iz().fromArray(t) } return void 0 !== e.displacementMap && (r.displacementMap = i(e.displacementMap)), void 0 !== e.displacementScale && (r.displacementScale = e.displacementScale), void 0 !== e.displacementBias && (r.displacementBias = e.displacementBias), void 0 !== e.roughnessMap && (r.roughnessMap = i(e.roughnessMap)), void 0 !== e.metalnessMap && (r.metalnessMap = i(e.metalnessMap)), void 0 !== e.emissiveMap && (r.emissiveMap = i(e.emissiveMap)), void 0 !== e.emissiveIntensity && (r.emissiveIntensity = e.emissiveIntensity), void 0 !== e.specularMap && (r.specularMap = i(e.specularMap)), void 0 !== e.specularIntensityMap && (r.specularIntensityMap = i(e.specularIntensityMap)), void 0 !== e.specularColorMap && (r.specularColorMap = i(e.specularColorMap)), void 0 !== e.envMap && (r.envMap = i(e.envMap)), void 0 !== e.envMapRotation && r.envMapRotation.fromArray(e.envMapRotation), void 0 !== e.envMapIntensity && (r.envMapIntensity = e.envMapIntensity), void 0 !== e.reflectivity && (r.reflectivity = e.reflectivity), void 0 !== e.refractionRatio && (r.refractionRatio = e.refractionRatio), void 0 !== e.lightMap && (r.lightMap = i(e.lightMap)), void 0 !== e.lightMapIntensity && (r.lightMapIntensity = e.lightMapIntensity), void 0 !== e.aoMap && (r.aoMap = i(e.aoMap)), void 0 !== e.aoMapIntensity && (r.aoMapIntensity = e.aoMapIntensity), void 0 !== e.gradientMap && (r.gradientMap = i(e.gradientMap)), void 0 !== e.clearcoatMap && (r.clearcoatMap = i(e.clearcoatMap)), void 0 !== e.clearcoatRoughnessMap && (r.clearcoatRoughnessMap = i(e.clearcoatRoughnessMap)), void 0 !== e.clearcoatNormalMap && (r.clearcoatNormalMap = i(e.clearcoatNormalMap)), void 0 !== e.clearcoatNormalScale && (r.clearcoatNormalScale = new iz().fromArray(e.clearcoatNormalScale)), void 0 !== e.iridescenceMap && (r.iridescenceMap = i(e.iridescenceMap)), void 0 !== e.iridescenceThicknessMap && (r.iridescenceThicknessMap = i(e.iridescenceThicknessMap)), void 0 !== e.transmissionMap && (r.transmissionMap = i(e.transmissionMap)), void 0 !== e.thicknessMap && (r.thicknessMap = i(e.thicknessMap)), void 0 !== e.anisotropyMap && (r.anisotropyMap = i(e.anisotropyMap)), void 0 !== e.sheenColorMap && (r.sheenColorMap = i(e.sheenColorMap)), void 0 !== e.sheenRoughnessMap && (r.sheenRoughnessMap = i(e.sheenRoughnessMap)), r } setTextures(e) { return this.textures = e, this } createMaterialFromType(e) { return l4.createMaterialFromType(e) } static createMaterialFromType(e) { return new ({ ShadowMaterial: o4, SpriteMaterial: s_, RawShaderMaterial: o5, ShaderMaterial: sn, PointsMaterial: aN, MeshPhysicalMaterial: o6, MeshStandardMaterial: o8, MeshPhongMaterial: o9, MeshToonMaterial: o7, MeshNormalMaterial: le, MeshLambertMaterial: lt, MeshDepthMaterial: li, MeshDistanceMaterial: lr, MeshBasicMaterial: nb, MeshMatcapMaterial: ln, LineDashedMaterial: ls, LineBasicMaterial: ab, Material: nE })[e] } } class l5 { static decodeText(e) { if (console.warn("THREE.LoaderUtils: decodeText() has been deprecated with r165 and will be removed with r175. Use TextDecoder instead."), "undefined" != typeof TextDecoder) return new TextDecoder().decode(e); let t = ""; for (let i = 0, r = e.length; i < r; i++)t += String.fromCharCode(e[i]); try { return decodeURIComponent(escape(t)) } catch (e) { return t } } static extractUrlBase(e) { let t = e.lastIndexOf("/"); return -1 === t ? "./" : e.slice(0, t + 1) } static resolveURL(e, t) { return "string" != typeof e || "" === e ? "" : (/^https?:\/\//i.test(t) && /^\//.test(e) && (t = t.replace(/(^https?:\/\/[^\/]+).*/i, "$1")), /^(https?:)?\/\//i.test(e) || /^data:.*,.*$/i.test(e) || /^blob:.*$/i.test(e)) ? e : t + e } } class l8 extends nq { constructor() { super(), this.isInstancedBufferGeometry = !0, this.type = "InstancedBufferGeometry", this.instanceCount = 1 / 0 } copy(e) { return super.copy(e), this.instanceCount = e.instanceCount, this } toJSON() { let e = super.toJSON(); return e.instanceCount = this.instanceCount, e.isInstancedBufferGeometry = !0, e } } class l6 extends lR { constructor(e) { super(e) } load(e, t, i, r) { let n = this, s = new lL(n.manager); s.setPath(n.path), s.setRequestHeader(n.requestHeader), s.setWithCredentials(n.withCredentials), s.load(e, function (i) { try { t(n.parse(JSON.parse(i))) } catch (t) { r ? r(t) : console.error(t), n.manager.itemError(e) } }, i, r) } parse(e) { let t = {}, i = {}; function r(e, r) { if (void 0 !== t[r]) return t[r]; let n = e.interleavedBuffers[r], s = function (e, t) { if (void 0 !== i[t]) return i[t]; let r = new Uint32Array(e.arrayBuffers[t]).buffer; return i[t] = r, r }(e, n.buffer), a = new sx(ij(n.type, s), n.stride); return a.uuid = n.uuid, t[r] = a, a } let n = e.isInstancedBufferGeometry ? new l8 : new nq, s = e.data.index; if (void 0 !== s) { let e = ij(s.type, s.array); n.setIndex(new nP(e, 1)) } let a = e.data.attributes; for (let t in a) { let i; let s = a[t]; if (s.isInterleavedBufferAttribute) i = new sA(r(e.data, s.data), s.itemSize, s.offset, s.normalized); else { let e = ij(s.type, s.array); i = new (s.isInstancedBufferAttribute ? s1 : nP)(e, s.itemSize, s.normalized) } void 0 !== s.name && (i.name = s.name), void 0 !== s.usage && i.setUsage(s.usage), n.setAttribute(t, i) } let o = e.data.morphAttributes; if (o) for (let t in o) { let i = o[t], s = []; for (let t = 0, n = i.length; t < n; t++) { let n; let a = i[t]; n = a.isInterleavedBufferAttribute ? new sA(r(e.data, a.data), a.itemSize, a.offset, a.normalized) : new nP(ij(a.type, a.array), a.itemSize, a.normalized), void 0 !== a.name && (n.name = a.name), s.push(n) } n.morphAttributes[t] = s } e.data.morphTargetsRelative && (n.morphTargetsRelative = !0); let l = e.data.groups || e.data.drawcalls || e.data.offsets; if (void 0 !== l) for (let e = 0, t = l.length; e !== t; ++e) { let t = l[e]; n.addGroup(t.start, t.count, t.materialIndex) } let u = e.data.boundingSphere; if (void 0 !== u) { let e = new rl; void 0 !== u.center && e.fromArray(u.center), n.boundingSphere = new rC(e, u.radius) } return e.name && (n.name = e.name), e.userData && (n.userData = e.userData), n } } class l9 extends lR { constructor(e) { super(e) } load(e, t, i, r) { let n = this, s = "" === this.path ? l5.extractUrlBase(e) : this.path; this.resourcePath = this.resourcePath || s; let a = new lL(this.manager); a.setPath(this.path), a.setRequestHeader(this.requestHeader), a.setWithCredentials(this.withCredentials), a.load(e, function (i) { let s = null; try { s = JSON.parse(i) } catch (t) { void 0 !== r && r(t), console.error("THREE:ObjectLoader: Can't parse " + e + ".", t.message); return } let a = s.metadata; if (void 0 === a || void 0 === a.type || "geometry" === a.type.toLowerCase()) { void 0 !== r && r(Error("THREE.ObjectLoader: Can't load " + e)), console.error("THREE.ObjectLoader: Can't load " + e); return } n.parse(s, t) }, i, r) } async loadAsync(e, t) { let i = "" === this.path ? l5.extractUrlBase(e) : this.path; this.resourcePath = this.resourcePath || i; let r = new lL(this.manager); r.setPath(this.path), r.setRequestHeader(this.requestHeader), r.setWithCredentials(this.withCredentials); let n = JSON.parse(await r.loadAsync(e, t)), s = n.metadata; if (void 0 === s || void 0 === s.type || "geometry" === s.type.toLowerCase()) throw Error("THREE.ObjectLoader: Can't load " + e); return await this.parseAsync(n) } parse(e, t) { let i = this.parseAnimations(e.animations), r = this.parseShapes(e.shapes), n = this.parseGeometries(e.geometries, r), s = this.parseImages(e.images, function () { void 0 !== t && t(l) }), a = this.parseTextures(e.textures, s), o = this.parseMaterials(e.materials, a), l = this.parseObject(e.object, n, o, a, i), u = this.parseSkeletons(e.skeletons, l); if (this.bindSkeletons(l, u), this.bindLightTargets(l), void 0 !== t) { let e = !1; for (let t in s) if (s[t].data instanceof HTMLImageElement) { e = !0; break } !1 === e && t(l) } return l } async parseAsync(e) { let t = this.parseAnimations(e.animations), i = this.parseShapes(e.shapes), r = this.parseGeometries(e.geometries, i), n = await this.parseImagesAsync(e.images), s = this.parseTextures(e.textures, n), a = this.parseMaterials(e.materials, s), o = this.parseObject(e.object, r, a, s, t), l = this.parseSkeletons(e.skeletons, o); return this.bindSkeletons(o, l), this.bindLightTargets(o), o } parseShapes(e) { let t = {}; if (void 0 !== e) for (let i = 0, r = e.length; i < r; i++) { let r = new oE().fromJSON(e[i]); t[r.uuid] = r } return t } parseSkeletons(e, t) { let i = {}, r = {}; if (t.traverse(function (e) { e.isBone && (r[e.uuid] = e) }), void 0 !== e) for (let t = 0, n = e.length; t < n; t++) { let n = new s0().fromJSON(e[t], r); i[n.uuid] = n } return i } parseGeometries(e, t) { let i = {}; if (void 0 !== e) { let r = new l6; for (let n = 0, s = e.length; n < s; n++) { let s; let a = e[n]; switch (a.type) { case "BufferGeometry": case "InstancedBufferGeometry": s = r.parse(a); break; default: a.type in o3 ? s = o3[a.type].fromJSON(a, t) : console.warn(`THREE.ObjectLoader: Unsupported geometry type "${a.type}"`) }s.uuid = a.uuid, void 0 !== a.name && (s.name = a.name), void 0 !== a.userData && (s.userData = a.userData), i[a.uuid] = s } } return i } parseMaterials(e, t) { let i = {}, r = {}; if (void 0 !== e) { let n = new l4; n.setTextures(t); for (let t = 0, s = e.length; t < s; t++) { let s = e[t]; void 0 === i[s.uuid] && (i[s.uuid] = n.parse(s)), r[s.uuid] = i[s.uuid] } } return r } parseAnimations(e) { let t = {}; if (void 0 !== e) for (let i = 0; i < e.length; i++) { let r = e[i], n = lb.parse(r); t[n.uuid] = n } return t } parseImages(e, t) { let i; let r = this, n = {}; function s(e) { if ("string" == typeof e) { var t; return t = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(e) ? e : r.resourcePath + e, r.manager.itemStart(t), i.load(t, function () { r.manager.itemEnd(t) }, void 0, function () { r.manager.itemError(t), r.manager.itemEnd(t) }) } return e.data ? { data: ij(e.type, e.data), width: e.width, height: e.height } : null } if (void 0 !== e && e.length > 0) { (i = new lO(new lw(t))).setCrossOrigin(this.crossOrigin); for (let t = 0, i = e.length; t < i; t++) { let i = e[t], r = i.url; if (Array.isArray(r)) { let e = []; for (let t = 0, i = r.length; t < i; t++) { let i = s(r[t]); null !== i && (i instanceof HTMLImageElement ? e.push(i) : e.push(new sZ(i.data, i.width, i.height))) } n[i.uuid] = new i8(e) } else { let e = s(i.url); n[i.uuid] = new i8(e) } } } return n } async parseImagesAsync(e) { let t; let i = this, r = {}; async function n(e) { if ("string" == typeof e) { let r = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(e) ? e : i.resourcePath + e; return await t.loadAsync(r) } return e.data ? { data: ij(e.type, e.data), width: e.width, height: e.height } : null } if (void 0 !== e && e.length > 0) { (t = new lO(this.manager)).setCrossOrigin(this.crossOrigin); for (let t = 0, i = e.length; t < i; t++) { let i = e[t], s = i.url; if (Array.isArray(s)) { let e = []; for (let t = 0, i = s.length; t < i; t++) { let i = s[t], r = await n(i); null !== r && (r instanceof HTMLImageElement ? e.push(r) : e.push(new sZ(r.data, r.width, r.height))) } r[i.uuid] = new i8(e) } else { let e = await n(i.url); r[i.uuid] = new i8(e) } } } return r } parseTextures(e, t) { function i(e, t) { return "number" == typeof e ? e : (console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.", e), t[e]) } let r = {}; if (void 0 !== e) for (let n = 0, s = e.length; n < s; n++) { let s; let a = e[n]; void 0 === a.image && console.warn('THREE.ObjectLoader: No "image" specified for', a.uuid), void 0 === t[a.image] && console.warn("THREE.ObjectLoader: Undefined image", a.image); let o = t[a.image], l = o.data; Array.isArray(l) ? (s = new sc, 6 === l.length && (s.needsUpdate = !0)) : (s = l && l.data ? new sZ : new i7, l && (s.needsUpdate = !0)), s.source = o, s.uuid = a.uuid, void 0 !== a.name && (s.name = a.name), void 0 !== a.mapping && (s.mapping = i(a.mapping, l7)), void 0 !== a.channel && (s.channel = a.channel), void 0 !== a.offset && s.offset.fromArray(a.offset), void 0 !== a.repeat && s.repeat.fromArray(a.repeat), void 0 !== a.center && s.center.fromArray(a.center), void 0 !== a.rotation && (s.rotation = a.rotation), void 0 !== a.wrap && (s.wrapS = i(a.wrap[0], ue), s.wrapT = i(a.wrap[1], ue)), void 0 !== a.format && (s.format = a.format), void 0 !== a.internalFormat && (s.internalFormat = a.internalFormat), void 0 !== a.type && (s.type = a.type), void 0 !== a.colorSpace && (s.colorSpace = a.colorSpace), void 0 !== a.minFilter && (s.minFilter = i(a.minFilter, ut)), void 0 !== a.magFilter && (s.magFilter = i(a.magFilter, ut)), void 0 !== a.anisotropy && (s.anisotropy = a.anisotropy), void 0 !== a.flipY && (s.flipY = a.flipY), void 0 !== a.generateMipmaps && (s.generateMipmaps = a.generateMipmaps), void 0 !== a.premultiplyAlpha && (s.premultiplyAlpha = a.premultiplyAlpha), void 0 !== a.unpackAlignment && (s.unpackAlignment = a.unpackAlignment), void 0 !== a.compareFunction && (s.compareFunction = a.compareFunction), void 0 !== a.userData && (s.userData = a.userData), r[a.uuid] = s } return r } parseObject(e, t, i, r, n) { let s, a, o; function l(e) { return void 0 === t[e] && console.warn("THREE.ObjectLoader: Undefined geometry", e), t[e] } function u(e) { if (void 0 !== e) { if (Array.isArray(e)) { let t = []; for (let r = 0, n = e.length; r < n; r++) { let n = e[r]; void 0 === i[n] && console.warn("THREE.ObjectLoader: Undefined material", n), t.push(i[n]) } return t } return void 0 === i[e] && console.warn("THREE.ObjectLoader: Undefined material", e), i[e] } } function h(e) { return void 0 === r[e] && console.warn("THREE.ObjectLoader: Undefined texture", e), r[e] } switch (e.type) { case "Scene": s = new sy, void 0 !== e.background && (Number.isInteger(e.background) ? s.background = new nS(e.background) : s.background = h(e.background)), void 0 !== e.environment && (s.environment = h(e.environment)), void 0 !== e.fog && ("Fog" === e.fog.type ? s.fog = new sv(e.fog.color, e.fog.near, e.fog.far) : "FogExp2" === e.fog.type && (s.fog = new sg(e.fog.color, e.fog.density)), "" !== e.fog.name && (s.fog.name = e.fog.name)), void 0 !== e.backgroundBlurriness && (s.backgroundBlurriness = e.backgroundBlurriness), void 0 !== e.backgroundIntensity && (s.backgroundIntensity = e.backgroundIntensity), void 0 !== e.backgroundRotation && s.backgroundRotation.fromArray(e.backgroundRotation), void 0 !== e.environmentIntensity && (s.environmentIntensity = e.environmentIntensity), void 0 !== e.environmentRotation && s.environmentRotation.fromArray(e.environmentRotation); break; case "PerspectiveCamera": s = new su(e.fov, e.aspect, e.near, e.far), void 0 !== e.focus && (s.focus = e.focus), void 0 !== e.zoom && (s.zoom = e.zoom), void 0 !== e.filmGauge && (s.filmGauge = e.filmGauge), void 0 !== e.filmOffset && (s.filmOffset = e.filmOffset), void 0 !== e.view && (s.view = Object.assign({}, e.view)); break; case "OrthographicCamera": s = new lZ(e.left, e.right, e.top, e.bottom, e.near, e.far), void 0 !== e.zoom && (s.zoom = e.zoom), void 0 !== e.view && (s.view = Object.assign({}, e.view)); break; case "AmbientLight": s = new l0(e.color, e.intensity); break; case "DirectionalLight": (s = new lJ(e.color, e.intensity)).target = e.target || ""; break; case "PointLight": s = new lQ(e.color, e.intensity, e.distance, e.decay); break; case "RectAreaLight": s = new l1(e.color, e.intensity, e.width, e.height); break; case "SpotLight": (s = new lj(e.color, e.intensity, e.distance, e.angle, e.penumbra, e.decay)).target = e.target || ""; break; case "HemisphereLight": s = new lB(e.color, e.groundColor, e.intensity); break; case "LightProbe": s = new l3().fromJSON(e); break; case "SkinnedMesh": s = new sq(a = l(e.geometry), o = u(e.material)), void 0 !== e.bindMode && (s.bindMode = e.bindMode), void 0 !== e.bindMatrix && s.bindMatrix.fromArray(e.bindMatrix), void 0 !== e.skeleton && (s.skeleton = e.skeleton); break; case "Mesh": s = new n6(a = l(e.geometry), o = u(e.material)); break; case "InstancedMesh": a = l(e.geometry), o = u(e.material); let c = e.count, d = e.instanceMatrix, f = e.instanceColor; (s = new s7(a, o, c)).instanceMatrix = new s1(new Float32Array(d.array), 16), void 0 !== f && (s.instanceColor = new s1(new Float32Array(f.array), f.itemSize)); break; case "BatchedMesh": a = l(e.geometry), o = u(e.material), (s = new aE(e.maxInstanceCount, e.maxVertexCount, e.maxIndexCount, o)).geometry = a, s.perObjectFrustumCulled = e.perObjectFrustumCulled, s.sortObjects = e.sortObjects, s._drawRanges = e.drawRanges, s._reservedRanges = e.reservedRanges, s._visibility = e.visibility, s._active = e.active, s._bounds = e.bounds.map(e => { let t = new rc; t.min.fromArray(e.boxMin), t.max.fromArray(e.boxMax); let i = new rC; return i.radius = e.sphereRadius, i.center.fromArray(e.sphereCenter), { boxInitialized: e.boxInitialized, box: t, sphereInitialized: e.sphereInitialized, sphere: i } }), s._maxInstanceCount = e.maxInstanceCount, s._maxVertexCount = e.maxVertexCount, s._maxIndexCount = e.maxIndexCount, s._geometryInitialized = e.geometryInitialized, s._geometryCount = e.geometryCount, s._matricesTexture = h(e.matricesTexture.uuid), void 0 !== e.colorsTexture && (s._colorsTexture = h(e.colorsTexture.uuid)); break; case "LOD": s = new sB; break; case "Line": s = new aP(l(e.geometry), u(e.material)); break; case "LineLoop": s = new aU(l(e.geometry), u(e.material)); break; case "LineSegments": s = new aF(l(e.geometry), u(e.material)); break; case "PointCloud": case "Points": s = new aV(l(e.geometry), u(e.material)); break; case "Sprite": s = new sk(u(e.material)); break; case "Group": s = new sf; break; case "Bone": s = new sQ; break; default: s = new nt }if (s.uuid = e.uuid, void 0 !== e.name && (s.name = e.name), void 0 !== e.matrix ? (s.matrix.fromArray(e.matrix), void 0 !== e.matrixAutoUpdate && (s.matrixAutoUpdate = e.matrixAutoUpdate), s.matrixAutoUpdate && s.matrix.decompose(s.position, s.quaternion, s.scale)) : (void 0 !== e.position && s.position.fromArray(e.position), void 0 !== e.rotation && s.rotation.fromArray(e.rotation), void 0 !== e.quaternion && s.quaternion.fromArray(e.quaternion), void 0 !== e.scale && s.scale.fromArray(e.scale)), void 0 !== e.up && s.up.fromArray(e.up), void 0 !== e.castShadow && (s.castShadow = e.castShadow), void 0 !== e.receiveShadow && (s.receiveShadow = e.receiveShadow), e.shadow && (void 0 !== e.shadow.intensity && (s.shadow.intensity = e.shadow.intensity), void 0 !== e.shadow.bias && (s.shadow.bias = e.shadow.bias), void 0 !== e.shadow.normalBias && (s.shadow.normalBias = e.shadow.normalBias), void 0 !== e.shadow.radius && (s.shadow.radius = e.shadow.radius), void 0 !== e.shadow.mapSize && s.shadow.mapSize.fromArray(e.shadow.mapSize), void 0 !== e.shadow.camera && (s.shadow.camera = this.parseObject(e.shadow.camera))), void 0 !== e.visible && (s.visible = e.visible), void 0 !== e.frustumCulled && (s.frustumCulled = e.frustumCulled), void 0 !== e.renderOrder && (s.renderOrder = e.renderOrder), void 0 !== e.userData && (s.userData = e.userData), void 0 !== e.layers && (s.layers.mask = e.layers), void 0 !== e.children) { let a = e.children; for (let e = 0; e < a.length; e++)s.add(this.parseObject(a[e], t, i, r, n)) } if (void 0 !== e.animations) { let t = e.animations; for (let e = 0; e < t.length; e++) { let i = t[e]; s.animations.push(n[i]) } } if ("LOD" === e.type) { void 0 !== e.autoUpdate && (s.autoUpdate = e.autoUpdate); let t = e.levels; for (let e = 0; e < t.length; e++) { let i = t[e], r = s.getObjectByProperty("uuid", i.object); void 0 !== r && s.addLevel(r, i.distance, i.hysteresis) } } return s } bindSkeletons(e, t) { 0 !== Object.keys(t).length && e.traverse(function (e) { if (!0 === e.isSkinnedMesh && void 0 !== e.skeleton) { let i = t[e.skeleton]; void 0 === i ? console.warn("THREE.ObjectLoader: No skeleton found with UUID:", e.skeleton) : e.bind(i, e.bindMatrix) } }) } bindLightTargets(e) { e.traverse(function (t) { if (t.isDirectionalLight || t.isSpotLight) { let i = t.target, r = e.getObjectByProperty("uuid", i); void 0 !== r ? t.target = r : t.target = new nt } }) } } let l7 = { UVMapping: em, CubeReflectionMapping: eg, CubeRefractionMapping: ev, EquirectangularReflectionMapping: ey, EquirectangularRefractionMapping: ex, CubeUVReflectionMapping: eS }, ue = { RepeatWrapping: eA, ClampToEdgeWrapping: e_, MirroredRepeatWrapping: eE }, ut = { NearestFilter: eb, NearestMipmapNearestFilter: eT, NearestMipmapLinearFilter: eM, LinearFilter: eC, LinearMipmapNearestFilter: eI, LinearMipmapLinearFilter: eP }; class ui extends lR { constructor(e) { super(e), this.isImageBitmapLoader = !0, "undefined" == typeof createImageBitmap && console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."), "undefined" == typeof fetch && console.warn("THREE.ImageBitmapLoader: fetch() not supported."), this.options = { premultiplyAlpha: "none" } } setOptions(e) { return this.options = e, this } load(e, t, i, r) { void 0 === e && (e = ""), void 0 !== this.path && (e = this.path + e), e = this.manager.resolveURL(e); let n = this, s = lT.get(e); if (void 0 !== s) { if (n.manager.itemStart(e), s.then) { s.then(i => { t && t(i), n.manager.itemEnd(e) }).catch(e => { r && r(e) }); return } return setTimeout(function () { t && t(s), n.manager.itemEnd(e) }, 0), s } let a = {}; a.credentials = "anonymous" === this.crossOrigin ? "same-origin" : "include", a.headers = this.requestHeader; let o = fetch(e, a).then(function (e) { return e.blob() }).then(function (e) { return createImageBitmap(e, Object.assign(n.options, { colorSpaceConversion: "none" })) }).then(function (i) { return lT.add(e, i), t && t(i), n.manager.itemEnd(e), i }).catch(function (t) { r && r(t), lT.remove(e), n.manager.itemError(e), n.manager.itemEnd(e) }); lT.add(e, o), n.manager.itemStart(e) } } class ur { static getContext() { return void 0 === s && (s = new (window.AudioContext || window.webkitAudioContext)), s } static setContext(e) { s = e } } class un extends lR { constructor(e) { super(e) } load(e, t, i, r) { let n = this, s = new lL(this.manager); function a(t) { r ? r(t) : console.error(t), n.manager.itemError(e) } s.setResponseType("arraybuffer"), s.setPath(this.path), s.setRequestHeader(this.requestHeader), s.setWithCredentials(this.withCredentials), s.load(e, function (e) { try { let i = e.slice(0); ur.getContext().decodeAudioData(i, function (e) { t(e) }).catch(a) } catch (e) { a(e) } }, i, r) } } let us = new rN, ua = new rN, uo = new rN; class ul { constructor() { this.type = "StereoCamera", this.aspect = 1, this.eyeSep = .064, this.cameraL = new su, this.cameraL.layers.enable(1), this.cameraL.matrixAutoUpdate = !1, this.cameraR = new su, this.cameraR.layers.enable(2), this.cameraR.matrixAutoUpdate = !1, this._cache = { focus: null, fov: null, aspect: null, near: null, far: null, zoom: null, eyeSep: null } } update(e) { let t = this._cache; if (t.focus !== e.focus || t.fov !== e.fov || t.aspect !== e.aspect * this.aspect || t.near !== e.near || t.far !== e.far || t.zoom !== e.zoom || t.eyeSep !== this.eyeSep) { let i, r; t.focus = e.focus, t.fov = e.fov, t.aspect = e.aspect * this.aspect, t.near = e.near, t.far = e.far, t.zoom = e.zoom, t.eyeSep = this.eyeSep, uo.copy(e.projectionMatrix); let n = t.eyeSep / 2, s = n * t.near / t.focus, a = t.near * Math.tan(iL * t.fov * .5) / t.zoom; ua.elements[12] = -n, us.elements[12] = n, i = -a * t.aspect + s, r = a * t.aspect + s, uo.elements[0] = 2 * t.near / (r - i), uo.elements[8] = (r + i) / (r - i), this.cameraL.projectionMatrix.copy(uo), i = -a * t.aspect - s, r = a * t.aspect - s, uo.elements[0] = 2 * t.near / (r - i), uo.elements[8] = (r + i) / (r - i), this.cameraR.projectionMatrix.copy(uo) } this.cameraL.matrixWorld.copy(e.matrixWorld).multiply(ua), this.cameraR.matrixWorld.copy(e.matrixWorld).multiply(us) } } class uu extends su { constructor(e = []) { super(), this.isArrayCamera = !0, this.cameras = e, this.index = 0 } } class uh { constructor(e = !0) { this.autoStart = e, this.startTime = 0, this.oldTime = 0, this.elapsedTime = 0, this.running = !1 } start() { this.startTime = uc(), this.oldTime = this.startTime, this.elapsedTime = 0, this.running = !0 } stop() { this.getElapsedTime(), this.running = !1, this.autoStart = !1 } getElapsedTime() { return this.getDelta(), this.elapsedTime } getDelta() { let e = 0; if (this.autoStart && !this.running) return this.start(), 0; if (this.running) { let t = uc(); e = (t - this.oldTime) / 1e3, this.oldTime = t, this.elapsedTime += e } return e } } function uc() { return performance.now() } let ud = new rl, uf = new ro, up = new rl, um = new rl; class ug extends nt { constructor() { super(), this.type = "AudioListener", this.context = ur.getContext(), this.gain = this.context.createGain(), this.gain.connect(this.context.destination), this.filter = null, this.timeDelta = 0, this._clock = new uh } getInput() { return this.gain } removeFilter() { return null !== this.filter && (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination), this.gain.connect(this.context.destination), this.filter = null), this } getFilter() { return this.filter } setFilter(e) { return null !== this.filter ? (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination)) : this.gain.disconnect(this.context.destination), this.filter = e, this.gain.connect(this.filter), this.filter.connect(this.context.destination), this } getMasterVolume() { return this.gain.gain.value } setMasterVolume(e) { return this.gain.gain.setTargetAtTime(e, this.context.currentTime, .01), this } updateMatrixWorld(e) { super.updateMatrixWorld(e); let t = this.context.listener, i = this.up; if (this.timeDelta = this._clock.getDelta(), this.matrixWorld.decompose(ud, uf, up), um.set(0, 0, -1).applyQuaternion(uf), t.positionX) { let e = this.context.currentTime + this.timeDelta; t.positionX.linearRampToValueAtTime(ud.x, e), t.positionY.linearRampToValueAtTime(ud.y, e), t.positionZ.linearRampToValueAtTime(ud.z, e), t.forwardX.linearRampToValueAtTime(um.x, e), t.forwardY.linearRampToValueAtTime(um.y, e), t.forwardZ.linearRampToValueAtTime(um.z, e), t.upX.linearRampToValueAtTime(i.x, e), t.upY.linearRampToValueAtTime(i.y, e), t.upZ.linearRampToValueAtTime(i.z, e) } else t.setPosition(ud.x, ud.y, ud.z), t.setOrientation(um.x, um.y, um.z, i.x, i.y, i.z) } } class uv extends nt { constructor(e) { super(), this.type = "Audio", this.listener = e, this.context = e.context, this.gain = this.context.createGain(), this.gain.connect(e.getInput()), this.autoplay = !1, this.buffer = null, this.detune = 0, this.loop = !1, this.loopStart = 0, this.loopEnd = 0, this.offset = 0, this.duration = void 0, this.playbackRate = 1, this.isPlaying = !1, this.hasPlaybackControl = !0, this.source = null, this.sourceType = "empty", this._startedAt = 0, this._progress = 0, this._connected = !1, this.filters = [] } getOutput() { return this.gain } setNodeSource(e) { return this.hasPlaybackControl = !1, this.sourceType = "audioNode", this.source = e, this.connect(), this } setMediaElementSource(e) { return this.hasPlaybackControl = !1, this.sourceType = "mediaNode", this.source = this.context.createMediaElementSource(e), this.connect(), this } setMediaStreamSource(e) { return this.hasPlaybackControl = !1, this.sourceType = "mediaStreamNode", this.source = this.context.createMediaStreamSource(e), this.connect(), this } setBuffer(e) { return this.buffer = e, this.sourceType = "buffer", this.autoplay && this.play(), this } play(e = 0) { if (!0 === this.isPlaying) { console.warn("THREE.Audio: Audio is already playing."); return } if (!1 === this.hasPlaybackControl) { console.warn("THREE.Audio: this Audio has no playback control."); return } this._startedAt = this.context.currentTime + e; let t = this.context.createBufferSource(); return t.buffer = this.buffer, t.loop = this.loop, t.loopStart = this.loopStart, t.loopEnd = this.loopEnd, t.onended = this.onEnded.bind(this), t.start(this._startedAt, this._progress + this.offset, this.duration), this.isPlaying = !0, this.source = t, this.setDetune(this.detune), this.setPlaybackRate(this.playbackRate), this.connect() } pause() { if (!1 === this.hasPlaybackControl) { console.warn("THREE.Audio: this Audio has no playback control."); return } return !0 === this.isPlaying && (this._progress += Math.max(this.context.currentTime - this._startedAt, 0) * this.playbackRate, !0 === this.loop && (this._progress = this._progress % (this.duration || this.buffer.duration)), this.source.stop(), this.source.onended = null, this.isPlaying = !1), this } stop(e = 0) { if (!1 === this.hasPlaybackControl) { console.warn("THREE.Audio: this Audio has no playback control."); return } return this._progress = 0, null !== this.source && (this.source.stop(this.context.currentTime + e), this.source.onended = null), this.isPlaying = !1, this } connect() { if (this.filters.length > 0) { this.source.connect(this.filters[0]); for (let e = 1, t = this.filters.length; e < t; e++)this.filters[e - 1].connect(this.filters[e]); this.filters[this.filters.length - 1].connect(this.getOutput()) } else this.source.connect(this.getOutput()); return this._connected = !0, this } disconnect() { if (!1 !== this._connected) { if (this.filters.length > 0) { this.source.disconnect(this.filters[0]); for (let e = 1, t = this.filters.length; e < t; e++)this.filters[e - 1].disconnect(this.filters[e]); this.filters[this.filters.length - 1].disconnect(this.getOutput()) } else this.source.disconnect(this.getOutput()); return this._connected = !1, this } } getFilters() { return this.filters } setFilters(e) { return e || (e = []), !0 === this._connected ? (this.disconnect(), this.filters = e.slice(), this.connect()) : this.filters = e.slice(), this } setDetune(e) { return this.detune = e, !0 === this.isPlaying && void 0 !== this.source.detune && this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, .01), this } getDetune() { return this.detune } getFilter() { return this.getFilters()[0] } setFilter(e) { return this.setFilters(e ? [e] : []) } setPlaybackRate(e) { if (!1 === this.hasPlaybackControl) { console.warn("THREE.Audio: this Audio has no playback control."); return } return this.playbackRate = e, !0 === this.isPlaying && this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, .01), this } getPlaybackRate() { return this.playbackRate } onEnded() { this.isPlaying = !1, this._progress = 0 } getLoop() { return !1 === this.hasPlaybackControl ? (console.warn("THREE.Audio: this Audio has no playback control."), !1) : this.loop } setLoop(e) { if (!1 === this.hasPlaybackControl) { console.warn("THREE.Audio: this Audio has no playback control."); return } return this.loop = e, !0 === this.isPlaying && (this.source.loop = this.loop), this } setLoopStart(e) { return this.loopStart = e, this } setLoopEnd(e) { return this.loopEnd = e, this } getVolume() { return this.gain.gain.value } setVolume(e) { return this.gain.gain.setTargetAtTime(e, this.context.currentTime, .01), this } copy(e, t) { return (super.copy(e, t), "buffer" !== e.sourceType) ? console.warn("THREE.Audio: Audio source type cannot be copied.") : (this.autoplay = e.autoplay, this.buffer = e.buffer, this.detune = e.detune, this.loop = e.loop, this.loopStart = e.loopStart, this.loopEnd = e.loopEnd, this.offset = e.offset, this.duration = e.duration, this.playbackRate = e.playbackRate, this.hasPlaybackControl = e.hasPlaybackControl, this.sourceType = e.sourceType, this.filters = e.filters.slice()), this } clone(e) { return new this.constructor(this.listener).copy(this, e) } } let uy = new rl, ux = new ro, uS = new rl, uA = new rl; class u_ extends uv { constructor(e) { super(e), this.panner = this.context.createPanner(), this.panner.panningModel = "HRTF", this.panner.connect(this.gain) } connect() { return super.connect(), this.panner.connect(this.gain), this } disconnect() { return super.disconnect(), this.panner.disconnect(this.gain), this } getOutput() { return this.panner } getRefDistance() { return this.panner.refDistance } setRefDistance(e) { return this.panner.refDistance = e, this } getRolloffFactor() { return this.panner.rolloffFactor } setRolloffFactor(e) { return this.panner.rolloffFactor = e, this } getDistanceModel() { return this.panner.distanceModel } setDistanceModel(e) { return this.panner.distanceModel = e, this } getMaxDistance() { return this.panner.maxDistance } setMaxDistance(e) { return this.panner.maxDistance = e, this } setDirectionalCone(e, t, i) { return this.panner.coneInnerAngle = e, this.panner.coneOuterAngle = t, this.panner.coneOuterGain = i, this } updateMatrixWorld(e) { if (super.updateMatrixWorld(e), !0 === this.hasPlaybackControl && !1 === this.isPlaying) return; this.matrixWorld.decompose(uy, ux, uS), uA.set(0, 0, 1).applyQuaternion(ux); let t = this.panner; if (t.positionX) { let e = this.context.currentTime + this.listener.timeDelta; t.positionX.linearRampToValueAtTime(uy.x, e), t.positionY.linearRampToValueAtTime(uy.y, e), t.positionZ.linearRampToValueAtTime(uy.z, e), t.orientationX.linearRampToValueAtTime(uA.x, e), t.orientationY.linearRampToValueAtTime(uA.y, e), t.orientationZ.linearRampToValueAtTime(uA.z, e) } else t.setPosition(uy.x, uy.y, uy.z), t.setOrientation(uA.x, uA.y, uA.z) } } class uE { constructor(e, t = 2048) { this.analyser = e.context.createAnalyser(), this.analyser.fftSize = t, this.data = new Uint8Array(this.analyser.frequencyBinCount), e.getOutput().connect(this.analyser) } getFrequencyData() { return this.analyser.getByteFrequencyData(this.data), this.data } getAverageFrequency() { let e = 0, t = this.getFrequencyData(); for (let i = 0; i < t.length; i++)e += t[i]; return e / t.length } } class ub { constructor(e, t, i) { let r, n, s; switch (this.binding = e, this.valueSize = i, t) { case "quaternion": r = this._slerp, n = this._slerpAdditive, s = this._setAdditiveIdentityQuaternion, this.buffer = new Float64Array(6 * i), this._workIndex = 5; break; case "string": case "bool": r = this._select, n = this._select, s = this._setAdditiveIdentityOther, this.buffer = Array(5 * i); break; default: r = this._lerp, n = this._lerpAdditive, s = this._setAdditiveIdentityNumeric, this.buffer = new Float64Array(5 * i) }this._mixBufferRegion = r, this._mixBufferRegionAdditive = n, this._setIdentity = s, this._origIndex = 3, this._addIndex = 4, this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, this.useCount = 0, this.referenceCount = 0 } accumulate(e, t) { let i = this.buffer, r = this.valueSize, n = e * r + r, s = this.cumulativeWeight; if (0 === s) { for (let e = 0; e !== r; ++e)i[n + e] = i[e]; s = t } else { s += t; let e = t / s; this._mixBufferRegion(i, n, 0, e, r) } this.cumulativeWeight = s } accumulateAdditive(e) { let t = this.buffer, i = this.valueSize, r = i * this._addIndex; 0 === this.cumulativeWeightAdditive && this._setIdentity(), this._mixBufferRegionAdditive(t, r, 0, e, i), this.cumulativeWeightAdditive += e } apply(e) { let t = this.valueSize, i = this.buffer, r = e * t + t, n = this.cumulativeWeight, s = this.cumulativeWeightAdditive, a = this.binding; if (this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, n < 1) { let e = t * this._origIndex; this._mixBufferRegion(i, r, e, 1 - n, t) } s > 0 && this._mixBufferRegionAdditive(i, r, this._addIndex * t, 1, t); for (let e = t, n = t + t; e !== n; ++e)if (i[e] !== i[e + t]) { a.setValue(i, r); break } } saveOriginalState() { let e = this.binding, t = this.buffer, i = this.valueSize, r = i * this._origIndex; e.getValue(t, r); for (let e = i; e !== r; ++e)t[e] = t[r + e % i]; this._setIdentity(), this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0 } restoreOriginalState() { let e = 3 * this.valueSize; this.binding.setValue(this.buffer, e) } _setAdditiveIdentityNumeric() { let e = this._addIndex * this.valueSize, t = e + this.valueSize; for (let i = e; i < t; i++)this.buffer[i] = 0 } _setAdditiveIdentityQuaternion() { this._setAdditiveIdentityNumeric(), this.buffer[this._addIndex * this.valueSize + 3] = 1 } _setAdditiveIdentityOther() { let e = this._origIndex * this.valueSize, t = this._addIndex * this.valueSize; for (let i = 0; i < this.valueSize; i++)this.buffer[t + i] = this.buffer[e + i] } _select(e, t, i, r, n) { if (r >= .5) for (let r = 0; r !== n; ++r)e[t + r] = e[i + r] } _slerp(e, t, i, r) { ro.slerpFlat(e, t, e, t, e, i, r) } _slerpAdditive(e, t, i, r, n) { let s = this._workIndex * n; ro.multiplyQuaternionsFlat(e, s, e, t, e, i), ro.slerpFlat(e, t, e, t, e, s, r) } _lerp(e, t, i, r, n) { let s = 1 - r; for (let a = 0; a !== n; ++a) { let n = t + a; e[n] = e[n] * s + e[i + a] * r } } _lerpAdditive(e, t, i, r, n) { for (let s = 0; s !== n; ++s) { let n = t + s; e[n] = e[n] + e[i + s] * r } } } let uT = "\\[\\]\\.:\\/", uw = RegExp("[" + uT + "]", "g"), uM = "[^" + uT + "]", uR = "[^" + uT.replace("\\.", "") + "]", uC = /((?:WC+[\/:])*)/.source.replace("WC", uM), uI = RegExp("^" + uC + /(WCOD+)?/.source.replace("WCOD", uR) + /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", uM) + /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", uM) + "$"), uL = ["material", "materials", "bones", "map"]; class uP { constructor(e, t, i) { let r = i || uD.parseTrackName(t); this._targetGroup = e, this._bindings = e.subscribe_(t, r) } getValue(e, t) { this.bind(); let i = this._targetGroup.nCachedObjects_, r = this._bindings[i]; void 0 !== r && r.getValue(e, t) } setValue(e, t) { let i = this._bindings; for (let r = this._targetGroup.nCachedObjects_, n = i.length; r !== n; ++r)i[r].setValue(e, t) } bind() { let e = this._bindings; for (let t = this._targetGroup.nCachedObjects_, i = e.length; t !== i; ++t)e[t].bind() } unbind() { let e = this._bindings; for (let t = this._targetGroup.nCachedObjects_, i = e.length; t !== i; ++t)e[t].unbind() } } class uD { constructor(e, t, i) { this.path = t, this.parsedPath = i || uD.parseTrackName(t), this.node = uD.findNode(e, this.parsedPath.nodeName), this.rootNode = e, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound } static create(e, t, i) { return e && e.isAnimationObjectGroup ? new uD.Composite(e, t, i) : new uD(e, t, i) } static sanitizeNodeName(e) { return e.replace(/\s/g, "_").replace(uw, "") } static parseTrackName(e) { let t = uI.exec(e); if (null === t) throw Error("PropertyBinding: Cannot parse trackName: " + e); let i = { nodeName: t[2], objectName: t[3], objectIndex: t[4], propertyName: t[5], propertyIndex: t[6] }, r = i.nodeName && i.nodeName.lastIndexOf("."); if (void 0 !== r && -1 !== r) { let e = i.nodeName.substring(r + 1); -1 !== uL.indexOf(e) && (i.nodeName = i.nodeName.substring(0, r), i.objectName = e) } if (null === i.propertyName || 0 === i.propertyName.length) throw Error("PropertyBinding: can not parse propertyName from trackName: " + e); return i } static findNode(e, t) { if (void 0 === t || "" === t || "." === t || -1 === t || t === e.name || t === e.uuid) return e; if (e.skeleton) { let i = e.skeleton.getBoneByName(t); if (void 0 !== i) return i } if (e.children) { let i = function (e) { for (let r = 0; r < e.length; r++) { let n = e[r]; if (n.name === t || n.uuid === t) return n; let s = i(n.children); if (s) return s } return null }, r = i(e.children); if (r) return r } return null } _getValue_unavailable() { } _setValue_unavailable() { } _getValue_direct(e, t) { e[t] = this.targetObject[this.propertyName] } _getValue_array(e, t) { let i = this.resolvedProperty; for (let r = 0, n = i.length; r !== n; ++r)e[t++] = i[r] } _getValue_arrayElement(e, t) { e[t] = this.resolvedProperty[this.propertyIndex] } _getValue_toArray(e, t) { this.resolvedProperty.toArray(e, t) } _setValue_direct(e, t) { this.targetObject[this.propertyName] = e[t] } _setValue_direct_setNeedsUpdate(e, t) { this.targetObject[this.propertyName] = e[t], this.targetObject.needsUpdate = !0 } _setValue_direct_setMatrixWorldNeedsUpdate(e, t) { this.targetObject[this.propertyName] = e[t], this.targetObject.matrixWorldNeedsUpdate = !0 } _setValue_array(e, t) { let i = this.resolvedProperty; for (let r = 0, n = i.length; r !== n; ++r)i[r] = e[t++] } _setValue_array_setNeedsUpdate(e, t) { let i = this.resolvedProperty; for (let r = 0, n = i.length; r !== n; ++r)i[r] = e[t++]; this.targetObject.needsUpdate = !0 } _setValue_array_setMatrixWorldNeedsUpdate(e, t) { let i = this.resolvedProperty; for (let r = 0, n = i.length; r !== n; ++r)i[r] = e[t++]; this.targetObject.matrixWorldNeedsUpdate = !0 } _setValue_arrayElement(e, t) { this.resolvedProperty[this.propertyIndex] = e[t] } _setValue_arrayElement_setNeedsUpdate(e, t) { this.resolvedProperty[this.propertyIndex] = e[t], this.targetObject.needsUpdate = !0 } _setValue_arrayElement_setMatrixWorldNeedsUpdate(e, t) { this.resolvedProperty[this.propertyIndex] = e[t], this.targetObject.matrixWorldNeedsUpdate = !0 } _setValue_fromArray(e, t) { this.resolvedProperty.fromArray(e, t) } _setValue_fromArray_setNeedsUpdate(e, t) { this.resolvedProperty.fromArray(e, t), this.targetObject.needsUpdate = !0 } _setValue_fromArray_setMatrixWorldNeedsUpdate(e, t) { this.resolvedProperty.fromArray(e, t), this.targetObject.matrixWorldNeedsUpdate = !0 } _getValue_unbound(e, t) { this.bind(), this.getValue(e, t) } _setValue_unbound(e, t) { this.bind(), this.setValue(e, t) } bind() { let e = this.node, t = this.parsedPath, i = t.objectName, r = t.propertyName, n = t.propertyIndex; if (e || (e = uD.findNode(this.rootNode, t.nodeName), this.node = e), this.getValue = this._getValue_unavailable, this.setValue = this._setValue_unavailable, !e) { console.warn("THREE.PropertyBinding: No target node found for track: " + this.path + "."); return } if (i) { let r = t.objectIndex; switch (i) { case "materials": if (!e.material) { console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this); return } if (!e.material.materials) { console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this); return } e = e.material.materials; break; case "bones": if (!e.skeleton) { console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this); return } e = e.skeleton.bones; for (let t = 0; t < e.length; t++)if (e[t].name === r) { r = t; break } break; case "map": if ("map" in e) { e = e.map; break } if (!e.material) { console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this); return } if (!e.material.map) { console.error("THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.", this); return } e = e.material.map; break; default: if (void 0 === e[i]) { console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this); return } e = e[i] }if (void 0 !== r) { if (void 0 === e[r]) { console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, e); return } e = e[r] } } let s = e[r]; if (void 0 === s) { console.error("THREE.PropertyBinding: Trying to update property for track: " + t.nodeName + "." + r + " but it wasn't found.", e); return } let a = this.Versioning.None; this.targetObject = e, !0 === e.isMaterial ? a = this.Versioning.NeedsUpdate : !0 === e.isObject3D && (a = this.Versioning.MatrixWorldNeedsUpdate); let o = this.BindingType.Direct; if (void 0 !== n) { if ("morphTargetInfluences" === r) { if (!e.geometry) { console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this); return } if (!e.geometry.morphAttributes) { console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this); return } void 0 !== e.morphTargetDictionary[n] && (n = e.morphTargetDictionary[n]) } o = this.BindingType.ArrayElement, this.resolvedProperty = s, this.propertyIndex = n } else void 0 !== s.fromArray && void 0 !== s.toArray ? (o = this.BindingType.HasFromToArray, this.resolvedProperty = s) : Array.isArray(s) ? (o = this.BindingType.EntireArray, this.resolvedProperty = s) : this.propertyName = r; this.getValue = this.GetterByBindingType[o], this.setValue = this.SetterByBindingTypeAndVersioning[o][a] } unbind() { this.node = null, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound } } uD.Composite = uP, uD.prototype.BindingType = { Direct: 0, EntireArray: 1, ArrayElement: 2, HasFromToArray: 3 }, uD.prototype.Versioning = { None: 0, NeedsUpdate: 1, MatrixWorldNeedsUpdate: 2 }, uD.prototype.GetterByBindingType = [uD.prototype._getValue_direct, uD.prototype._getValue_array, uD.prototype._getValue_arrayElement, uD.prototype._getValue_toArray], uD.prototype.SetterByBindingTypeAndVersioning = [[uD.prototype._setValue_direct, uD.prototype._setValue_direct_setNeedsUpdate, uD.prototype._setValue_direct_setMatrixWorldNeedsUpdate], [uD.prototype._setValue_array, uD.prototype._setValue_array_setNeedsUpdate, uD.prototype._setValue_array_setMatrixWorldNeedsUpdate], [uD.prototype._setValue_arrayElement, uD.prototype._setValue_arrayElement_setNeedsUpdate, uD.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate], [uD.prototype._setValue_fromArray, uD.prototype._setValue_fromArray_setNeedsUpdate, uD.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]]; class uO { constructor() { this.isAnimationObjectGroup = !0, this.uuid = iD(), this._objects = Array.prototype.slice.call(arguments), this.nCachedObjects_ = 0; let e = {}; this._indicesByUUID = e; for (let t = 0, i = arguments.length; t !== i; ++t)e[arguments[t].uuid] = t; this._paths = [], this._parsedPaths = [], this._bindings = [], this._bindingsIndicesByPath = {}; let t = this; this.stats = { objects: { get total() { return t._objects.length }, get inUse() { return this.total - t.nCachedObjects_ } }, get bindingsPerObject() { return t._bindings.length } } } add() { let e = this._objects, t = this._indicesByUUID, i = this._paths, r = this._parsedPaths, n = this._bindings, s = n.length, a, o = e.length, l = this.nCachedObjects_; for (let u = 0, h = arguments.length; u !== h; ++u) { let h = arguments[u], c = h.uuid, d = t[c]; if (void 0 === d) { d = o++, t[c] = d, e.push(h); for (let e = 0; e !== s; ++e)n[e].push(new uD(h, i[e], r[e])) } else if (d < l) { a = e[d]; let o = --l, u = e[o]; t[u.uuid] = d, e[d] = u, t[c] = o, e[o] = h; for (let e = 0; e !== s; ++e) { let t = n[e], s = t[o], a = t[d]; t[d] = s, void 0 === a && (a = new uD(h, i[e], r[e])), t[o] = a } } else e[d] !== a && console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.") } this.nCachedObjects_ = l } remove() { let e = this._objects, t = this._indicesByUUID, i = this._bindings, r = i.length, n = this.nCachedObjects_; for (let s = 0, a = arguments.length; s !== a; ++s) { let a = arguments[s], o = a.uuid, l = t[o]; if (void 0 !== l && l >= n) { let s = n++, u = e[s]; t[u.uuid] = l, e[l] = u, t[o] = s, e[s] = a; for (let e = 0; e !== r; ++e) { let t = i[e], r = t[s], n = t[l]; t[l] = r, t[s] = n } } } this.nCachedObjects_ = n } uncache() { let e = this._objects, t = this._indicesByUUID, i = this._bindings, r = i.length, n = this.nCachedObjects_, s = e.length; for (let a = 0, o = arguments.length; a !== o; ++a) { let o = arguments[a], l = o.uuid, u = t[l]; if (void 0 !== u) { if (delete t[l], u < n) { let a = --n, o = e[a], l = --s, h = e[l]; t[o.uuid] = u, e[u] = o, t[h.uuid] = a, e[a] = h, e.pop(); for (let e = 0; e !== r; ++e) { let t = i[e], r = t[a], n = t[l]; t[u] = r, t[a] = n, t.pop() } } else { let n = --s, a = e[n]; n > 0 && (t[a.uuid] = u), e[u] = a, e.pop(); for (let e = 0; e !== r; ++e) { let t = i[e]; t[u] = t[n], t.pop() } } } } this.nCachedObjects_ = n } subscribe_(e, t) { let i = this._bindingsIndicesByPath, r = i[e], n = this._bindings; if (void 0 !== r) return n[r]; let s = this._paths, a = this._parsedPaths, o = this._objects, l = o.length, u = this.nCachedObjects_, h = Array(l); r = n.length, i[e] = r, s.push(e), a.push(t), n.push(h); for (let i = u, r = o.length; i !== r; ++i) { let r = o[i]; h[i] = new uD(r, e, t) } return h } unsubscribe_(e) { let t = this._bindingsIndicesByPath, i = t[e]; if (void 0 !== i) { let r = this._paths, n = this._parsedPaths, s = this._bindings, a = s.length - 1, o = s[a]; t[e[a]] = i, s[i] = o, s.pop(), n[i] = n[a], n.pop(), r[i] = r[a], r.pop() } } } class uk { constructor(e, t, i = null, r = t.blendMode) { this._mixer = e, this._clip = t, this._localRoot = i, this.blendMode = r; let n = t.tracks, s = n.length, a = Array(s), o = { endingStart: tD, endingEnd: tD }; for (let e = 0; e !== s; ++e) { let t = n[e].createInterpolant(null); a[e] = t, t.settings = o } this._interpolantSettings = o, this._interpolants = a, this._propertyBindings = Array(s), this._cacheIndex = null, this._byClipCacheIndex = null, this._timeScaleInterpolant = null, this._weightInterpolant = null, this.loop = tR, this._loopCount = -1, this._startTime = null, this.time = 0, this.timeScale = 1, this._effectiveTimeScale = 1, this.weight = 1, this._effectiveWeight = 1, this.repetitions = 1 / 0, this.paused = !1, this.enabled = !0, this.clampWhenFinished = !1, this.zeroSlopeAtStart = !0, this.zeroSlopeAtEnd = !0 } play() { return this._mixer._activateAction(this), this } stop() { return this._mixer._deactivateAction(this), this.reset() } reset() { return this.paused = !1, this.enabled = !0, this.time = 0, this._loopCount = -1, this._startTime = null, this.stopFading().stopWarping() } isRunning() { return this.enabled && !this.paused && 0 !== this.timeScale && null === this._startTime && this._mixer._isActiveAction(this) } isScheduled() { return this._mixer._isActiveAction(this) } startAt(e) { return this._startTime = e, this } setLoop(e, t) { return this.loop = e, this.repetitions = t, this } setEffectiveWeight(e) { return this.weight = e, this._effectiveWeight = this.enabled ? e : 0, this.stopFading() } getEffectiveWeight() { return this._effectiveWeight } fadeIn(e) { return this._scheduleFading(e, 0, 1) } fadeOut(e) { return this._scheduleFading(e, 1, 0) } crossFadeFrom(e, t, i) { if (e.fadeOut(t), this.fadeIn(t), i) { let i = this._clip.duration, r = e._clip.duration; e.warp(1, r / i, t), this.warp(i / r, 1, t) } return this } crossFadeTo(e, t, i) { return e.crossFadeFrom(this, t, i) } stopFading() { let e = this._weightInterpolant; return null !== e && (this._weightInterpolant = null, this._mixer._takeBackControlInterpolant(e)), this } setEffectiveTimeScale(e) { return this.timeScale = e, this._effectiveTimeScale = this.paused ? 0 : e, this.stopWarping() } getEffectiveTimeScale() { return this._effectiveTimeScale } setDuration(e) { return this.timeScale = this._clip.duration / e, this.stopWarping() } syncWith(e) { return this.time = e.time, this.timeScale = e.timeScale, this.stopWarping() } halt(e) { return this.warp(this._effectiveTimeScale, 0, e) } warp(e, t, i) { let r = this._mixer, n = r.time, s = this.timeScale, a = this._timeScaleInterpolant; null === a && (a = r._lendControlInterpolant(), this._timeScaleInterpolant = a); let o = a.parameterPositions, l = a.sampleValues; return o[0] = n, o[1] = n + i, l[0] = e / s, l[1] = t / s, this } stopWarping() { let e = this._timeScaleInterpolant; return null !== e && (this._timeScaleInterpolant = null, this._mixer._takeBackControlInterpolant(e)), this } getMixer() { return this._mixer } getClip() { return this._clip } getRoot() { return this._localRoot || this._mixer._root } _update(e, t, i, r) { if (!this.enabled) { this._updateWeight(e); return } let n = this._startTime; if (null !== n) { let r = (e - n) * i; r < 0 || 0 === i ? t = 0 : (this._startTime = null, t = i * r) } t *= this._updateTimeScale(e); let s = this._updateTime(t), a = this._updateWeight(e); if (a > 0) { let e = this._interpolants, t = this._propertyBindings; if (this.blendMode === tU) for (let i = 0, r = e.length; i !== r; ++i)e[i].evaluate(s), t[i].accumulateAdditive(a); else for (let i = 0, n = e.length; i !== n; ++i)e[i].evaluate(s), t[i].accumulate(r, a) } } _updateWeight(e) { let t = 0; if (this.enabled) { t = this.weight; let i = this._weightInterpolant; if (null !== i) { let r = i.evaluate(e)[0]; t *= r, e > i.parameterPositions[1] && (this.stopFading(), 0 === r && (this.enabled = !1)) } } return this._effectiveWeight = t, t } _updateTimeScale(e) { let t = 0; if (!this.paused) { t = this.timeScale; let i = this._timeScaleInterpolant; null !== i && (t *= i.evaluate(e)[0], e > i.parameterPositions[1] && (this.stopWarping(), 0 === t ? this.paused = !0 : this.timeScale = t)) } return this._effectiveTimeScale = t, t } _updateTime(e) { let t = this._clip.duration, i = this.loop, r = this.time + e, n = this._loopCount, s = i === tC; if (0 === e) return -1 === n ? r : s && (1 & n) == 1 ? t - r : r; if (i === tM) { -1 === n && (this._loopCount = 0, this._setEndings(!0, !0, !1)); a: { if (r >= t) r = t; else if (r < 0) r = 0; else { this.time = r; break a } this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, this.time = r, this._mixer.dispatchEvent({ type: "finished", action: this, direction: e < 0 ? -1 : 1 }) } } else { if (-1 === n && (e >= 0 ? (n = 0, this._setEndings(!0, 0 === this.repetitions, s)) : this._setEndings(0 === this.repetitions, !0, s)), r >= t || r < 0) { let i = Math.floor(r / t); r -= t * i, n += Math.abs(i); let a = this.repetitions - n; if (a <= 0) this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, r = e > 0 ? t : 0, this.time = r, this._mixer.dispatchEvent({ type: "finished", action: this, direction: e > 0 ? 1 : -1 }); else { if (1 === a) { let t = e < 0; this._setEndings(t, !t, s) } else this._setEndings(!1, !1, s); this._loopCount = n, this.time = r, this._mixer.dispatchEvent({ type: "loop", action: this, loopDelta: i }) } } else this.time = r; if (s && (1 & n) == 1) return t - r } return r } _setEndings(e, t, i) { let r = this._interpolantSettings; i ? (r.endingStart = tO, r.endingEnd = tO) : (e ? r.endingStart = this.zeroSlopeAtStart ? tO : tD : r.endingStart = tk, t ? r.endingEnd = this.zeroSlopeAtEnd ? tO : tD : r.endingEnd = tk) } _scheduleFading(e, t, i) { let r = this._mixer, n = r.time, s = this._weightInterpolant; null === s && (s = r._lendControlInterpolant(), this._weightInterpolant = s); let a = s.parameterPositions, o = s.sampleValues; return a[0] = n, o[0] = t, a[1] = n + e, o[1] = i, this } } let uF = new Float32Array(1); class uU extends iR { constructor(e) { super(), this._root = e, this._initMemoryManager(), this._accuIndex = 0, this.time = 0, this.timeScale = 1 } _bindAction(e, t) { let i = e._localRoot || this._root, r = e._clip.tracks, n = r.length, s = e._propertyBindings, a = e._interpolants, o = i.uuid, l = this._bindingsByRootAndName, u = l[o]; void 0 === u && (u = {}, l[o] = u); for (let e = 0; e !== n; ++e) { let n = r[e], l = n.name, h = u[l]; if (void 0 !== h) ++h.referenceCount, s[e] = h; else { if (void 0 !== (h = s[e])) { null === h._cacheIndex && (++h.referenceCount, this._addInactiveBinding(h, o, l)); continue } let r = t && t._propertyBindings[e].binding.parsedPath; h = new ub(uD.create(i, l, r), n.ValueTypeName, n.getValueSize()), ++h.referenceCount, this._addInactiveBinding(h, o, l), s[e] = h } a[e].resultBuffer = h.buffer } } _activateAction(e) { if (!this._isActiveAction(e)) { if (null === e._cacheIndex) { let t = (e._localRoot || this._root).uuid, i = e._clip.uuid, r = this._actionsByClip[i]; this._bindAction(e, r && r.knownActions[0]), this._addInactiveAction(e, i, t) } let t = e._propertyBindings; for (let e = 0, i = t.length; e !== i; ++e) { let i = t[e]; 0 == i.useCount++ && (this._lendBinding(i), i.saveOriginalState()) } this._lendAction(e) } } _deactivateAction(e) { if (this._isActiveAction(e)) { let t = e._propertyBindings; for (let e = 0, i = t.length; e !== i; ++e) { let i = t[e]; 0 == --i.useCount && (i.restoreOriginalState(), this._takeBackBinding(i)) } this._takeBackAction(e) } } _initMemoryManager() { this._actions = [], this._nActiveActions = 0, this._actionsByClip = {}, this._bindings = [], this._nActiveBindings = 0, this._bindingsByRootAndName = {}, this._controlInterpolants = [], this._nActiveControlInterpolants = 0; let e = this; this.stats = { actions: { get total() { return e._actions.length }, get inUse() { return e._nActiveActions } }, bindings: { get total() { return e._bindings.length }, get inUse() { return e._nActiveBindings } }, controlInterpolants: { get total() { return e._controlInterpolants.length }, get inUse() { return e._nActiveControlInterpolants } } } } _isActiveAction(e) { let t = e._cacheIndex; return null !== t && t < this._nActiveActions } _addInactiveAction(e, t, i) { let r = this._actions, n = this._actionsByClip, s = n[t]; if (void 0 === s) s = { knownActions: [e], actionByRoot: {} }, e._byClipCacheIndex = 0, n[t] = s; else { let t = s.knownActions; e._byClipCacheIndex = t.length, t.push(e) } e._cacheIndex = r.length, r.push(e), s.actionByRoot[i] = e } _removeInactiveAction(e) { let t = this._actions, i = t[t.length - 1], r = e._cacheIndex; i._cacheIndex = r, t[r] = i, t.pop(), e._cacheIndex = null; let n = e._clip.uuid, s = this._actionsByClip, a = s[n], o = a.knownActions, l = o[o.length - 1], u = e._byClipCacheIndex; l._byClipCacheIndex = u, o[u] = l, o.pop(), e._byClipCacheIndex = null; let h = a.actionByRoot, c = (e._localRoot || this._root).uuid; delete h[c], 0 === o.length && delete s[n], this._removeInactiveBindingsForAction(e) } _removeInactiveBindingsForAction(e) { let t = e._propertyBindings; for (let e = 0, i = t.length; e !== i; ++e) { let i = t[e]; 0 == --i.referenceCount && this._removeInactiveBinding(i) } } _lendAction(e) { let t = this._actions, i = e._cacheIndex, r = this._nActiveActions++, n = t[r]; e._cacheIndex = r, t[r] = e, n._cacheIndex = i, t[i] = n } _takeBackAction(e) { let t = this._actions, i = e._cacheIndex, r = --this._nActiveActions, n = t[r]; e._cacheIndex = r, t[r] = e, n._cacheIndex = i, t[i] = n } _addInactiveBinding(e, t, i) { let r = this._bindingsByRootAndName, n = this._bindings, s = r[t]; void 0 === s && (s = {}, r[t] = s), s[i] = e, e._cacheIndex = n.length, n.push(e) } _removeInactiveBinding(e) { let t = this._bindings, i = e.binding, r = i.rootNode.uuid, n = i.path, s = this._bindingsByRootAndName, a = s[r], o = t[t.length - 1], l = e._cacheIndex; o._cacheIndex = l, t[l] = o, t.pop(), delete a[n], 0 === Object.keys(a).length && delete s[r] } _lendBinding(e) { let t = this._bindings, i = e._cacheIndex, r = this._nActiveBindings++, n = t[r]; e._cacheIndex = r, t[r] = e, n._cacheIndex = i, t[i] = n } _takeBackBinding(e) { let t = this._bindings, i = e._cacheIndex, r = --this._nActiveBindings, n = t[r]; e._cacheIndex = r, t[r] = e, n._cacheIndex = i, t[i] = n } _lendControlInterpolant() { let e = this._controlInterpolants, t = this._nActiveControlInterpolants++, i = e[t]; return void 0 === i && ((i = new lp(new Float32Array(2), new Float32Array(2), 1, uF)).__cacheIndex = t, e[t] = i), i } _takeBackControlInterpolant(e) { let t = this._controlInterpolants, i = e.__cacheIndex, r = --this._nActiveControlInterpolants, n = t[r]; e.__cacheIndex = r, t[r] = e, n.__cacheIndex = i, t[i] = n } clipAction(e, t, i) { let r = t || this._root, n = r.uuid, s = "string" == typeof e ? lb.findByName(r, e) : e, a = null !== s ? s.uuid : e, o = this._actionsByClip[a], l = null; if (void 0 === i && (i = null !== s ? s.blendMode : tF), void 0 !== o) { let e = o.actionByRoot[n]; if (void 0 !== e && e.blendMode === i) return e; l = o.knownActions[0], null === s && (s = l._clip) } if (null === s) return null; let u = new uk(this, s, t, i); return this._bindAction(u, l), this._addInactiveAction(u, a, n), u } existingAction(e, t) { let i = t || this._root, r = i.uuid, n = "string" == typeof e ? lb.findByName(i, e) : e, s = n ? n.uuid : e, a = this._actionsByClip[s]; return void 0 !== a && a.actionByRoot[r] || null } stopAllAction() { let e = this._actions, t = this._nActiveActions; for (let i = t - 1; i >= 0; --i)e[i].stop(); return this } update(e) { e *= this.timeScale; let t = this._actions, i = this._nActiveActions, r = this.time += e, n = Math.sign(e), s = this._accuIndex ^= 1; for (let a = 0; a !== i; ++a)t[a]._update(r, e, n, s); let a = this._bindings, o = this._nActiveBindings; for (let e = 0; e !== o; ++e)a[e].apply(s); return this } setTime(e) { this.time = 0; for (let e = 0; e < this._actions.length; e++)this._actions[e].time = 0; return this.update(e) } getRoot() { return this._root } uncacheClip(e) { let t = this._actions, i = e.uuid, r = this._actionsByClip, n = r[i]; if (void 0 !== n) { let e = n.knownActions; for (let i = 0, r = e.length; i !== r; ++i) { let r = e[i]; this._deactivateAction(r); let n = r._cacheIndex, s = t[t.length - 1]; r._cacheIndex = null, r._byClipCacheIndex = null, s._cacheIndex = n, t[n] = s, t.pop(), this._removeInactiveBindingsForAction(r) } delete r[i] } } uncacheRoot(e) { let t = e.uuid, i = this._actionsByClip; for (let e in i) { let r = i[e].actionByRoot[t]; void 0 !== r && (this._deactivateAction(r), this._removeInactiveAction(r)) } let r = this._bindingsByRootAndName[t]; if (void 0 !== r) for (let e in r) { let t = r[e]; t.restoreOriginalState(), this._removeInactiveBinding(t) } } uncacheAction(e, t) { let i = this.existingAction(e, t); null !== i && (this._deactivateAction(i), this._removeInactiveAction(i)) } } class uN extends rt { constructor(e = 1, t = 1, i = 1, r = {}) { super(e, t, r), this.isRenderTarget3D = !0, this.depth = i, this.texture = new rs(null, e, t, i), this.texture.isRenderTargetTexture = !0 } } class uB extends rt { constructor(e = 1, t = 1, i = 1, r = {}) { super(e, t, r), this.isRenderTargetArray = !0, this.depth = i, this.texture = new rr(null, e, t, i), this.texture.isRenderTargetTexture = !0 } } class uz { constructor(e) { this.value = e } clone() { return new uz(void 0 === this.value.clone ? this.value : this.value.clone()) } } let uG = 0; class uH extends iR { constructor() { super(), this.isUniformsGroup = !0, Object.defineProperty(this, "id", { value: uG++ }), this.name = "", this.usage = ip, this.uniforms = [] } add(e) { return this.uniforms.push(e), this } remove(e) { let t = this.uniforms.indexOf(e); return -1 !== t && this.uniforms.splice(t, 1), this } setName(e) { return this.name = e, this } setUsage(e) { return this.usage = e, this } dispose() { return this.dispatchEvent({ type: "dispose" }), this } copy(e) { this.name = e.name, this.usage = e.usage; let t = e.uniforms; this.uniforms.length = 0; for (let e = 0, i = t.length; e < i; e++) { let i = Array.isArray(t[e]) ? t[e] : [t[e]]; for (let e = 0; e < i.length; e++)this.uniforms.push(i[e].clone()) } return this } clone() { return new this.constructor().copy(this) } } class uV extends sx { constructor(e, t, i = 1) { super(e, t), this.isInstancedInterleavedBuffer = !0, this.meshPerAttribute = i } copy(e) { return super.copy(e), this.meshPerAttribute = e.meshPerAttribute, this } clone(e) { let t = super.clone(e); return t.meshPerAttribute = this.meshPerAttribute, t } toJSON(e) { let t = super.toJSON(e); return t.isInstancedInterleavedBuffer = !0, t.meshPerAttribute = this.meshPerAttribute, t } } class uW { constructor(e, t, i, r, n) { this.isGLBufferAttribute = !0, this.name = "", this.buffer = e, this.type = t, this.itemSize = i, this.elementSize = r, this.count = n, this.version = 0 } set needsUpdate(e) { !0 === e && this.version++ } setBuffer(e) { return this.buffer = e, this } setType(e, t) { return this.type = e, this.elementSize = t, this } setItemSize(e) { return this.itemSize = e, this } setCount(e) { return this.count = e, this } } let uj = new rN; class uY { constructor(e, t, i = 0, r = 1 / 0) { this.ray = new rU(e, t), this.near = i, this.far = r, this.camera = null, this.layers = new rq, this.params = { Mesh: {}, Line: { threshold: 1 }, LOD: {}, Points: { threshold: 1 }, Sprite: {} } } set(e, t) { this.ray.set(e, t) } setFromCamera(e, t) { t.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(t.matrixWorld), this.ray.direction.set(e.x, e.y, .5).unproject(t).sub(this.ray.origin).normalize(), this.camera = t) : t.isOrthographicCamera ? (this.ray.origin.set(e.x, e.y, (t.near + t.far) / (t.near - t.far)).unproject(t), this.ray.direction.set(0, 0, -1).transformDirection(t.matrixWorld), this.camera = t) : console.error("THREE.Raycaster: Unsupported camera type: " + t.type) } setFromXRController(e) { return uj.identity().extractRotation(e.matrixWorld), this.ray.origin.setFromMatrixPosition(e.matrixWorld), this.ray.direction.set(0, 0, -1).applyMatrix4(uj), this } intersectObject(e, t = !0, i = []) { return uK(e, this, i, t), i.sort(uX), i } intersectObjects(e, t = !0, i = []) { for (let r = 0, n = e.length; r < n; r++)uK(e[r], this, i, t); return i.sort(uX), i } } function uX(e, t) { return e.distance - t.distance } function uK(e, t, i, r) { let n = !0; if (e.layers.test(t.layers) && !1 === e.raycast(t, i) && (n = !1), !0 === n && !0 === r) { let r = e.children; for (let e = 0, n = r.length; e < n; e++)uK(r[e], t, i, !0) } } class uq { constructor(e = 1, t = 0, i = 0) { this.radius = e, this.phi = t, this.theta = i } set(e, t, i) { return this.radius = e, this.phi = t, this.theta = i, this } copy(e) { return this.radius = e.radius, this.phi = e.phi, this.theta = e.theta, this } makeSafe() { return this.phi = iO(this.phi, 1e-6, Math.PI - 1e-6), this } setFromVector3(e) { return this.setFromCartesianCoords(e.x, e.y, e.z) } setFromCartesianCoords(e, t, i) { return this.radius = Math.sqrt(e * e + t * t + i * i), 0 === this.radius ? (this.theta = 0, this.phi = 0) : (this.theta = Math.atan2(e, i), this.phi = Math.acos(iO(t / this.radius, -1, 1))), this } clone() { return new this.constructor().copy(this) } } class uQ { constructor(e = 1, t = 0, i = 0) { this.radius = e, this.theta = t, this.y = i } set(e, t, i) { return this.radius = e, this.theta = t, this.y = i, this } copy(e) { return this.radius = e.radius, this.theta = e.theta, this.y = e.y, this } setFromVector3(e) { return this.setFromCartesianCoords(e.x, e.y, e.z) } setFromCartesianCoords(e, t, i) { return this.radius = Math.sqrt(e * e + i * i), this.theta = Math.atan2(e, i), this.y = t, this } clone() { return new this.constructor().copy(this) } } class uZ { constructor(e, t, i, r) { uZ.prototype.isMatrix2 = !0, this.elements = [1, 0, 0, 1], void 0 !== e && this.set(e, t, i, r) } identity() { return this.set(1, 0, 0, 1), this } fromArray(e, t = 0) { for (let i = 0; i < 4; i++)this.elements[i] = e[i + t]; return this } set(e, t, i, r) { let n = this.elements; return n[0] = e, n[2] = t, n[1] = i, n[3] = r, this } } let u$ = new iz; class uJ { constructor(e = new iz(Infinity, Infinity), t = new iz(-1 / 0, -1 / 0)) { this.isBox2 = !0, this.min = e, this.max = t } set(e, t) { return this.min.copy(e), this.max.copy(t), this } setFromPoints(e) { this.makeEmpty(); for (let t = 0, i = e.length; t < i; t++)this.expandByPoint(e[t]); return this } setFromCenterAndSize(e, t) { let i = u$.copy(t).multiplyScalar(.5); return this.min.copy(e).sub(i), this.max.copy(e).add(i), this } clone() { return new this.constructor().copy(this) } copy(e) { return this.min.copy(e.min), this.max.copy(e.max), this } makeEmpty() { return this.min.x = this.min.y = Infinity, this.max.x = this.max.y = -1 / 0, this } isEmpty() { return this.max.x < this.min.x || this.max.y < this.min.y } getCenter(e) { return this.isEmpty() ? e.set(0, 0) : e.addVectors(this.min, this.max).multiplyScalar(.5) } getSize(e) { return this.isEmpty() ? e.set(0, 0) : e.subVectors(this.max, this.min) } expandByPoint(e) { return this.min.min(e), this.max.max(e), this } expandByVector(e) { return this.min.sub(e), this.max.add(e), this } expandByScalar(e) { return this.min.addScalar(-e), this.max.addScalar(e), this } containsPoint(e) { return e.x >= this.min.x && e.x <= this.max.x && e.y >= this.min.y && e.y <= this.max.y } containsBox(e) { return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y } getParameter(e, t) { return t.set((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y)) } intersectsBox(e) { return e.max.x >= this.min.x && e.min.x <= this.max.x && e.max.y >= this.min.y && e.min.y <= this.max.y } clampPoint(e, t) { return t.copy(e).clamp(this.min, this.max) } distanceToPoint(e) { return this.clampPoint(e, u$).distanceTo(e) } intersect(e) { return this.min.max(e.min), this.max.min(e.max), this.isEmpty() && this.makeEmpty(), this } union(e) { return this.min.min(e.min), this.max.max(e.max), this } translate(e) { return this.min.add(e), this.max.add(e), this } equals(e) { return e.min.equals(this.min) && e.max.equals(this.max) } } let u0 = new rl, u1 = new rl; class u2 { constructor(e = new rl, t = new rl) { this.start = e, this.end = t } set(e, t) { return this.start.copy(e), this.end.copy(t), this } copy(e) { return this.start.copy(e.start), this.end.copy(e.end), this } getCenter(e) { return e.addVectors(this.start, this.end).multiplyScalar(.5) } delta(e) { return e.subVectors(this.end, this.start) } distanceSq() { return this.start.distanceToSquared(this.end) } distance() { return this.start.distanceTo(this.end) } at(e, t) { return this.delta(t).multiplyScalar(e).add(this.start) } closestPointToPointParameter(e, t) { u0.subVectors(e, this.start), u1.subVectors(this.end, this.start); let i = u1.dot(u1), r = u1.dot(u0) / i; return t && (r = iO(r, 0, 1)), r } closestPointToPoint(e, t, i) { let r = this.closestPointToPointParameter(e, t); return this.delta(i).multiplyScalar(r).add(this.start) } applyMatrix4(e) { return this.start.applyMatrix4(e), this.end.applyMatrix4(e), this } equals(e) { return e.start.equals(this.start) && e.end.equals(this.end) } clone() { return new this.constructor().copy(this) } } let u3 = new rl; class u4 extends nt { constructor(e, t) { super(), this.light = e, this.matrixAutoUpdate = !1, this.color = t, this.type = "SpotLightHelper"; let i = new nq, r = [0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, -1, 1]; for (let e = 0, t = 1; e < 32; e++, t++) { let i = e / 32 * Math.PI * 2, n = t / 32 * Math.PI * 2; r.push(Math.cos(i), Math.sin(i), 1, Math.cos(n), Math.sin(n), 1) } i.setAttribute("position", new nG(r, 3)); let n = new ab({ fog: !1, toneMapped: !1 }); this.cone = new aF(i, n), this.add(this.cone), this.update() } dispose() { this.cone.geometry.dispose(), this.cone.material.dispose() } update() { this.light.updateWorldMatrix(!0, !1), this.light.target.updateWorldMatrix(!0, !1), this.parent ? (this.parent.updateWorldMatrix(!0), this.matrix.copy(this.parent.matrixWorld).invert().multiply(this.light.matrixWorld)) : this.matrix.copy(this.light.matrixWorld), this.matrixWorld.copy(this.light.matrixWorld); let e = this.light.distance ? this.light.distance : 1e3, t = e * Math.tan(this.light.angle); this.cone.scale.set(t, t, e), u3.setFromMatrixPosition(this.light.target.matrixWorld), this.cone.lookAt(u3), void 0 !== this.color ? this.cone.material.color.set(this.color) : this.cone.material.color.copy(this.light.color) } } let u5 = new rl, u8 = new rN, u6 = new rN; class u9 extends aF { constructor(e) { let t = function e(t) { let i = []; !0 === t.isBone && i.push(t); for (let r = 0; r < t.children.length; r++)i.push(...e(t.children[r])); return i }(e), i = new nq, r = [], n = [], s = new nS(0, 0, 1), a = new nS(0, 1, 0); for (let e = 0; e < t.length; e++) { let i = t[e]; i.parent && i.parent.isBone && (r.push(0, 0, 0), r.push(0, 0, 0), n.push(s.r, s.g, s.b), n.push(a.r, a.g, a.b)) } i.setAttribute("position", new nG(r, 3)), i.setAttribute("color", new nG(n, 3)), super(i, new ab({ vertexColors: !0, depthTest: !1, depthWrite: !1, toneMapped: !1, transparent: !0 })), this.isSkeletonHelper = !0, this.type = "SkeletonHelper", this.root = e, this.bones = t, this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1 } updateMatrixWorld(e) { let t = this.bones, i = this.geometry, r = i.getAttribute("position"); u6.copy(this.root.matrixWorld).invert(); for (let e = 0, i = 0; e < t.length; e++) { let n = t[e]; n.parent && n.parent.isBone && (u8.multiplyMatrices(u6, n.matrixWorld), u5.setFromMatrixPosition(u8), r.setXYZ(i, u5.x, u5.y, u5.z), u8.multiplyMatrices(u6, n.parent.matrixWorld), u5.setFromMatrixPosition(u8), r.setXYZ(i + 1, u5.x, u5.y, u5.z), i += 2) } i.getAttribute("position").needsUpdate = !0, super.updateMatrixWorld(e) } dispose() { this.geometry.dispose(), this.material.dispose() } } class u7 extends n6 { constructor(e, t, i) { super(new oQ(t, 4, 2), new nb({ wireframe: !0, fog: !1, toneMapped: !1 })), this.light = e, this.color = i, this.type = "PointLightHelper", this.matrix = this.light.matrixWorld, this.matrixAutoUpdate = !1, this.update() } dispose() { this.geometry.dispose(), this.material.dispose() } update() { this.light.updateWorldMatrix(!0, !1), void 0 !== this.color ? this.material.color.set(this.color) : this.material.color.copy(this.light.color) } } let he = new rl, ht = new nS, hi = new nS; class hr extends nt { constructor(e, t, i) { super(), this.light = e, this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.color = i, this.type = "HemisphereLightHelper"; let r = new oY(t); r.rotateY(.5 * Math.PI), this.material = new nb({ wireframe: !0, fog: !1, toneMapped: !1 }), void 0 === this.color && (this.material.vertexColors = !0); let n = new Float32Array(3 * r.getAttribute("position").count); r.setAttribute("color", new nP(n, 3)), this.add(new n6(r, this.material)), this.update() } dispose() { this.children[0].geometry.dispose(), this.children[0].material.dispose() } update() { let e = this.children[0]; if (void 0 !== this.color) this.material.color.set(this.color); else { let t = e.geometry.getAttribute("color"); ht.copy(this.light.color), hi.copy(this.light.groundColor); for (let e = 0, i = t.count; e < i; e++) { let r = e < i / 2 ? ht : hi; t.setXYZ(e, r.r, r.g, r.b) } t.needsUpdate = !0 } this.light.updateWorldMatrix(!0, !1), e.lookAt(he.setFromMatrixPosition(this.light.matrixWorld).negate()) } } class hn extends aF { constructor(e = 10, t = 10, i = 4473924, r = 8947848) { i = new nS(i), r = new nS(r); let n = t / 2, s = e / t, a = e / 2, o = [], l = []; for (let e = 0, u = 0, h = -a; e <= t; e++, h += s) { o.push(-a, 0, h, a, 0, h), o.push(h, 0, -a, h, 0, a); let t = e === n ? i : r; t.toArray(l, u), u += 3, t.toArray(l, u), u += 3, t.toArray(l, u), u += 3, t.toArray(l, u), u += 3 } let u = new nq; u.setAttribute("position", new nG(o, 3)), u.setAttribute("color", new nG(l, 3)), super(u, new ab({ vertexColors: !0, toneMapped: !1 })), this.type = "GridHelper" } dispose() { this.geometry.dispose(), this.material.dispose() } } class hs extends aF { constructor(e = 10, t = 16, i = 8, r = 64, n = 4473924, s = 8947848) { n = new nS(n), s = new nS(s); let a = [], o = []; if (t > 1) for (let i = 0; i < t; i++) { let r = i / t * (2 * Math.PI), l = Math.sin(r) * e, u = Math.cos(r) * e; a.push(0, 0, 0), a.push(l, 0, u); let h = 1 & i ? n : s; o.push(h.r, h.g, h.b), o.push(h.r, h.g, h.b) } for (let t = 0; t < i; t++) { let l = 1 & t ? n : s, u = e - e / i * t; for (let e = 0; e < r; e++) { let t = e / r * (2 * Math.PI), i = Math.sin(t) * u, n = Math.cos(t) * u; a.push(i, 0, n), o.push(l.r, l.g, l.b), i = Math.sin(t = (e + 1) / r * (2 * Math.PI)) * u, n = Math.cos(t) * u, a.push(i, 0, n), o.push(l.r, l.g, l.b) } } let l = new nq; l.setAttribute("position", new nG(a, 3)), l.setAttribute("color", new nG(o, 3)), super(l, new ab({ vertexColors: !0, toneMapped: !1 })), this.type = "PolarGridHelper" } dispose() { this.geometry.dispose(), this.material.dispose() } } let ha = new rl, ho = new rl, hl = new rl; class hu extends nt { constructor(e, t, i) { super(), this.light = e, this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.color = i, this.type = "DirectionalLightHelper", void 0 === t && (t = 1); let r = new nq; r.setAttribute("position", new nG([-t, t, 0, t, t, 0, t, -t, 0, -t, -t, 0, -t, t, 0], 3)); let n = new ab({ fog: !1, toneMapped: !1 }); this.lightPlane = new aP(r, n), this.add(this.lightPlane), (r = new nq).setAttribute("position", new nG([0, 0, 0, 0, 0, 1], 3)), this.targetLine = new aP(r, n), this.add(this.targetLine), this.update() } dispose() { this.lightPlane.geometry.dispose(), this.lightPlane.material.dispose(), this.targetLine.geometry.dispose(), this.targetLine.material.dispose() } update() { this.light.updateWorldMatrix(!0, !1), this.light.target.updateWorldMatrix(!0, !1), ha.setFromMatrixPosition(this.light.matrixWorld), ho.setFromMatrixPosition(this.light.target.matrixWorld), hl.subVectors(ho, ha), this.lightPlane.lookAt(ho), void 0 !== this.color ? (this.lightPlane.material.color.set(this.color), this.targetLine.material.color.set(this.color)) : (this.lightPlane.material.color.copy(this.light.color), this.targetLine.material.color.copy(this.light.color)), this.targetLine.lookAt(ho), this.targetLine.scale.z = hl.length() } } let hh = new rl, hc = new ss; class hd extends aF { constructor(e) { let t = new nq, i = new ab({ color: 0xffffff, vertexColors: !0, toneMapped: !1 }), r = [], n = [], s = {}; function a(e, t) { o(e), o(t) } function o(e) { r.push(0, 0, 0), n.push(0, 0, 0), void 0 === s[e] && (s[e] = []), s[e].push(r.length / 3 - 1) } a("n1", "n2"), a("n2", "n4"), a("n4", "n3"), a("n3", "n1"), a("f1", "f2"), a("f2", "f4"), a("f4", "f3"), a("f3", "f1"), a("n1", "f1"), a("n2", "f2"), a("n3", "f3"), a("n4", "f4"), a("p", "n1"), a("p", "n2"), a("p", "n3"), a("p", "n4"), a("u1", "u2"), a("u2", "u3"), a("u3", "u1"), a("c", "t"), a("p", "c"), a("cn1", "cn2"), a("cn3", "cn4"), a("cf1", "cf2"), a("cf3", "cf4"), t.setAttribute("position", new nG(r, 3)), t.setAttribute("color", new nG(n, 3)), super(t, i), this.type = "CameraHelper", this.camera = e, this.camera.updateProjectionMatrix && this.camera.updateProjectionMatrix(), this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.pointMap = s, this.update(); let l = new nS(0xffaa00), u = new nS(0xff0000), h = new nS(43775), c = new nS(0xffffff), d = new nS(3355443); this.setColors(l, u, h, c, d) } setColors(e, t, i, r, n) { let s = this.geometry.getAttribute("color"); s.setXYZ(0, e.r, e.g, e.b), s.setXYZ(1, e.r, e.g, e.b), s.setXYZ(2, e.r, e.g, e.b), s.setXYZ(3, e.r, e.g, e.b), s.setXYZ(4, e.r, e.g, e.b), s.setXYZ(5, e.r, e.g, e.b), s.setXYZ(6, e.r, e.g, e.b), s.setXYZ(7, e.r, e.g, e.b), s.setXYZ(8, e.r, e.g, e.b), s.setXYZ(9, e.r, e.g, e.b), s.setXYZ(10, e.r, e.g, e.b), s.setXYZ(11, e.r, e.g, e.b), s.setXYZ(12, e.r, e.g, e.b), s.setXYZ(13, e.r, e.g, e.b), s.setXYZ(14, e.r, e.g, e.b), s.setXYZ(15, e.r, e.g, e.b), s.setXYZ(16, e.r, e.g, e.b), s.setXYZ(17, e.r, e.g, e.b), s.setXYZ(18, e.r, e.g, e.b), s.setXYZ(19, e.r, e.g, e.b), s.setXYZ(20, e.r, e.g, e.b), s.setXYZ(21, e.r, e.g, e.b), s.setXYZ(22, e.r, e.g, e.b), s.setXYZ(23, e.r, e.g, e.b), s.setXYZ(24, t.r, t.g, t.b), s.setXYZ(25, t.r, t.g, t.b), s.setXYZ(26, t.r, t.g, t.b), s.setXYZ(27, t.r, t.g, t.b), s.setXYZ(28, t.r, t.g, t.b), s.setXYZ(29, t.r, t.g, t.b), s.setXYZ(30, t.r, t.g, t.b), s.setXYZ(31, t.r, t.g, t.b), s.setXYZ(32, i.r, i.g, i.b), s.setXYZ(33, i.r, i.g, i.b), s.setXYZ(34, i.r, i.g, i.b), s.setXYZ(35, i.r, i.g, i.b), s.setXYZ(36, i.r, i.g, i.b), s.setXYZ(37, i.r, i.g, i.b), s.setXYZ(38, r.r, r.g, r.b), s.setXYZ(39, r.r, r.g, r.b), s.setXYZ(40, n.r, n.g, n.b), s.setXYZ(41, n.r, n.g, n.b), s.setXYZ(42, n.r, n.g, n.b), s.setXYZ(43, n.r, n.g, n.b), s.setXYZ(44, n.r, n.g, n.b), s.setXYZ(45, n.r, n.g, n.b), s.setXYZ(46, n.r, n.g, n.b), s.setXYZ(47, n.r, n.g, n.b), s.setXYZ(48, n.r, n.g, n.b), s.setXYZ(49, n.r, n.g, n.b), s.needsUpdate = !0 } update() { let e = this.geometry, t = this.pointMap; hc.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse); let i = this.camera.coordinateSystem === iT ? -1 : 0; hf("c", t, e, hc, 0, 0, i), hf("t", t, e, hc, 0, 0, 1), hf("n1", t, e, hc, -1, -1, i), hf("n2", t, e, hc, 1, -1, i), hf("n3", t, e, hc, -1, 1, i), hf("n4", t, e, hc, 1, 1, i), hf("f1", t, e, hc, -1, -1, 1), hf("f2", t, e, hc, 1, -1, 1), hf("f3", t, e, hc, -1, 1, 1), hf("f4", t, e, hc, 1, 1, 1), hf("u1", t, e, hc, .7, 1.1, i), hf("u2", t, e, hc, -.7, 1.1, i), hf("u3", t, e, hc, 0, 2, i), hf("cf1", t, e, hc, -1, 0, 1), hf("cf2", t, e, hc, 1, 0, 1), hf("cf3", t, e, hc, 0, -1, 1), hf("cf4", t, e, hc, 0, 1, 1), hf("cn1", t, e, hc, -1, 0, i), hf("cn2", t, e, hc, 1, 0, i), hf("cn3", t, e, hc, 0, -1, i), hf("cn4", t, e, hc, 0, 1, i), e.getAttribute("position").needsUpdate = !0 } dispose() { this.geometry.dispose(), this.material.dispose() } } function hf(e, t, i, r, n, s, a) { hh.set(n, s, a).unproject(r); let o = t[e]; if (void 0 !== o) { let e = i.getAttribute("position"); for (let t = 0, i = o.length; t < i; t++)e.setXYZ(o[t], hh.x, hh.y, hh.z) } } let hp = new rc; class hm extends aF { constructor(e, t = 0xffff00) { let i = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]), r = new Float32Array(24), n = new nq; n.setIndex(new nP(i, 1)), n.setAttribute("position", new nP(r, 3)), super(n, new ab({ color: t, toneMapped: !1 })), this.object = e, this.type = "BoxHelper", this.matrixAutoUpdate = !1, this.update() } update() { if (void 0 !== this.object && hp.setFromObject(this.object), hp.isEmpty()) return; let e = hp.min, t = hp.max, i = this.geometry.attributes.position, r = i.array; r[0] = t.x, r[1] = t.y, r[2] = t.z, r[3] = e.x, r[4] = t.y, r[5] = t.z, r[6] = e.x, r[7] = e.y, r[8] = t.z, r[9] = t.x, r[10] = e.y, r[11] = t.z, r[12] = t.x, r[13] = t.y, r[14] = e.z, r[15] = e.x, r[16] = t.y, r[17] = e.z, r[18] = e.x, r[19] = e.y, r[20] = e.z, r[21] = t.x, r[22] = e.y, r[23] = e.z, i.needsUpdate = !0, this.geometry.computeBoundingSphere() } setFromObject(e) { return this.object = e, this.update(), this } copy(e, t) { return super.copy(e, t), this.object = e.object, this } dispose() { this.geometry.dispose(), this.material.dispose() } } class hg extends aF { constructor(e, t = 0xffff00) { let i = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]), r = new nq; r.setIndex(new nP(i, 1)), r.setAttribute("position", new nG([1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1], 3)), super(r, new ab({ color: t, toneMapped: !1 })), this.box = e, this.type = "Box3Helper", this.geometry.computeBoundingSphere() } updateMatrixWorld(e) { let t = this.box; t.isEmpty() || (t.getCenter(this.position), t.getSize(this.scale), this.scale.multiplyScalar(.5), super.updateMatrixWorld(e)) } dispose() { this.geometry.dispose(), this.material.dispose() } } class hv extends aP { constructor(e, t = 1, i = 0xffff00) { let r = new nq; r.setAttribute("position", new nG([1, -1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, 1, 0, -1, -1, 0, 1, -1, 0, 1, 1, 0], 3)), r.computeBoundingSphere(), super(r, new ab({ color: i, toneMapped: !1 })), this.type = "PlaneHelper", this.plane = e, this.size = t; let n = new nq; n.setAttribute("position", new nG([1, 1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, -1, 0, 1, -1, 0], 3)), n.computeBoundingSphere(), this.add(new n6(n, new nb({ color: i, opacity: .2, transparent: !0, depthWrite: !1, toneMapped: !1 }))) } updateMatrixWorld(e) { this.position.set(0, 0, 0), this.scale.set(.5 * this.size, .5 * this.size, 1), this.lookAt(this.plane.normal), this.translateZ(-this.plane.constant), super.updateMatrixWorld(e) } dispose() { this.geometry.dispose(), this.material.dispose(), this.children[0].geometry.dispose(), this.children[0].material.dispose() } } let hy = new rl; class hx extends nt { constructor(e = new rl(0, 0, 1), t = new rl(0, 0, 0), i = 1, r = 0xffff00, n = .2 * i, s = .2 * n) { super(), this.type = "ArrowHelper", void 0 === a && ((a = new nq).setAttribute("position", new nG([0, 0, 0, 0, 1, 0], 3)), (o = new op(0, .5, 1, 5, 1)).translate(0, -.5, 0)), this.position.copy(t), this.line = new aP(a, new ab({ color: r, toneMapped: !1 })), this.line.matrixAutoUpdate = !1, this.add(this.line), this.cone = new n6(o, new nb({ color: r, toneMapped: !1 })), this.cone.matrixAutoUpdate = !1, this.add(this.cone), this.setDirection(e), this.setLength(i, n, s) } setDirection(e) { if (e.y > .99999) this.quaternion.set(0, 0, 0, 1); else if (e.y < -.99999) this.quaternion.set(1, 0, 0, 0); else { hy.set(e.z, 0, -e.x).normalize(); let t = Math.acos(e.y); this.quaternion.setFromAxisAngle(hy, t) } } setLength(e, t = .2 * e, i = .2 * t) { this.line.scale.set(1, Math.max(1e-4, e - t), 1), this.line.updateMatrix(), this.cone.scale.set(i, t, i), this.cone.position.y = e, this.cone.updateMatrix() } setColor(e) { this.line.material.color.set(e), this.cone.material.color.set(e) } copy(e) { return super.copy(e, !1), this.line.copy(e.line), this.cone.copy(e.cone), this } dispose() { this.line.geometry.dispose(), this.line.material.dispose(), this.cone.geometry.dispose(), this.cone.material.dispose() } } class hS extends aF { constructor(e = 1) { let t = new nq; t.setAttribute("position", new nG([0, 0, 0, e, 0, 0, 0, 0, 0, 0, e, 0, 0, 0, 0, 0, 0, e], 3)), t.setAttribute("color", new nG([1, 0, 0, 1, .6, 0, 0, 1, 0, .6, 1, 0, 0, 0, 1, 0, .6, 1], 3)), super(t, new ab({ vertexColors: !0, toneMapped: !1 })), this.type = "AxesHelper" } setColors(e, t, i) { let r = new nS, n = this.geometry.attributes.color.array; return r.set(e), r.toArray(n, 0), r.toArray(n, 3), r.set(t), r.toArray(n, 6), r.toArray(n, 9), r.set(i), r.toArray(n, 12), r.toArray(n, 15), this.geometry.attributes.color.needsUpdate = !0, this } dispose() { this.geometry.dispose(), this.material.dispose() } } class hA { constructor() { this.type = "ShapePath", this.color = new nS, this.subPaths = [], this.currentPath = null } moveTo(e, t) { return this.currentPath = new oh, this.subPaths.push(this.currentPath), this.currentPath.moveTo(e, t), this } lineTo(e, t) { return this.currentPath.lineTo(e, t), this } quadraticCurveTo(e, t, i, r) { return this.currentPath.quadraticCurveTo(e, t, i, r), this } bezierCurveTo(e, t, i, r, n, s) { return this.currentPath.bezierCurveTo(e, t, i, r, n, s), this } splineThru(e) { return this.currentPath.splineThru(e), this } toShapes(e) { let t, i, r, n, s; let a = oz.isClockWise, o = this.subPaths; if (0 === o.length) return []; let l = []; if (1 === o.length) return i = o[0], (r = new oE).curves = i.curves, l.push(r), l; let u = !a(o[0].getPoints()); u = e ? !u : u; let h = [], c = [], d = [], f = 0; c[0] = void 0, d[f] = []; for (let r = 0, s = o.length; r < s; r++)t = a(n = (i = o[r]).getPoints()), (t = e ? !t : t) ? (!u && c[f] && f++, c[f] = { s: new oE, p: n }, c[f].s.curves = i.curves, u && f++, d[f] = []) : d[f].push({ h: i, p: n[0] }); if (!c[0]) return function (e) { let t = []; for (let i = 0, r = e.length; i < r; i++) { let r = e[i], n = new oE; n.curves = r.curves, t.push(n) } return t }(o); if (c.length > 1) { let e = !1, t = 0; for (let e = 0, t = c.length; e < t; e++)h[e] = []; for (let i = 0, r = c.length; i < r; i++) { let r = d[i]; for (let n = 0; n < r.length; n++) { let s = r[n], a = !0; for (let r = 0; r < c.length; r++)(function (e, t) { let i = t.length, r = !1; for (let n = i - 1, s = 0; s < i; n = s++) { let i = t[n], a = t[s], o = a.x - i.x, l = a.y - i.y; if (Math.abs(l) > Number.EPSILON) { if (l < 0 && (i = t[s], o = -o, a = t[n], l = -l), e.y < i.y || e.y > a.y) continue; if (e.y === i.y) { if (e.x === i.x) return !0 } else { let t = l * (e.x - i.x) - o * (e.y - i.y); if (0 === t) return !0; if (t < 0) continue; r = !r } } else { if (e.y !== i.y) continue; if (a.x <= e.x && e.x <= i.x || i.x <= e.x && e.x <= a.x) return !0 } } return r })(s.p, c[r].p) && (i !== r && t++, a ? (a = !1, h[r].push(s)) : e = !0); a && h[i].push(s) } } t > 0 && !1 === e && (d = h) } for (let e = 0, t = c.length; e < t; e++) { r = c[e].s, l.push(r), s = d[e]; for (let e = 0, t = s.length; e < t; e++)r.holes.push(s[e].h) } return l } } class h_ extends iR { constructor(e, t = null) { super(), this.object = e, this.domElement = t, this.enabled = !0, this.state = -1, this.keys = {}, this.mouseButtons = { LEFT: null, MIDDLE: null, RIGHT: null }, this.touches = { ONE: null, TWO: null } } connect() { } disconnect() { } dispose() { } update() { } } function hE(e, t, i, r) { let n = function (e) { switch (e) { case eO: case ek: return { byteLength: 1, components: 1 }; case eU: case eF: case eG: return { byteLength: 2, components: 1 }; case eH: case eV: return { byteLength: 2, components: 4 }; case eB: case eN: case ez: return { byteLength: 4, components: 1 }; case ej: return { byteLength: 4, components: 3 } }throw Error(`Unknown texture type ${e}.`) }(r); switch (i) { case eY: case eq: return e * t; case eQ: return e * t * 2; case eJ: case e0: return e * t / n.components * n.byteLength; case e1: case e2: return e * t * 2 / n.components * n.byteLength; case eX: return e * t * 3 / n.components * n.byteLength; case eK: case e4: return e * t * 4 / n.components * n.byteLength; case e5: case e8: return Math.floor((e + 3) / 4) * Math.floor((t + 3) / 4) * 8; case e6: case e9: return Math.floor((e + 3) / 4) * Math.floor((t + 3) / 4) * 16; case te: case ti: return Math.max(e, 16) * Math.max(t, 8) / 4; case e7: case tt: return Math.max(e, 8) * Math.max(t, 8) / 2; case tr: case tn: return Math.floor((e + 3) / 4) * Math.floor((t + 3) / 4) * 8; case ts: case ta: return Math.floor((e + 3) / 4) * Math.floor((t + 3) / 4) * 16; case to: return Math.floor((e + 4) / 5) * Math.floor((t + 3) / 4) * 16; case tl: return Math.floor((e + 4) / 5) * Math.floor((t + 4) / 5) * 16; case tu: return Math.floor((e + 5) / 6) * Math.floor((t + 4) / 5) * 16; case th: return Math.floor((e + 5) / 6) * Math.floor((t + 5) / 6) * 16; case tc: return Math.floor((e + 7) / 8) * Math.floor((t + 4) / 5) * 16; case td: return Math.floor((e + 7) / 8) * Math.floor((t + 5) / 6) * 16; case tf: return Math.floor((e + 7) / 8) * Math.floor((t + 7) / 8) * 16; case tp: return Math.floor((e + 9) / 10) * Math.floor((t + 4) / 5) * 16; case tm: return Math.floor((e + 9) / 10) * Math.floor((t + 5) / 6) * 16; case tg: return Math.floor((e + 9) / 10) * Math.floor((t + 7) / 8) * 16; case tv: return Math.floor((e + 9) / 10) * Math.floor((t + 9) / 10) * 16; case ty: return Math.floor((e + 11) / 12) * Math.floor((t + 9) / 10) * 16; case tx: return Math.floor((e + 11) / 12) * Math.floor((t + 11) / 12) * 16; case tS: case tA: case t_: return Math.ceil(e / 4) * Math.ceil(t / 4) * 16; case tE: case tb: return Math.ceil(e / 4) * Math.ceil(t / 4) * 8; case tT: case tw: return Math.ceil(e / 4) * Math.ceil(t / 4) * 16 }throw Error(`Unable to determine texture byte length for ${i} format.`) } class hb { static contain(e, t) { return function (e, t) { let i = e.image && e.image.width ? e.image.width / e.image.height : 1; return i > t ? (e.repeat.x = 1, e.repeat.y = i / t, e.offset.x = 0, e.offset.y = (1 - e.repeat.y) / 2) : (e.repeat.x = t / i, e.repeat.y = 1, e.offset.x = (1 - e.repeat.x) / 2, e.offset.y = 0), e }(e, t) } static cover(e, t) { return function (e, t) { let i = e.image && e.image.width ? e.image.width / e.image.height : 1; return i > t ? (e.repeat.x = t / i, e.repeat.y = 1, e.offset.x = (1 - e.repeat.x) / 2, e.offset.y = 0) : (e.repeat.x = 1, e.repeat.y = i / t, e.offset.x = 0, e.offset.y = (1 - e.repeat.y) / 2), e }(e, t) } static fill(e) { return e.repeat.x = 1, e.repeat.y = 1, e.offset.x = 0, e.offset.y = 0, e } static getByteLength(e, t, i, r) { return hE(e, t, i, r) } } "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", { detail: { revision: l } })), "undefined" != typeof window && (window.__THREE__ ? console.warn("WARNING: Multiple instances of Three.js being imported.") : window.__THREE__ = l)
  }, 9437: (e, t, i) => {
    "use strict"; i.r(t), i.d(t, { ACESFilmicToneMapping: () => r.FV, AddEquation: () => r.gO9, AddOperation: () => r.XrR, AdditiveAnimationBlendMode: () => r.DAe, AdditiveBlending: () => r.EZo, AgXToneMapping: () => r.LAk, AlphaFormat: () => r.wrO, AlwaysCompare: () => r.FFZ, AlwaysDepth: () => r.lGu, AlwaysStencilFunc: () => r.sKt, AmbientLight: () => r.$p8, AnimationAction: () => r.pPE, AnimationClip: () => r.tz3, AnimationLoader: () => r.kEx, AnimationMixer: () => r.Iw4, AnimationObjectGroup: () => r.P5j, AnimationUtils: () => r.AKb, ArcCurve: () => r.ibB, ArrayCamera: () => r.nZQ, ArrowHelper: () => r.E0M, AttachedBindMode: () => r.BER, Audio: () => r.fP5, AudioAnalyser: () => r.CwR, AudioContext: () => r.UtX, AudioListener: () => r.Pf$, AudioLoader: () => r.Am1, AxesHelper: () => r.IzY, BackSide: () => r.hsX, BasicDepthPacking: () => r.Rkk, BasicShadowMap: () => r.bTm, BatchedMesh: () => r.$Ed, Bone: () => r.$Kf, BooleanKeyframeTrack: () => r.YOZ, Box2: () => r.UtB, Box3: () => r.NRn, Box3Helper: () => r.BND, BoxGeometry: () => r.iNn, BoxHelper: () => r.IWo, BufferAttribute: () => r.THS, BufferGeometry: () => r.LoY, BufferGeometryLoader: () => r.SUR, ByteType: () => r.tJf, Cache: () => r.l2R, Camera: () => r.i7d, CameraHelper: () => r.WTh, CanvasTexture: () => r.GOR, CapsuleGeometry: () => r.qU7, CatmullRomCurve3: () => r.B6O, CineonToneMapping: () => r.nNL, CircleGeometry: () => r.tcD, ClampToEdgeWrapping: () => r.ghU, Clock: () => r.zD7, Color: () => r.Q1f, ColorKeyframeTrack: () => r.T6I, ColorManagement: () => r.ppV, CompressedArrayTexture: () => r.iOZ, CompressedCubeTexture: () => r.c5h, CompressedTexture: () => r.FvD, CompressedTextureLoader: () => r.YRT, ConeGeometry: () => r.qFE, ConstantAlphaFactor: () => r.e0p, ConstantColorFactor: () => r.RrE, Controls: () => r.H2z, CubeCamera: () => r.F1T, CubeReflectionMapping: () => r.hy7, CubeRefractionMapping: () => r.xFO, CubeTexture: () => r.b4q, CubeTextureLoader: () => r.ScU, CubeUVReflectionMapping: () => r.Om, CubicBezierCurve: () => r.Z0B, CubicBezierCurve3: () => r.s0K, CubicInterpolant: () => r.Pdi, CullFaceBack: () => r.Vb5, CullFaceFront: () => r.Jnc, CullFaceFrontBack: () => r.ywQ, CullFaceNone: () => r.WNZ, Curve: () => r.Ipv, CurvePath: () => r.jGm, CustomBlending: () => r.bCz, CustomToneMapping: () => r.g7M, CylinderGeometry: () => r.Ho_, Cylindrical: () => r.hjs, Data3DTexture: () => r.dYF, DataArrayTexture: () => r.rFo, DataTexture: () => r.GYF, DataTextureLoader: () => r.BRH, DataUtils: () => r.GxU, DecrementStencilOp: () => r.ROr, DecrementWrapStencilOp: () => r.fJr, DefaultLoadingManager: () => r.h_9, DepthFormat: () => r.zdS, DepthStencilFormat: () => r.dcC, DepthTexture: () => r.VCu, DetachedBindMode: () => r.Fvi, DirectionalLight: () => r.ZyN, DirectionalLightHelper: () => r.PFK, DiscreteInterpolant: () => r.Yhb, DodecahedronGeometry: () => r.nEu, DoubleSide: () => r.$EB, DstAlphaFactor: () => r.hdd, DstColorFactor: () => r.wn6, DynamicCopyUsage: () => r.MOq, DynamicDrawUsage: () => r.Vnu, DynamicReadUsage: () => r.hIf, EdgesGeometry: () => r.TDQ, EllipseCurve: () => r.S20, EqualCompare: () => r.kO0, EqualDepth: () => r.U3G, EqualStencilFunc: () => r.jsO, EquirectangularReflectionMapping: () => r.wfO, EquirectangularRefractionMapping: () => r.uV5, Euler: () => r.O9p, EventDispatcher: () => r.Qev, ExtrudeGeometry: () => r.QCA, FileLoader: () => r.Y9S, Float16BufferAttribute: () => r.Oax, Float32BufferAttribute: () => r.qtW, FloatType: () => r.RQf, Fog: () => r.jUj, FogExp2: () => r.cRK, FramebufferTexture: () => r.Pem, FrontSide: () => r.hB5, Frustum: () => r.PPD, GLBufferAttribute: () => r.oh6, GLSL1: () => r.Wyr, GLSL3: () => r.Wdf, GreaterCompare: () => r.eoi, GreaterDepth: () => r.K52, GreaterEqualCompare: () => r.gWB, GreaterEqualDepth: () => r.Gwm, GreaterEqualStencilFunc: () => r.TMh, GreaterStencilFunc: () => r.RcT, GridHelper: () => r.fTw, Group: () => r.YJl, HalfFloatType: () => r.ix0, HemisphereLight: () => r.dth, HemisphereLightHelper: () => r.R1W, IcosahedronGeometry: () => r.WBB, ImageBitmapLoader: () => r.Kzg, ImageLoader: () => r.$NF, ImageUtils: () => r.HgN, IncrementStencilOp: () => r.HLH, IncrementWrapStencilOp: () => r.Ru$, InstancedBufferAttribute: () => r.uWO, InstancedBufferGeometry: () => r.CmU, InstancedInterleavedBuffer: () => r.LuO, InstancedMesh: () => r.ZLX, Int16BufferAttribute: () => r.Hrb, Int32BufferAttribute: () => r.vmz, Int8BufferAttribute: () => r.wvS, IntType: () => r.Yuy, InterleavedBuffer: () => r.eB$, InterleavedBufferAttribute: () => r.eHs, Interpolant: () => r.lGw, InterpolateDiscrete: () => r.ljd, InterpolateLinear: () => r.PJ3, InterpolateSmooth: () => r.EQC, InvertStencilOp: () => r.oVO, KeepStencilOp: () => r.VVr, KeyframeTrack: () => r.UJ6, LOD: () => r.UpK, LatheGeometry: () => r.nzx, Layers: () => r.zgK, LessCompare: () => r.vim, LessDepth: () => r.brA, LessEqualCompare: () => r.TiK, LessEqualDepth: () => r.xSv, LessEqualStencilFunc: () => r.CR7, LessStencilFunc: () => r.kYr, Light: () => r.veJ, LightProbe: () => r.FZo, Line: () => r.N1A, Line3: () => r.cZY, LineBasicMaterial: () => r.mrM, LineCurve: () => r.GZZ, LineCurve3: () => r.VnP, LineDashedMaterial: () => r.Fvt, LineLoop: () => r.FCc, LineSegments: () => r.DXC, LinearFilter: () => r.k6q, LinearInterpolant: () => r.ezk, LinearMipMapLinearFilter: () => r.NZq, LinearMipMapNearestFilter: () => r.iUH, LinearMipmapLinearFilter: () => r.$_I, LinearMipmapNearestFilter: () => r.kRr, LinearSRGBColorSpace: () => r.Zr2, LinearToneMapping: () => r.kyO, LinearTransfer: () => r.VxR, Loader: () => r.aHM, LoaderUtils: () => r.r6x, LoadingManager: () => r.KPJ, LoopOnce: () => r.G3T, LoopPingPong: () => r.lc7, LoopRepeat: () => r.aMy, LuminanceAlphaFormat: () => r.CMB, LuminanceFormat: () => r.Kzv, MOUSE: () => r.kBv, Material: () => r.imn, MaterialLoader: () => r.jut, MathUtils: () => r.cj9, Matrix2: () => r.k_V, Matrix3: () => r.dwI, Matrix4: () => r.kn4, MaxEquation: () => r.$ei, Mesh: () => r.eaF, MeshBasicMaterial: () => r.V9B, MeshDepthMaterial: () => r.CSG, MeshDistanceMaterial: () => r.aVO, MeshLambertMaterial: () => r.G_z, MeshMatcapMaterial: () => r.FNr, MeshNormalMaterial: () => r.qBx, MeshPhongMaterial: () => r.tXL, MeshPhysicalMaterial: () => r.uSd, MeshStandardMaterial: () => r._4j, MeshToonMaterial: () => r.Df, MinEquation: () => r.znC, MirroredRepeatWrapping: () => r.kTW, MixOperation: () => r.KRh, MultiplyBlending: () => r.EdD, MultiplyOperation: () => r.caT, NearestFilter: () => r.hxR, NearestMipMapLinearFilter: () => r.a$r, NearestMipMapNearestFilter: () => r.$O9, NearestMipmapLinearFilter: () => r.Cfg, NearestMipmapNearestFilter: () => r.pHI, NeutralToneMapping: () => r.aJ8, NeverCompare: () => r.amv, NeverDepth: () => r.eHc, NeverStencilFunc: () => r.HPb, NoBlending: () => r.XIg, NoColorSpace: () => r.jf0, NoToneMapping: () => r.y_p, NormalAnimationBlendMode: () => r.Ke9, NormalBlending: () => r.NTi, NotEqualCompare: () => r.jzd, NotEqualDepth: () => r.bw0, NotEqualStencilFunc: () => r.klZ, NumberKeyframeTrack: () => r.Hit, Object3D: () => r.B69, ObjectLoader: () => r.XTe, ObjectSpaceNormalMap: () => r.vyJ, OctahedronGeometry: () => r.Ufg, OneFactor: () => r.qad, OneMinusConstantAlphaFactor: () => r.ov9, OneMinusConstantColorFactor: () => r.$Yl, OneMinusDstAlphaFactor: () => r.Nt7, OneMinusDstColorFactor: () => r.aEY, OneMinusSrcAlphaFactor: () => r.OuU, OneMinusSrcColorFactor: () => r.LiQ, OrthographicCamera: () => r.qUd, PCFShadowMap: () => r.QP0, PCFSoftShadowMap: () => r.Wk7, PMREMGenerator: () => C, Path: () => r.wAk, PerspectiveCamera: () => r.ubm, Plane: () => r.Zcv, PlaneGeometry: () => r.bdM, PlaneHelper: () => r.ZM4, PointLight: () => r.HiM, PointLightHelper: () => r.F1l, Points: () => r.ONl, PointsMaterial: () => r.BH$, PolarGridHelper: () => r.hzE, PolyhedronGeometry: () => r.pFK, PositionalAudio: () => r.xZx, PropertyBinding: () => r.Nwf, PropertyMixer: () => r.N2s, QuadraticBezierCurve: () => r.dAo, QuadraticBezierCurve3: () => r.CV9, Quaternion: () => r.PTz, QuaternionKeyframeTrack: () => r.MBL, QuaternionLinearInterpolant: () => r.GBG, RED_GREEN_RGTC2_Format: () => r.HO_, RED_RGTC1_Format: () => r.Kef, REVISION: () => r.sPf, RGBADepthPacking: () => r.N5j, RGBAFormat: () => r.GWd, RGBAIntegerFormat: () => r.c90, RGBA_ASTC_10x10_Format: () => r.y3Z, RGBA_ASTC_10x5_Format: () => r.uB5, RGBA_ASTC_10x6_Format: () => r.lyL, RGBA_ASTC_10x8_Format: () => r.bC7, RGBA_ASTC_12x10_Format: () => r.ojs, RGBA_ASTC_12x12_Format: () => r.S$4, RGBA_ASTC_4x4_Format: () => r.qa3, RGBA_ASTC_5x4_Format: () => r.B_h, RGBA_ASTC_5x5_Format: () => r.czI, RGBA_ASTC_6x5_Format: () => r.rSH, RGBA_ASTC_6x6_Format: () => r.Qrf, RGBA_ASTC_8x5_Format: () => r.psI, RGBA_ASTC_8x6_Format: () => r.a5J, RGBA_ASTC_8x8_Format: () => r._QJ, RGBA_BPTC_Format: () => r.Fn, RGBA_ETC2_EAC_Format: () => r.KDk, RGBA_PVRTC_2BPPV1_Format: () => r.pBf, RGBA_PVRTC_4BPPV1_Format: () => r.HXV, RGBA_S3TC_DXT1_Format: () => r.Nz6, RGBA_S3TC_DXT3_Format: () => r.jR7, RGBA_S3TC_DXT5_Format: () => r.BXX, RGBDepthPacking: () => r.wTz, RGBFormat: () => r.HIg, RGBIntegerFormat: () => r.VGF, RGB_BPTC_SIGNED_Format: () => r.H23, RGB_BPTC_UNSIGNED_Format: () => r.W9U, RGB_ETC1_Format: () => r.CVz, RGB_ETC2_Format: () => r.Riy, RGB_PVRTC_2BPPV1_Format: () => r.kTp, RGB_PVRTC_4BPPV1_Format: () => r.k6Q, RGB_S3TC_DXT1_Format: () => r.IE4, RGDepthPacking: () => r.k8v, RGFormat: () => r.paN, RGIntegerFormat: () => r.TkQ, RawShaderMaterial: () => r.D$Q, Ray: () => r.RlV, Raycaster: () => r.tBo, RectAreaLight: () => r.ure, RedFormat: () => r.VT0, RedIntegerFormat: () => r.ZQM, ReinhardToneMapping: () => r.Mjd, RenderTarget: () => r.O0B, RenderTarget3D: () => r.XMJ, RenderTargetArray: () => r.rrX, RepeatWrapping: () => r.GJx, ReplaceStencilOp: () => r.kG0, ReverseSubtractEquation: () => r.nST, RingGeometry: () => r.rKP, SIGNED_RED_GREEN_RGTC2_Format: () => r.CWW, SIGNED_RED_RGTC1_Format: () => r.XG_, SRGBColorSpace: () => r.er$, SRGBTransfer: () => r.KLL, Scene: () => r.Z58, ShaderChunk: () => a, ShaderLib: () => l, ShaderMaterial: () => r.BKk, ShadowMaterial: () => r.q2, Shape: () => r.ypk, ShapeGeometry: () => r.MSw, ShapePath: () => r.Ld9, ShapeUtils: () => r.xJ6, ShortType: () => r.fBL, Skeleton: () => r.EAD, SkeletonHelper: () => r._xc, SkinnedMesh: () => r.I46, Source: () => r.kLi, Sphere: () => r.iyt, SphereGeometry: () => r.Gu$, Spherical: () => r.YHV, SphericalHarmonics3: () => r.xOk, SplineCurve: () => r.xfg, SpotLight: () => r.nCl, SpotLightHelper: () => r.Fpm, Sprite: () => r.kxk, SpriteMaterial: () => r.RoJ, SrcAlphaFactor: () => r.ie2, SrcAlphaSaturateFactor: () => r.hgQ, SrcColorFactor: () => r.f4X, StaticCopyUsage: () => r.Hrq, StaticDrawUsage: () => r.agE, StaticReadUsage: () => r.uXQ, StereoCamera: () => r.keZ, StreamCopyUsage: () => r.rOG, StreamDrawUsage: () => r.Ktl, StreamReadUsage: () => r.uov, StringKeyframeTrack: () => r.hZF, SubtractEquation: () => r.FXf, SubtractiveBlending: () => r.Kwu, TOUCH: () => r.wtR, TangentSpaceNormalMap: () => r.bI3, TetrahedronGeometry: () => r.Zpd, Texture: () => r.gPd, TextureLoader: () => r.Tap, TextureUtils: () => r.Vwu, TimestampQuery: () => r.v9J, TorusGeometry: () => r.O3Y, TorusKnotGeometry: () => r.UPV, Triangle: () => r.lMl, TriangleFanDrawMode: () => r.rYR, TriangleStripDrawMode: () => r.O49, TrianglesDrawMode: () => r.RJ4, TubeGeometry: () => r.j6, UVMapping: () => r.UTZ, Uint16BufferAttribute: () => r.A$4, Uint32BufferAttribute: () => r.MW4, Uint8BufferAttribute: () => r.baL, Uint8ClampedBufferAttribute: () => r.fc6, Uniform: () => r.nc$, UniformsGroup: () => r.dzP, UniformsLib: () => o, UniformsUtils: () => r.LlO, UnsignedByteType: () => r.OUM, UnsignedInt248Type: () => r.V3x, UnsignedInt5999Type: () => r.Dmk, UnsignedIntType: () => r.bkx, UnsignedShort4444Type: () => r.Wew, UnsignedShort5551Type: () => r.gJ2, UnsignedShortType: () => r.cHt, VSMShadowMap: () => r.RyA, Vector2: () => r.I9Y, Vector3: () => r.Pq0, Vector4: () => r.IUQ, VectorKeyframeTrack: () => r.RiT, VideoFrameTexture: () => r.SYV, VideoTexture: () => r.Nv2, WebGL3DRenderTarget: () => r.ALV, WebGLArrayRenderTarget: () => r.y9J, WebGLCoordinateSystem: () => r.TdN, WebGLCubeRenderTarget: () => r.o6l, WebGLRenderTarget: () => r.nWS, WebGLRenderer: () => tM, WebGLUtils: () => ty, WebGPUCoordinateSystem: () => r.i7u, WebXRController: () => r.R3r, WireframeGeometry: () => r.XJ7, WrapAroundEnding: () => r.dhZ, ZeroCurvatureEnding: () => r.rQf, ZeroFactor: () => r.ojh, ZeroSlopeEnding: () => r.h2z, ZeroStencilOp: () => r.kqe, createCanvasElement: () => r.lPF }); var r = i(4922); function n() { let e = null, t = !1, i = null, r = null; function n(t, s) { i(t, s), r = e.requestAnimationFrame(n) } return { start: function () { !0 !== t && null !== i && (r = e.requestAnimationFrame(n), t = !0) }, stop: function () { e.cancelAnimationFrame(r), t = !1 }, setAnimationLoop: function (e) { i = e }, setContext: function (t) { e = t } } } function s(e) { let t = new WeakMap; return { get: function (e) { return e.isInterleavedBufferAttribute && (e = e.data), t.get(e) }, remove: function (i) { i.isInterleavedBufferAttribute && (i = i.data); let r = t.get(i); r && (e.deleteBuffer(r.buffer), t.delete(i)) }, update: function (i, r) { if (i.isInterleavedBufferAttribute && (i = i.data), i.isGLBufferAttribute) { let e = t.get(i); (!e || e.version < i.version) && t.set(i, { buffer: i.buffer, type: i.type, bytesPerElement: i.elementSize, version: i.version }); return } let n = t.get(i); if (void 0 === n) t.set(i, function (t, i) { let r; let n = t.array, s = t.usage, a = n.byteLength, o = e.createBuffer(); if (e.bindBuffer(i, o), e.bufferData(i, n, s), t.onUploadCallback(), n instanceof Float32Array) r = e.FLOAT; else if (n instanceof Uint16Array) r = t.isFloat16BufferAttribute ? e.HALF_FLOAT : e.UNSIGNED_SHORT; else if (n instanceof Int16Array) r = e.SHORT; else if (n instanceof Uint32Array) r = e.UNSIGNED_INT; else if (n instanceof Int32Array) r = e.INT; else if (n instanceof Int8Array) r = e.BYTE; else if (n instanceof Uint8Array) r = e.UNSIGNED_BYTE; else if (n instanceof Uint8ClampedArray) r = e.UNSIGNED_BYTE; else throw Error("THREE.WebGLAttributes: Unsupported buffer data format: " + n); return { buffer: o, type: r, bytesPerElement: n.BYTES_PER_ELEMENT, version: t.version, size: a } }(i, r)); else if (n.version < i.version) { if (n.size !== i.array.byteLength) throw Error("THREE.WebGLAttributes: The size of the buffer attribute's array buffer does not match the original size. Resizing buffer attributes is not supported."); !function (t, i, r) { let n = i.array, s = i.updateRanges; if (e.bindBuffer(r, t), 0 === s.length) e.bufferSubData(r, 0, n); else { s.sort((e, t) => e.start - t.start); let t = 0; for (let e = 1; e < s.length; e++) { let i = s[t], r = s[e]; r.start <= i.start + i.count + 1 ? i.count = Math.max(i.count, r.start + r.count - i.start) : s[++t] = r } s.length = t + 1; for (let t = 0, i = s.length; t < i; t++) { let i = s[t]; e.bufferSubData(r, i.start * n.BYTES_PER_ELEMENT, n, i.start, i.count) } i.clearUpdateRanges() } i.onUploadCallback() }(n.buffer, i, r), n.version = i.version } } } } let a = { alphahash_fragment: "#ifdef USE_ALPHAHASH\n	if ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;\n#endif", alphahash_pars_fragment: "#ifdef USE_ALPHAHASH\n	const float ALPHA_HASH_SCALE = 0.05;\n	float hash2D( vec2 value ) {\n		return fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );\n	}\n	float hash3D( vec3 value ) {\n		return hash2D( vec2( hash2D( value.xy ), value.z ) );\n	}\n	float getAlphaHashThreshold( vec3 position ) {\n		float maxDeriv = max(\n			length( dFdx( position.xyz ) ),\n			length( dFdy( position.xyz ) )\n		);\n		float pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );\n		vec2 pixScales = vec2(\n			exp2( floor( log2( pixScale ) ) ),\n			exp2( ceil( log2( pixScale ) ) )\n		);\n		vec2 alpha = vec2(\n			hash3D( floor( pixScales.x * position.xyz ) ),\n			hash3D( floor( pixScales.y * position.xyz ) )\n		);\n		float lerpFactor = fract( log2( pixScale ) );\n		float x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;\n		float a = min( lerpFactor, 1.0 - lerpFactor );\n		vec3 cases = vec3(\n			x * x / ( 2.0 * a * ( 1.0 - a ) ),\n			( x - 0.5 * a ) / ( 1.0 - a ),\n			1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )\n		);\n		float threshold = ( x < ( 1.0 - a ) )\n			? ( ( x < a ) ? cases.x : cases.y )\n			: cases.z;\n		return clamp( threshold , 1.0e-6, 1.0 );\n	}\n#endif", alphamap_fragment: "#ifdef USE_ALPHAMAP\n	diffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;\n#endif", alphamap_pars_fragment: "#ifdef USE_ALPHAMAP\n	uniform sampler2D alphaMap;\n#endif", alphatest_fragment: "#ifdef USE_ALPHATEST\n	#ifdef ALPHA_TO_COVERAGE\n	diffuseColor.a = smoothstep( alphaTest, alphaTest + fwidth( diffuseColor.a ), diffuseColor.a );\n	if ( diffuseColor.a == 0.0 ) discard;\n	#else\n	if ( diffuseColor.a < alphaTest ) discard;\n	#endif\n#endif", alphatest_pars_fragment: "#ifdef USE_ALPHATEST\n	uniform float alphaTest;\n#endif", aomap_fragment: "#ifdef USE_AOMAP\n	float ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;\n	reflectedLight.indirectDiffuse *= ambientOcclusion;\n	#if defined( USE_CLEARCOAT ) \n		clearcoatSpecularIndirect *= ambientOcclusion;\n	#endif\n	#if defined( USE_SHEEN ) \n		sheenSpecularIndirect *= ambientOcclusion;\n	#endif\n	#if defined( USE_ENVMAP ) && defined( STANDARD )\n		float dotNV = saturate( dot( geometryNormal, geometryViewDir ) );\n		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\n	#endif\n#endif", aomap_pars_fragment: "#ifdef USE_AOMAP\n	uniform sampler2D aoMap;\n	uniform float aoMapIntensity;\n#endif", batching_pars_vertex: "#ifdef USE_BATCHING\n	#if ! defined( GL_ANGLE_multi_draw )\n	#define gl_DrawID _gl_DrawID\n	uniform int _gl_DrawID;\n	#endif\n	uniform highp sampler2D batchingTexture;\n	uniform highp usampler2D batchingIdTexture;\n	mat4 getBatchingMatrix( const in float i ) {\n		int size = textureSize( batchingTexture, 0 ).x;\n		int j = int( i ) * 4;\n		int x = j % size;\n		int y = j / size;\n		vec4 v1 = texelFetch( batchingTexture, ivec2( x, y ), 0 );\n		vec4 v2 = texelFetch( batchingTexture, ivec2( x + 1, y ), 0 );\n		vec4 v3 = texelFetch( batchingTexture, ivec2( x + 2, y ), 0 );\n		vec4 v4 = texelFetch( batchingTexture, ivec2( x + 3, y ), 0 );\n		return mat4( v1, v2, v3, v4 );\n	}\n	float getIndirectIndex( const in int i ) {\n		int size = textureSize( batchingIdTexture, 0 ).x;\n		int x = i % size;\n		int y = i / size;\n		return float( texelFetch( batchingIdTexture, ivec2( x, y ), 0 ).r );\n	}\n#endif\n#ifdef USE_BATCHING_COLOR\n	uniform sampler2D batchingColorTexture;\n	vec3 getBatchingColor( const in float i ) {\n		int size = textureSize( batchingColorTexture, 0 ).x;\n		int j = int( i );\n		int x = j % size;\n		int y = j / size;\n		return texelFetch( batchingColorTexture, ivec2( x, y ), 0 ).rgb;\n	}\n#endif", batching_vertex: "#ifdef USE_BATCHING\n	mat4 batchingMatrix = getBatchingMatrix( getIndirectIndex( gl_DrawID ) );\n#endif", begin_vertex: "vec3 transformed = vec3( position );\n#ifdef USE_ALPHAHASH\n	vPosition = vec3( position );\n#endif", beginnormal_vertex: "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n	vec3 objectTangent = vec3( tangent.xyz );\n#endif", bsdfs: "float G_BlinnPhong_Implicit( ) {\n	return 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {\n	vec3 halfDir = normalize( lightDir + viewDir );\n	float dotNH = saturate( dot( normal, halfDir ) );\n	float dotVH = saturate( dot( viewDir, halfDir ) );\n	vec3 F = F_Schlick( specularColor, 1.0, dotVH );\n	float G = G_BlinnPhong_Implicit( );\n	float D = D_BlinnPhong( shininess, dotNH );\n	return F * ( G * D );\n} // validated", iridescence_fragment: "#ifdef USE_IRIDESCENCE\n	const mat3 XYZ_TO_REC709 = mat3(\n		 3.2404542, -0.9692660,  0.0556434,\n		-1.5371385,  1.8760108, -0.2040259,\n		-0.4985314,  0.0415560,  1.0572252\n	);\n	vec3 Fresnel0ToIor( vec3 fresnel0 ) {\n		vec3 sqrtF0 = sqrt( fresnel0 );\n		return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );\n	}\n	vec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {\n		return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );\n	}\n	float IorToFresnel0( float transmittedIor, float incidentIor ) {\n		return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));\n	}\n	vec3 evalSensitivity( float OPD, vec3 shift ) {\n		float phase = 2.0 * PI * OPD * 1.0e-9;\n		vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );\n		vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );\n		vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );\n		vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );\n		xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );\n		xyz /= 1.0685e-7;\n		vec3 rgb = XYZ_TO_REC709 * xyz;\n		return rgb;\n	}\n	vec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {\n		vec3 I;\n		float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );\n		float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );\n		float cosTheta2Sq = 1.0 - sinTheta2Sq;\n		if ( cosTheta2Sq < 0.0 ) {\n			return vec3( 1.0 );\n		}\n		float cosTheta2 = sqrt( cosTheta2Sq );\n		float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );\n		float R12 = F_Schlick( R0, 1.0, cosTheta1 );\n		float T121 = 1.0 - R12;\n		float phi12 = 0.0;\n		if ( iridescenceIOR < outsideIOR ) phi12 = PI;\n		float phi21 = PI - phi12;\n		vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );		vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );\n		vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );\n		vec3 phi23 = vec3( 0.0 );\n		if ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;\n		if ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;\n		if ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;\n		float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;\n		vec3 phi = vec3( phi21 ) + phi23;\n		vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );\n		vec3 r123 = sqrt( R123 );\n		vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );\n		vec3 C0 = R12 + Rs;\n		I = C0;\n		vec3 Cm = Rs - T121;\n		for ( int m = 1; m <= 2; ++ m ) {\n			Cm *= r123;\n			vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );\n			I += Cm * Sm;\n		}\n		return max( I, vec3( 0.0 ) );\n	}\n#endif", bumpmap_pars_fragment: "#ifdef USE_BUMPMAP\n	uniform sampler2D bumpMap;\n	uniform float bumpScale;\n	vec2 dHdxy_fwd() {\n		vec2 dSTdx = dFdx( vBumpMapUv );\n		vec2 dSTdy = dFdy( vBumpMapUv );\n		float Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;\n		float dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;\n		float dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;\n		return vec2( dBx, dBy );\n	}\n	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n		vec3 vSigmaX = normalize( dFdx( surf_pos.xyz ) );\n		vec3 vSigmaY = normalize( dFdy( surf_pos.xyz ) );\n		vec3 vN = surf_norm;\n		vec3 R1 = cross( vSigmaY, vN );\n		vec3 R2 = cross( vN, vSigmaX );\n		float fDet = dot( vSigmaX, R1 ) * faceDirection;\n		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n		return normalize( abs( fDet ) * surf_norm - vGrad );\n	}\n#endif", clipping_planes_fragment: "#if NUM_CLIPPING_PLANES > 0\n	vec4 plane;\n	#ifdef ALPHA_TO_COVERAGE\n		float distanceToPlane, distanceGradient;\n		float clipOpacity = 1.0;\n		#pragma unroll_loop_start\n		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n			plane = clippingPlanes[ i ];\n			distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;\n			distanceGradient = fwidth( distanceToPlane ) / 2.0;\n			clipOpacity *= smoothstep( - distanceGradient, distanceGradient, distanceToPlane );\n			if ( clipOpacity == 0.0 ) discard;\n		}\n		#pragma unroll_loop_end\n		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n			float unionClipOpacity = 1.0;\n			#pragma unroll_loop_start\n			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n				plane = clippingPlanes[ i ];\n				distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;\n				distanceGradient = fwidth( distanceToPlane ) / 2.0;\n				unionClipOpacity *= 1.0 - smoothstep( - distanceGradient, distanceGradient, distanceToPlane );\n			}\n			#pragma unroll_loop_end\n			clipOpacity *= 1.0 - unionClipOpacity;\n		#endif\n		diffuseColor.a *= clipOpacity;\n		if ( diffuseColor.a == 0.0 ) discard;\n	#else\n		#pragma unroll_loop_start\n		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n			plane = clippingPlanes[ i ];\n			if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n		}\n		#pragma unroll_loop_end\n		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n			bool clipped = true;\n			#pragma unroll_loop_start\n			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n				plane = clippingPlanes[ i ];\n				clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n			}\n			#pragma unroll_loop_end\n			if ( clipped ) discard;\n		#endif\n	#endif\n#endif", clipping_planes_pars_fragment: "#if NUM_CLIPPING_PLANES > 0\n	varying vec3 vClipPosition;\n	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif", clipping_planes_pars_vertex: "#if NUM_CLIPPING_PLANES > 0\n	varying vec3 vClipPosition;\n#endif", clipping_planes_vertex: "#if NUM_CLIPPING_PLANES > 0\n	vClipPosition = - mvPosition.xyz;\n#endif", color_fragment: "#if defined( USE_COLOR_ALPHA )\n	diffuseColor *= vColor;\n#elif defined( USE_COLOR )\n	diffuseColor.rgb *= vColor;\n#endif", color_pars_fragment: "#if defined( USE_COLOR_ALPHA )\n	varying vec4 vColor;\n#elif defined( USE_COLOR )\n	varying vec3 vColor;\n#endif", color_pars_vertex: "#if defined( USE_COLOR_ALPHA )\n	varying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )\n	varying vec3 vColor;\n#endif", color_vertex: "#if defined( USE_COLOR_ALPHA )\n	vColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )\n	vColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n	vColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n	vColor.xyz *= instanceColor.xyz;\n#endif\n#ifdef USE_BATCHING_COLOR\n	vec3 batchingColor = getBatchingColor( getIndirectIndex( gl_DrawID ) );\n	vColor.xyz *= batchingColor.xyz;\n#endif", common: "#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nvec3 pow2( const in vec3 x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }\nhighp float rand( const in vec2 uv ) {\n	const highp float a = 12.9898, b = 78.233, c = 43758.5453;\n	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n	return fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n	float precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n	float precisionSafeLength( vec3 v ) {\n		float maxComponent = max3( abs( v ) );\n		return length( v / maxComponent ) * maxComponent;\n	}\n#endif\nstruct IncidentLight {\n	vec3 color;\n	vec3 direction;\n	bool visible;\n};\nstruct ReflectedLight {\n	vec3 directDiffuse;\n	vec3 directSpecular;\n	vec3 indirectDiffuse;\n	vec3 indirectSpecular;\n};\n#ifdef USE_ALPHAHASH\n	varying vec3 vPosition;\n#endif\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n	mat3 tmp;\n	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n	return tmp;\n}\nbool isPerspectiveMatrix( mat4 m ) {\n	return m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n	return vec2( u, v );\n}\nvec3 BRDF_Lambert( const in vec3 diffuseColor ) {\n	return RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {\n	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nfloat F_Schlick( const in float f0, const in float f90, const in float dotVH ) {\n	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n} // validated", cube_uv_reflection_fragment: "#ifdef ENVMAP_TYPE_CUBE_UV\n	#define cubeUV_minMipLevel 4.0\n	#define cubeUV_minTileSize 16.0\n	float getFace( vec3 direction ) {\n		vec3 absDirection = abs( direction );\n		float face = - 1.0;\n		if ( absDirection.x > absDirection.z ) {\n			if ( absDirection.x > absDirection.y )\n				face = direction.x > 0.0 ? 0.0 : 3.0;\n			else\n				face = direction.y > 0.0 ? 1.0 : 4.0;\n		} else {\n			if ( absDirection.z > absDirection.y )\n				face = direction.z > 0.0 ? 2.0 : 5.0;\n			else\n				face = direction.y > 0.0 ? 1.0 : 4.0;\n		}\n		return face;\n	}\n	vec2 getUV( vec3 direction, float face ) {\n		vec2 uv;\n		if ( face == 0.0 ) {\n			uv = vec2( direction.z, direction.y ) / abs( direction.x );\n		} else if ( face == 1.0 ) {\n			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n		} else if ( face == 2.0 ) {\n			uv = vec2( - direction.x, direction.y ) / abs( direction.z );\n		} else if ( face == 3.0 ) {\n			uv = vec2( - direction.z, direction.y ) / abs( direction.x );\n		} else if ( face == 4.0 ) {\n			uv = vec2( - direction.x, direction.z ) / abs( direction.y );\n		} else {\n			uv = vec2( direction.x, direction.y ) / abs( direction.z );\n		}\n		return 0.5 * ( uv + 1.0 );\n	}\n	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n		float face = getFace( direction );\n		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n		mipInt = max( mipInt, cubeUV_minMipLevel );\n		float faceSize = exp2( mipInt );\n		highp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;\n		if ( face > 2.0 ) {\n			uv.y += faceSize;\n			face -= 3.0;\n		}\n		uv.x += face * faceSize;\n		uv.x += filterInt * 3.0 * cubeUV_minTileSize;\n		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );\n		uv.x *= CUBEUV_TEXEL_WIDTH;\n		uv.y *= CUBEUV_TEXEL_HEIGHT;\n		#ifdef texture2DGradEXT\n			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;\n		#else\n			return texture2D( envMap, uv ).rgb;\n		#endif\n	}\n	#define cubeUV_r0 1.0\n	#define cubeUV_m0 - 2.0\n	#define cubeUV_r1 0.8\n	#define cubeUV_m1 - 1.0\n	#define cubeUV_r4 0.4\n	#define cubeUV_m4 2.0\n	#define cubeUV_r5 0.305\n	#define cubeUV_m5 3.0\n	#define cubeUV_r6 0.21\n	#define cubeUV_m6 4.0\n	float roughnessToMip( float roughness ) {\n		float mip = 0.0;\n		if ( roughness >= cubeUV_r1 ) {\n			mip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;\n		} else if ( roughness >= cubeUV_r4 ) {\n			mip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;\n		} else if ( roughness >= cubeUV_r5 ) {\n			mip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;\n		} else if ( roughness >= cubeUV_r6 ) {\n			mip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;\n		} else {\n			mip = - 2.0 * log2( 1.16 * roughness );		}\n		return mip;\n	}\n	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n		float mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );\n		float mipF = fract( mip );\n		float mipInt = floor( mip );\n		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n		if ( mipF == 0.0 ) {\n			return vec4( color0, 1.0 );\n		} else {\n			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n			return vec4( mix( color0, color1, mipF ), 1.0 );\n		}\n	}\n#endif", defaultnormal_vertex: "vec3 transformedNormal = objectNormal;\n#ifdef USE_TANGENT\n	vec3 transformedTangent = objectTangent;\n#endif\n#ifdef USE_BATCHING\n	mat3 bm = mat3( batchingMatrix );\n	transformedNormal /= vec3( dot( bm[ 0 ], bm[ 0 ] ), dot( bm[ 1 ], bm[ 1 ] ), dot( bm[ 2 ], bm[ 2 ] ) );\n	transformedNormal = bm * transformedNormal;\n	#ifdef USE_TANGENT\n		transformedTangent = bm * transformedTangent;\n	#endif\n#endif\n#ifdef USE_INSTANCING\n	mat3 im = mat3( instanceMatrix );\n	transformedNormal /= vec3( dot( im[ 0 ], im[ 0 ] ), dot( im[ 1 ], im[ 1 ] ), dot( im[ 2 ], im[ 2 ] ) );\n	transformedNormal = im * transformedNormal;\n	#ifdef USE_TANGENT\n		transformedTangent = im * transformedTangent;\n	#endif\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n	transformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n	transformedTangent = ( modelViewMatrix * vec4( transformedTangent, 0.0 ) ).xyz;\n	#ifdef FLIP_SIDED\n		transformedTangent = - transformedTangent;\n	#endif\n#endif", displacementmap_pars_vertex: "#ifdef USE_DISPLACEMENTMAP\n	uniform sampler2D displacementMap;\n	uniform float displacementScale;\n	uniform float displacementBias;\n#endif", displacementmap_vertex: "#ifdef USE_DISPLACEMENTMAP\n	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );\n#endif", emissivemap_fragment: "#ifdef USE_EMISSIVEMAP\n	vec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );\n	#ifdef DECODE_VIDEO_TEXTURE_EMISSIVE\n		emissiveColor = sRGBTransferEOTF( emissiveColor );\n	#endif\n	totalEmissiveRadiance *= emissiveColor.rgb;\n#endif", emissivemap_pars_fragment: "#ifdef USE_EMISSIVEMAP\n	uniform sampler2D emissiveMap;\n#endif", colorspace_fragment: "gl_FragColor = linearToOutputTexel( gl_FragColor );", colorspace_pars_fragment: "vec4 LinearTransferOETF( in vec4 value ) {\n	return value;\n}\nvec4 sRGBTransferEOTF( in vec4 value ) {\n	return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 sRGBTransferOETF( in vec4 value ) {\n	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}", envmap_fragment: "#ifdef USE_ENVMAP\n	#ifdef ENV_WORLDPOS\n		vec3 cameraToFrag;\n		if ( isOrthographic ) {\n			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n		} else {\n			cameraToFrag = normalize( vWorldPosition - cameraPosition );\n		}\n		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n		#ifdef ENVMAP_MODE_REFLECTION\n			vec3 reflectVec = reflect( cameraToFrag, worldNormal );\n		#else\n			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n		#endif\n	#else\n		vec3 reflectVec = vReflect;\n	#endif\n	#ifdef ENVMAP_TYPE_CUBE\n		vec4 envColor = textureCube( envMap, envMapRotation * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n	#else\n		vec4 envColor = vec4( 0.0 );\n	#endif\n	#ifdef ENVMAP_BLENDING_MULTIPLY\n		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n	#elif defined( ENVMAP_BLENDING_MIX )\n		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n	#elif defined( ENVMAP_BLENDING_ADD )\n		outgoingLight += envColor.xyz * specularStrength * reflectivity;\n	#endif\n#endif", envmap_common_pars_fragment: "#ifdef USE_ENVMAP\n	uniform float envMapIntensity;\n	uniform float flipEnvMap;\n	uniform mat3 envMapRotation;\n	#ifdef ENVMAP_TYPE_CUBE\n		uniform samplerCube envMap;\n	#else\n		uniform sampler2D envMap;\n	#endif\n	\n#endif", envmap_pars_fragment: "#ifdef USE_ENVMAP\n	uniform float reflectivity;\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n		#define ENV_WORLDPOS\n	#endif\n	#ifdef ENV_WORLDPOS\n		varying vec3 vWorldPosition;\n		uniform float refractionRatio;\n	#else\n		varying vec3 vReflect;\n	#endif\n#endif", envmap_pars_vertex: "#ifdef USE_ENVMAP\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n		#define ENV_WORLDPOS\n	#endif\n	#ifdef ENV_WORLDPOS\n		\n		varying vec3 vWorldPosition;\n	#else\n		varying vec3 vReflect;\n		uniform float refractionRatio;\n	#endif\n#endif", envmap_physical_pars_fragment: "#ifdef USE_ENVMAP\n	vec3 getIBLIrradiance( const in vec3 normal ) {\n		#ifdef ENVMAP_TYPE_CUBE_UV\n			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * worldNormal, 1.0 );\n			return PI * envMapColor.rgb * envMapIntensity;\n		#else\n			return vec3( 0.0 );\n		#endif\n	}\n	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {\n		#ifdef ENVMAP_TYPE_CUBE_UV\n			vec3 reflectVec = reflect( - viewDir, normal );\n			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * reflectVec, roughness );\n			return envMapColor.rgb * envMapIntensity;\n		#else\n			return vec3( 0.0 );\n		#endif\n	}\n	#ifdef USE_ANISOTROPY\n		vec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {\n			#ifdef ENVMAP_TYPE_CUBE_UV\n				vec3 bentNormal = cross( bitangent, viewDir );\n				bentNormal = normalize( cross( bentNormal, bitangent ) );\n				bentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );\n				return getIBLRadiance( viewDir, bentNormal, roughness );\n			#else\n				return vec3( 0.0 );\n			#endif\n		}\n	#endif\n#endif", envmap_vertex: "#ifdef USE_ENVMAP\n	#ifdef ENV_WORLDPOS\n		vWorldPosition = worldPosition.xyz;\n	#else\n		vec3 cameraToVertex;\n		if ( isOrthographic ) {\n			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n		} else {\n			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n		}\n		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n		#ifdef ENVMAP_MODE_REFLECTION\n			vReflect = reflect( cameraToVertex, worldNormal );\n		#else\n			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n		#endif\n	#endif\n#endif", fog_vertex: "#ifdef USE_FOG\n	vFogDepth = - mvPosition.z;\n#endif", fog_pars_vertex: "#ifdef USE_FOG\n	varying float vFogDepth;\n#endif", fog_fragment: "#ifdef USE_FOG\n	#ifdef FOG_EXP2\n		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n	#else\n		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n	#endif\n	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif", fog_pars_fragment: "#ifdef USE_FOG\n	uniform vec3 fogColor;\n	varying float vFogDepth;\n	#ifdef FOG_EXP2\n		uniform float fogDensity;\n	#else\n		uniform float fogNear;\n		uniform float fogFar;\n	#endif\n#endif", gradientmap_pars_fragment: "#ifdef USE_GRADIENTMAP\n	uniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n	float dotNL = dot( normal, lightDirection );\n	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n	#ifdef USE_GRADIENTMAP\n		return vec3( texture2D( gradientMap, coord ).r );\n	#else\n		vec2 fw = fwidth( coord ) * 0.5;\n		return mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );\n	#endif\n}", lightmap_pars_fragment: "#ifdef USE_LIGHTMAP\n	uniform sampler2D lightMap;\n	uniform float lightMapIntensity;\n#endif", lights_lambert_fragment: "LambertMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularStrength = specularStrength;", lights_lambert_pars_fragment: "varying vec3 vViewPosition;\nstruct LambertMaterial {\n	vec3 diffuseColor;\n	float specularStrength;\n};\nvoid RE_Direct_Lambert( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {\n	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );\n	vec3 irradiance = dotNL * directLight.color;\n	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct				RE_Direct_Lambert\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_Lambert", lights_pars_begin: "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\n#if defined( USE_LIGHT_PROBES )\n	uniform vec3 lightProbe[ 9 ];\n#endif\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n	float x = normal.x, y = normal.y, z = normal.z;\n	vec3 result = shCoefficients[ 0 ] * 0.886227;\n	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n	return result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {\n	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n	return irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n	vec3 irradiance = ambientLightColor;\n	return irradiance;\n}\nfloat getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n	float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n	if ( cutoffDistance > 0.0 ) {\n		distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n	}\n	return distanceFalloff;\n}\nfloat getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {\n	return smoothstep( coneCosine, penumbraCosine, angleCosine );\n}\n#if NUM_DIR_LIGHTS > 0\n	struct DirectionalLight {\n		vec3 direction;\n		vec3 color;\n	};\n	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n	void getDirectionalLightInfo( const in DirectionalLight directionalLight, out IncidentLight light ) {\n		light.color = directionalLight.color;\n		light.direction = directionalLight.direction;\n		light.visible = true;\n	}\n#endif\n#if NUM_POINT_LIGHTS > 0\n	struct PointLight {\n		vec3 position;\n		vec3 color;\n		float distance;\n		float decay;\n	};\n	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n	void getPointLightInfo( const in PointLight pointLight, const in vec3 geometryPosition, out IncidentLight light ) {\n		vec3 lVector = pointLight.position - geometryPosition;\n		light.direction = normalize( lVector );\n		float lightDistance = length( lVector );\n		light.color = pointLight.color;\n		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );\n		light.visible = ( light.color != vec3( 0.0 ) );\n	}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n	struct SpotLight {\n		vec3 position;\n		vec3 direction;\n		vec3 color;\n		float distance;\n		float decay;\n		float coneCos;\n		float penumbraCos;\n	};\n	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n	void getSpotLightInfo( const in SpotLight spotLight, const in vec3 geometryPosition, out IncidentLight light ) {\n		vec3 lVector = spotLight.position - geometryPosition;\n		light.direction = normalize( lVector );\n		float angleCos = dot( light.direction, spotLight.direction );\n		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n		if ( spotAttenuation > 0.0 ) {\n			float lightDistance = length( lVector );\n			light.color = spotLight.color * spotAttenuation;\n			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );\n			light.visible = ( light.color != vec3( 0.0 ) );\n		} else {\n			light.color = vec3( 0.0 );\n			light.visible = false;\n		}\n	}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n	struct RectAreaLight {\n		vec3 color;\n		vec3 position;\n		vec3 halfWidth;\n		vec3 halfHeight;\n	};\n	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;\n	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n	struct HemisphereLight {\n		vec3 direction;\n		vec3 skyColor;\n		vec3 groundColor;\n	};\n	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {\n		float dotNL = dot( normal, hemiLight.direction );\n		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n		return irradiance;\n	}\n#endif", lights_toon_fragment: "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;", lights_toon_pars_fragment: "varying vec3 vViewPosition;\nstruct ToonMaterial {\n	vec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n	vec3 irradiance = getGradientIrradiance( geometryNormal, directLight.direction ) * directLight.color;\n	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct				RE_Direct_Toon\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon", lights_phong_fragment: "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;", lights_phong_pars_fragment: "varying vec3 vViewPosition;\nstruct BlinnPhongMaterial {\n	vec3 diffuseColor;\n	vec3 specularColor;\n	float specularShininess;\n	float specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );\n	vec3 irradiance = dotNL * directLight.color;\n	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometryViewDir, geometryNormal, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct				RE_Direct_BlinnPhong\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong", lights_physical_fragment: "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( nonPerturbedNormal ) ), abs( dFdy( nonPerturbedNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;\nmaterial.roughness = min( material.roughness, 1.0 );\n#ifdef IOR\n	material.ior = ior;\n	#ifdef USE_SPECULAR\n		float specularIntensityFactor = specularIntensity;\n		vec3 specularColorFactor = specularColor;\n		#ifdef USE_SPECULAR_COLORMAP\n			specularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;\n		#endif\n		#ifdef USE_SPECULAR_INTENSITYMAP\n			specularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;\n		#endif\n		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );\n	#else\n		float specularIntensityFactor = 1.0;\n		vec3 specularColorFactor = vec3( 1.0 );\n		material.specularF90 = 1.0;\n	#endif\n	material.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );\n#else\n	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );\n	material.specularF90 = 1.0;\n#endif\n#ifdef USE_CLEARCOAT\n	material.clearcoat = clearcoat;\n	material.clearcoatRoughness = clearcoatRoughness;\n	material.clearcoatF0 = vec3( 0.04 );\n	material.clearcoatF90 = 1.0;\n	#ifdef USE_CLEARCOATMAP\n		material.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;\n	#endif\n	#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;\n	#endif\n	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n	material.clearcoatRoughness += geometryRoughness;\n	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_DISPERSION\n	material.dispersion = dispersion;\n#endif\n#ifdef USE_IRIDESCENCE\n	material.iridescence = iridescence;\n	material.iridescenceIOR = iridescenceIOR;\n	#ifdef USE_IRIDESCENCEMAP\n		material.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;\n	#endif\n	#ifdef USE_IRIDESCENCE_THICKNESSMAP\n		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;\n	#else\n		material.iridescenceThickness = iridescenceThicknessMaximum;\n	#endif\n#endif\n#ifdef USE_SHEEN\n	material.sheenColor = sheenColor;\n	#ifdef USE_SHEEN_COLORMAP\n		material.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;\n	#endif\n	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );\n	#ifdef USE_SHEEN_ROUGHNESSMAP\n		material.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;\n	#endif\n#endif\n#ifdef USE_ANISOTROPY\n	#ifdef USE_ANISOTROPYMAP\n		mat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );\n		vec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;\n		vec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;\n	#else\n		vec2 anisotropyV = anisotropyVector;\n	#endif\n	material.anisotropy = length( anisotropyV );\n	if( material.anisotropy == 0.0 ) {\n		anisotropyV = vec2( 1.0, 0.0 );\n	} else {\n		anisotropyV /= material.anisotropy;\n		material.anisotropy = saturate( material.anisotropy );\n	}\n	material.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );\n	material.anisotropyT = tbn[ 0 ] * anisotropyV.x + tbn[ 1 ] * anisotropyV.y;\n	material.anisotropyB = tbn[ 1 ] * anisotropyV.x - tbn[ 0 ] * anisotropyV.y;\n#endif", lights_physical_pars_fragment: "struct PhysicalMaterial {\n	vec3 diffuseColor;\n	float roughness;\n	vec3 specularColor;\n	float specularF90;\n	float dispersion;\n	#ifdef USE_CLEARCOAT\n		float clearcoat;\n		float clearcoatRoughness;\n		vec3 clearcoatF0;\n		float clearcoatF90;\n	#endif\n	#ifdef USE_IRIDESCENCE\n		float iridescence;\n		float iridescenceIOR;\n		float iridescenceThickness;\n		vec3 iridescenceFresnel;\n		vec3 iridescenceF0;\n	#endif\n	#ifdef USE_SHEEN\n		vec3 sheenColor;\n		float sheenRoughness;\n	#endif\n	#ifdef IOR\n		float ior;\n	#endif\n	#ifdef USE_TRANSMISSION\n		float transmission;\n		float transmissionAlpha;\n		float thickness;\n		float attenuationDistance;\n		vec3 attenuationColor;\n	#endif\n	#ifdef USE_ANISOTROPY\n		float anisotropy;\n		float alphaT;\n		vec3 anisotropyT;\n		vec3 anisotropyB;\n	#endif\n};\nvec3 clearcoatSpecularDirect = vec3( 0.0 );\nvec3 clearcoatSpecularIndirect = vec3( 0.0 );\nvec3 sheenSpecularDirect = vec3( 0.0 );\nvec3 sheenSpecularIndirect = vec3(0.0 );\nvec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {\n    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );\n    float x2 = x * x;\n    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );\n    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );\n}\nfloat V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n	float a2 = pow2( alpha );\n	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n	return 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n	float a2 = pow2( alpha );\n	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n	return RECIPROCAL_PI * a2 / pow2( denom );\n}\n#ifdef USE_ANISOTROPY\n	float V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {\n		float gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );\n		float gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );\n		float v = 0.5 / ( gv + gl );\n		return saturate(v);\n	}\n	float D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {\n		float a2 = alphaT * alphaB;\n		highp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );\n		highp float v2 = dot( v, v );\n		float w2 = a2 / v2;\n		return RECIPROCAL_PI * a2 * pow2 ( w2 );\n	}\n#endif\n#ifdef USE_CLEARCOAT\n	vec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {\n		vec3 f0 = material.clearcoatF0;\n		float f90 = material.clearcoatF90;\n		float roughness = material.clearcoatRoughness;\n		float alpha = pow2( roughness );\n		vec3 halfDir = normalize( lightDir + viewDir );\n		float dotNL = saturate( dot( normal, lightDir ) );\n		float dotNV = saturate( dot( normal, viewDir ) );\n		float dotNH = saturate( dot( normal, halfDir ) );\n		float dotVH = saturate( dot( viewDir, halfDir ) );\n		vec3 F = F_Schlick( f0, f90, dotVH );\n		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n		float D = D_GGX( alpha, dotNH );\n		return F * ( V * D );\n	}\n#endif\nvec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {\n	vec3 f0 = material.specularColor;\n	float f90 = material.specularF90;\n	float roughness = material.roughness;\n	float alpha = pow2( roughness );\n	vec3 halfDir = normalize( lightDir + viewDir );\n	float dotNL = saturate( dot( normal, lightDir ) );\n	float dotNV = saturate( dot( normal, viewDir ) );\n	float dotNH = saturate( dot( normal, halfDir ) );\n	float dotVH = saturate( dot( viewDir, halfDir ) );\n	vec3 F = F_Schlick( f0, f90, dotVH );\n	#ifdef USE_IRIDESCENCE\n		F = mix( F, material.iridescenceFresnel, material.iridescence );\n	#endif\n	#ifdef USE_ANISOTROPY\n		float dotTL = dot( material.anisotropyT, lightDir );\n		float dotTV = dot( material.anisotropyT, viewDir );\n		float dotTH = dot( material.anisotropyT, halfDir );\n		float dotBL = dot( material.anisotropyB, lightDir );\n		float dotBV = dot( material.anisotropyB, viewDir );\n		float dotBH = dot( material.anisotropyB, halfDir );\n		float V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );\n		float D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );\n	#else\n		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n		float D = D_GGX( alpha, dotNH );\n	#endif\n	return F * ( V * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n	const float LUT_SIZE = 64.0;\n	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n	const float LUT_BIAS = 0.5 / LUT_SIZE;\n	float dotNV = saturate( dot( N, V ) );\n	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n	uv = uv * LUT_SCALE + LUT_BIAS;\n	return uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n	float l = length( f );\n	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n	float x = dot( v1, v2 );\n	float y = abs( x );\n	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n	float b = 3.4175940 + ( 4.1616724 + y ) * y;\n	float v = a / b;\n	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n	return cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n	vec3 lightNormal = cross( v1, v2 );\n	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n	vec3 T1, T2;\n	T1 = normalize( V - N * dot( V, N ) );\n	T2 = - cross( N, T1 );\n	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n	vec3 coords[ 4 ];\n	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n	coords[ 0 ] = normalize( coords[ 0 ] );\n	coords[ 1 ] = normalize( coords[ 1 ] );\n	coords[ 2 ] = normalize( coords[ 2 ] );\n	coords[ 3 ] = normalize( coords[ 3 ] );\n	vec3 vectorFormFactor = vec3( 0.0 );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n	return vec3( result );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie( float roughness, float dotNH ) {\n	float alpha = pow2( roughness );\n	float invAlpha = 1.0 / alpha;\n	float cos2h = dotNH * dotNH;\n	float sin2h = max( 1.0 - cos2h, 0.0078125 );\n	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );\n}\nfloat V_Neubelt( float dotNV, float dotNL ) {\n	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );\n}\nvec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {\n	vec3 halfDir = normalize( lightDir + viewDir );\n	float dotNL = saturate( dot( normal, lightDir ) );\n	float dotNV = saturate( dot( normal, viewDir ) );\n	float dotNH = saturate( dot( normal, halfDir ) );\n	float D = D_Charlie( sheenRoughness, dotNH );\n	float V = V_Neubelt( dotNV, dotNL );\n	return sheenColor * ( D * V );\n}\n#endif\nfloat IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n	float dotNV = saturate( dot( normal, viewDir ) );\n	float r2 = roughness * roughness;\n	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;\n	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;\n	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );\n	return saturate( DG * RECIPROCAL_PI );\n}\nvec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n	float dotNV = saturate( dot( normal, viewDir ) );\n	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n	vec4 r = roughness * c0 + c1;\n	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;\n	return fab;\n}\nvec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {\n	vec2 fab = DFGApprox( normal, viewDir, roughness );\n	return specularColor * fab.x + specularF90 * fab.y;\n}\n#ifdef USE_IRIDESCENCE\nvoid computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#else\nvoid computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#endif\n	vec2 fab = DFGApprox( normal, viewDir, roughness );\n	#ifdef USE_IRIDESCENCE\n		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );\n	#else\n		vec3 Fr = specularColor;\n	#endif\n	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;\n	float Ess = fab.x + fab.y;\n	float Ems = 1.0 - Ess;\n	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n	singleScatter += FssEss;\n	multiScatter += Fms * Ems;\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n		vec3 normal = geometryNormal;\n		vec3 viewDir = geometryViewDir;\n		vec3 position = geometryPosition;\n		vec3 lightPos = rectAreaLight.position;\n		vec3 halfWidth = rectAreaLight.halfWidth;\n		vec3 halfHeight = rectAreaLight.halfHeight;\n		vec3 lightColor = rectAreaLight.color;\n		float roughness = material.roughness;\n		vec3 rectCoords[ 4 ];\n		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n		vec2 uv = LTC_Uv( normal, viewDir, roughness );\n		vec4 t1 = texture2D( ltc_1, uv );\n		vec4 t2 = texture2D( ltc_2, uv );\n		mat3 mInv = mat3(\n			vec3( t1.x, 0, t1.y ),\n			vec3(    0, 1,    0 ),\n			vec3( t1.z, 0, t1.w )\n		);\n		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n	}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );\n	vec3 irradiance = dotNL * directLight.color;\n	#ifdef USE_CLEARCOAT\n		float dotNLcc = saturate( dot( geometryClearcoatNormal, directLight.direction ) );\n		vec3 ccIrradiance = dotNLcc * directLight.color;\n		clearcoatSpecularDirect += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometryViewDir, geometryClearcoatNormal, material );\n	#endif\n	#ifdef USE_SHEEN\n		sheenSpecularDirect += irradiance * BRDF_Sheen( directLight.direction, geometryViewDir, geometryNormal, material.sheenColor, material.sheenRoughness );\n	#endif\n	reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometryViewDir, geometryNormal, material );\n	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n	#ifdef USE_CLEARCOAT\n		clearcoatSpecularIndirect += clearcoatRadiance * EnvironmentBRDF( geometryClearcoatNormal, geometryViewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n	#endif\n	#ifdef USE_SHEEN\n		sheenSpecularIndirect += irradiance * material.sheenColor * IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness );\n	#endif\n	vec3 singleScattering = vec3( 0.0 );\n	vec3 multiScattering = vec3( 0.0 );\n	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n	#ifdef USE_IRIDESCENCE\n		computeMultiscatteringIridescence( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );\n	#else\n		computeMultiscattering( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );\n	#endif\n	vec3 totalScattering = singleScattering + multiScattering;\n	vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );\n	reflectedLight.indirectSpecular += radiance * singleScattering;\n	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct				RE_Direct_Physical\n#define RE_Direct_RectArea		RE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular		RE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}", lights_fragment_begin: "\nvec3 geometryPosition = - vViewPosition;\nvec3 geometryNormal = normal;\nvec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\nvec3 geometryClearcoatNormal = vec3( 0.0 );\n#ifdef USE_CLEARCOAT\n	geometryClearcoatNormal = clearcoatNormal;\n#endif\n#ifdef USE_IRIDESCENCE\n	float dotNVi = saturate( dot( normal, geometryViewDir ) );\n	if ( material.iridescenceThickness == 0.0 ) {\n		material.iridescence = 0.0;\n	} else {\n		material.iridescence = saturate( material.iridescence );\n	}\n	if ( material.iridescence > 0.0 ) {\n		material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );\n		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );\n	}\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n	PointLight pointLight;\n	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n	PointLightShadow pointLightShadow;\n	#endif\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n		pointLight = pointLights[ i ];\n		getPointLightInfo( pointLight, geometryPosition, directLight );\n		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n		pointLightShadow = pointLightShadows[ i ];\n		directLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowIntensity, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n	SpotLight spotLight;\n	vec4 spotColor;\n	vec3 spotLightCoord;\n	bool inSpotLightMap;\n	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n	SpotLightShadow spotLightShadow;\n	#endif\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n		spotLight = spotLights[ i ];\n		getSpotLightInfo( spotLight, geometryPosition, directLight );\n		#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\n		#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX\n		#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n		#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS\n		#else\n		#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\n		#endif\n		#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )\n			spotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;\n			inSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );\n			spotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );\n			directLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;\n		#endif\n		#undef SPOT_LIGHT_MAP_INDEX\n		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n		spotLightShadow = spotLightShadows[ i ];\n		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowIntensity, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n	DirectionalLight directionalLight;\n	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n	DirectionalLightShadow directionalLightShadow;\n	#endif\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n		directionalLight = directionalLights[ i ];\n		getDirectionalLightInfo( directionalLight, directLight );\n		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n		directionalLightShadow = directionalLightShadows[ i ];\n		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowIntensity, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n	RectAreaLight rectAreaLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n		rectAreaLight = rectAreaLights[ i ];\n		RE_Direct_RectArea( rectAreaLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n	vec3 iblIrradiance = vec3( 0.0 );\n	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n	#if defined( USE_LIGHT_PROBES )\n		irradiance += getLightProbeIrradiance( lightProbe, geometryNormal );\n	#endif\n	#if ( NUM_HEMI_LIGHTS > 0 )\n		#pragma unroll_loop_start\n		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );\n		}\n		#pragma unroll_loop_end\n	#endif\n#endif\n#if defined( RE_IndirectSpecular )\n	vec3 radiance = vec3( 0.0 );\n	vec3 clearcoatRadiance = vec3( 0.0 );\n#endif", lights_fragment_maps: "#if defined( RE_IndirectDiffuse )\n	#ifdef USE_LIGHTMAP\n		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );\n		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n		irradiance += lightMapIrradiance;\n	#endif\n	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n		iblIrradiance += getIBLIrradiance( geometryNormal );\n	#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n	#ifdef USE_ANISOTROPY\n		radiance += getIBLAnisotropyRadiance( geometryViewDir, geometryNormal, material.roughness, material.anisotropyB, material.anisotropy );\n	#else\n		radiance += getIBLRadiance( geometryViewDir, geometryNormal, material.roughness );\n	#endif\n	#ifdef USE_CLEARCOAT\n		clearcoatRadiance += getIBLRadiance( geometryViewDir, geometryClearcoatNormal, material.clearcoatRoughness );\n	#endif\n#endif", lights_fragment_end: "#if defined( RE_IndirectDiffuse )\n	RE_IndirectDiffuse( irradiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n#endif", logdepthbuf_fragment: "#if defined( USE_LOGDEPTHBUF )\n	gl_FragDepth = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif", logdepthbuf_pars_fragment: "#if defined( USE_LOGDEPTHBUF )\n	uniform float logDepthBufFC;\n	varying float vFragDepth;\n	varying float vIsPerspective;\n#endif", logdepthbuf_pars_vertex: "#ifdef USE_LOGDEPTHBUF\n	varying float vFragDepth;\n	varying float vIsPerspective;\n#endif", logdepthbuf_vertex: "#ifdef USE_LOGDEPTHBUF\n	vFragDepth = 1.0 + gl_Position.w;\n	vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n#endif", map_fragment: "#ifdef USE_MAP\n	vec4 sampledDiffuseColor = texture2D( map, vMapUv );\n	#ifdef DECODE_VIDEO_TEXTURE\n		sampledDiffuseColor = sRGBTransferEOTF( sampledDiffuseColor );\n	#endif\n	diffuseColor *= sampledDiffuseColor;\n#endif", map_pars_fragment: "#ifdef USE_MAP\n	uniform sampler2D map;\n#endif", map_particle_fragment: "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n	#if defined( USE_POINTS_UV )\n		vec2 uv = vUv;\n	#else\n		vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n	#endif\n#endif\n#ifdef USE_MAP\n	diffuseColor *= texture2D( map, uv );\n#endif\n#ifdef USE_ALPHAMAP\n	diffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif", map_particle_pars_fragment: "#if defined( USE_POINTS_UV )\n	varying vec2 vUv;\n#else\n	#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n		uniform mat3 uvTransform;\n	#endif\n#endif\n#ifdef USE_MAP\n	uniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n	uniform sampler2D alphaMap;\n#endif", metalnessmap_fragment: "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n	vec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );\n	metalnessFactor *= texelMetalness.b;\n#endif", metalnessmap_pars_fragment: "#ifdef USE_METALNESSMAP\n	uniform sampler2D metalnessMap;\n#endif", morphinstance_vertex: "#ifdef USE_INSTANCING_MORPH\n	float morphTargetInfluences[ MORPHTARGETS_COUNT ];\n	float morphTargetBaseInfluence = texelFetch( morphTexture, ivec2( 0, gl_InstanceID ), 0 ).r;\n	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n		morphTargetInfluences[i] =  texelFetch( morphTexture, ivec2( i + 1, gl_InstanceID ), 0 ).r;\n	}\n#endif", morphcolor_vertex: "#if defined( USE_MORPHCOLORS )\n	vColor *= morphTargetBaseInfluence;\n	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n		#if defined( USE_COLOR_ALPHA )\n			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];\n		#elif defined( USE_COLOR )\n			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];\n		#endif\n	}\n#endif", morphnormal_vertex: "#ifdef USE_MORPHNORMALS\n	objectNormal *= morphTargetBaseInfluence;\n	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n		if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];\n	}\n#endif", morphtarget_pars_vertex: "#ifdef USE_MORPHTARGETS\n	#ifndef USE_INSTANCING_MORPH\n		uniform float morphTargetBaseInfluence;\n		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];\n	#endif\n	uniform sampler2DArray morphTargetsTexture;\n	uniform ivec2 morphTargetsTextureSize;\n	vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {\n		int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;\n		int y = texelIndex / morphTargetsTextureSize.x;\n		int x = texelIndex - y * morphTargetsTextureSize.x;\n		ivec3 morphUV = ivec3( x, y, morphTargetIndex );\n		return texelFetch( morphTargetsTexture, morphUV, 0 );\n	}\n#endif", morphtarget_vertex: "#ifdef USE_MORPHTARGETS\n	transformed *= morphTargetBaseInfluence;\n	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n		if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];\n	}\n#endif", normal_fragment_begin: "float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n	vec3 fdx = dFdx( vViewPosition );\n	vec3 fdy = dFdy( vViewPosition );\n	vec3 normal = normalize( cross( fdx, fdy ) );\n#else\n	vec3 normal = normalize( vNormal );\n	#ifdef DOUBLE_SIDED\n		normal *= faceDirection;\n	#endif\n#endif\n#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )\n	#ifdef USE_TANGENT\n		mat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );\n	#else\n		mat3 tbn = getTangentFrame( - vViewPosition, normal,\n		#if defined( USE_NORMALMAP )\n			vNormalMapUv\n		#elif defined( USE_CLEARCOAT_NORMALMAP )\n			vClearcoatNormalMapUv\n		#else\n			vUv\n		#endif\n		);\n	#endif\n	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )\n		tbn[0] *= faceDirection;\n		tbn[1] *= faceDirection;\n	#endif\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n	#ifdef USE_TANGENT\n		mat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );\n	#else\n		mat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );\n	#endif\n	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )\n		tbn2[0] *= faceDirection;\n		tbn2[1] *= faceDirection;\n	#endif\n#endif\nvec3 nonPerturbedNormal = normal;", normal_fragment_maps: "#ifdef USE_NORMALMAP_OBJECTSPACE\n	normal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;\n	#ifdef FLIP_SIDED\n		normal = - normal;\n	#endif\n	#ifdef DOUBLE_SIDED\n		normal = normal * faceDirection;\n	#endif\n	normal = normalize( normalMatrix * normal );\n#elif defined( USE_NORMALMAP_TANGENTSPACE )\n	vec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;\n	mapN.xy *= normalScale;\n	normal = normalize( tbn * mapN );\n#elif defined( USE_BUMPMAP )\n	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif", normal_pars_fragment: "#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n	#ifdef USE_TANGENT\n		varying vec3 vTangent;\n		varying vec3 vBitangent;\n	#endif\n#endif", normal_pars_vertex: "#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n	#ifdef USE_TANGENT\n		varying vec3 vTangent;\n		varying vec3 vBitangent;\n	#endif\n#endif", normal_vertex: "#ifndef FLAT_SHADED\n	vNormal = normalize( transformedNormal );\n	#ifdef USE_TANGENT\n		vTangent = normalize( transformedTangent );\n		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n	#endif\n#endif", normalmap_pars_fragment: "#ifdef USE_NORMALMAP\n	uniform sampler2D normalMap;\n	uniform vec2 normalScale;\n#endif\n#ifdef USE_NORMALMAP_OBJECTSPACE\n	uniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )\n	mat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {\n		vec3 q0 = dFdx( eye_pos.xyz );\n		vec3 q1 = dFdy( eye_pos.xyz );\n		vec2 st0 = dFdx( uv.st );\n		vec2 st1 = dFdy( uv.st );\n		vec3 N = surf_norm;\n		vec3 q1perp = cross( q1, N );\n		vec3 q0perp = cross( N, q0 );\n		vec3 T = q1perp * st0.x + q0perp * st1.x;\n		vec3 B = q1perp * st0.y + q0perp * st1.y;\n		float det = max( dot( T, T ), dot( B, B ) );\n		float scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );\n		return mat3( T * scale, B * scale, N );\n	}\n#endif", clearcoat_normal_fragment_begin: "#ifdef USE_CLEARCOAT\n	vec3 clearcoatNormal = nonPerturbedNormal;\n#endif", clearcoat_normal_fragment_maps: "#ifdef USE_CLEARCOAT_NORMALMAP\n	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;\n	clearcoatMapN.xy *= clearcoatNormalScale;\n	clearcoatNormal = normalize( tbn2 * clearcoatMapN );\n#endif", clearcoat_pars_fragment: "#ifdef USE_CLEARCOATMAP\n	uniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n	uniform sampler2D clearcoatNormalMap;\n	uniform vec2 clearcoatNormalScale;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n	uniform sampler2D clearcoatRoughnessMap;\n#endif", iridescence_pars_fragment: "#ifdef USE_IRIDESCENCEMAP\n	uniform sampler2D iridescenceMap;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n	uniform sampler2D iridescenceThicknessMap;\n#endif", opaque_fragment: "#ifdef OPAQUE\ndiffuseColor.a = 1.0;\n#endif\n#ifdef USE_TRANSMISSION\ndiffuseColor.a *= material.transmissionAlpha;\n#endif\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );", packing: "vec3 packNormalToRGB( const in vec3 normal ) {\n	return normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n	return 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;const float ShiftRight8 = 1. / 256.;\nconst float Inv255 = 1. / 255.;\nconst vec4 PackFactors = vec4( 1.0, 256.0, 256.0 * 256.0, 256.0 * 256.0 * 256.0 );\nconst vec2 UnpackFactors2 = vec2( UnpackDownscale, 1.0 / PackFactors.g );\nconst vec3 UnpackFactors3 = vec3( UnpackDownscale / PackFactors.rg, 1.0 / PackFactors.b );\nconst vec4 UnpackFactors4 = vec4( UnpackDownscale / PackFactors.rgb, 1.0 / PackFactors.a );\nvec4 packDepthToRGBA( const in float v ) {\n	if( v <= 0.0 )\n		return vec4( 0., 0., 0., 0. );\n	if( v >= 1.0 )\n		return vec4( 1., 1., 1., 1. );\n	float vuf;\n	float af = modf( v * PackFactors.a, vuf );\n	float bf = modf( vuf * ShiftRight8, vuf );\n	float gf = modf( vuf * ShiftRight8, vuf );\n	return vec4( vuf * Inv255, gf * PackUpscale, bf * PackUpscale, af );\n}\nvec3 packDepthToRGB( const in float v ) {\n	if( v <= 0.0 )\n		return vec3( 0., 0., 0. );\n	if( v >= 1.0 )\n		return vec3( 1., 1., 1. );\n	float vuf;\n	float bf = modf( v * PackFactors.b, vuf );\n	float gf = modf( vuf * ShiftRight8, vuf );\n	return vec3( vuf * Inv255, gf * PackUpscale, bf );\n}\nvec2 packDepthToRG( const in float v ) {\n	if( v <= 0.0 )\n		return vec2( 0., 0. );\n	if( v >= 1.0 )\n		return vec2( 1., 1. );\n	float vuf;\n	float gf = modf( v * 256., vuf );\n	return vec2( vuf * Inv255, gf );\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n	return dot( v, UnpackFactors4 );\n}\nfloat unpackRGBToDepth( const in vec3 v ) {\n	return dot( v, UnpackFactors3 );\n}\nfloat unpackRGToDepth( const in vec2 v ) {\n	return v.r * UnpackFactors2.r + v.g * UnpackFactors2.g;\n}\nvec4 pack2HalfToRGBA( const in vec2 v ) {\n	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );\n	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );\n}\nvec2 unpackRGBATo2Half( const in vec4 v ) {\n	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n	return ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {\n	return depth * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {\n	return ( near * far ) / ( ( far - near ) * depth - far );\n}", premultiplied_alpha_fragment: "#ifdef PREMULTIPLIED_ALPHA\n	gl_FragColor.rgb *= gl_FragColor.a;\n#endif", project_vertex: "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_BATCHING\n	mvPosition = batchingMatrix * mvPosition;\n#endif\n#ifdef USE_INSTANCING\n	mvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;", dithering_fragment: "#ifdef DITHERING\n	gl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif", dithering_pars_fragment: "#ifdef DITHERING\n	vec3 dithering( vec3 color ) {\n		float grid_position = rand( gl_FragCoord.xy );\n		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n		return color + dither_shift_RGB;\n	}\n#endif", roughnessmap_fragment: "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n	vec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );\n	roughnessFactor *= texelRoughness.g;\n#endif", roughnessmap_pars_fragment: "#ifdef USE_ROUGHNESSMAP\n	uniform sampler2D roughnessMap;\n#endif", shadowmap_pars_fragment: "#if NUM_SPOT_LIGHT_COORDS > 0\n	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];\n#endif\n#if NUM_SPOT_LIGHT_MAPS > 0\n	uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];\n#endif\n#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n		struct DirectionalLightShadow {\n			float shadowIntensity;\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n		struct SpotLightShadow {\n			float shadowIntensity;\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n		struct PointLightShadow {\n			float shadowIntensity;\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n			float shadowCameraNear;\n			float shadowCameraFar;\n		};\n		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n	#endif\n	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n	}\n	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n		return unpackRGBATo2Half( texture2D( shadow, uv ) );\n	}\n	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n		float occlusion = 1.0;\n		vec2 distribution = texture2DDistribution( shadow, uv );\n		float hard_shadow = step( compare , distribution.x );\n		if (hard_shadow != 1.0 ) {\n			float distance = compare - distribution.x ;\n			float variance = max( 0.00000, distribution.y * distribution.y );\n			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n		}\n		return occlusion;\n	}\n	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n		float shadow = 1.0;\n		shadowCoord.xyz /= shadowCoord.w;\n		shadowCoord.z += shadowBias;\n		bool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;\n		bool frustumTest = inFrustum && shadowCoord.z <= 1.0;\n		if ( frustumTest ) {\n		#if defined( SHADOWMAP_TYPE_PCF )\n			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n			float dx0 = - texelSize.x * shadowRadius;\n			float dy0 = - texelSize.y * shadowRadius;\n			float dx1 = + texelSize.x * shadowRadius;\n			float dy1 = + texelSize.y * shadowRadius;\n			float dx2 = dx0 / 2.0;\n			float dy2 = dy0 / 2.0;\n			float dx3 = dx1 / 2.0;\n			float dy3 = dy1 / 2.0;\n			shadow = (\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n			) * ( 1.0 / 17.0 );\n		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n			float dx = texelSize.x;\n			float dy = texelSize.y;\n			vec2 uv = shadowCoord.xy;\n			vec2 f = fract( uv * shadowMapSize + 0.5 );\n			uv -= f * texelSize;\n			shadow = (\n				texture2DCompare( shadowMap, uv, shadowCoord.z ) +\n				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),\n					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n					 f.x ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),\n					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n					 f.x ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),\n					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n					 f.y ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),\n					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n					 f.y ) +\n				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),\n						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n						  f.x ),\n					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),\n						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n						  f.x ),\n					 f.y )\n			) * ( 1.0 / 9.0 );\n		#elif defined( SHADOWMAP_TYPE_VSM )\n			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n		#else\n			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n		#endif\n		}\n		return mix( 1.0, shadow, shadowIntensity );\n	}\n	vec2 cubeToUV( vec3 v, float texelSizeY ) {\n		vec3 absV = abs( v );\n		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n		absV *= scaleToCube;\n		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n		vec2 planar = v.xy;\n		float almostATexel = 1.5 * texelSizeY;\n		float almostOne = 1.0 - almostATexel;\n		if ( absV.z >= almostOne ) {\n			if ( v.z > 0.0 )\n				planar.x = 4.0 - v.x;\n		} else if ( absV.x >= almostOne ) {\n			float signX = sign( v.x );\n			planar.x = v.z * signX + 2.0 * signX;\n		} else if ( absV.y >= almostOne ) {\n			float signY = sign( v.y );\n			planar.x = v.x + 2.0 * signY + 2.0;\n			planar.y = v.z * signY - 2.0;\n		}\n		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n	}\n	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n		float shadow = 1.0;\n		vec3 lightToPosition = shadowCoord.xyz;\n		\n		float lightToPositionLength = length( lightToPosition );\n		if ( lightToPositionLength - shadowCameraFar <= 0.0 && lightToPositionLength - shadowCameraNear >= 0.0 ) {\n			float dp = ( lightToPositionLength - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );			dp += shadowBias;\n			vec3 bd3D = normalize( lightToPosition );\n			vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n			#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n				vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n				shadow = (\n					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n					texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n				) * ( 1.0 / 9.0 );\n			#else\n				shadow = texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n			#endif\n		}\n		return mix( 1.0, shadow, shadowIntensity );\n	}\n#endif", shadowmap_pars_vertex: "#if NUM_SPOT_LIGHT_COORDS > 0\n	uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];\n	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];\n#endif\n#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n		struct DirectionalLightShadow {\n			float shadowIntensity;\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n		struct SpotLightShadow {\n			float shadowIntensity;\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n		struct PointLightShadow {\n			float shadowIntensity;\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n			float shadowCameraNear;\n			float shadowCameraFar;\n		};\n		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n	#endif\n#endif", shadowmap_vertex: "#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )\n	vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n	vec4 shadowWorldPosition;\n#endif\n#if defined( USE_SHADOWMAP )\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n		#pragma unroll_loop_start\n		for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n			vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n		}\n		#pragma unroll_loop_end\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n		#pragma unroll_loop_start\n		for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n			vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n		}\n		#pragma unroll_loop_end\n	#endif\n#endif\n#if NUM_SPOT_LIGHT_COORDS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {\n		shadowWorldPosition = worldPosition;\n		#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n			shadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;\n		#endif\n		vSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;\n	}\n	#pragma unroll_loop_end\n#endif", shadowmask_pars_fragment: "float getShadowMask() {\n	float shadow = 1.0;\n	#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n	DirectionalLightShadow directionalLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n		directionalLight = directionalLightShadows[ i ];\n		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowIntensity, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n	SpotLightShadow spotLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n		spotLight = spotLightShadows[ i ];\n		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowIntensity, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n	PointLightShadow pointLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n		pointLight = pointLightShadows[ i ];\n		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowIntensity, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#endif\n	return shadow;\n}", skinbase_vertex: "#ifdef USE_SKINNING\n	mat4 boneMatX = getBoneMatrix( skinIndex.x );\n	mat4 boneMatY = getBoneMatrix( skinIndex.y );\n	mat4 boneMatZ = getBoneMatrix( skinIndex.z );\n	mat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif", skinning_pars_vertex: "#ifdef USE_SKINNING\n	uniform mat4 bindMatrix;\n	uniform mat4 bindMatrixInverse;\n	uniform highp sampler2D boneTexture;\n	mat4 getBoneMatrix( const in float i ) {\n		int size = textureSize( boneTexture, 0 ).x;\n		int j = int( i ) * 4;\n		int x = j % size;\n		int y = j / size;\n		vec4 v1 = texelFetch( boneTexture, ivec2( x, y ), 0 );\n		vec4 v2 = texelFetch( boneTexture, ivec2( x + 1, y ), 0 );\n		vec4 v3 = texelFetch( boneTexture, ivec2( x + 2, y ), 0 );\n		vec4 v4 = texelFetch( boneTexture, ivec2( x + 3, y ), 0 );\n		return mat4( v1, v2, v3, v4 );\n	}\n#endif", skinning_vertex: "#ifdef USE_SKINNING\n	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n	vec4 skinned = vec4( 0.0 );\n	skinned += boneMatX * skinVertex * skinWeight.x;\n	skinned += boneMatY * skinVertex * skinWeight.y;\n	skinned += boneMatZ * skinVertex * skinWeight.z;\n	skinned += boneMatW * skinVertex * skinWeight.w;\n	transformed = ( bindMatrixInverse * skinned ).xyz;\n#endif", skinnormal_vertex: "#ifdef USE_SKINNING\n	mat4 skinMatrix = mat4( 0.0 );\n	skinMatrix += skinWeight.x * boneMatX;\n	skinMatrix += skinWeight.y * boneMatY;\n	skinMatrix += skinWeight.z * boneMatZ;\n	skinMatrix += skinWeight.w * boneMatW;\n	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n	#ifdef USE_TANGENT\n		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n	#endif\n#endif", specularmap_fragment: "float specularStrength;\n#ifdef USE_SPECULARMAP\n	vec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );\n	specularStrength = texelSpecular.r;\n#else\n	specularStrength = 1.0;\n#endif", specularmap_pars_fragment: "#ifdef USE_SPECULARMAP\n	uniform sampler2D specularMap;\n#endif", tonemapping_fragment: "#if defined( TONE_MAPPING )\n	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif", tonemapping_pars_fragment: "#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n	return saturate( toneMappingExposure * color );\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n	color *= toneMappingExposure;\n	return saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 CineonToneMapping( vec3 color ) {\n	color *= toneMappingExposure;\n	color = max( vec3( 0.0 ), color - 0.004 );\n	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n	return a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n	const mat3 ACESInputMat = mat3(\n		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),\n		vec3( 0.04823, 0.01566, 0.83777 )\n	);\n	const mat3 ACESOutputMat = mat3(\n		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),\n		vec3( -0.07367, -0.00605,  1.07602 )\n	);\n	color *= toneMappingExposure / 0.6;\n	color = ACESInputMat * color;\n	color = RRTAndODTFit( color );\n	color = ACESOutputMat * color;\n	return saturate( color );\n}\nconst mat3 LINEAR_REC2020_TO_LINEAR_SRGB = mat3(\n	vec3( 1.6605, - 0.1246, - 0.0182 ),\n	vec3( - 0.5876, 1.1329, - 0.1006 ),\n	vec3( - 0.0728, - 0.0083, 1.1187 )\n);\nconst mat3 LINEAR_SRGB_TO_LINEAR_REC2020 = mat3(\n	vec3( 0.6274, 0.0691, 0.0164 ),\n	vec3( 0.3293, 0.9195, 0.0880 ),\n	vec3( 0.0433, 0.0113, 0.8956 )\n);\nvec3 agxDefaultContrastApprox( vec3 x ) {\n	vec3 x2 = x * x;\n	vec3 x4 = x2 * x2;\n	return + 15.5 * x4 * x2\n		- 40.14 * x4 * x\n		+ 31.96 * x4\n		- 6.868 * x2 * x\n		+ 0.4298 * x2\n		+ 0.1191 * x\n		- 0.00232;\n}\nvec3 AgXToneMapping( vec3 color ) {\n	const mat3 AgXInsetMatrix = mat3(\n		vec3( 0.856627153315983, 0.137318972929847, 0.11189821299995 ),\n		vec3( 0.0951212405381588, 0.761241990602591, 0.0767994186031903 ),\n		vec3( 0.0482516061458583, 0.101439036467562, 0.811302368396859 )\n	);\n	const mat3 AgXOutsetMatrix = mat3(\n		vec3( 1.1271005818144368, - 0.1413297634984383, - 0.14132976349843826 ),\n		vec3( - 0.11060664309660323, 1.157823702216272, - 0.11060664309660294 ),\n		vec3( - 0.016493938717834573, - 0.016493938717834257, 1.2519364065950405 )\n	);\n	const float AgxMinEv = - 12.47393;	const float AgxMaxEv = 4.026069;\n	color *= toneMappingExposure;\n	color = LINEAR_SRGB_TO_LINEAR_REC2020 * color;\n	color = AgXInsetMatrix * color;\n	color = max( color, 1e-10 );	color = log2( color );\n	color = ( color - AgxMinEv ) / ( AgxMaxEv - AgxMinEv );\n	color = clamp( color, 0.0, 1.0 );\n	color = agxDefaultContrastApprox( color );\n	color = AgXOutsetMatrix * color;\n	color = pow( max( vec3( 0.0 ), color ), vec3( 2.2 ) );\n	color = LINEAR_REC2020_TO_LINEAR_SRGB * color;\n	color = clamp( color, 0.0, 1.0 );\n	return color;\n}\nvec3 NeutralToneMapping( vec3 color ) {\n	const float StartCompression = 0.8 - 0.04;\n	const float Desaturation = 0.15;\n	color *= toneMappingExposure;\n	float x = min( color.r, min( color.g, color.b ) );\n	float offset = x < 0.08 ? x - 6.25 * x * x : 0.04;\n	color -= offset;\n	float peak = max( color.r, max( color.g, color.b ) );\n	if ( peak < StartCompression ) return color;\n	float d = 1. - StartCompression;\n	float newPeak = 1. - d * d / ( peak + d - StartCompression );\n	color *= newPeak / peak;\n	float g = 1. - 1. / ( Desaturation * ( peak - newPeak ) + 1. );\n	return mix( color, vec3( newPeak ), g );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }", transmission_fragment: "#ifdef USE_TRANSMISSION\n	material.transmission = transmission;\n	material.transmissionAlpha = 1.0;\n	material.thickness = thickness;\n	material.attenuationDistance = attenuationDistance;\n	material.attenuationColor = attenuationColor;\n	#ifdef USE_TRANSMISSIONMAP\n		material.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;\n	#endif\n	#ifdef USE_THICKNESSMAP\n		material.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;\n	#endif\n	vec3 pos = vWorldPosition;\n	vec3 v = normalize( cameraPosition - pos );\n	vec3 n = inverseTransformDirection( normal, viewMatrix );\n	vec4 transmitted = getIBLVolumeRefraction(\n		n, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,\n		pos, modelMatrix, viewMatrix, projectionMatrix, material.dispersion, material.ior, material.thickness,\n		material.attenuationColor, material.attenuationDistance );\n	material.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );\n	totalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );\n#endif", transmission_pars_fragment: "#ifdef USE_TRANSMISSION\n	uniform float transmission;\n	uniform float thickness;\n	uniform float attenuationDistance;\n	uniform vec3 attenuationColor;\n	#ifdef USE_TRANSMISSIONMAP\n		uniform sampler2D transmissionMap;\n	#endif\n	#ifdef USE_THICKNESSMAP\n		uniform sampler2D thicknessMap;\n	#endif\n	uniform vec2 transmissionSamplerSize;\n	uniform sampler2D transmissionSamplerMap;\n	uniform mat4 modelMatrix;\n	uniform mat4 projectionMatrix;\n	varying vec3 vWorldPosition;\n	float w0( float a ) {\n		return ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );\n	}\n	float w1( float a ) {\n		return ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );\n	}\n	float w2( float a ){\n		return ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );\n	}\n	float w3( float a ) {\n		return ( 1.0 / 6.0 ) * ( a * a * a );\n	}\n	float g0( float a ) {\n		return w0( a ) + w1( a );\n	}\n	float g1( float a ) {\n		return w2( a ) + w3( a );\n	}\n	float h0( float a ) {\n		return - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );\n	}\n	float h1( float a ) {\n		return 1.0 + w3( a ) / ( w2( a ) + w3( a ) );\n	}\n	vec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {\n		uv = uv * texelSize.zw + 0.5;\n		vec2 iuv = floor( uv );\n		vec2 fuv = fract( uv );\n		float g0x = g0( fuv.x );\n		float g1x = g1( fuv.x );\n		float h0x = h0( fuv.x );\n		float h1x = h1( fuv.x );\n		float h0y = h0( fuv.y );\n		float h1y = h1( fuv.y );\n		vec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;\n		vec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;\n		vec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;\n		vec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;\n		return g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +\n			g1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );\n	}\n	vec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {\n		vec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );\n		vec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );\n		vec2 fLodSizeInv = 1.0 / fLodSize;\n		vec2 cLodSizeInv = 1.0 / cLodSize;\n		vec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );\n		vec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );\n		return mix( fSample, cSample, fract( lod ) );\n	}\n	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {\n		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );\n		vec3 modelScale;\n		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );\n		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );\n		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );\n		return normalize( refractionVector ) * thickness * modelScale;\n	}\n	float applyIorToRoughness( const in float roughness, const in float ior ) {\n		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );\n	}\n	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {\n		float lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );\n		return textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );\n	}\n	vec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {\n		if ( isinf( attenuationDistance ) ) {\n			return vec3( 1.0 );\n		} else {\n			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;\n			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance;\n		}\n	}\n	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,\n		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,\n		const in mat4 viewMatrix, const in mat4 projMatrix, const in float dispersion, const in float ior, const in float thickness,\n		const in vec3 attenuationColor, const in float attenuationDistance ) {\n		vec4 transmittedLight;\n		vec3 transmittance;\n		#ifdef USE_DISPERSION\n			float halfSpread = ( ior - 1.0 ) * 0.025 * dispersion;\n			vec3 iors = vec3( ior - halfSpread, ior, ior + halfSpread );\n			for ( int i = 0; i < 3; i ++ ) {\n				vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, iors[ i ], modelMatrix );\n				vec3 refractedRayExit = position + transmissionRay;\n				vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n				vec2 refractionCoords = ndcPos.xy / ndcPos.w;\n				refractionCoords += 1.0;\n				refractionCoords /= 2.0;\n				vec4 transmissionSample = getTransmissionSample( refractionCoords, roughness, iors[ i ] );\n				transmittedLight[ i ] = transmissionSample[ i ];\n				transmittedLight.a += transmissionSample.a;\n				transmittance[ i ] = diffuseColor[ i ] * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance )[ i ];\n			}\n			transmittedLight.a /= 3.0;\n		#else\n			vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );\n			vec3 refractedRayExit = position + transmissionRay;\n			vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n			vec2 refractionCoords = ndcPos.xy / ndcPos.w;\n			refractionCoords += 1.0;\n			refractionCoords /= 2.0;\n			transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );\n			transmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );\n		#endif\n		vec3 attenuatedColor = transmittance * transmittedLight.rgb;\n		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );\n		float transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;\n		return vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );\n	}\n#endif", uv_pars_fragment: "#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n	varying vec2 vUv;\n#endif\n#ifdef USE_MAP\n	varying vec2 vMapUv;\n#endif\n#ifdef USE_ALPHAMAP\n	varying vec2 vAlphaMapUv;\n#endif\n#ifdef USE_LIGHTMAP\n	varying vec2 vLightMapUv;\n#endif\n#ifdef USE_AOMAP\n	varying vec2 vAoMapUv;\n#endif\n#ifdef USE_BUMPMAP\n	varying vec2 vBumpMapUv;\n#endif\n#ifdef USE_NORMALMAP\n	varying vec2 vNormalMapUv;\n#endif\n#ifdef USE_EMISSIVEMAP\n	varying vec2 vEmissiveMapUv;\n#endif\n#ifdef USE_METALNESSMAP\n	varying vec2 vMetalnessMapUv;\n#endif\n#ifdef USE_ROUGHNESSMAP\n	varying vec2 vRoughnessMapUv;\n#endif\n#ifdef USE_ANISOTROPYMAP\n	varying vec2 vAnisotropyMapUv;\n#endif\n#ifdef USE_CLEARCOATMAP\n	varying vec2 vClearcoatMapUv;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n	varying vec2 vClearcoatNormalMapUv;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n	varying vec2 vClearcoatRoughnessMapUv;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n	varying vec2 vIridescenceMapUv;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n	varying vec2 vIridescenceThicknessMapUv;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n	varying vec2 vSheenColorMapUv;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n	varying vec2 vSheenRoughnessMapUv;\n#endif\n#ifdef USE_SPECULARMAP\n	varying vec2 vSpecularMapUv;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n	varying vec2 vSpecularColorMapUv;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n	varying vec2 vSpecularIntensityMapUv;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n	uniform mat3 transmissionMapTransform;\n	varying vec2 vTransmissionMapUv;\n#endif\n#ifdef USE_THICKNESSMAP\n	uniform mat3 thicknessMapTransform;\n	varying vec2 vThicknessMapUv;\n#endif", uv_pars_vertex: "#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n	varying vec2 vUv;\n#endif\n#ifdef USE_MAP\n	uniform mat3 mapTransform;\n	varying vec2 vMapUv;\n#endif\n#ifdef USE_ALPHAMAP\n	uniform mat3 alphaMapTransform;\n	varying vec2 vAlphaMapUv;\n#endif\n#ifdef USE_LIGHTMAP\n	uniform mat3 lightMapTransform;\n	varying vec2 vLightMapUv;\n#endif\n#ifdef USE_AOMAP\n	uniform mat3 aoMapTransform;\n	varying vec2 vAoMapUv;\n#endif\n#ifdef USE_BUMPMAP\n	uniform mat3 bumpMapTransform;\n	varying vec2 vBumpMapUv;\n#endif\n#ifdef USE_NORMALMAP\n	uniform mat3 normalMapTransform;\n	varying vec2 vNormalMapUv;\n#endif\n#ifdef USE_DISPLACEMENTMAP\n	uniform mat3 displacementMapTransform;\n	varying vec2 vDisplacementMapUv;\n#endif\n#ifdef USE_EMISSIVEMAP\n	uniform mat3 emissiveMapTransform;\n	varying vec2 vEmissiveMapUv;\n#endif\n#ifdef USE_METALNESSMAP\n	uniform mat3 metalnessMapTransform;\n	varying vec2 vMetalnessMapUv;\n#endif\n#ifdef USE_ROUGHNESSMAP\n	uniform mat3 roughnessMapTransform;\n	varying vec2 vRoughnessMapUv;\n#endif\n#ifdef USE_ANISOTROPYMAP\n	uniform mat3 anisotropyMapTransform;\n	varying vec2 vAnisotropyMapUv;\n#endif\n#ifdef USE_CLEARCOATMAP\n	uniform mat3 clearcoatMapTransform;\n	varying vec2 vClearcoatMapUv;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n	uniform mat3 clearcoatNormalMapTransform;\n	varying vec2 vClearcoatNormalMapUv;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n	uniform mat3 clearcoatRoughnessMapTransform;\n	varying vec2 vClearcoatRoughnessMapUv;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n	uniform mat3 sheenColorMapTransform;\n	varying vec2 vSheenColorMapUv;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n	uniform mat3 sheenRoughnessMapTransform;\n	varying vec2 vSheenRoughnessMapUv;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n	uniform mat3 iridescenceMapTransform;\n	varying vec2 vIridescenceMapUv;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n	uniform mat3 iridescenceThicknessMapTransform;\n	varying vec2 vIridescenceThicknessMapUv;\n#endif\n#ifdef USE_SPECULARMAP\n	uniform mat3 specularMapTransform;\n	varying vec2 vSpecularMapUv;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n	uniform mat3 specularColorMapTransform;\n	varying vec2 vSpecularColorMapUv;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n	uniform mat3 specularIntensityMapTransform;\n	varying vec2 vSpecularIntensityMapUv;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n	uniform mat3 transmissionMapTransform;\n	varying vec2 vTransmissionMapUv;\n#endif\n#ifdef USE_THICKNESSMAP\n	uniform mat3 thicknessMapTransform;\n	varying vec2 vThicknessMapUv;\n#endif", uv_vertex: "#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n	vUv = vec3( uv, 1 ).xy;\n#endif\n#ifdef USE_MAP\n	vMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ALPHAMAP\n	vAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_LIGHTMAP\n	vLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_AOMAP\n	vAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_BUMPMAP\n	vBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_NORMALMAP\n	vNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_DISPLACEMENTMAP\n	vDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_EMISSIVEMAP\n	vEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_METALNESSMAP\n	vMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ROUGHNESSMAP\n	vRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ANISOTROPYMAP\n	vAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOATMAP\n	vClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n	vClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n	vClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n	vIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n	vIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n	vSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n	vSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULARMAP\n	vSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n	vSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n	vSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n	vTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_THICKNESSMAP\n	vThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;\n#endif", worldpos_vertex: "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0\n	vec4 worldPosition = vec4( transformed, 1.0 );\n	#ifdef USE_BATCHING\n		worldPosition = batchingMatrix * worldPosition;\n	#endif\n	#ifdef USE_INSTANCING\n		worldPosition = instanceMatrix * worldPosition;\n	#endif\n	worldPosition = modelMatrix * worldPosition;\n#endif", background_vert: "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n	gl_Position = vec4( position.xy, 1.0, 1.0 );\n}", background_frag: "uniform sampler2D t2D;\nuniform float backgroundIntensity;\nvarying vec2 vUv;\nvoid main() {\n	vec4 texColor = texture2D( t2D, vUv );\n	#ifdef DECODE_VIDEO_TEXTURE\n		texColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );\n	#endif\n	texColor.rgb *= backgroundIntensity;\n	gl_FragColor = texColor;\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n}", backgroundCube_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vWorldDirection = transformDirection( position, modelMatrix );\n	#include <begin_vertex>\n	#include <project_vertex>\n	gl_Position.z = gl_Position.w;\n}", backgroundCube_frag: "#ifdef ENVMAP_TYPE_CUBE\n	uniform samplerCube envMap;\n#elif defined( ENVMAP_TYPE_CUBE_UV )\n	uniform sampler2D envMap;\n#endif\nuniform float flipEnvMap;\nuniform float backgroundBlurriness;\nuniform float backgroundIntensity;\nuniform mat3 backgroundRotation;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n	#ifdef ENVMAP_TYPE_CUBE\n		vec4 texColor = textureCube( envMap, backgroundRotation * vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );\n	#elif defined( ENVMAP_TYPE_CUBE_UV )\n		vec4 texColor = textureCubeUV( envMap, backgroundRotation * vWorldDirection, backgroundBlurriness );\n	#else\n		vec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n	#endif\n	texColor.rgb *= backgroundIntensity;\n	gl_FragColor = texColor;\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n}", cube_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vWorldDirection = transformDirection( position, modelMatrix );\n	#include <begin_vertex>\n	#include <project_vertex>\n	gl_Position.z = gl_Position.w;\n}", cube_frag: "uniform samplerCube tCube;\nuniform float tFlip;\nuniform float opacity;\nvarying vec3 vWorldDirection;\nvoid main() {\n	vec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );\n	gl_FragColor = texColor;\n	gl_FragColor.a *= opacity;\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n}", depth_vert: "#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n	#include <uv_vertex>\n	#include <batching_vertex>\n	#include <skinbase_vertex>\n	#include <morphinstance_vertex>\n	#ifdef USE_DISPLACEMENTMAP\n		#include <beginnormal_vertex>\n		#include <morphnormal_vertex>\n		#include <skinnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vHighPrecisionZW = gl_Position.zw;\n}", depth_frag: "#if DEPTH_PACKING == 3200\n	uniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n	vec4 diffuseColor = vec4( 1.0 );\n	#include <clipping_planes_fragment>\n	#if DEPTH_PACKING == 3200\n		diffuseColor.a = opacity;\n	#endif\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <alphahash_fragment>\n	#include <logdepthbuf_fragment>\n	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n	#if DEPTH_PACKING == 3200\n		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n	#elif DEPTH_PACKING == 3201\n		gl_FragColor = packDepthToRGBA( fragCoordZ );\n	#elif DEPTH_PACKING == 3202\n		gl_FragColor = vec4( packDepthToRGB( fragCoordZ ), 1.0 );\n	#elif DEPTH_PACKING == 3203\n		gl_FragColor = vec4( packDepthToRG( fragCoordZ ), 0.0, 1.0 );\n	#endif\n}", distanceRGBA_vert: "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <batching_vertex>\n	#include <skinbase_vertex>\n	#include <morphinstance_vertex>\n	#ifdef USE_DISPLACEMENTMAP\n		#include <beginnormal_vertex>\n		#include <morphnormal_vertex>\n		#include <skinnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <worldpos_vertex>\n	#include <clipping_planes_vertex>\n	vWorldPosition = worldPosition.xyz;\n}", distanceRGBA_frag: "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n	vec4 diffuseColor = vec4( 1.0 );\n	#include <clipping_planes_fragment>\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <alphahash_fragment>\n	float dist = length( vWorldPosition - referencePosition );\n	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n	dist = saturate( dist );\n	gl_FragColor = packDepthToRGBA( dist );\n}", equirect_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vWorldDirection = transformDirection( position, modelMatrix );\n	#include <begin_vertex>\n	#include <project_vertex>\n}", equirect_frag: "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vec3 direction = normalize( vWorldDirection );\n	vec2 sampleUV = equirectUv( direction );\n	gl_FragColor = texture2D( tEquirect, sampleUV );\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n}", linedashed_vert: "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	vLineDistance = scale * lineDistance;\n	#include <uv_vertex>\n	#include <color_vertex>\n	#include <morphinstance_vertex>\n	#include <morphcolor_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n}", linedashed_frag: "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <clipping_planes_fragment>\n	if ( mod( vLineDistance, totalSize ) > dashSize ) {\n		discard;\n	}\n	vec3 outgoingLight = vec3( 0.0 );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	outgoingLight = diffuseColor.rgb;\n	#include <opaque_fragment>\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n}", meshbasic_vert: "#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <color_vertex>\n	#include <morphinstance_vertex>\n	#include <morphcolor_vertex>\n	#include <batching_vertex>\n	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\n		#include <beginnormal_vertex>\n		#include <morphnormal_vertex>\n		#include <skinbase_vertex>\n		#include <skinnormal_vertex>\n		#include <defaultnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <fog_vertex>\n}", meshbasic_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <clipping_planes_fragment>\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <alphahash_fragment>\n	#include <specularmap_fragment>\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	#ifdef USE_LIGHTMAP\n		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );\n		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;\n	#else\n		reflectedLight.indirectDiffuse += vec3( 1.0 );\n	#endif\n	#include <aomap_fragment>\n	reflectedLight.indirectDiffuse *= diffuseColor.rgb;\n	vec3 outgoingLight = reflectedLight.indirectDiffuse;\n	#include <envmap_fragment>\n	#include <opaque_fragment>\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}", meshlambert_vert: "#define LAMBERT\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <color_vertex>\n	#include <morphinstance_vertex>\n	#include <morphcolor_vertex>\n	#include <batching_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}", meshlambert_frag: "#define LAMBERT\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_lambert_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <clipping_planes_fragment>\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <alphahash_fragment>\n	#include <specularmap_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_lambert_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n	#include <envmap_fragment>\n	#include <opaque_fragment>\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}", meshmatcap_vert: "#define MATCAP\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <color_vertex>\n	#include <morphinstance_vertex>\n	#include <morphcolor_vertex>\n	#include <batching_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n	vViewPosition = - mvPosition.xyz;\n}", meshmatcap_frag: "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <clipping_planes_fragment>\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <alphahash_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	vec3 viewDir = normalize( vViewPosition );\n	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n	vec3 y = cross( viewDir, x );\n	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n	#ifdef USE_MATCAP\n		vec4 matcapColor = texture2D( matcap, uv );\n	#else\n		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );\n	#endif\n	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n	#include <opaque_fragment>\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}", meshnormal_vert: "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n	varying vec3 vViewPosition;\n#endif\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <batching_vertex>\n	#include <beginnormal_vertex>\n	#include <morphinstance_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n	vViewPosition = - mvPosition.xyz;\n#endif\n}", meshnormal_frag: "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n	varying vec3 vViewPosition;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	vec4 diffuseColor = vec4( 0.0, 0.0, 0.0, opacity );\n	#include <clipping_planes_fragment>\n	#include <logdepthbuf_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	gl_FragColor = vec4( packNormalToRGB( normal ), diffuseColor.a );\n	#ifdef OPAQUE\n		gl_FragColor.a = 1.0;\n	#endif\n}", meshphong_vert: "#define PHONG\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <color_vertex>\n	#include <morphcolor_vertex>\n	#include <batching_vertex>\n	#include <beginnormal_vertex>\n	#include <morphinstance_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}", meshphong_frag: "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <clipping_planes_fragment>\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <alphahash_fragment>\n	#include <specularmap_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_phong_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n	#include <envmap_fragment>\n	#include <opaque_fragment>\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}", meshphysical_vert: "#define STANDARD\nvarying vec3 vViewPosition;\n#ifdef USE_TRANSMISSION\n	varying vec3 vWorldPosition;\n#endif\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <color_vertex>\n	#include <morphinstance_vertex>\n	#include <morphcolor_vertex>\n	#include <batching_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n#ifdef USE_TRANSMISSION\n	vWorldPosition = worldPosition.xyz;\n#endif\n}", meshphysical_frag: "#define STANDARD\n#ifdef PHYSICAL\n	#define IOR\n	#define USE_SPECULAR\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef IOR\n	uniform float ior;\n#endif\n#ifdef USE_SPECULAR\n	uniform float specularIntensity;\n	uniform vec3 specularColor;\n	#ifdef USE_SPECULAR_COLORMAP\n		uniform sampler2D specularColorMap;\n	#endif\n	#ifdef USE_SPECULAR_INTENSITYMAP\n		uniform sampler2D specularIntensityMap;\n	#endif\n#endif\n#ifdef USE_CLEARCOAT\n	uniform float clearcoat;\n	uniform float clearcoatRoughness;\n#endif\n#ifdef USE_DISPERSION\n	uniform float dispersion;\n#endif\n#ifdef USE_IRIDESCENCE\n	uniform float iridescence;\n	uniform float iridescenceIOR;\n	uniform float iridescenceThicknessMinimum;\n	uniform float iridescenceThicknessMaximum;\n#endif\n#ifdef USE_SHEEN\n	uniform vec3 sheenColor;\n	uniform float sheenRoughness;\n	#ifdef USE_SHEEN_COLORMAP\n		uniform sampler2D sheenColorMap;\n	#endif\n	#ifdef USE_SHEEN_ROUGHNESSMAP\n		uniform sampler2D sheenRoughnessMap;\n	#endif\n#endif\n#ifdef USE_ANISOTROPY\n	uniform vec2 anisotropyVector;\n	#ifdef USE_ANISOTROPYMAP\n		uniform sampler2D anisotropyMap;\n	#endif\n#endif\nvarying vec3 vViewPosition;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <iridescence_fragment>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_physical_pars_fragment>\n#include <transmission_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <iridescence_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <clipping_planes_fragment>\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <alphahash_fragment>\n	#include <roughnessmap_fragment>\n	#include <metalnessmap_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <clearcoat_normal_fragment_begin>\n	#include <clearcoat_normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_physical_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n	#include <transmission_fragment>\n	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\n	#ifdef USE_SHEEN\n		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );\n		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecularDirect + sheenSpecularIndirect;\n	#endif\n	#ifdef USE_CLEARCOAT\n		float dotNVcc = saturate( dot( geometryClearcoatNormal, geometryViewDir ) );\n		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );\n		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + ( clearcoatSpecularDirect + clearcoatSpecularIndirect ) * material.clearcoat;\n	#endif\n	#include <opaque_fragment>\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}", meshtoon_vert: "#define TOON\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <color_vertex>\n	#include <morphinstance_vertex>\n	#include <morphcolor_vertex>\n	#include <batching_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}", meshtoon_frag: "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <clipping_planes_fragment>\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <alphahash_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_toon_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n	#include <opaque_fragment>\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}", points_vert: "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n#ifdef USE_POINTS_UV\n	varying vec2 vUv;\n	uniform mat3 uvTransform;\n#endif\nvoid main() {\n	#ifdef USE_POINTS_UV\n		vUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n	#endif\n	#include <color_vertex>\n	#include <morphinstance_vertex>\n	#include <morphcolor_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <project_vertex>\n	gl_PointSize = size;\n	#ifdef USE_SIZEATTENUATION\n		bool isPerspective = isPerspectiveMatrix( projectionMatrix );\n		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n	#endif\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <worldpos_vertex>\n	#include <fog_vertex>\n}", points_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <clipping_planes_fragment>\n	vec3 outgoingLight = vec3( 0.0 );\n	#include <logdepthbuf_fragment>\n	#include <map_particle_fragment>\n	#include <color_fragment>\n	#include <alphatest_fragment>\n	#include <alphahash_fragment>\n	outgoingLight = diffuseColor.rgb;\n	#include <opaque_fragment>\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n}", shadow_vert: "#include <common>\n#include <batching_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n	#include <batching_vertex>\n	#include <beginnormal_vertex>\n	#include <morphinstance_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}", shadow_frag: "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <logdepthbuf_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n	#include <logdepthbuf_fragment>\n	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n	#include <fog_fragment>\n}", sprite_vert: "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	vec4 mvPosition = modelViewMatrix[ 3 ];\n	vec2 scale = vec2( length( modelMatrix[ 0 ].xyz ), length( modelMatrix[ 1 ].xyz ) );\n	#ifndef USE_SIZEATTENUATION\n		bool isPerspective = isPerspectiveMatrix( projectionMatrix );\n		if ( isPerspective ) scale *= - mvPosition.z;\n	#endif\n	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n	vec2 rotatedPosition;\n	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n	mvPosition.xy += rotatedPosition;\n	gl_Position = projectionMatrix * mvPosition;\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n}", sprite_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <clipping_planes_fragment>\n	vec3 outgoingLight = vec3( 0.0 );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <alphahash_fragment>\n	outgoingLight = diffuseColor.rgb;\n	#include <opaque_fragment>\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n	#include <fog_fragment>\n}" }, o = { common: { diffuse: { value: new r.Q1f(0xffffff) }, opacity: { value: 1 }, map: { value: null }, mapTransform: { value: new r.dwI }, alphaMap: { value: null }, alphaMapTransform: { value: new r.dwI }, alphaTest: { value: 0 } }, specularmap: { specularMap: { value: null }, specularMapTransform: { value: new r.dwI } }, envmap: { envMap: { value: null }, envMapRotation: { value: new r.dwI }, flipEnvMap: { value: -1 }, reflectivity: { value: 1 }, ior: { value: 1.5 }, refractionRatio: { value: .98 } }, aomap: { aoMap: { value: null }, aoMapIntensity: { value: 1 }, aoMapTransform: { value: new r.dwI } }, lightmap: { lightMap: { value: null }, lightMapIntensity: { value: 1 }, lightMapTransform: { value: new r.dwI } }, bumpmap: { bumpMap: { value: null }, bumpMapTransform: { value: new r.dwI }, bumpScale: { value: 1 } }, normalmap: { normalMap: { value: null }, normalMapTransform: { value: new r.dwI }, normalScale: { value: new r.I9Y(1, 1) } }, displacementmap: { displacementMap: { value: null }, displacementMapTransform: { value: new r.dwI }, displacementScale: { value: 1 }, displacementBias: { value: 0 } }, emissivemap: { emissiveMap: { value: null }, emissiveMapTransform: { value: new r.dwI } }, metalnessmap: { metalnessMap: { value: null }, metalnessMapTransform: { value: new r.dwI } }, roughnessmap: { roughnessMap: { value: null }, roughnessMapTransform: { value: new r.dwI } }, gradientmap: { gradientMap: { value: null } }, fog: { fogDensity: { value: 25e-5 }, fogNear: { value: 1 }, fogFar: { value: 2e3 }, fogColor: { value: new r.Q1f(0xffffff) } }, lights: { ambientLightColor: { value: [] }, lightProbe: { value: [] }, directionalLights: { value: [], properties: { direction: {}, color: {} } }, directionalLightShadows: { value: [], properties: { shadowIntensity: 1, shadowBias: {}, shadowNormalBias: {}, shadowRadius: {}, shadowMapSize: {} } }, directionalShadowMap: { value: [] }, directionalShadowMatrix: { value: [] }, spotLights: { value: [], properties: { color: {}, position: {}, direction: {}, distance: {}, coneCos: {}, penumbraCos: {}, decay: {} } }, spotLightShadows: { value: [], properties: { shadowIntensity: 1, shadowBias: {}, shadowNormalBias: {}, shadowRadius: {}, shadowMapSize: {} } }, spotLightMap: { value: [] }, spotShadowMap: { value: [] }, spotLightMatrix: { value: [] }, pointLights: { value: [], properties: { color: {}, position: {}, decay: {}, distance: {} } }, pointLightShadows: { value: [], properties: { shadowIntensity: 1, shadowBias: {}, shadowNormalBias: {}, shadowRadius: {}, shadowMapSize: {}, shadowCameraNear: {}, shadowCameraFar: {} } }, pointShadowMap: { value: [] }, pointShadowMatrix: { value: [] }, hemisphereLights: { value: [], properties: { direction: {}, skyColor: {}, groundColor: {} } }, rectAreaLights: { value: [], properties: { color: {}, position: {}, width: {}, height: {} } }, ltc_1: { value: null }, ltc_2: { value: null } }, points: { diffuse: { value: new r.Q1f(0xffffff) }, opacity: { value: 1 }, size: { value: 1 }, scale: { value: 1 }, map: { value: null }, alphaMap: { value: null }, alphaMapTransform: { value: new r.dwI }, alphaTest: { value: 0 }, uvTransform: { value: new r.dwI } }, sprite: { diffuse: { value: new r.Q1f(0xffffff) }, opacity: { value: 1 }, center: { value: new r.I9Y(.5, .5) }, rotation: { value: 0 }, map: { value: null }, mapTransform: { value: new r.dwI }, alphaMap: { value: null }, alphaMapTransform: { value: new r.dwI }, alphaTest: { value: 0 } } }, l = { basic: { uniforms: (0, r.Iit)([o.common, o.specularmap, o.envmap, o.aomap, o.lightmap, o.fog]), vertexShader: a.meshbasic_vert, fragmentShader: a.meshbasic_frag }, lambert: { uniforms: (0, r.Iit)([o.common, o.specularmap, o.envmap, o.aomap, o.lightmap, o.emissivemap, o.bumpmap, o.normalmap, o.displacementmap, o.fog, o.lights, { emissive: { value: new r.Q1f(0) } }]), vertexShader: a.meshlambert_vert, fragmentShader: a.meshlambert_frag }, phong: { uniforms: (0, r.Iit)([o.common, o.specularmap, o.envmap, o.aomap, o.lightmap, o.emissivemap, o.bumpmap, o.normalmap, o.displacementmap, o.fog, o.lights, { emissive: { value: new r.Q1f(0) }, specular: { value: new r.Q1f(1118481) }, shininess: { value: 30 } }]), vertexShader: a.meshphong_vert, fragmentShader: a.meshphong_frag }, standard: { uniforms: (0, r.Iit)([o.common, o.envmap, o.aomap, o.lightmap, o.emissivemap, o.bumpmap, o.normalmap, o.displacementmap, o.roughnessmap, o.metalnessmap, o.fog, o.lights, { emissive: { value: new r.Q1f(0) }, roughness: { value: 1 }, metalness: { value: 0 }, envMapIntensity: { value: 1 } }]), vertexShader: a.meshphysical_vert, fragmentShader: a.meshphysical_frag }, toon: { uniforms: (0, r.Iit)([o.common, o.aomap, o.lightmap, o.emissivemap, o.bumpmap, o.normalmap, o.displacementmap, o.gradientmap, o.fog, o.lights, { emissive: { value: new r.Q1f(0) } }]), vertexShader: a.meshtoon_vert, fragmentShader: a.meshtoon_frag }, matcap: { uniforms: (0, r.Iit)([o.common, o.bumpmap, o.normalmap, o.displacementmap, o.fog, { matcap: { value: null } }]), vertexShader: a.meshmatcap_vert, fragmentShader: a.meshmatcap_frag }, points: { uniforms: (0, r.Iit)([o.points, o.fog]), vertexShader: a.points_vert, fragmentShader: a.points_frag }, dashed: { uniforms: (0, r.Iit)([o.common, o.fog, { scale: { value: 1 }, dashSize: { value: 1 }, totalSize: { value: 2 } }]), vertexShader: a.linedashed_vert, fragmentShader: a.linedashed_frag }, depth: { uniforms: (0, r.Iit)([o.common, o.displacementmap]), vertexShader: a.depth_vert, fragmentShader: a.depth_frag }, normal: { uniforms: (0, r.Iit)([o.common, o.bumpmap, o.normalmap, o.displacementmap, { opacity: { value: 1 } }]), vertexShader: a.meshnormal_vert, fragmentShader: a.meshnormal_frag }, sprite: { uniforms: (0, r.Iit)([o.sprite, o.fog]), vertexShader: a.sprite_vert, fragmentShader: a.sprite_frag }, background: { uniforms: { uvTransform: { value: new r.dwI }, t2D: { value: null }, backgroundIntensity: { value: 1 } }, vertexShader: a.background_vert, fragmentShader: a.background_frag }, backgroundCube: { uniforms: { envMap: { value: null }, flipEnvMap: { value: -1 }, backgroundBlurriness: { value: 0 }, backgroundIntensity: { value: 1 }, backgroundRotation: { value: new r.dwI } }, vertexShader: a.backgroundCube_vert, fragmentShader: a.backgroundCube_frag }, cube: { uniforms: { tCube: { value: null }, tFlip: { value: -1 }, opacity: { value: 1 } }, vertexShader: a.cube_vert, fragmentShader: a.cube_frag }, equirect: { uniforms: { tEquirect: { value: null } }, vertexShader: a.equirect_vert, fragmentShader: a.equirect_frag }, distanceRGBA: { uniforms: (0, r.Iit)([o.common, o.displacementmap, { referencePosition: { value: new r.Pq0 }, nearDistance: { value: 1 }, farDistance: { value: 1e3 } }]), vertexShader: a.distanceRGBA_vert, fragmentShader: a.distanceRGBA_frag }, shadow: { uniforms: (0, r.Iit)([o.lights, o.fog, { color: { value: new r.Q1f(0) }, opacity: { value: 1 } }]), vertexShader: a.shadow_vert, fragmentShader: a.shadow_frag } }; l.physical = { uniforms: (0, r.Iit)([l.standard.uniforms, { clearcoat: { value: 0 }, clearcoatMap: { value: null }, clearcoatMapTransform: { value: new r.dwI }, clearcoatNormalMap: { value: null }, clearcoatNormalMapTransform: { value: new r.dwI }, clearcoatNormalScale: { value: new r.I9Y(1, 1) }, clearcoatRoughness: { value: 0 }, clearcoatRoughnessMap: { value: null }, clearcoatRoughnessMapTransform: { value: new r.dwI }, dispersion: { value: 0 }, iridescence: { value: 0 }, iridescenceMap: { value: null }, iridescenceMapTransform: { value: new r.dwI }, iridescenceIOR: { value: 1.3 }, iridescenceThicknessMinimum: { value: 100 }, iridescenceThicknessMaximum: { value: 400 }, iridescenceThicknessMap: { value: null }, iridescenceThicknessMapTransform: { value: new r.dwI }, sheen: { value: 0 }, sheenColor: { value: new r.Q1f(0) }, sheenColorMap: { value: null }, sheenColorMapTransform: { value: new r.dwI }, sheenRoughness: { value: 1 }, sheenRoughnessMap: { value: null }, sheenRoughnessMapTransform: { value: new r.dwI }, transmission: { value: 0 }, transmissionMap: { value: null }, transmissionMapTransform: { value: new r.dwI }, transmissionSamplerSize: { value: new r.I9Y }, transmissionSamplerMap: { value: null }, thickness: { value: 0 }, thicknessMap: { value: null }, thicknessMapTransform: { value: new r.dwI }, attenuationDistance: { value: 0 }, attenuationColor: { value: new r.Q1f(0) }, specularColor: { value: new r.Q1f(1, 1, 1) }, specularColorMap: { value: null }, specularColorMapTransform: { value: new r.dwI }, specularIntensity: { value: 1 }, specularIntensityMap: { value: null }, specularIntensityMapTransform: { value: new r.dwI }, anisotropyVector: { value: new r.I9Y }, anisotropyMap: { value: null }, anisotropyMapTransform: { value: new r.dwI } }]), vertexShader: a.meshphysical_vert, fragmentShader: a.meshphysical_frag }; let u = { r: 0, b: 0, g: 0 }, h = new r.O9p, c = new r.kn4; function d(e, t, i, n, s, a, o) { let d, f; let p = new r.Q1f(0), m = !0 === a ? 0 : 1, g = null, v = 0, y = null; function x(e) { let r = !0 === e.isScene ? e.background : null; return r && r.isTexture && (r = (e.backgroundBlurriness > 0 ? i : t).get(r)), r } function S(t, i) { t.getRGB(u, (0, r._Ut)(e)), n.buffers.color.setClear(u.r, u.g, u.b, i, o) } return { getClearColor: function () { return p }, setClearColor: function (e, t = 1) { p.set(e), S(p, m = t) }, getClearAlpha: function () { return m }, setClearAlpha: function (e) { S(p, m = e) }, render: function (t) { let i = !1, r = x(t); null === r ? S(p, m) : r && r.isColor && (S(r, 1), i = !0); let s = e.xr.getEnvironmentBlendMode(); "additive" === s ? n.buffers.color.setClear(0, 0, 0, 1, o) : "alpha-blend" === s && n.buffers.color.setClear(0, 0, 0, 0, o), (e.autoClear || i) && (n.buffers.depth.setTest(!0), n.buffers.depth.setMask(!0), n.buffers.color.setMask(!0), e.clear(e.autoClearColor, e.autoClearDepth, e.autoClearStencil)) }, addToRenderList: function (t, i) { let n = x(i); n && (n.isCubeTexture || n.mapping === r.Om) ? (void 0 === f && ((f = new r.eaF(new r.iNn(1, 1, 1), new r.BKk({ name: "BackgroundCubeMaterial", uniforms: (0, r.lxW)(l.backgroundCube.uniforms), vertexShader: l.backgroundCube.vertexShader, fragmentShader: l.backgroundCube.fragmentShader, side: r.hsX, depthTest: !1, depthWrite: !1, fog: !1 }))).geometry.deleteAttribute("normal"), f.geometry.deleteAttribute("uv"), f.onBeforeRender = function (e, t, i) { this.matrixWorld.copyPosition(i.matrixWorld) }, Object.defineProperty(f.material, "envMap", { get: function () { return this.uniforms.envMap.value } }), s.update(f)), h.copy(i.backgroundRotation), h.x *= -1, h.y *= -1, h.z *= -1, n.isCubeTexture && !1 === n.isRenderTargetTexture && (h.y *= -1, h.z *= -1), f.material.uniforms.envMap.value = n, f.material.uniforms.flipEnvMap.value = n.isCubeTexture && !1 === n.isRenderTargetTexture ? -1 : 1, f.material.uniforms.backgroundBlurriness.value = i.backgroundBlurriness, f.material.uniforms.backgroundIntensity.value = i.backgroundIntensity, f.material.uniforms.backgroundRotation.value.setFromMatrix4(c.makeRotationFromEuler(h)), f.material.toneMapped = r.ppV.getTransfer(n.colorSpace) !== r.KLL, (g !== n || v !== n.version || y !== e.toneMapping) && (f.material.needsUpdate = !0, g = n, v = n.version, y = e.toneMapping), f.layers.enableAll(), t.unshift(f, f.geometry, f.material, 0, 0, null)) : n && n.isTexture && (void 0 === d && ((d = new r.eaF(new r.bdM(2, 2), new r.BKk({ name: "BackgroundMaterial", uniforms: (0, r.lxW)(l.background.uniforms), vertexShader: l.background.vertexShader, fragmentShader: l.background.fragmentShader, side: r.hB5, depthTest: !1, depthWrite: !1, fog: !1 }))).geometry.deleteAttribute("normal"), Object.defineProperty(d.material, "map", { get: function () { return this.uniforms.t2D.value } }), s.update(d)), d.material.uniforms.t2D.value = n, d.material.uniforms.backgroundIntensity.value = i.backgroundIntensity, d.material.toneMapped = r.ppV.getTransfer(n.colorSpace) !== r.KLL, !0 === n.matrixAutoUpdate && n.updateMatrix(), d.material.uniforms.uvTransform.value.copy(n.matrix), (g !== n || v !== n.version || y !== e.toneMapping) && (d.material.needsUpdate = !0, g = n, v = n.version, y = e.toneMapping), d.layers.enableAll(), t.unshift(d, d.geometry, d.material, 0, 0, null)) }, dispose: function () { void 0 !== f && (f.geometry.dispose(), f.material.dispose(), f = void 0), void 0 !== d && (d.geometry.dispose(), d.material.dispose(), d = void 0) } } } function f(e, t) { let i = e.getParameter(e.MAX_VERTEX_ATTRIBS), n = {}, s = h(null), a = s, o = !1; function l(t) { return e.bindVertexArray(t) } function u(t) { return e.deleteVertexArray(t) } function h(e) { let t = [], r = [], n = []; for (let e = 0; e < i; e++)t[e] = 0, r[e] = 0, n[e] = 0; return { geometry: null, program: null, wireframe: !1, newAttributes: t, enabledAttributes: r, attributeDivisors: n, object: e, attributes: {}, index: null } } function c() { let e = a.newAttributes; for (let t = 0, i = e.length; t < i; t++)e[t] = 0 } function d(e) { f(e, 0) } function f(t, i) { let r = a.newAttributes, n = a.enabledAttributes, s = a.attributeDivisors; r[t] = 1, 0 === n[t] && (e.enableVertexAttribArray(t), n[t] = 1), s[t] !== i && (e.vertexAttribDivisor(t, i), s[t] = i) } function p() { let t = a.newAttributes, i = a.enabledAttributes; for (let r = 0, n = i.length; r < n; r++)i[r] !== t[r] && (e.disableVertexAttribArray(r), i[r] = 0) } function m(t, i, r, n, s, a, o) { !0 === o ? e.vertexAttribIPointer(t, i, r, s, a) : e.vertexAttribPointer(t, i, r, n, s, a) } function g() { v(), o = !0, a !== s && l((a = s).object) } function v() { s.geometry = null, s.program = null, s.wireframe = !1 } return { setup: function (i, s, u, g, v) { let y = !1, x = function (t, i, r) { let s = !0 === r.wireframe, a = n[t.id]; void 0 === a && (a = {}, n[t.id] = a); let o = a[i.id]; void 0 === o && (o = {}, a[i.id] = o); let l = o[s]; return void 0 === l && (l = h(e.createVertexArray()), o[s] = l), l }(g, u, s); a !== x && l((a = x).object), (y = function (e, t, i, r) { let n = a.attributes, s = t.attributes, o = 0, l = i.getAttributes(); for (let t in l) if (l[t].location >= 0) { let i = n[t], r = s[t]; if (void 0 === r && ("instanceMatrix" === t && e.instanceMatrix && (r = e.instanceMatrix), "instanceColor" === t && e.instanceColor && (r = e.instanceColor)), void 0 === i || i.attribute !== r || r && i.data !== r.data) return !0; o++ } return a.attributesNum !== o || a.index !== r }(i, g, u, v)) && function (e, t, i, r) { let n = {}, s = t.attributes, o = 0, l = i.getAttributes(); for (let t in l) if (l[t].location >= 0) { let i = s[t]; void 0 === i && ("instanceMatrix" === t && e.instanceMatrix && (i = e.instanceMatrix), "instanceColor" === t && e.instanceColor && (i = e.instanceColor)); let r = {}; r.attribute = i, i && i.data && (r.data = i.data), n[t] = r, o++ } a.attributes = n, a.attributesNum = o, a.index = r }(i, g, u, v), null !== v && t.update(v, e.ELEMENT_ARRAY_BUFFER), (y || o) && (o = !1, function (i, n, s, a) { c(); let o = a.attributes, l = s.getAttributes(), u = n.defaultAttributeValues; for (let n in l) { let s = l[n]; if (s.location >= 0) { let l = o[n]; if (void 0 === l && ("instanceMatrix" === n && i.instanceMatrix && (l = i.instanceMatrix), "instanceColor" === n && i.instanceColor && (l = i.instanceColor)), void 0 !== l) { let n = l.normalized, o = l.itemSize, u = t.get(l); if (void 0 === u) continue; let h = u.buffer, c = u.type, p = u.bytesPerElement, g = c === e.INT || c === e.UNSIGNED_INT || l.gpuType === r.Yuy; if (l.isInterleavedBufferAttribute) { let t = l.data, r = t.stride, u = l.offset; if (t.isInstancedInterleavedBuffer) { for (let e = 0; e < s.locationSize; e++)f(s.location + e, t.meshPerAttribute); !0 !== i.isInstancedMesh && void 0 === a._maxInstanceCount && (a._maxInstanceCount = t.meshPerAttribute * t.count) } else for (let e = 0; e < s.locationSize; e++)d(s.location + e); e.bindBuffer(e.ARRAY_BUFFER, h); for (let e = 0; e < s.locationSize; e++)m(s.location + e, o / s.locationSize, c, n, r * p, (u + o / s.locationSize * e) * p, g) } else { if (l.isInstancedBufferAttribute) { for (let e = 0; e < s.locationSize; e++)f(s.location + e, l.meshPerAttribute); !0 !== i.isInstancedMesh && void 0 === a._maxInstanceCount && (a._maxInstanceCount = l.meshPerAttribute * l.count) } else for (let e = 0; e < s.locationSize; e++)d(s.location + e); e.bindBuffer(e.ARRAY_BUFFER, h); for (let e = 0; e < s.locationSize; e++)m(s.location + e, o / s.locationSize, c, n, o * p, o / s.locationSize * e * p, g) } } else if (void 0 !== u) { let t = u[n]; if (void 0 !== t) switch (t.length) { case 2: e.vertexAttrib2fv(s.location, t); break; case 3: e.vertexAttrib3fv(s.location, t); break; case 4: e.vertexAttrib4fv(s.location, t); break; default: e.vertexAttrib1fv(s.location, t) } } } } p() }(i, s, u, g), null !== v && e.bindBuffer(e.ELEMENT_ARRAY_BUFFER, t.get(v).buffer)) }, reset: g, resetDefaultState: v, dispose: function () { for (let e in g(), n) { let t = n[e]; for (let e in t) { let i = t[e]; for (let e in i) u(i[e].object), delete i[e]; delete t[e] } delete n[e] } }, releaseStatesOfGeometry: function (e) { if (void 0 === n[e.id]) return; let t = n[e.id]; for (let e in t) { let i = t[e]; for (let e in i) u(i[e].object), delete i[e]; delete t[e] } delete n[e.id] }, releaseStatesOfProgram: function (e) { for (let t in n) { let i = n[t]; if (void 0 === i[e.id]) continue; let r = i[e.id]; for (let e in r) u(r[e].object), delete r[e]; delete i[e.id] } }, initAttributes: c, enableAttribute: d, disableUnusedAttributes: p } } function p(e, t, i) { let r; function n(t, n, s) { 0 !== s && (e.drawArraysInstanced(r, t, n, s), i.update(n, r, s)) } this.setMode = function (e) { r = e }, this.render = function (t, n) { e.drawArrays(r, t, n), i.update(n, r, 1) }, this.renderInstances = n, this.renderMultiDraw = function (e, n, s) { if (0 === s) return; t.get("WEBGL_multi_draw").multiDrawArraysWEBGL(r, e, 0, n, 0, s); let a = 0; for (let e = 0; e < s; e++)a += n[e]; i.update(a, r, 1) }, this.renderMultiDrawInstances = function (e, s, a, o) { if (0 === a) return; let l = t.get("WEBGL_multi_draw"); if (null === l) for (let t = 0; t < e.length; t++)n(e[t], s[t], o[t]); else { l.multiDrawArraysInstancedWEBGL(r, e, 0, s, 0, o, 0, a); let t = 0; for (let e = 0; e < a; e++)t += s[e] * o[e]; i.update(t, r, 1) } } } function m(e, t, i, n) { let s; function a(t) { if ("highp" === t) { if (e.getShaderPrecisionFormat(e.VERTEX_SHADER, e.HIGH_FLOAT).precision > 0 && e.getShaderPrecisionFormat(e.FRAGMENT_SHADER, e.HIGH_FLOAT).precision > 0) return "highp"; t = "mediump" } return "mediump" === t && e.getShaderPrecisionFormat(e.VERTEX_SHADER, e.MEDIUM_FLOAT).precision > 0 && e.getShaderPrecisionFormat(e.FRAGMENT_SHADER, e.MEDIUM_FLOAT).precision > 0 ? "mediump" : "lowp" } let o = void 0 !== i.precision ? i.precision : "highp", l = a(o); l !== o && (console.warn("THREE.WebGLRenderer:", o, "not supported, using", l, "instead."), o = l); let u = !0 === i.logarithmicDepthBuffer, h = !0 === i.reverseDepthBuffer && t.has("EXT_clip_control"), c = e.getParameter(e.MAX_TEXTURE_IMAGE_UNITS), d = e.getParameter(e.MAX_VERTEX_TEXTURE_IMAGE_UNITS), f = e.getParameter(e.MAX_TEXTURE_SIZE), p = e.getParameter(e.MAX_CUBE_MAP_TEXTURE_SIZE), m = e.getParameter(e.MAX_VERTEX_ATTRIBS), g = e.getParameter(e.MAX_VERTEX_UNIFORM_VECTORS); return { isWebGL2: !0, getMaxAnisotropy: function () { if (void 0 !== s) return s; if (!0 === t.has("EXT_texture_filter_anisotropic")) { let i = t.get("EXT_texture_filter_anisotropic"); s = e.getParameter(i.MAX_TEXTURE_MAX_ANISOTROPY_EXT) } else s = 0; return s }, getMaxPrecision: a, textureFormatReadable: function (t) { return t === r.GWd || n.convert(t) === e.getParameter(e.IMPLEMENTATION_COLOR_READ_FORMAT) }, textureTypeReadable: function (i) { let s = i === r.ix0 && (t.has("EXT_color_buffer_half_float") || t.has("EXT_color_buffer_float")); return i === r.OUM || n.convert(i) === e.getParameter(e.IMPLEMENTATION_COLOR_READ_TYPE) || i === r.RQf || !!s }, precision: o, logarithmicDepthBuffer: u, reverseDepthBuffer: h, maxTextures: c, maxVertexTextures: d, maxTextureSize: f, maxCubemapSize: p, maxAttributes: m, maxVertexUniforms: g, maxVaryings: e.getParameter(e.MAX_VARYING_VECTORS), maxFragmentUniforms: e.getParameter(e.MAX_FRAGMENT_UNIFORM_VECTORS), vertexTextures: d > 0, maxSamples: e.getParameter(e.MAX_SAMPLES) } } function g(e) { let t = this, i = null, n = 0, s = !1, a = !1, o = new r.Zcv, l = new r.dwI, u = { value: null, needsUpdate: !1 }; function h(e, i, r, n) { let s = null !== e ? e.length : 0, a = null; if (0 !== s) { if (a = u.value, !0 !== n || null === a) { let t = r + 4 * s, n = i.matrixWorldInverse; l.getNormalMatrix(n), (null === a || a.length < t) && (a = new Float32Array(t)); for (let t = 0, i = r; t !== s; ++t, i += 4)o.copy(e[t]).applyMatrix4(n, l), o.normal.toArray(a, i), a[i + 3] = o.constant } u.value = a, u.needsUpdate = !0 } return t.numPlanes = s, t.numIntersection = 0, a } this.uniform = u, this.numPlanes = 0, this.numIntersection = 0, this.init = function (e, t) { let i = 0 !== e.length || t || 0 !== n || s; return s = t, n = e.length, i }, this.beginShadows = function () { a = !0, h(null) }, this.endShadows = function () { a = !1 }, this.setGlobalState = function (e, t) { i = h(e, t, 0) }, this.setState = function (r, o, l) { let c = r.clippingPlanes, d = r.clipIntersection, f = r.clipShadows, p = e.get(r); if (s && null !== c && 0 !== c.length && (!a || f)) { let e = a ? 0 : n, t = 4 * e, r = p.clippingState || null; u.value = r, r = h(c, o, t, l); for (let e = 0; e !== t; ++e)r[e] = i[e]; p.clippingState = r, this.numIntersection = d ? this.numPlanes : 0, this.numPlanes += e } else a ? h(null) : (u.value !== i && (u.value = i, u.needsUpdate = n > 0), t.numPlanes = n, t.numIntersection = 0) } } function v(e) { let t = new WeakMap; function i(e, t) { return t === r.wfO ? e.mapping = r.hy7 : t === r.uV5 && (e.mapping = r.xFO), e } function n(e) { let i = e.target; i.removeEventListener("dispose", n); let r = t.get(i); void 0 !== r && (t.delete(i), r.dispose()) } return { get: function (s) { if (s && s.isTexture) { let a = s.mapping; if (a === r.wfO || a === r.uV5) { if (t.has(s)) return i(t.get(s).texture, s.mapping); { let a = s.image; if (!a || !(a.height > 0)) return null; { let o = new r.o6l(a.height); return o.fromEquirectangularTexture(e, s), t.set(s, o), s.addEventListener("dispose", n), i(o.texture, s.mapping) } } } } return s }, dispose: function () { t = new WeakMap } } } let y = [.125, .215, .35, .446, .526, .582], x = new r.qUd, S = new r.Q1f, A = null, _ = 0, E = 0, b = !1, T = (1 + Math.sqrt(5)) / 2, w = 1 / T, M = [new r.Pq0(-T, w, 0), new r.Pq0(T, w, 0), new r.Pq0(-w, 0, T), new r.Pq0(w, 0, T), new r.Pq0(0, T, -w), new r.Pq0(0, T, w), new r.Pq0(-1, 1, -1), new r.Pq0(1, 1, -1), new r.Pq0(-1, 1, 1), new r.Pq0(1, 1, 1)], R = new r.Pq0; class C {
      constructor(e) { this._renderer = e, this._pingPongRenderTarget = null, this._lodMax = 0, this._cubeSize = 0, this._lodPlanes = [], this._sizeLods = [], this._sigmas = [], this._blurMaterial = null, this._cubemapMaterial = null, this._equirectMaterial = null, this._compileMaterial(this._blurMaterial) } fromScene(e, t = 0, i = .1, r = 100, n = {}) { let { size: s = 256, position: a = R } = n; A = this._renderer.getRenderTarget(), _ = this._renderer.getActiveCubeFace(), E = this._renderer.getActiveMipmapLevel(), b = this._renderer.xr.enabled, this._renderer.xr.enabled = !1, this._setSize(s); let o = this._allocateTargets(); return o.depthBuffer = !0, this._sceneToCubeUV(e, i, r, o, a), t > 0 && this._blur(o, 0, 0, t), this._applyPMREM(o), this._cleanup(o), o } fromEquirectangular(e, t = null) { return this._fromTexture(e, t) } fromCubemap(e, t = null) { return this._fromTexture(e, t) } compileCubemapShader() { null === this._cubemapMaterial && (this._cubemapMaterial = D(), this._compileMaterial(this._cubemapMaterial)) } compileEquirectangularShader() { null === this._equirectMaterial && (this._equirectMaterial = P(), this._compileMaterial(this._equirectMaterial)) } dispose() { this._dispose(), null !== this._cubemapMaterial && this._cubemapMaterial.dispose(), null !== this._equirectMaterial && this._equirectMaterial.dispose() } _setSize(e) { this._lodMax = Math.floor(Math.log2(e)), this._cubeSize = Math.pow(2, this._lodMax) } _dispose() { null !== this._blurMaterial && this._blurMaterial.dispose(), null !== this._pingPongRenderTarget && this._pingPongRenderTarget.dispose(); for (let e = 0; e < this._lodPlanes.length; e++)this._lodPlanes[e].dispose() } _cleanup(e) { this._renderer.setRenderTarget(A, _, E), this._renderer.xr.enabled = b, e.scissorTest = !1, L(e, 0, 0, e.width, e.height) } _fromTexture(e, t) { e.mapping === r.hy7 || e.mapping === r.xFO ? this._setSize(0 === e.image.length ? 16 : e.image[0].width || e.image[0].image.width) : this._setSize(e.image.width / 4), A = this._renderer.getRenderTarget(), _ = this._renderer.getActiveCubeFace(), E = this._renderer.getActiveMipmapLevel(), b = this._renderer.xr.enabled, this._renderer.xr.enabled = !1; let i = t || this._allocateTargets(); return this._textureToCubeUV(e, i), this._applyPMREM(i), this._cleanup(i), i } _allocateTargets() {
        let e = 3 * Math.max(this._cubeSize, 112), t = 4 * this._cubeSize, i = { magFilter: r.k6q, minFilter: r.k6q, generateMipmaps: !1, type: r.ix0, format: r.GWd, colorSpace: r.Zr2, depthBuffer: !1 }, n = I(e, t, i); if (null === this._pingPongRenderTarget || this._pingPongRenderTarget.width !== e || this._pingPongRenderTarget.height !== t) {
          null !== this._pingPongRenderTarget && this._dispose(), this._pingPongRenderTarget = I(e, t, i); let { _lodMax: n } = this; ({ sizeLods: this._sizeLods, lodPlanes: this._lodPlanes, sigmas: this._sigmas } = function (e) { let t = [], i = [], n = [], s = e, a = e - 4 + 1 + y.length; for (let o = 0; o < a; o++) { let a = Math.pow(2, s); i.push(a); let l = 1 / a; o > e - 4 ? l = y[o - e + 4 - 1] : 0 === o && (l = 0), n.push(l); let u = 1 / (a - 2), h = -u, c = 1 + u, d = [h, h, c, h, c, c, h, h, c, c, h, c], f = new Float32Array(108), p = new Float32Array(72), m = new Float32Array(36); for (let e = 0; e < 6; e++) { let t = e % 3 * 2 / 3 - 1, i = e > 2 ? 0 : -1, r = [t, i, 0, t + 2 / 3, i, 0, t + 2 / 3, i + 1, 0, t, i, 0, t + 2 / 3, i + 1, 0, t, i + 1, 0]; f.set(r, 18 * e), p.set(d, 12 * e); let n = [e, e, e, e, e, e]; m.set(n, 6 * e) } let g = new r.LoY; g.setAttribute("position", new r.THS(f, 3)), g.setAttribute("uv", new r.THS(p, 2)), g.setAttribute("faceIndex", new r.THS(m, 1)), t.push(g), s > 4 && s-- } return { lodPlanes: t, sizeLods: i, sigmas: n } }(n)), this._blurMaterial = function (e, t, i) {
            let n = new Float32Array(20), s = new r.Pq0(0, 1, 0); return new r.BKk({
              name: "SphericalGaussianBlur", defines: { n: 20, CUBEUV_TEXEL_WIDTH: 1 / t, CUBEUV_TEXEL_HEIGHT: 1 / i, CUBEUV_MAX_MIP: `${e}.0` }, uniforms: { envMap: { value: null }, samples: { value: 1 }, weights: { value: n }, latitudinal: { value: !1 }, dTheta: { value: 0 }, mipInt: { value: 0 }, poleAxis: { value: s } }, vertexShader: O(), fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`, blending: r.XIg, depthTest: !1, depthWrite: !1
            })
          }(n, e, t)
        } return n
      } _compileMaterial(e) { let t = new r.eaF(this._lodPlanes[0], e); this._renderer.compile(t, x) } _sceneToCubeUV(e, t, i, n, s) { let a = new r.ubm(90, 1, t, i), o = [1, -1, 1, 1, 1, 1], l = [1, 1, 1, -1, -1, -1], u = this._renderer, h = u.autoClear, c = u.toneMapping; u.getClearColor(S), u.toneMapping = r.y_p, u.autoClear = !1; let d = new r.V9B({ name: "PMREM.Background", side: r.hsX, depthWrite: !1, depthTest: !1 }), f = new r.eaF(new r.iNn, d), p = !1, m = e.background; m ? m.isColor && (d.color.copy(m), e.background = null, p = !0) : (d.color.copy(S), p = !0); for (let t = 0; t < 6; t++) { let i = t % 3; 0 === i ? (a.up.set(0, o[t], 0), a.position.set(s.x, s.y, s.z), a.lookAt(s.x + l[t], s.y, s.z)) : 1 === i ? (a.up.set(0, 0, o[t]), a.position.set(s.x, s.y, s.z), a.lookAt(s.x, s.y + l[t], s.z)) : (a.up.set(0, o[t], 0), a.position.set(s.x, s.y, s.z), a.lookAt(s.x, s.y, s.z + l[t])); let r = this._cubeSize; L(n, i * r, t > 2 ? r : 0, r, r), u.setRenderTarget(n), p && u.render(f, a), u.render(e, a) } f.geometry.dispose(), f.material.dispose(), u.toneMapping = c, u.autoClear = h, e.background = m } _textureToCubeUV(e, t) { let i = this._renderer, n = e.mapping === r.hy7 || e.mapping === r.xFO; n ? (null === this._cubemapMaterial && (this._cubemapMaterial = D()), this._cubemapMaterial.uniforms.flipEnvMap.value = !1 === e.isRenderTargetTexture ? -1 : 1) : null === this._equirectMaterial && (this._equirectMaterial = P()); let s = n ? this._cubemapMaterial : this._equirectMaterial, a = new r.eaF(this._lodPlanes[0], s); s.uniforms.envMap.value = e; let o = this._cubeSize; L(t, 0, 0, 3 * o, 2 * o), i.setRenderTarget(t), i.render(a, x) } _applyPMREM(e) { let t = this._renderer, i = t.autoClear; t.autoClear = !1; let r = this._lodPlanes.length; for (let t = 1; t < r; t++) { let i = Math.sqrt(this._sigmas[t] * this._sigmas[t] - this._sigmas[t - 1] * this._sigmas[t - 1]), n = M[(r - t - 1) % M.length]; this._blur(e, t - 1, t, i, n) } t.autoClear = i } _blur(e, t, i, r, n) { let s = this._pingPongRenderTarget; this._halfBlur(e, s, t, i, r, "latitudinal", n), this._halfBlur(s, e, i, i, r, "longitudinal", n) } _halfBlur(e, t, i, n, s, a, o) { let l = this._renderer, u = this._blurMaterial; "latitudinal" !== a && "longitudinal" !== a && console.error("blur direction must be either latitudinal or longitudinal!"); let h = new r.eaF(this._lodPlanes[n], u), c = u.uniforms, d = this._sizeLods[i] - 1, f = isFinite(s) ? Math.PI / (2 * d) : 2 * Math.PI / 39, p = s / f, m = isFinite(s) ? 1 + Math.floor(3 * p) : 20; m > 20 && console.warn(`sigmaRadians, ${s}, is too large and will clip, as it requested ${m} samples when the maximum is set to 20`); let g = [], v = 0; for (let e = 0; e < 20; ++e) { let t = e / p, i = Math.exp(-t * t / 2); g.push(i), 0 === e ? v += i : e < m && (v += 2 * i) } for (let e = 0; e < g.length; e++)g[e] = g[e] / v; c.envMap.value = e.texture, c.samples.value = m, c.weights.value = g, c.latitudinal.value = "latitudinal" === a, o && (c.poleAxis.value = o); let { _lodMax: y } = this; c.dTheta.value = f, c.mipInt.value = y - i; let S = this._sizeLods[n], A = 4 * (this._cubeSize - S); L(t, 3 * S * (n > y - 4 ? n - y + 4 : 0), A, 3 * S, 2 * S), l.setRenderTarget(t), l.render(h, x) }
    } function I(e, t, i) { let n = new r.nWS(e, t, i); return n.texture.mapping = r.Om, n.texture.name = "PMREM.cubeUv", n.scissorTest = !0, n } function L(e, t, i, r, n) { e.viewport.set(t, i, r, n), e.scissor.set(t, i, r, n) } function P() {
      return new r.BKk({
        name: "EquirectangularToCubeUV", uniforms: { envMap: { value: null } }, vertexShader: O(), fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`, blending: r.XIg, depthTest: !1, depthWrite: !1
      })
    } function D() {
      return new r.BKk({
        name: "CubemapToCubeUV", uniforms: { envMap: { value: null }, flipEnvMap: { value: -1 } }, vertexShader: O(), fragmentShader: `

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`, blending: r.XIg, depthTest: !1, depthWrite: !1
      })
    } function O() {
      return `

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`} function k(e) { let t = new WeakMap, i = null; function n(e) { let i = e.target; i.removeEventListener("dispose", n); let r = t.get(i); void 0 !== r && (t.delete(i), r.dispose()) } return { get: function (s) { if (s && s.isTexture) { let a = s.mapping, o = a === r.wfO || a === r.uV5, l = a === r.hy7 || a === r.xFO; if (o || l) { let r = t.get(s), a = void 0 !== r ? r.texture.pmremVersion : 0; if (s.isRenderTargetTexture && s.pmremVersion !== a) return null === i && (i = new C(e)), (r = o ? i.fromEquirectangular(s, r) : i.fromCubemap(s, r)).texture.pmremVersion = s.pmremVersion, t.set(s, r), r.texture; if (void 0 !== r) return r.texture; { let a = s.image; return o && a && a.height > 0 || l && a && function (e) { let t = 0; for (let i = 0; i < 6; i++)void 0 !== e[i] && t++; return 6 === t }(a) ? (null === i && (i = new C(e)), (r = o ? i.fromEquirectangular(s) : i.fromCubemap(s)).texture.pmremVersion = s.pmremVersion, t.set(s, r), s.addEventListener("dispose", n), r.texture) : null } } } return s }, dispose: function () { t = new WeakMap, null !== i && (i.dispose(), i = null) } } } function F(e) { let t = {}; function i(i) { let r; if (void 0 !== t[i]) return t[i]; switch (i) { case "WEBGL_depth_texture": r = e.getExtension("WEBGL_depth_texture") || e.getExtension("MOZ_WEBGL_depth_texture") || e.getExtension("WEBKIT_WEBGL_depth_texture"); break; case "EXT_texture_filter_anisotropic": r = e.getExtension("EXT_texture_filter_anisotropic") || e.getExtension("MOZ_EXT_texture_filter_anisotropic") || e.getExtension("WEBKIT_EXT_texture_filter_anisotropic"); break; case "WEBGL_compressed_texture_s3tc": r = e.getExtension("WEBGL_compressed_texture_s3tc") || e.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || e.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc"); break; case "WEBGL_compressed_texture_pvrtc": r = e.getExtension("WEBGL_compressed_texture_pvrtc") || e.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc"); break; default: r = e.getExtension(i) }return t[i] = r, r } return { has: function (e) { return null !== i(e) }, init: function () { i("EXT_color_buffer_float"), i("WEBGL_clip_cull_distance"), i("OES_texture_float_linear"), i("EXT_color_buffer_half_float"), i("WEBGL_multisampled_render_to_texture"), i("WEBGL_render_shared_exponent") }, get: function (e) { let t = i(e); return null === t && (0, r.mcG)("THREE.WebGLRenderer: " + e + " extension not supported."), t } } } function U(e, t, i, n) { let s = {}, a = new WeakMap; function o(e) { let r = e.target; for (let e in null !== r.index && t.remove(r.index), r.attributes) t.remove(r.attributes[e]); r.removeEventListener("dispose", o), delete s[r.id]; let l = a.get(r); l && (t.remove(l), a.delete(r)), n.releaseStatesOfGeometry(r), !0 === r.isInstancedBufferGeometry && delete r._maxInstanceCount, i.memory.geometries-- } function l(e) { let i = [], n = e.index, s = e.attributes.position, o = 0; if (null !== n) { let e = n.array; o = n.version; for (let t = 0, r = e.length; t < r; t += 3) { let r = e[t + 0], n = e[t + 1], s = e[t + 2]; i.push(r, n, n, s, s, r) } } else { if (void 0 === s) return; let e = s.array; o = s.version; for (let t = 0, r = e.length / 3 - 1; t < r; t += 3) { let e = t + 0, r = t + 1, n = t + 2; i.push(e, r, r, n, n, e) } } let l = new ((0, r.AQS)(i) ? r.MW4 : r.A$4)(i, 1); l.version = o; let u = a.get(e); u && t.remove(u), a.set(e, l) } return { get: function (e, t) { return !0 === s[t.id] || (t.addEventListener("dispose", o), s[t.id] = !0, i.memory.geometries++), t }, update: function (i) { let r = i.attributes; for (let i in r) t.update(r[i], e.ARRAY_BUFFER) }, getWireframeAttribute: function (e) { let t = a.get(e); if (t) { let i = e.index; null !== i && t.version < i.version && l(e) } else l(e); return a.get(e) } } } function N(e, t, i) { let r, n, s; function a(t, a, o) { 0 !== o && (e.drawElementsInstanced(r, a, n, t * s, o), i.update(a, r, o)) } this.setMode = function (e) { r = e }, this.setIndex = function (e) { n = e.type, s = e.bytesPerElement }, this.render = function (t, a) { e.drawElements(r, a, n, t * s), i.update(a, r, 1) }, this.renderInstances = a, this.renderMultiDraw = function (e, s, a) { if (0 === a) return; t.get("WEBGL_multi_draw").multiDrawElementsWEBGL(r, s, 0, n, e, 0, a); let o = 0; for (let e = 0; e < a; e++)o += s[e]; i.update(o, r, 1) }, this.renderMultiDrawInstances = function (e, o, l, u) { if (0 === l) return; let h = t.get("WEBGL_multi_draw"); if (null === h) for (let t = 0; t < e.length; t++)a(e[t] / s, o[t], u[t]); else { h.multiDrawElementsInstancedWEBGL(r, o, 0, n, e, 0, u, 0, l); let t = 0; for (let e = 0; e < l; e++)t += o[e] * u[e]; i.update(t, r, 1) } } } function B(e) { let t = { frame: 0, calls: 0, triangles: 0, points: 0, lines: 0 }; return { memory: { geometries: 0, textures: 0 }, render: t, programs: null, autoReset: !0, reset: function () { t.calls = 0, t.triangles = 0, t.points = 0, t.lines = 0 }, update: function (i, r, n) { switch (t.calls++, r) { case e.TRIANGLES: t.triangles += i / 3 * n; break; case e.LINES: t.lines += i / 2 * n; break; case e.LINE_STRIP: t.lines += n * (i - 1); break; case e.LINE_LOOP: t.lines += n * i; break; case e.POINTS: t.points += n * i; break; default: console.error("THREE.WebGLInfo: Unknown draw mode:", r) } } } } function z(e, t, i) { let n = new WeakMap, s = new r.IUQ; return { update: function (a, o, l) { let u = a.morphTargetInfluences, h = o.morphAttributes.position || o.morphAttributes.normal || o.morphAttributes.color, c = void 0 !== h ? h.length : 0, d = n.get(o); if (void 0 === d || d.count !== c) { void 0 !== d && d.texture.dispose(); let e = void 0 !== o.morphAttributes.position, i = void 0 !== o.morphAttributes.normal, a = void 0 !== o.morphAttributes.color, l = o.morphAttributes.position || [], u = o.morphAttributes.normal || [], h = o.morphAttributes.color || [], f = 0; !0 === e && (f = 1), !0 === i && (f = 2), !0 === a && (f = 3); let p = o.attributes.position.count * f, m = 1; p > t.maxTextureSize && (m = Math.ceil(p / t.maxTextureSize), p = t.maxTextureSize); let g = new Float32Array(p * m * 4 * c), v = new r.rFo(g, p, m, c); v.type = r.RQf, v.needsUpdate = !0; let y = 4 * f; for (let t = 0; t < c; t++) { let r = l[t], n = u[t], o = h[t], c = p * m * 4 * t; for (let t = 0; t < r.count; t++) { let l = t * y; !0 === e && (s.fromBufferAttribute(r, t), g[c + l + 0] = s.x, g[c + l + 1] = s.y, g[c + l + 2] = s.z, g[c + l + 3] = 0), !0 === i && (s.fromBufferAttribute(n, t), g[c + l + 4] = s.x, g[c + l + 5] = s.y, g[c + l + 6] = s.z, g[c + l + 7] = 0), !0 === a && (s.fromBufferAttribute(o, t), g[c + l + 8] = s.x, g[c + l + 9] = s.y, g[c + l + 10] = s.z, g[c + l + 11] = 4 === o.itemSize ? s.w : 1) } } d = { count: c, texture: v, size: new r.I9Y(p, m) }, n.set(o, d), o.addEventListener("dispose", function e() { v.dispose(), n.delete(o), o.removeEventListener("dispose", e) }) } if (!0 === a.isInstancedMesh && null !== a.morphTexture) l.getUniforms().setValue(e, "morphTexture", a.morphTexture, i); else { let t = 0; for (let e = 0; e < u.length; e++)t += u[e]; let i = o.morphTargetsRelative ? 1 : 1 - t; l.getUniforms().setValue(e, "morphTargetBaseInfluence", i), l.getUniforms().setValue(e, "morphTargetInfluences", u) } l.getUniforms().setValue(e, "morphTargetsTexture", d.texture, i), l.getUniforms().setValue(e, "morphTargetsTextureSize", d.size) } } } function G(e, t, i, r) { let n = new WeakMap; function s(e) { let t = e.target; t.removeEventListener("dispose", s), i.remove(t.instanceMatrix), null !== t.instanceColor && i.remove(t.instanceColor) } return { update: function (a) { let o = r.render.frame, l = a.geometry, u = t.get(a, l); if (n.get(u) !== o && (t.update(u), n.set(u, o)), a.isInstancedMesh && (!1 === a.hasEventListener("dispose", s) && a.addEventListener("dispose", s), n.get(a) !== o && (i.update(a.instanceMatrix, e.ARRAY_BUFFER), null !== a.instanceColor && i.update(a.instanceColor, e.ARRAY_BUFFER), n.set(a, o))), a.isSkinnedMesh) { let e = a.skeleton; n.get(e) !== o && (e.update(), n.set(e, o)) } return u }, dispose: function () { n = new WeakMap } } } let H = new r.gPd, V = new r.VCu(1, 1), W = new r.rFo, j = new r.dYF, Y = new r.b4q, X = [], K = [], q = new Float32Array(16), Q = new Float32Array(9), Z = new Float32Array(4); function $(e, t, i) { let r = e[0]; if (r <= 0 || r > 0) return e; let n = t * i, s = X[n]; if (void 0 === s && (s = new Float32Array(n), X[n] = s), 0 !== t) { r.toArray(s, 0); for (let r = 1, n = 0; r !== t; ++r)n += i, e[r].toArray(s, n) } return s } function J(e, t) { if (e.length !== t.length) return !1; for (let i = 0, r = e.length; i < r; i++)if (e[i] !== t[i]) return !1; return !0 } function ee(e, t) { for (let i = 0, r = t.length; i < r; i++)e[i] = t[i] } function et(e, t) { let i = K[t]; void 0 === i && (i = new Int32Array(t), K[t] = i); for (let r = 0; r !== t; ++r)i[r] = e.allocateTextureUnit(); return i } function ei(e, t) { let i = this.cache; i[0] !== t && (e.uniform1f(this.addr, t), i[0] = t) } function er(e, t) { let i = this.cache; if (void 0 !== t.x) (i[0] !== t.x || i[1] !== t.y) && (e.uniform2f(this.addr, t.x, t.y), i[0] = t.x, i[1] = t.y); else { if (J(i, t)) return; e.uniform2fv(this.addr, t), ee(i, t) } } function en(e, t) { let i = this.cache; if (void 0 !== t.x) (i[0] !== t.x || i[1] !== t.y || i[2] !== t.z) && (e.uniform3f(this.addr, t.x, t.y, t.z), i[0] = t.x, i[1] = t.y, i[2] = t.z); else if (void 0 !== t.r) (i[0] !== t.r || i[1] !== t.g || i[2] !== t.b) && (e.uniform3f(this.addr, t.r, t.g, t.b), i[0] = t.r, i[1] = t.g, i[2] = t.b); else { if (J(i, t)) return; e.uniform3fv(this.addr, t), ee(i, t) } } function es(e, t) { let i = this.cache; if (void 0 !== t.x) (i[0] !== t.x || i[1] !== t.y || i[2] !== t.z || i[3] !== t.w) && (e.uniform4f(this.addr, t.x, t.y, t.z, t.w), i[0] = t.x, i[1] = t.y, i[2] = t.z, i[3] = t.w); else { if (J(i, t)) return; e.uniform4fv(this.addr, t), ee(i, t) } } function ea(e, t) { let i = this.cache, r = t.elements; if (void 0 === r) { if (J(i, t)) return; e.uniformMatrix2fv(this.addr, !1, t), ee(i, t) } else { if (J(i, r)) return; Z.set(r), e.uniformMatrix2fv(this.addr, !1, Z), ee(i, r) } } function eo(e, t) { let i = this.cache, r = t.elements; if (void 0 === r) { if (J(i, t)) return; e.uniformMatrix3fv(this.addr, !1, t), ee(i, t) } else { if (J(i, r)) return; Q.set(r), e.uniformMatrix3fv(this.addr, !1, Q), ee(i, r) } } function el(e, t) { let i = this.cache, r = t.elements; if (void 0 === r) { if (J(i, t)) return; e.uniformMatrix4fv(this.addr, !1, t), ee(i, t) } else { if (J(i, r)) return; q.set(r), e.uniformMatrix4fv(this.addr, !1, q), ee(i, r) } } function eu(e, t) { let i = this.cache; i[0] !== t && (e.uniform1i(this.addr, t), i[0] = t) } function eh(e, t) { let i = this.cache; if (void 0 !== t.x) (i[0] !== t.x || i[1] !== t.y) && (e.uniform2i(this.addr, t.x, t.y), i[0] = t.x, i[1] = t.y); else { if (J(i, t)) return; e.uniform2iv(this.addr, t), ee(i, t) } } function ec(e, t) { let i = this.cache; if (void 0 !== t.x) (i[0] !== t.x || i[1] !== t.y || i[2] !== t.z) && (e.uniform3i(this.addr, t.x, t.y, t.z), i[0] = t.x, i[1] = t.y, i[2] = t.z); else { if (J(i, t)) return; e.uniform3iv(this.addr, t), ee(i, t) } } function ed(e, t) { let i = this.cache; if (void 0 !== t.x) (i[0] !== t.x || i[1] !== t.y || i[2] !== t.z || i[3] !== t.w) && (e.uniform4i(this.addr, t.x, t.y, t.z, t.w), i[0] = t.x, i[1] = t.y, i[2] = t.z, i[3] = t.w); else { if (J(i, t)) return; e.uniform4iv(this.addr, t), ee(i, t) } } function ef(e, t) { let i = this.cache; i[0] !== t && (e.uniform1ui(this.addr, t), i[0] = t) } function ep(e, t) { let i = this.cache; if (void 0 !== t.x) (i[0] !== t.x || i[1] !== t.y) && (e.uniform2ui(this.addr, t.x, t.y), i[0] = t.x, i[1] = t.y); else { if (J(i, t)) return; e.uniform2uiv(this.addr, t), ee(i, t) } } function em(e, t) { let i = this.cache; if (void 0 !== t.x) (i[0] !== t.x || i[1] !== t.y || i[2] !== t.z) && (e.uniform3ui(this.addr, t.x, t.y, t.z), i[0] = t.x, i[1] = t.y, i[2] = t.z); else { if (J(i, t)) return; e.uniform3uiv(this.addr, t), ee(i, t) } } function eg(e, t) { let i = this.cache; if (void 0 !== t.x) (i[0] !== t.x || i[1] !== t.y || i[2] !== t.z || i[3] !== t.w) && (e.uniform4ui(this.addr, t.x, t.y, t.z, t.w), i[0] = t.x, i[1] = t.y, i[2] = t.z, i[3] = t.w); else { if (J(i, t)) return; e.uniform4uiv(this.addr, t), ee(i, t) } } function ev(e, t, i) { let n; let s = this.cache, a = i.allocateTextureUnit(); s[0] !== a && (e.uniform1i(this.addr, a), s[0] = a), this.type === e.SAMPLER_2D_SHADOW ? (V.compareFunction = r.TiK, n = V) : n = H, i.setTexture2D(t || n, a) } function ey(e, t, i) { let r = this.cache, n = i.allocateTextureUnit(); r[0] !== n && (e.uniform1i(this.addr, n), r[0] = n), i.setTexture3D(t || j, n) } function ex(e, t, i) { let r = this.cache, n = i.allocateTextureUnit(); r[0] !== n && (e.uniform1i(this.addr, n), r[0] = n), i.setTextureCube(t || Y, n) } function eS(e, t, i) { let r = this.cache, n = i.allocateTextureUnit(); r[0] !== n && (e.uniform1i(this.addr, n), r[0] = n), i.setTexture2DArray(t || W, n) } function eA(e, t) { e.uniform1fv(this.addr, t) } function e_(e, t) { let i = $(t, this.size, 2); e.uniform2fv(this.addr, i) } function eE(e, t) { let i = $(t, this.size, 3); e.uniform3fv(this.addr, i) } function eb(e, t) { let i = $(t, this.size, 4); e.uniform4fv(this.addr, i) } function eT(e, t) { let i = $(t, this.size, 4); e.uniformMatrix2fv(this.addr, !1, i) } function ew(e, t) { let i = $(t, this.size, 9); e.uniformMatrix3fv(this.addr, !1, i) } function eM(e, t) { let i = $(t, this.size, 16); e.uniformMatrix4fv(this.addr, !1, i) } function eR(e, t) { e.uniform1iv(this.addr, t) } function eC(e, t) { e.uniform2iv(this.addr, t) } function eI(e, t) { e.uniform3iv(this.addr, t) } function eL(e, t) { e.uniform4iv(this.addr, t) } function eP(e, t) { e.uniform1uiv(this.addr, t) } function eD(e, t) { e.uniform2uiv(this.addr, t) } function eO(e, t) { e.uniform3uiv(this.addr, t) } function ek(e, t) { e.uniform4uiv(this.addr, t) } function eF(e, t, i) { let r = this.cache, n = t.length, s = et(i, n); J(r, s) || (e.uniform1iv(this.addr, s), ee(r, s)); for (let e = 0; e !== n; ++e)i.setTexture2D(t[e] || H, s[e]) } function eU(e, t, i) { let r = this.cache, n = t.length, s = et(i, n); J(r, s) || (e.uniform1iv(this.addr, s), ee(r, s)); for (let e = 0; e !== n; ++e)i.setTexture3D(t[e] || j, s[e]) } function eN(e, t, i) { let r = this.cache, n = t.length, s = et(i, n); J(r, s) || (e.uniform1iv(this.addr, s), ee(r, s)); for (let e = 0; e !== n; ++e)i.setTextureCube(t[e] || Y, s[e]) } function eB(e, t, i) { let r = this.cache, n = t.length, s = et(i, n); J(r, s) || (e.uniform1iv(this.addr, s), ee(r, s)); for (let e = 0; e !== n; ++e)i.setTexture2DArray(t[e] || W, s[e]) } class ez { constructor(e, t, i) { this.id = e, this.addr = i, this.cache = [], this.type = t.type, this.setValue = function (e) { switch (e) { case 5126: return ei; case 35664: return er; case 35665: return en; case 35666: return es; case 35674: return ea; case 35675: return eo; case 35676: return el; case 5124: case 35670: return eu; case 35667: case 35671: return eh; case 35668: case 35672: return ec; case 35669: case 35673: return ed; case 5125: return ef; case 36294: return ep; case 36295: return em; case 36296: return eg; case 35678: case 36198: case 36298: case 36306: case 35682: return ev; case 35679: case 36299: case 36307: return ey; case 35680: case 36300: case 36308: case 36293: return ex; case 36289: case 36303: case 36311: case 36292: return eS } }(t.type) } } class eG { constructor(e, t, i) { this.id = e, this.addr = i, this.cache = [], this.type = t.type, this.size = t.size, this.setValue = function (e) { switch (e) { case 5126: return eA; case 35664: return e_; case 35665: return eE; case 35666: return eb; case 35674: return eT; case 35675: return ew; case 35676: return eM; case 5124: case 35670: return eR; case 35667: case 35671: return eC; case 35668: case 35672: return eI; case 35669: case 35673: return eL; case 5125: return eP; case 36294: return eD; case 36295: return eO; case 36296: return ek; case 35678: case 36198: case 36298: case 36306: case 35682: return eF; case 35679: case 36299: case 36307: return eU; case 35680: case 36300: case 36308: case 36293: return eN; case 36289: case 36303: case 36311: case 36292: return eB } }(t.type) } } class eH { constructor(e) { this.id = e, this.seq = [], this.map = {} } setValue(e, t, i) { let r = this.seq; for (let n = 0, s = r.length; n !== s; ++n) { let s = r[n]; s.setValue(e, t[s.id], i) } } } let eV = /(\w+)(\])?(\[|\.)?/g; function eW(e, t) { e.seq.push(t), e.map[t.id] = t } class ej { constructor(e, t) { this.seq = [], this.map = {}; let i = e.getProgramParameter(t, e.ACTIVE_UNIFORMS); for (let r = 0; r < i; ++r) { let i = e.getActiveUniform(t, r), n = e.getUniformLocation(t, i.name); !function (e, t, i) { let r = e.name, n = r.length; for (eV.lastIndex = 0; ;) { let s = eV.exec(r), a = eV.lastIndex, o = s[1], l = "]" === s[2], u = s[3]; if (l && (o |= 0), void 0 === u || "[" === u && a + 2 === n) { eW(i, void 0 === u ? new ez(o, e, t) : new eG(o, e, t)); break } { let e = i.map[o]; void 0 === e && eW(i, e = new eH(o)), i = e } } }(i, n, this) } } setValue(e, t, i, r) { let n = this.map[t]; void 0 !== n && n.setValue(e, i, r) } setOptional(e, t, i) { let r = t[i]; void 0 !== r && this.setValue(e, i, r) } static upload(e, t, i, r) { for (let n = 0, s = t.length; n !== s; ++n) { let s = t[n], a = i[s.id]; !1 !== a.needsUpdate && s.setValue(e, a.value, r) } } static seqWithValue(e, t) { let i = []; for (let r = 0, n = e.length; r !== n; ++r) { let n = e[r]; n.id in t && i.push(n) } return i } } function eY(e, t, i) { let r = e.createShader(t); return e.shaderSource(r, i), e.compileShader(r), r } let eX = 0, eK = new r.dwI; function eq(e, t, i) { let r = e.getShaderParameter(t, e.COMPILE_STATUS), n = e.getShaderInfoLog(t).trim(); if (r && "" === n) return ""; let s = /ERROR: 0:(\d+)/.exec(n); if (!s) return n; { let r = parseInt(s[1]); return i.toUpperCase() + "\n\n" + n + "\n\n" + function (e, t) { let i = e.split("\n"), r = [], n = Math.max(t - 6, 0), s = Math.min(t + 6, i.length); for (let e = n; e < s; e++) { let n = e + 1; r.push(`${n === t ? ">" : " "} ${n}: ${i[e]}`) } return r.join("\n") }(e.getShaderSource(t), r) } } let eQ = new r.Pq0; function eZ(e) { return "" !== e } function e$(e, t) { let i = t.numSpotLightShadows + t.numSpotLightMaps - t.numSpotLightShadowsWithMaps; return e.replace(/NUM_DIR_LIGHTS/g, t.numDirLights).replace(/NUM_SPOT_LIGHTS/g, t.numSpotLights).replace(/NUM_SPOT_LIGHT_MAPS/g, t.numSpotLightMaps).replace(/NUM_SPOT_LIGHT_COORDS/g, i).replace(/NUM_RECT_AREA_LIGHTS/g, t.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, t.numPointLights).replace(/NUM_HEMI_LIGHTS/g, t.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, t.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g, t.numSpotLightShadowsWithMaps).replace(/NUM_SPOT_LIGHT_SHADOWS/g, t.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, t.numPointLightShadows) } function eJ(e, t) { return e.replace(/NUM_CLIPPING_PLANES/g, t.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, t.numClippingPlanes - t.numClipIntersection) } let e0 = /^[ \t]*#include +<([\w\d./]+)>/gm; function e1(e) { return e.replace(e0, e3) } let e2 = new Map; function e3(e, t) { let i = a[t]; if (void 0 === i) { let e = e2.get(t); if (void 0 !== e) i = a[e], console.warn('THREE.WebGLRenderer: Shader chunk "%s" has been deprecated. Use "%s" instead.', t, e); else throw Error("Can not resolve #include <" + t + ">") } return e1(i) } let e4 = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g; function e5(e) { return e.replace(e4, e8) } function e8(e, t, i, r) { let n = ""; for (let e = parseInt(t); e < parseInt(i); e++)n += r.replace(/\[\s*i\s*\]/g, "[ " + e + " ]").replace(/UNROLLED_LOOP_INDEX/g, e); return n } function e6(e) {
      let t = `precision ${e.precision} float;
	precision ${e.precision} int;
	precision ${e.precision} sampler2D;
	precision ${e.precision} samplerCube;
	precision ${e.precision} sampler3D;
	precision ${e.precision} sampler2DArray;
	precision ${e.precision} sampler2DShadow;
	precision ${e.precision} samplerCubeShadow;
	precision ${e.precision} sampler2DArrayShadow;
	precision ${e.precision} isampler2D;
	precision ${e.precision} isampler3D;
	precision ${e.precision} isamplerCube;
	precision ${e.precision} isampler2DArray;
	precision ${e.precision} usampler2D;
	precision ${e.precision} usampler3D;
	precision ${e.precision} usamplerCube;
	precision ${e.precision} usampler2DArray;
	`; return "highp" === e.precision ? t += "\n#define HIGH_PRECISION" : "mediump" === e.precision ? t += "\n#define MEDIUM_PRECISION" : "lowp" === e.precision && (t += "\n#define LOW_PRECISION"), t
    } function e9(e, t, i, n) {
      let s, o, l, u, h, c; let d = e.getContext(), f = i.defines, p = i.vertexShader, m = i.fragmentShader, g = (h = "SHADOWMAP_TYPE_BASIC", i.shadowMapType === r.QP0 ? h = "SHADOWMAP_TYPE_PCF" : i.shadowMapType === r.Wk7 ? h = "SHADOWMAP_TYPE_PCF_SOFT" : i.shadowMapType === r.RyA && (h = "SHADOWMAP_TYPE_VSM"), h), v = function (e) { let t = "ENVMAP_TYPE_CUBE"; if (e.envMap) switch (e.envMapMode) { case r.hy7: case r.xFO: t = "ENVMAP_TYPE_CUBE"; break; case r.Om: t = "ENVMAP_TYPE_CUBE_UV" }return t }(i), y = (c = "ENVMAP_MODE_REFLECTION", i.envMap && i.envMapMode === r.xFO && (c = "ENVMAP_MODE_REFRACTION"), c), x = function (e) { let t = "ENVMAP_BLENDING_NONE"; if (e.envMap) switch (e.combine) { case r.caT: t = "ENVMAP_BLENDING_MULTIPLY"; break; case r.KRh: t = "ENVMAP_BLENDING_MIX"; break; case r.XrR: t = "ENVMAP_BLENDING_ADD" }return t }(i), S = function (e) { let t = e.envMapCubeUVHeight; if (null === t) return null; let i = Math.log2(t) - 2; return { texelWidth: 1 / (3 * Math.max(Math.pow(2, i), 112)), texelHeight: 1 / t, maxMip: i } }(i), A = [i.extensionClipCullDistance ? "#extension GL_ANGLE_clip_cull_distance : require" : "", i.extensionMultiDraw ? "#extension GL_ANGLE_multi_draw : require" : ""].filter(eZ).join("\n"), _ = function (e) { let t = []; for (let i in e) { let r = e[i]; !1 !== r && t.push("#define " + i + " " + r) } return t.join("\n") }(f), E = d.createProgram(), b = i.glslVersion ? "#version " + i.glslVersion + "\n" : ""; i.isRawShaderMaterial ? ((s = ["#define SHADER_TYPE " + i.shaderType, "#define SHADER_NAME " + i.shaderName, _].filter(eZ).join("\n")).length > 0 && (s += "\n"), (o = ["#define SHADER_TYPE " + i.shaderType, "#define SHADER_NAME " + i.shaderName, _].filter(eZ).join("\n")).length > 0 && (o += "\n")) : (s = [e6(i), "#define SHADER_TYPE " + i.shaderType, "#define SHADER_NAME " + i.shaderName, _, i.extensionClipCullDistance ? "#define USE_CLIP_DISTANCE" : "", i.batching ? "#define USE_BATCHING" : "", i.batchingColor ? "#define USE_BATCHING_COLOR" : "", i.instancing ? "#define USE_INSTANCING" : "", i.instancingColor ? "#define USE_INSTANCING_COLOR" : "", i.instancingMorph ? "#define USE_INSTANCING_MORPH" : "", i.useFog && i.fog ? "#define USE_FOG" : "", i.useFog && i.fogExp2 ? "#define FOG_EXP2" : "", i.map ? "#define USE_MAP" : "", i.envMap ? "#define USE_ENVMAP" : "", i.envMap ? "#define " + y : "", i.lightMap ? "#define USE_LIGHTMAP" : "", i.aoMap ? "#define USE_AOMAP" : "", i.bumpMap ? "#define USE_BUMPMAP" : "", i.normalMap ? "#define USE_NORMALMAP" : "", i.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "", i.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "", i.displacementMap ? "#define USE_DISPLACEMENTMAP" : "", i.emissiveMap ? "#define USE_EMISSIVEMAP" : "", i.anisotropy ? "#define USE_ANISOTROPY" : "", i.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "", i.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", i.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", i.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", i.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "", i.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "", i.specularMap ? "#define USE_SPECULARMAP" : "", i.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "", i.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "", i.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", i.metalnessMap ? "#define USE_METALNESSMAP" : "", i.alphaMap ? "#define USE_ALPHAMAP" : "", i.alphaHash ? "#define USE_ALPHAHASH" : "", i.transmission ? "#define USE_TRANSMISSION" : "", i.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", i.thicknessMap ? "#define USE_THICKNESSMAP" : "", i.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "", i.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "", i.mapUv ? "#define MAP_UV " + i.mapUv : "", i.alphaMapUv ? "#define ALPHAMAP_UV " + i.alphaMapUv : "", i.lightMapUv ? "#define LIGHTMAP_UV " + i.lightMapUv : "", i.aoMapUv ? "#define AOMAP_UV " + i.aoMapUv : "", i.emissiveMapUv ? "#define EMISSIVEMAP_UV " + i.emissiveMapUv : "", i.bumpMapUv ? "#define BUMPMAP_UV " + i.bumpMapUv : "", i.normalMapUv ? "#define NORMALMAP_UV " + i.normalMapUv : "", i.displacementMapUv ? "#define DISPLACEMENTMAP_UV " + i.displacementMapUv : "", i.metalnessMapUv ? "#define METALNESSMAP_UV " + i.metalnessMapUv : "", i.roughnessMapUv ? "#define ROUGHNESSMAP_UV " + i.roughnessMapUv : "", i.anisotropyMapUv ? "#define ANISOTROPYMAP_UV " + i.anisotropyMapUv : "", i.clearcoatMapUv ? "#define CLEARCOATMAP_UV " + i.clearcoatMapUv : "", i.clearcoatNormalMapUv ? "#define CLEARCOAT_NORMALMAP_UV " + i.clearcoatNormalMapUv : "", i.clearcoatRoughnessMapUv ? "#define CLEARCOAT_ROUGHNESSMAP_UV " + i.clearcoatRoughnessMapUv : "", i.iridescenceMapUv ? "#define IRIDESCENCEMAP_UV " + i.iridescenceMapUv : "", i.iridescenceThicknessMapUv ? "#define IRIDESCENCE_THICKNESSMAP_UV " + i.iridescenceThicknessMapUv : "", i.sheenColorMapUv ? "#define SHEEN_COLORMAP_UV " + i.sheenColorMapUv : "", i.sheenRoughnessMapUv ? "#define SHEEN_ROUGHNESSMAP_UV " + i.sheenRoughnessMapUv : "", i.specularMapUv ? "#define SPECULARMAP_UV " + i.specularMapUv : "", i.specularColorMapUv ? "#define SPECULAR_COLORMAP_UV " + i.specularColorMapUv : "", i.specularIntensityMapUv ? "#define SPECULAR_INTENSITYMAP_UV " + i.specularIntensityMapUv : "", i.transmissionMapUv ? "#define TRANSMISSIONMAP_UV " + i.transmissionMapUv : "", i.thicknessMapUv ? "#define THICKNESSMAP_UV " + i.thicknessMapUv : "", i.vertexTangents && !1 === i.flatShading ? "#define USE_TANGENT" : "", i.vertexColors ? "#define USE_COLOR" : "", i.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", i.vertexUv1s ? "#define USE_UV1" : "", i.vertexUv2s ? "#define USE_UV2" : "", i.vertexUv3s ? "#define USE_UV3" : "", i.pointsUvs ? "#define USE_POINTS_UV" : "", i.flatShading ? "#define FLAT_SHADED" : "", i.skinning ? "#define USE_SKINNING" : "", i.morphTargets ? "#define USE_MORPHTARGETS" : "", i.morphNormals && !1 === i.flatShading ? "#define USE_MORPHNORMALS" : "", i.morphColors ? "#define USE_MORPHCOLORS" : "", i.morphTargetsCount > 0 ? "#define MORPHTARGETS_TEXTURE_STRIDE " + i.morphTextureStride : "", i.morphTargetsCount > 0 ? "#define MORPHTARGETS_COUNT " + i.morphTargetsCount : "", i.doubleSided ? "#define DOUBLE_SIDED" : "", i.flipSided ? "#define FLIP_SIDED" : "", i.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", i.shadowMapEnabled ? "#define " + g : "", i.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", i.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "", i.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", i.reverseDepthBuffer ? "#define USE_REVERSEDEPTHBUF" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", "#ifdef USE_INSTANCING", "	attribute mat4 instanceMatrix;", "#endif", "#ifdef USE_INSTANCING_COLOR", "	attribute vec3 instanceColor;", "#endif", "#ifdef USE_INSTANCING_MORPH", "	uniform sampler2D morphTexture;", "#endif", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_UV1", "	attribute vec2 uv1;", "#endif", "#ifdef USE_UV2", "	attribute vec2 uv2;", "#endif", "#ifdef USE_UV3", "	attribute vec2 uv3;", "#endif", "#ifdef USE_TANGENT", "	attribute vec4 tangent;", "#endif", "#if defined( USE_COLOR_ALPHA )", "	attribute vec4 color;", "#elif defined( USE_COLOR )", "	attribute vec3 color;", "#endif", "#ifdef USE_SKINNING", "	attribute vec4 skinIndex;", "	attribute vec4 skinWeight;", "#endif", "\n"].filter(eZ).join("\n"), o = [e6(i), "#define SHADER_TYPE " + i.shaderType, "#define SHADER_NAME " + i.shaderName, _, i.useFog && i.fog ? "#define USE_FOG" : "", i.useFog && i.fogExp2 ? "#define FOG_EXP2" : "", i.alphaToCoverage ? "#define ALPHA_TO_COVERAGE" : "", i.map ? "#define USE_MAP" : "", i.matcap ? "#define USE_MATCAP" : "", i.envMap ? "#define USE_ENVMAP" : "", i.envMap ? "#define " + v : "", i.envMap ? "#define " + y : "", i.envMap ? "#define " + x : "", S ? "#define CUBEUV_TEXEL_WIDTH " + S.texelWidth : "", S ? "#define CUBEUV_TEXEL_HEIGHT " + S.texelHeight : "", S ? "#define CUBEUV_MAX_MIP " + S.maxMip + ".0" : "", i.lightMap ? "#define USE_LIGHTMAP" : "", i.aoMap ? "#define USE_AOMAP" : "", i.bumpMap ? "#define USE_BUMPMAP" : "", i.normalMap ? "#define USE_NORMALMAP" : "", i.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "", i.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "", i.emissiveMap ? "#define USE_EMISSIVEMAP" : "", i.anisotropy ? "#define USE_ANISOTROPY" : "", i.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "", i.clearcoat ? "#define USE_CLEARCOAT" : "", i.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", i.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", i.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", i.dispersion ? "#define USE_DISPERSION" : "", i.iridescence ? "#define USE_IRIDESCENCE" : "", i.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "", i.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "", i.specularMap ? "#define USE_SPECULARMAP" : "", i.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "", i.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "", i.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", i.metalnessMap ? "#define USE_METALNESSMAP" : "", i.alphaMap ? "#define USE_ALPHAMAP" : "", i.alphaTest ? "#define USE_ALPHATEST" : "", i.alphaHash ? "#define USE_ALPHAHASH" : "", i.sheen ? "#define USE_SHEEN" : "", i.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "", i.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "", i.transmission ? "#define USE_TRANSMISSION" : "", i.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", i.thicknessMap ? "#define USE_THICKNESSMAP" : "", i.vertexTangents && !1 === i.flatShading ? "#define USE_TANGENT" : "", i.vertexColors || i.instancingColor || i.batchingColor ? "#define USE_COLOR" : "", i.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", i.vertexUv1s ? "#define USE_UV1" : "", i.vertexUv2s ? "#define USE_UV2" : "", i.vertexUv3s ? "#define USE_UV3" : "", i.pointsUvs ? "#define USE_POINTS_UV" : "", i.gradientMap ? "#define USE_GRADIENTMAP" : "", i.flatShading ? "#define FLAT_SHADED" : "", i.doubleSided ? "#define DOUBLE_SIDED" : "", i.flipSided ? "#define FLIP_SIDED" : "", i.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", i.shadowMapEnabled ? "#define " + g : "", i.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", i.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "", i.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "", i.decodeVideoTextureEmissive ? "#define DECODE_VIDEO_TEXTURE_EMISSIVE" : "", i.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", i.reverseDepthBuffer ? "#define USE_REVERSEDEPTHBUF" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", i.toneMapping !== r.y_p ? "#define TONE_MAPPING" : "", i.toneMapping !== r.y_p ? a.tonemapping_pars_fragment : "", i.toneMapping !== r.y_p ? function (e, t) { let i; switch (t) { case r.kyO: i = "Linear"; break; case r.Mjd: i = "Reinhard"; break; case r.nNL: i = "Cineon"; break; case r.FV: i = "ACESFilmic"; break; case r.LAk: i = "AgX"; break; case r.aJ8: i = "Neutral"; break; case r.g7M: i = "Custom"; break; default: console.warn("THREE.WebGLProgram: Unsupported toneMapping:", t), i = "Linear" }return "vec3 " + e + "( vec3 color ) { return " + i + "ToneMapping( color ); }" }("toneMapping", i.toneMapping) : "", i.dithering ? "#define DITHERING" : "", i.opaque ? "#define OPAQUE" : "", a.colorspace_pars_fragment, function (e, t) {
        let i = function (e) { r.ppV._getMatrix(eK, r.ppV.workingColorSpace, e); let t = `mat3( ${eK.elements.map(e => e.toFixed(4))} )`; switch (r.ppV.getTransfer(e)) { case r.VxR: return [t, "LinearTransferOETF"]; case r.KLL: return [t, "sRGBTransferOETF"]; default: return console.warn("THREE.WebGLProgram: Unsupported color space: ", e), [t, "LinearTransferOETF"] } }(t); return `vec4 ${e}( vec4 value ) {
	return ${i[1]}( vec4( value.rgb * ${i[0]}, value.a ) );
}`}("linearToOutputTexel", i.outputColorSpace), function () {
        r.ppV.getLuminanceCoefficients(eQ); let e = eQ.x.toFixed(4), t = eQ.y.toFixed(4), i = eQ.z.toFixed(4); return `float luminance( const in vec3 rgb ) {
	const vec3 weights = vec3( ${e}, ${t}, ${i} );
	return dot( weights, rgb );
}`}(), i.useDepthPacking ? "#define DEPTH_PACKING " + i.depthPacking : "", "\n"].filter(eZ).join("\n")), p = eJ(p = e$(p = e1(p), i), i), m = eJ(m = e$(m = e1(m), i), i), p = e5(p), m = e5(m), !0 !== i.isRawShaderMaterial && (b = "#version 300 es\n", s = [A, "#define attribute in", "#define varying out", "#define texture2D texture"].join("\n") + "\n" + s, o = ["#define varying in", i.glslVersion === r.Wdf ? "" : "layout(location = 0) out highp vec4 pc_fragColor;", i.glslVersion === r.Wdf ? "" : "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth", "#define texture2D texture", "#define textureCube texture", "#define texture2DProj textureProj", "#define texture2DLodEXT textureLod", "#define texture2DProjLodEXT textureProjLod", "#define textureCubeLodEXT textureLod", "#define texture2DGradEXT textureGrad", "#define texture2DProjGradEXT textureProjGrad", "#define textureCubeGradEXT textureGrad"].join("\n") + "\n" + o); let T = b + s + p, w = b + o + m, M = eY(d, d.VERTEX_SHADER, T), R = eY(d, d.FRAGMENT_SHADER, w); function C(t) { if (e.debug.checkShaderErrors) { let i = d.getProgramInfoLog(E).trim(), r = d.getShaderInfoLog(M).trim(), n = d.getShaderInfoLog(R).trim(), a = !0, l = !0; if (!1 === d.getProgramParameter(E, d.LINK_STATUS)) { if (a = !1, "function" == typeof e.debug.onShaderError) e.debug.onShaderError(d, E, M, R); else { let e = eq(d, M, "vertex"), r = eq(d, R, "fragment"); console.error("THREE.WebGLProgram: Shader Error " + d.getError() + " - VALIDATE_STATUS " + d.getProgramParameter(E, d.VALIDATE_STATUS) + "\n\nMaterial Name: " + t.name + "\nMaterial Type: " + t.type + "\n\nProgram Info Log: " + i + "\n" + e + "\n" + r) } } else "" !== i ? console.warn("THREE.WebGLProgram: Program Info Log:", i) : ("" === r || "" === n) && (l = !1); l && (t.diagnostics = { runnable: a, programLog: i, vertexShader: { log: r, prefix: s }, fragmentShader: { log: n, prefix: o } }) } d.deleteShader(M), d.deleteShader(R), l = new ej(d, E), u = function (e, t) { let i = {}, r = e.getProgramParameter(t, e.ACTIVE_ATTRIBUTES); for (let n = 0; n < r; n++) { let r = e.getActiveAttrib(t, n), s = r.name, a = 1; r.type === e.FLOAT_MAT2 && (a = 2), r.type === e.FLOAT_MAT3 && (a = 3), r.type === e.FLOAT_MAT4 && (a = 4), i[s] = { type: r.type, location: e.getAttribLocation(t, s), locationSize: a } } return i }(d, E) } d.attachShader(E, M), d.attachShader(E, R), void 0 !== i.index0AttributeName ? d.bindAttribLocation(E, 0, i.index0AttributeName) : !0 === i.morphTargets && d.bindAttribLocation(E, 0, "position"), d.linkProgram(E), this.getUniforms = function () { return void 0 === l && C(this), l }, this.getAttributes = function () { return void 0 === u && C(this), u }; let I = !1 === i.rendererExtensionParallelShaderCompile; return this.isReady = function () { return !1 === I && (I = d.getProgramParameter(E, 37297)), I }, this.destroy = function () { n.releaseStatesOfProgram(this), d.deleteProgram(E), this.program = void 0 }, this.type = i.shaderType, this.name = i.shaderName, this.id = eX++, this.cacheKey = t, this.usedTimes = 1, this.program = E, this.vertexShader = M, this.fragmentShader = R, this
    } let e7 = 0; class te { constructor() { this.shaderCache = new Map, this.materialCache = new Map } update(e) { let t = e.vertexShader, i = e.fragmentShader, r = this._getShaderStage(t), n = this._getShaderStage(i), s = this._getShaderCacheForMaterial(e); return !1 === s.has(r) && (s.add(r), r.usedTimes++), !1 === s.has(n) && (s.add(n), n.usedTimes++), this } remove(e) { for (let t of this.materialCache.get(e)) t.usedTimes--, 0 === t.usedTimes && this.shaderCache.delete(t.code); return this.materialCache.delete(e), this } getVertexShaderID(e) { return this._getShaderStage(e.vertexShader).id } getFragmentShaderID(e) { return this._getShaderStage(e.fragmentShader).id } dispose() { this.shaderCache.clear(), this.materialCache.clear() } _getShaderCacheForMaterial(e) { let t = this.materialCache, i = t.get(e); return void 0 === i && (i = new Set, t.set(e, i)), i } _getShaderStage(e) { let t = this.shaderCache, i = t.get(e); return void 0 === i && (i = new tt(e), t.set(e, i)), i } } class tt { constructor(e) { this.id = e7++, this.code = e, this.usedTimes = 0 } } function ti(e, t, i, n, s, a, o) { let u = new r.zgK, h = new te, c = new Set, d = [], f = s.logarithmicDepthBuffer, p = s.vertexTextures, m = s.precision, g = { MeshDepthMaterial: "depth", MeshDistanceMaterial: "distanceRGBA", MeshNormalMaterial: "normal", MeshBasicMaterial: "basic", MeshLambertMaterial: "lambert", MeshPhongMaterial: "phong", MeshToonMaterial: "toon", MeshStandardMaterial: "physical", MeshPhysicalMaterial: "physical", MeshMatcapMaterial: "matcap", LineBasicMaterial: "basic", LineDashedMaterial: "dashed", PointsMaterial: "points", ShadowMaterial: "shadow", SpriteMaterial: "sprite" }; function v(e) { return (c.add(e), 0 === e) ? "uv" : `uv${e}` } return { getParameters: function (a, u, d, y, x) { let S, A, _, E; let b = y.fog, T = x.geometry, w = a.isMeshStandardMaterial ? y.environment : null, M = (a.isMeshStandardMaterial ? i : t).get(a.envMap || w), R = M && M.mapping === r.Om ? M.image.height : null, C = g[a.type]; null !== a.precision && (m = s.getMaxPrecision(a.precision)) !== a.precision && console.warn("THREE.WebGLProgram.getParameters:", a.precision, "not supported, using", m, "instead."); let I = T.morphAttributes.position || T.morphAttributes.normal || T.morphAttributes.color, L = void 0 !== I ? I.length : 0, P = 0; if (void 0 !== T.morphAttributes.position && (P = 1), void 0 !== T.morphAttributes.normal && (P = 2), void 0 !== T.morphAttributes.color && (P = 3), C) { let e = l[C]; S = e.vertexShader, A = e.fragmentShader } else S = a.vertexShader, A = a.fragmentShader, h.update(a), _ = h.getVertexShaderID(a), E = h.getFragmentShaderID(a); let D = e.getRenderTarget(), O = e.state.buffers.depth.getReversed(), k = !0 === x.isInstancedMesh, F = !0 === x.isBatchedMesh, U = !!a.map, N = !!a.matcap, B = !!M, z = !!a.aoMap, G = !!a.lightMap, H = !!a.bumpMap, V = !!a.normalMap, W = !!a.displacementMap, j = !!a.emissiveMap, Y = !!a.metalnessMap, X = !!a.roughnessMap, K = a.anisotropy > 0, q = a.clearcoat > 0, Q = a.dispersion > 0, Z = a.iridescence > 0, $ = a.sheen > 0, J = a.transmission > 0, ee = K && !!a.anisotropyMap, et = q && !!a.clearcoatMap, ei = q && !!a.clearcoatNormalMap, er = q && !!a.clearcoatRoughnessMap, en = Z && !!a.iridescenceMap, es = Z && !!a.iridescenceThicknessMap, ea = $ && !!a.sheenColorMap, eo = $ && !!a.sheenRoughnessMap, el = !!a.specularMap, eu = !!a.specularColorMap, eh = !!a.specularIntensityMap, ec = J && !!a.transmissionMap, ed = J && !!a.thicknessMap, ef = !!a.gradientMap, ep = !!a.alphaMap, em = a.alphaTest > 0, eg = !!a.alphaHash, ev = !!a.extensions, ey = r.y_p; a.toneMapped && (null === D || !0 === D.isXRRenderTarget) && (ey = e.toneMapping); let ex = { shaderID: C, shaderType: a.type, shaderName: a.name, vertexShader: S, fragmentShader: A, defines: a.defines, customVertexShaderID: _, customFragmentShaderID: E, isRawShaderMaterial: !0 === a.isRawShaderMaterial, glslVersion: a.glslVersion, precision: m, batching: F, batchingColor: F && null !== x._colorsTexture, instancing: k, instancingColor: k && null !== x.instanceColor, instancingMorph: k && null !== x.morphTexture, supportsVertexTextures: p, outputColorSpace: null === D ? e.outputColorSpace : !0 === D.isXRRenderTarget ? D.texture.colorSpace : r.Zr2, alphaToCoverage: !!a.alphaToCoverage, map: U, matcap: N, envMap: B, envMapMode: B && M.mapping, envMapCubeUVHeight: R, aoMap: z, lightMap: G, bumpMap: H, normalMap: V, displacementMap: p && W, emissiveMap: j, normalMapObjectSpace: V && a.normalMapType === r.vyJ, normalMapTangentSpace: V && a.normalMapType === r.bI3, metalnessMap: Y, roughnessMap: X, anisotropy: K, anisotropyMap: ee, clearcoat: q, clearcoatMap: et, clearcoatNormalMap: ei, clearcoatRoughnessMap: er, dispersion: Q, iridescence: Z, iridescenceMap: en, iridescenceThicknessMap: es, sheen: $, sheenColorMap: ea, sheenRoughnessMap: eo, specularMap: el, specularColorMap: eu, specularIntensityMap: eh, transmission: J, transmissionMap: ec, thicknessMap: ed, gradientMap: ef, opaque: !1 === a.transparent && a.blending === r.NTi && !1 === a.alphaToCoverage, alphaMap: ep, alphaTest: em, alphaHash: eg, combine: a.combine, mapUv: U && v(a.map.channel), aoMapUv: z && v(a.aoMap.channel), lightMapUv: G && v(a.lightMap.channel), bumpMapUv: H && v(a.bumpMap.channel), normalMapUv: V && v(a.normalMap.channel), displacementMapUv: W && v(a.displacementMap.channel), emissiveMapUv: j && v(a.emissiveMap.channel), metalnessMapUv: Y && v(a.metalnessMap.channel), roughnessMapUv: X && v(a.roughnessMap.channel), anisotropyMapUv: ee && v(a.anisotropyMap.channel), clearcoatMapUv: et && v(a.clearcoatMap.channel), clearcoatNormalMapUv: ei && v(a.clearcoatNormalMap.channel), clearcoatRoughnessMapUv: er && v(a.clearcoatRoughnessMap.channel), iridescenceMapUv: en && v(a.iridescenceMap.channel), iridescenceThicknessMapUv: es && v(a.iridescenceThicknessMap.channel), sheenColorMapUv: ea && v(a.sheenColorMap.channel), sheenRoughnessMapUv: eo && v(a.sheenRoughnessMap.channel), specularMapUv: el && v(a.specularMap.channel), specularColorMapUv: eu && v(a.specularColorMap.channel), specularIntensityMapUv: eh && v(a.specularIntensityMap.channel), transmissionMapUv: ec && v(a.transmissionMap.channel), thicknessMapUv: ed && v(a.thicknessMap.channel), alphaMapUv: ep && v(a.alphaMap.channel), vertexTangents: !!T.attributes.tangent && (V || K), vertexColors: a.vertexColors, vertexAlphas: !0 === a.vertexColors && !!T.attributes.color && 4 === T.attributes.color.itemSize, pointsUvs: !0 === x.isPoints && !!T.attributes.uv && (U || ep), fog: !!b, useFog: !0 === a.fog, fogExp2: !!b && b.isFogExp2, flatShading: !0 === a.flatShading, sizeAttenuation: !0 === a.sizeAttenuation, logarithmicDepthBuffer: f, reverseDepthBuffer: O, skinning: !0 === x.isSkinnedMesh, morphTargets: void 0 !== T.morphAttributes.position, morphNormals: void 0 !== T.morphAttributes.normal, morphColors: void 0 !== T.morphAttributes.color, morphTargetsCount: L, morphTextureStride: P, numDirLights: u.directional.length, numPointLights: u.point.length, numSpotLights: u.spot.length, numSpotLightMaps: u.spotLightMap.length, numRectAreaLights: u.rectArea.length, numHemiLights: u.hemi.length, numDirLightShadows: u.directionalShadowMap.length, numPointLightShadows: u.pointShadowMap.length, numSpotLightShadows: u.spotShadowMap.length, numSpotLightShadowsWithMaps: u.numSpotLightShadowsWithMaps, numLightProbes: u.numLightProbes, numClippingPlanes: o.numPlanes, numClipIntersection: o.numIntersection, dithering: a.dithering, shadowMapEnabled: e.shadowMap.enabled && d.length > 0, shadowMapType: e.shadowMap.type, toneMapping: ey, decodeVideoTexture: U && !0 === a.map.isVideoTexture && r.ppV.getTransfer(a.map.colorSpace) === r.KLL, decodeVideoTextureEmissive: j && !0 === a.emissiveMap.isVideoTexture && r.ppV.getTransfer(a.emissiveMap.colorSpace) === r.KLL, premultipliedAlpha: a.premultipliedAlpha, doubleSided: a.side === r.$EB, flipSided: a.side === r.hsX, useDepthPacking: a.depthPacking >= 0, depthPacking: a.depthPacking || 0, index0AttributeName: a.index0AttributeName, extensionClipCullDistance: ev && !0 === a.extensions.clipCullDistance && n.has("WEBGL_clip_cull_distance"), extensionMultiDraw: (ev && !0 === a.extensions.multiDraw || F) && n.has("WEBGL_multi_draw"), rendererExtensionParallelShaderCompile: n.has("KHR_parallel_shader_compile"), customProgramCacheKey: a.customProgramCacheKey() }; return ex.vertexUv1s = c.has(1), ex.vertexUv2s = c.has(2), ex.vertexUv3s = c.has(3), c.clear(), ex }, getProgramCacheKey: function (t) { let i = []; if (t.shaderID ? i.push(t.shaderID) : (i.push(t.customVertexShaderID), i.push(t.customFragmentShaderID)), void 0 !== t.defines) for (let e in t.defines) i.push(e), i.push(t.defines[e]); return !1 === t.isRawShaderMaterial && (i.push(t.precision), i.push(t.outputColorSpace), i.push(t.envMapMode), i.push(t.envMapCubeUVHeight), i.push(t.mapUv), i.push(t.alphaMapUv), i.push(t.lightMapUv), i.push(t.aoMapUv), i.push(t.bumpMapUv), i.push(t.normalMapUv), i.push(t.displacementMapUv), i.push(t.emissiveMapUv), i.push(t.metalnessMapUv), i.push(t.roughnessMapUv), i.push(t.anisotropyMapUv), i.push(t.clearcoatMapUv), i.push(t.clearcoatNormalMapUv), i.push(t.clearcoatRoughnessMapUv), i.push(t.iridescenceMapUv), i.push(t.iridescenceThicknessMapUv), i.push(t.sheenColorMapUv), i.push(t.sheenRoughnessMapUv), i.push(t.specularMapUv), i.push(t.specularColorMapUv), i.push(t.specularIntensityMapUv), i.push(t.transmissionMapUv), i.push(t.thicknessMapUv), i.push(t.combine), i.push(t.fogExp2), i.push(t.sizeAttenuation), i.push(t.morphTargetsCount), i.push(t.morphAttributeCount), i.push(t.numDirLights), i.push(t.numPointLights), i.push(t.numSpotLights), i.push(t.numSpotLightMaps), i.push(t.numHemiLights), i.push(t.numRectAreaLights), i.push(t.numDirLightShadows), i.push(t.numPointLightShadows), i.push(t.numSpotLightShadows), i.push(t.numSpotLightShadowsWithMaps), i.push(t.numLightProbes), i.push(t.shadowMapType), i.push(t.toneMapping), i.push(t.numClippingPlanes), i.push(t.numClipIntersection), i.push(t.depthPacking), u.disableAll(), t.supportsVertexTextures && u.enable(0), t.instancing && u.enable(1), t.instancingColor && u.enable(2), t.instancingMorph && u.enable(3), t.matcap && u.enable(4), t.envMap && u.enable(5), t.normalMapObjectSpace && u.enable(6), t.normalMapTangentSpace && u.enable(7), t.clearcoat && u.enable(8), t.iridescence && u.enable(9), t.alphaTest && u.enable(10), t.vertexColors && u.enable(11), t.vertexAlphas && u.enable(12), t.vertexUv1s && u.enable(13), t.vertexUv2s && u.enable(14), t.vertexUv3s && u.enable(15), t.vertexTangents && u.enable(16), t.anisotropy && u.enable(17), t.alphaHash && u.enable(18), t.batching && u.enable(19), t.dispersion && u.enable(20), t.batchingColor && u.enable(21), i.push(u.mask), u.disableAll(), t.fog && u.enable(0), t.useFog && u.enable(1), t.flatShading && u.enable(2), t.logarithmicDepthBuffer && u.enable(3), t.reverseDepthBuffer && u.enable(4), t.skinning && u.enable(5), t.morphTargets && u.enable(6), t.morphNormals && u.enable(7), t.morphColors && u.enable(8), t.premultipliedAlpha && u.enable(9), t.shadowMapEnabled && u.enable(10), t.doubleSided && u.enable(11), t.flipSided && u.enable(12), t.useDepthPacking && u.enable(13), t.dithering && u.enable(14), t.transmission && u.enable(15), t.sheen && u.enable(16), t.opaque && u.enable(17), t.pointsUvs && u.enable(18), t.decodeVideoTexture && u.enable(19), t.decodeVideoTextureEmissive && u.enable(20), t.alphaToCoverage && u.enable(21), i.push(u.mask), i.push(e.outputColorSpace)), i.push(t.customProgramCacheKey), i.join() }, getUniforms: function (e) { let t; let i = g[e.type]; if (i) { let e = l[i]; t = r.LlO.clone(e.uniforms) } else t = e.uniforms; return t }, acquireProgram: function (t, i) { let r; for (let e = 0, t = d.length; e < t; e++) { let t = d[e]; if (t.cacheKey === i) { r = t, ++r.usedTimes; break } } return void 0 === r && (r = new e9(e, i, t, a), d.push(r)), r }, releaseProgram: function (e) { if (0 == --e.usedTimes) { let t = d.indexOf(e); d[t] = d[d.length - 1], d.pop(), e.destroy() } }, releaseShaderCache: function (e) { h.remove(e) }, programs: d, dispose: function () { h.dispose() } } } function tr() { let e = new WeakMap; return { has: function (t) { return e.has(t) }, get: function (t) { let i = e.get(t); return void 0 === i && (i = {}, e.set(t, i)), i }, remove: function (t) { e.delete(t) }, update: function (t, i, r) { e.get(t)[i] = r }, dispose: function () { e = new WeakMap } } } function tn(e, t) { return e.groupOrder !== t.groupOrder ? e.groupOrder - t.groupOrder : e.renderOrder !== t.renderOrder ? e.renderOrder - t.renderOrder : e.material.id !== t.material.id ? e.material.id - t.material.id : e.z !== t.z ? e.z - t.z : e.id - t.id } function ts(e, t) { return e.groupOrder !== t.groupOrder ? e.groupOrder - t.groupOrder : e.renderOrder !== t.renderOrder ? e.renderOrder - t.renderOrder : e.z !== t.z ? t.z - e.z : e.id - t.id } function ta() { let e = [], t = 0, i = [], r = [], n = []; function s(i, r, n, s, a, o) { let l = e[t]; return void 0 === l ? (l = { id: i.id, object: i, geometry: r, material: n, groupOrder: s, renderOrder: i.renderOrder, z: a, group: o }, e[t] = l) : (l.id = i.id, l.object = i, l.geometry = r, l.material = n, l.groupOrder = s, l.renderOrder = i.renderOrder, l.z = a, l.group = o), t++, l } return { opaque: i, transmissive: r, transparent: n, init: function () { t = 0, i.length = 0, r.length = 0, n.length = 0 }, push: function (e, t, a, o, l, u) { let h = s(e, t, a, o, l, u); a.transmission > 0 ? r.push(h) : !0 === a.transparent ? n.push(h) : i.push(h) }, unshift: function (e, t, a, o, l, u) { let h = s(e, t, a, o, l, u); a.transmission > 0 ? r.unshift(h) : !0 === a.transparent ? n.unshift(h) : i.unshift(h) }, finish: function () { for (let i = t, r = e.length; i < r; i++) { let t = e[i]; if (null === t.id) break; t.id = null, t.object = null, t.geometry = null, t.material = null, t.group = null } }, sort: function (e, t) { i.length > 1 && i.sort(e || tn), r.length > 1 && r.sort(t || ts), n.length > 1 && n.sort(t || ts) } } } function to() { let e = new WeakMap; return { get: function (t, i) { let r; let n = e.get(t); return void 0 === n ? (r = new ta, e.set(t, [r])) : i >= n.length ? (r = new ta, n.push(r)) : r = n[i], r }, dispose: function () { e = new WeakMap } } } function tl() { let e = {}; return { get: function (t) { let i; if (void 0 !== e[t.id]) return e[t.id]; switch (t.type) { case "DirectionalLight": i = { direction: new r.Pq0, color: new r.Q1f }; break; case "SpotLight": i = { position: new r.Pq0, direction: new r.Pq0, color: new r.Q1f, distance: 0, coneCos: 0, penumbraCos: 0, decay: 0 }; break; case "PointLight": i = { position: new r.Pq0, color: new r.Q1f, distance: 0, decay: 0 }; break; case "HemisphereLight": i = { direction: new r.Pq0, skyColor: new r.Q1f, groundColor: new r.Q1f }; break; case "RectAreaLight": i = { color: new r.Q1f, position: new r.Pq0, halfWidth: new r.Pq0, halfHeight: new r.Pq0 } }return e[t.id] = i, i } } } let tu = 0; function th(e, t) { return (t.castShadow ? 2 : 0) - (e.castShadow ? 2 : 0) + (t.map ? 1 : 0) - (e.map ? 1 : 0) } function tc(e) { let t = new tl, i = function () { let e = {}; return { get: function (t) { let i; if (void 0 !== e[t.id]) return e[t.id]; switch (t.type) { case "DirectionalLight": case "SpotLight": i = { shadowIntensity: 1, shadowBias: 0, shadowNormalBias: 0, shadowRadius: 1, shadowMapSize: new r.I9Y }; break; case "PointLight": i = { shadowIntensity: 1, shadowBias: 0, shadowNormalBias: 0, shadowRadius: 1, shadowMapSize: new r.I9Y, shadowCameraNear: 1, shadowCameraFar: 1e3 } }return e[t.id] = i, i } } }(), n = { version: 0, hash: { directionalLength: -1, pointLength: -1, spotLength: -1, rectAreaLength: -1, hemiLength: -1, numDirectionalShadows: -1, numPointShadows: -1, numSpotShadows: -1, numSpotMaps: -1, numLightProbes: -1 }, ambient: [0, 0, 0], probe: [], directional: [], directionalShadow: [], directionalShadowMap: [], directionalShadowMatrix: [], spot: [], spotLightMap: [], spotShadow: [], spotShadowMap: [], spotLightMatrix: [], rectArea: [], rectAreaLTC1: null, rectAreaLTC2: null, point: [], pointShadow: [], pointShadowMap: [], pointShadowMatrix: [], hemi: [], numSpotLightShadowsWithMaps: 0, numLightProbes: 0 }; for (let e = 0; e < 9; e++)n.probe.push(new r.Pq0); let s = new r.Pq0, a = new r.kn4, l = new r.kn4; return { setup: function (r) { let s = 0, a = 0, l = 0; for (let e = 0; e < 9; e++)n.probe[e].set(0, 0, 0); let u = 0, h = 0, c = 0, d = 0, f = 0, p = 0, m = 0, g = 0, v = 0, y = 0, x = 0; r.sort(th); for (let e = 0, o = r.length; e < o; e++) { let o = r[e], S = o.color, A = o.intensity, _ = o.distance, E = o.shadow && o.shadow.map ? o.shadow.map.texture : null; if (o.isAmbientLight) s += S.r * A, a += S.g * A, l += S.b * A; else if (o.isLightProbe) { for (let e = 0; e < 9; e++)n.probe[e].addScaledVector(o.sh.coefficients[e], A); x++ } else if (o.isDirectionalLight) { let e = t.get(o); if (e.color.copy(o.color).multiplyScalar(o.intensity), o.castShadow) { let e = o.shadow, t = i.get(o); t.shadowIntensity = e.intensity, t.shadowBias = e.bias, t.shadowNormalBias = e.normalBias, t.shadowRadius = e.radius, t.shadowMapSize = e.mapSize, n.directionalShadow[u] = t, n.directionalShadowMap[u] = E, n.directionalShadowMatrix[u] = o.shadow.matrix, p++ } n.directional[u] = e, u++ } else if (o.isSpotLight) { let e = t.get(o); e.position.setFromMatrixPosition(o.matrixWorld), e.color.copy(S).multiplyScalar(A), e.distance = _, e.coneCos = Math.cos(o.angle), e.penumbraCos = Math.cos(o.angle * (1 - o.penumbra)), e.decay = o.decay, n.spot[c] = e; let r = o.shadow; if (o.map && (n.spotLightMap[v] = o.map, v++, r.updateMatrices(o), o.castShadow && y++), n.spotLightMatrix[c] = r.matrix, o.castShadow) { let e = i.get(o); e.shadowIntensity = r.intensity, e.shadowBias = r.bias, e.shadowNormalBias = r.normalBias, e.shadowRadius = r.radius, e.shadowMapSize = r.mapSize, n.spotShadow[c] = e, n.spotShadowMap[c] = E, g++ } c++ } else if (o.isRectAreaLight) { let e = t.get(o); e.color.copy(S).multiplyScalar(A), e.halfWidth.set(.5 * o.width, 0, 0), e.halfHeight.set(0, .5 * o.height, 0), n.rectArea[d] = e, d++ } else if (o.isPointLight) { let e = t.get(o); if (e.color.copy(o.color).multiplyScalar(o.intensity), e.distance = o.distance, e.decay = o.decay, o.castShadow) { let e = o.shadow, t = i.get(o); t.shadowIntensity = e.intensity, t.shadowBias = e.bias, t.shadowNormalBias = e.normalBias, t.shadowRadius = e.radius, t.shadowMapSize = e.mapSize, t.shadowCameraNear = e.camera.near, t.shadowCameraFar = e.camera.far, n.pointShadow[h] = t, n.pointShadowMap[h] = E, n.pointShadowMatrix[h] = o.shadow.matrix, m++ } n.point[h] = e, h++ } else if (o.isHemisphereLight) { let e = t.get(o); e.skyColor.copy(o.color).multiplyScalar(A), e.groundColor.copy(o.groundColor).multiplyScalar(A), n.hemi[f] = e, f++ } } d > 0 && (!0 === e.has("OES_texture_float_linear") ? (n.rectAreaLTC1 = o.LTC_FLOAT_1, n.rectAreaLTC2 = o.LTC_FLOAT_2) : (n.rectAreaLTC1 = o.LTC_HALF_1, n.rectAreaLTC2 = o.LTC_HALF_2)), n.ambient[0] = s, n.ambient[1] = a, n.ambient[2] = l; let S = n.hash; (S.directionalLength !== u || S.pointLength !== h || S.spotLength !== c || S.rectAreaLength !== d || S.hemiLength !== f || S.numDirectionalShadows !== p || S.numPointShadows !== m || S.numSpotShadows !== g || S.numSpotMaps !== v || S.numLightProbes !== x) && (n.directional.length = u, n.spot.length = c, n.rectArea.length = d, n.point.length = h, n.hemi.length = f, n.directionalShadow.length = p, n.directionalShadowMap.length = p, n.pointShadow.length = m, n.pointShadowMap.length = m, n.spotShadow.length = g, n.spotShadowMap.length = g, n.directionalShadowMatrix.length = p, n.pointShadowMatrix.length = m, n.spotLightMatrix.length = g + v - y, n.spotLightMap.length = v, n.numSpotLightShadowsWithMaps = y, n.numLightProbes = x, S.directionalLength = u, S.pointLength = h, S.spotLength = c, S.rectAreaLength = d, S.hemiLength = f, S.numDirectionalShadows = p, S.numPointShadows = m, S.numSpotShadows = g, S.numSpotMaps = v, S.numLightProbes = x, n.version = tu++) }, setupView: function (e, t) { let i = 0, r = 0, o = 0, u = 0, h = 0, c = t.matrixWorldInverse; for (let t = 0, d = e.length; t < d; t++) { let d = e[t]; if (d.isDirectionalLight) { let e = n.directional[i]; e.direction.setFromMatrixPosition(d.matrixWorld), s.setFromMatrixPosition(d.target.matrixWorld), e.direction.sub(s), e.direction.transformDirection(c), i++ } else if (d.isSpotLight) { let e = n.spot[o]; e.position.setFromMatrixPosition(d.matrixWorld), e.position.applyMatrix4(c), e.direction.setFromMatrixPosition(d.matrixWorld), s.setFromMatrixPosition(d.target.matrixWorld), e.direction.sub(s), e.direction.transformDirection(c), o++ } else if (d.isRectAreaLight) { let e = n.rectArea[u]; e.position.setFromMatrixPosition(d.matrixWorld), e.position.applyMatrix4(c), l.identity(), a.copy(d.matrixWorld), a.premultiply(c), l.extractRotation(a), e.halfWidth.set(.5 * d.width, 0, 0), e.halfHeight.set(0, .5 * d.height, 0), e.halfWidth.applyMatrix4(l), e.halfHeight.applyMatrix4(l), u++ } else if (d.isPointLight) { let e = n.point[r]; e.position.setFromMatrixPosition(d.matrixWorld), e.position.applyMatrix4(c), r++ } else if (d.isHemisphereLight) { let e = n.hemi[h]; e.direction.setFromMatrixPosition(d.matrixWorld), e.direction.transformDirection(c), h++ } } }, state: n } } function td(e) { let t = new tc(e), i = [], r = [], n = { lightsArray: i, shadowsArray: r, camera: null, lights: t, transmissionRenderTarget: {} }; return { init: function (e) { n.camera = e, i.length = 0, r.length = 0 }, state: n, setupLights: function () { t.setup(i) }, setupLightsView: function (e) { t.setupView(i, e) }, pushLight: function (e) { i.push(e) }, pushShadow: function (e) { r.push(e) } } } function tf(e) { let t = new WeakMap; return { get: function (i, r = 0) { let n; let s = t.get(i); return void 0 === s ? (n = new td(e), t.set(i, [n])) : r >= s.length ? (n = new td(e), s.push(n)) : n = s[r], n }, dispose: function () { t = new WeakMap } } } function tp(e, t, i) { let n = new r.PPD, s = new r.I9Y, a = new r.I9Y, o = new r.IUQ, l = new r.CSG({ depthPacking: r.N5j }), u = new r.aVO, h = {}, c = i.maxTextureSize, d = { [r.hB5]: r.hsX, [r.hsX]: r.hB5, [r.$EB]: r.$EB }, f = new r.BKk({ defines: { VSM_SAMPLES: 8 }, uniforms: { shadow_pass: { value: null }, resolution: { value: new r.I9Y }, radius: { value: 4 } }, vertexShader: "void main() {\n	gl_Position = vec4( position, 1.0 );\n}", fragmentShader: "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n	const float samples = float( VSM_SAMPLES );\n	float mean = 0.0;\n	float squared_mean = 0.0;\n	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );\n	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;\n	for ( float i = 0.0; i < samples; i ++ ) {\n		float uvOffset = uvStart + i * uvStride;\n		#ifdef HORIZONTAL_PASS\n			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );\n			mean += distribution.x;\n			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n		#else\n			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );\n			mean += depth;\n			squared_mean += depth * depth;\n		#endif\n	}\n	mean = mean / samples;\n	squared_mean = squared_mean / samples;\n	float std_dev = sqrt( squared_mean - mean * mean );\n	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}" }), p = f.clone(); p.defines.HORIZONTAL_PASS = 1; let m = new r.LoY; m.setAttribute("position", new r.THS(new Float32Array([-1, -1, .5, 3, -1, .5, -1, 3, .5]), 3)); let g = new r.eaF(m, f), v = this; this.enabled = !1, this.autoUpdate = !0, this.needsUpdate = !1, this.type = r.QP0; let y = this.type; function x(t, i, n, s) { let a = null, o = !0 === n.isPointLight ? t.customDistanceMaterial : t.customDepthMaterial; if (void 0 !== o) a = o; else if (a = !0 === n.isPointLight ? u : l, e.localClippingEnabled && !0 === i.clipShadows && Array.isArray(i.clippingPlanes) && 0 !== i.clippingPlanes.length || i.displacementMap && 0 !== i.displacementScale || i.alphaMap && i.alphaTest > 0 || i.map && i.alphaTest > 0) { let e = a.uuid, t = i.uuid, r = h[e]; void 0 === r && (r = {}, h[e] = r); let n = r[t]; void 0 === n && (n = a.clone(), r[t] = n, i.addEventListener("dispose", S)), a = n } return a.visible = i.visible, a.wireframe = i.wireframe, s === r.RyA ? a.side = null !== i.shadowSide ? i.shadowSide : i.side : a.side = null !== i.shadowSide ? i.shadowSide : d[i.side], a.alphaMap = i.alphaMap, a.alphaTest = i.alphaTest, a.map = i.map, a.clipShadows = i.clipShadows, a.clippingPlanes = i.clippingPlanes, a.clipIntersection = i.clipIntersection, a.displacementMap = i.displacementMap, a.displacementScale = i.displacementScale, a.displacementBias = i.displacementBias, a.wireframeLinewidth = i.wireframeLinewidth, a.linewidth = i.linewidth, !0 === n.isPointLight && !0 === a.isMeshDistanceMaterial && (e.properties.get(a).light = n), a } function S(e) { for (let t in e.target.removeEventListener("dispose", S), h) { let i = h[t], r = e.target.uuid; r in i && (i[r].dispose(), delete i[r]) } } this.render = function (i, l, u) { if (!1 === v.enabled || !1 === v.autoUpdate && !1 === v.needsUpdate || 0 === i.length) return; let h = e.getRenderTarget(), d = e.getActiveCubeFace(), m = e.getActiveMipmapLevel(), S = e.state; S.setBlending(r.XIg), S.buffers.color.setClear(1, 1, 1, 1), S.buffers.depth.setTest(!0), S.setScissorTest(!1); let A = y !== r.RyA && this.type === r.RyA, _ = y === r.RyA && this.type !== r.RyA; for (let h = 0, d = i.length; h < d; h++) { let d = i[h], m = d.shadow; if (void 0 === m) { console.warn("THREE.WebGLShadowMap:", d, "has no shadow."); continue } if (!1 === m.autoUpdate && !1 === m.needsUpdate) continue; s.copy(m.mapSize); let v = m.getFrameExtents(); if (s.multiply(v), a.copy(m.mapSize), (s.x > c || s.y > c) && (s.x > c && (a.x = Math.floor(c / v.x), s.x = a.x * v.x, m.mapSize.x = a.x), s.y > c && (a.y = Math.floor(c / v.y), s.y = a.y * v.y, m.mapSize.y = a.y)), null === m.map || !0 === A || !0 === _) { let e = this.type !== r.RyA ? { minFilter: r.hxR, magFilter: r.hxR } : {}; null !== m.map && m.map.dispose(), m.map = new r.nWS(s.x, s.y, e), m.map.texture.name = d.name + ".shadowMap", m.camera.updateProjectionMatrix() } e.setRenderTarget(m.map), e.clear(); let y = m.getViewportCount(); for (let i = 0; i < y; i++) { let s = m.getViewport(i); o.set(a.x * s.x, a.y * s.y, a.x * s.z, a.y * s.w), S.viewport(o), m.updateMatrices(d, i), n = m.getFrustum(), function i(s, a, o, l, u) { if (!1 === s.visible) return; if (s.layers.test(a.layers) && (s.isMesh || s.isLine || s.isPoints) && (s.castShadow || s.receiveShadow && u === r.RyA) && (!s.frustumCulled || n.intersectsObject(s))) { s.modelViewMatrix.multiplyMatrices(o.matrixWorldInverse, s.matrixWorld); let i = t.update(s), r = s.material; if (Array.isArray(r)) { let t = i.groups; for (let n = 0, h = t.length; n < h; n++) { let h = t[n], c = r[h.materialIndex]; if (c && c.visible) { let t = x(s, c, l, u); s.onBeforeShadow(e, s, a, o, i, t, h), e.renderBufferDirect(o, null, i, t, s, h), s.onAfterShadow(e, s, a, o, i, t, h) } } } else if (r.visible) { let t = x(s, r, l, u); s.onBeforeShadow(e, s, a, o, i, t, null), e.renderBufferDirect(o, null, i, t, s, null), s.onAfterShadow(e, s, a, o, i, t, null) } } let h = s.children; for (let e = 0, t = h.length; e < t; e++)i(h[e], a, o, l, u) }(l, u, m.camera, d, this.type) } !0 !== m.isPointLightShadow && this.type === r.RyA && function (i, n) { let a = t.update(g); f.defines.VSM_SAMPLES !== i.blurSamples && (f.defines.VSM_SAMPLES = i.blurSamples, p.defines.VSM_SAMPLES = i.blurSamples, f.needsUpdate = !0, p.needsUpdate = !0), null === i.mapPass && (i.mapPass = new r.nWS(s.x, s.y)), f.uniforms.shadow_pass.value = i.map.texture, f.uniforms.resolution.value = i.mapSize, f.uniforms.radius.value = i.radius, e.setRenderTarget(i.mapPass), e.clear(), e.renderBufferDirect(n, null, a, f, g, null), p.uniforms.shadow_pass.value = i.mapPass.texture, p.uniforms.resolution.value = i.mapSize, p.uniforms.radius.value = i.radius, e.setRenderTarget(i.map), e.clear(), e.renderBufferDirect(n, null, a, p, g, null) }(m, u), m.needsUpdate = !1 } y = this.type, v.needsUpdate = !1, e.setRenderTarget(h, d, m) } } let tm = { [r.eHc]: r.lGu, [r.brA]: r.K52, [r.U3G]: r.bw0, [r.xSv]: r.Gwm, [r.lGu]: r.eHc, [r.K52]: r.brA, [r.bw0]: r.U3G, [r.Gwm]: r.xSv }; function tg(e, t) { let i = new function () { let t = !1, i = new r.IUQ, n = null, s = new r.IUQ(0, 0, 0, 0); return { setMask: function (i) { n === i || t || (e.colorMask(i, i, i, i), n = i) }, setLocked: function (e) { t = e }, setClear: function (t, r, n, a, o) { !0 === o && (t *= a, r *= a, n *= a), i.set(t, r, n, a), !1 === s.equals(i) && (e.clearColor(t, r, n, a), s.copy(i)) }, reset: function () { t = !1, n = null, s.set(-1, 0, 0, 0) } } }, n = new function () { let i = !1, n = !1, s = null, a = null, o = null; return { setReversed: function (e) { if (n !== e) { let e = t.get("EXT_clip_control"); n ? e.clipControlEXT(e.LOWER_LEFT_EXT, e.ZERO_TO_ONE_EXT) : e.clipControlEXT(e.LOWER_LEFT_EXT, e.NEGATIVE_ONE_TO_ONE_EXT); let i = o; o = null, this.setClear(i) } n = e }, getReversed: function () { return n }, setTest: function (t) { t ? z(e.DEPTH_TEST) : G(e.DEPTH_TEST) }, setMask: function (t) { s === t || i || (e.depthMask(t), s = t) }, setFunc: function (t) { if (n && (t = tm[t]), a !== t) { switch (t) { case r.eHc: e.depthFunc(e.NEVER); break; case r.lGu: e.depthFunc(e.ALWAYS); break; case r.brA: e.depthFunc(e.LESS); break; case r.xSv: e.depthFunc(e.LEQUAL); break; case r.U3G: e.depthFunc(e.EQUAL); break; case r.Gwm: e.depthFunc(e.GEQUAL); break; case r.K52: e.depthFunc(e.GREATER); break; case r.bw0: e.depthFunc(e.NOTEQUAL); break; default: e.depthFunc(e.LEQUAL) }a = t } }, setLocked: function (e) { i = e }, setClear: function (t) { o !== t && (n && (t = 1 - t), e.clearDepth(t), o = t) }, reset: function () { i = !1, s = null, a = null, o = null, n = !1 } } }, s = new function () { let t = !1, i = null, r = null, n = null, s = null, a = null, o = null, l = null, u = null; return { setTest: function (i) { t || (i ? z(e.STENCIL_TEST) : G(e.STENCIL_TEST)) }, setMask: function (r) { i === r || t || (e.stencilMask(r), i = r) }, setFunc: function (t, i, a) { (r !== t || n !== i || s !== a) && (e.stencilFunc(t, i, a), r = t, n = i, s = a) }, setOp: function (t, i, r) { (a !== t || o !== i || l !== r) && (e.stencilOp(t, i, r), a = t, o = i, l = r) }, setLocked: function (e) { t = e }, setClear: function (t) { u !== t && (e.clearStencil(t), u = t) }, reset: function () { t = !1, i = null, r = null, n = null, s = null, a = null, o = null, l = null, u = null } } }, a = new WeakMap, o = new WeakMap, l = {}, u = {}, h = new WeakMap, c = [], d = null, f = !1, p = null, m = null, g = null, v = null, y = null, x = null, S = null, A = new r.Q1f(0, 0, 0), _ = 0, E = !1, b = null, T = null, w = null, M = null, R = null, C = e.getParameter(e.MAX_COMBINED_TEXTURE_IMAGE_UNITS), I = !1, L = e.getParameter(e.VERSION); -1 !== L.indexOf("WebGL") ? I = parseFloat(/^WebGL (\d)/.exec(L)[1]) >= 1 : -1 !== L.indexOf("OpenGL ES") && (I = parseFloat(/^OpenGL ES (\d)/.exec(L)[1]) >= 2); let P = null, D = {}, O = e.getParameter(e.SCISSOR_BOX), k = e.getParameter(e.VIEWPORT), F = new r.IUQ().fromArray(O), U = new r.IUQ().fromArray(k); function N(t, i, r, n) { let s = new Uint8Array(4), a = e.createTexture(); e.bindTexture(t, a), e.texParameteri(t, e.TEXTURE_MIN_FILTER, e.NEAREST), e.texParameteri(t, e.TEXTURE_MAG_FILTER, e.NEAREST); for (let a = 0; a < r; a++)t === e.TEXTURE_3D || t === e.TEXTURE_2D_ARRAY ? e.texImage3D(i, 0, e.RGBA, 1, 1, n, 0, e.RGBA, e.UNSIGNED_BYTE, s) : e.texImage2D(i + a, 0, e.RGBA, 1, 1, 0, e.RGBA, e.UNSIGNED_BYTE, s); return a } let B = {}; function z(t) { !0 !== l[t] && (e.enable(t), l[t] = !0) } function G(t) { !1 !== l[t] && (e.disable(t), l[t] = !1) } B[e.TEXTURE_2D] = N(e.TEXTURE_2D, e.TEXTURE_2D, 1), B[e.TEXTURE_CUBE_MAP] = N(e.TEXTURE_CUBE_MAP, e.TEXTURE_CUBE_MAP_POSITIVE_X, 6), B[e.TEXTURE_2D_ARRAY] = N(e.TEXTURE_2D_ARRAY, e.TEXTURE_2D_ARRAY, 1, 1), B[e.TEXTURE_3D] = N(e.TEXTURE_3D, e.TEXTURE_3D, 1, 1), i.setClear(0, 0, 0, 1), n.setClear(1), s.setClear(0), z(e.DEPTH_TEST), n.setFunc(r.xSv), j(!1), Y(r.Vb5), z(e.CULL_FACE), W(r.XIg); let H = { [r.gO9]: e.FUNC_ADD, [r.FXf]: e.FUNC_SUBTRACT, [r.nST]: e.FUNC_REVERSE_SUBTRACT }; H[r.znC] = e.MIN, H[r.$ei] = e.MAX; let V = { [r.ojh]: e.ZERO, [r.qad]: e.ONE, [r.f4X]: e.SRC_COLOR, [r.ie2]: e.SRC_ALPHA, [r.hgQ]: e.SRC_ALPHA_SATURATE, [r.wn6]: e.DST_COLOR, [r.hdd]: e.DST_ALPHA, [r.LiQ]: e.ONE_MINUS_SRC_COLOR, [r.OuU]: e.ONE_MINUS_SRC_ALPHA, [r.aEY]: e.ONE_MINUS_DST_COLOR, [r.Nt7]: e.ONE_MINUS_DST_ALPHA, [r.RrE]: e.CONSTANT_COLOR, [r.$Yl]: e.ONE_MINUS_CONSTANT_COLOR, [r.e0p]: e.CONSTANT_ALPHA, [r.ov9]: e.ONE_MINUS_CONSTANT_ALPHA }; function W(t, i, n, s, a, o, l, u, h, c) { if (t === r.XIg) { !0 === f && (G(e.BLEND), f = !1); return } if (!1 === f && (z(e.BLEND), f = !0), t !== r.bCz) { if (t !== p || c !== E) { if ((m !== r.gO9 || y !== r.gO9) && (e.blendEquation(e.FUNC_ADD), m = r.gO9, y = r.gO9), c) switch (t) { case r.NTi: e.blendFuncSeparate(e.ONE, e.ONE_MINUS_SRC_ALPHA, e.ONE, e.ONE_MINUS_SRC_ALPHA); break; case r.EZo: e.blendFunc(e.ONE, e.ONE); break; case r.Kwu: e.blendFuncSeparate(e.ZERO, e.ONE_MINUS_SRC_COLOR, e.ZERO, e.ONE); break; case r.EdD: e.blendFuncSeparate(e.ZERO, e.SRC_COLOR, e.ZERO, e.SRC_ALPHA); break; default: console.error("THREE.WebGLState: Invalid blending: ", t) } else switch (t) { case r.NTi: e.blendFuncSeparate(e.SRC_ALPHA, e.ONE_MINUS_SRC_ALPHA, e.ONE, e.ONE_MINUS_SRC_ALPHA); break; case r.EZo: e.blendFunc(e.SRC_ALPHA, e.ONE); break; case r.Kwu: e.blendFuncSeparate(e.ZERO, e.ONE_MINUS_SRC_COLOR, e.ZERO, e.ONE); break; case r.EdD: e.blendFunc(e.ZERO, e.SRC_COLOR); break; default: console.error("THREE.WebGLState: Invalid blending: ", t) }g = null, v = null, x = null, S = null, A.set(0, 0, 0), _ = 0, p = t, E = c } return } a = a || i, o = o || n, l = l || s, (i !== m || a !== y) && (e.blendEquationSeparate(H[i], H[a]), m = i, y = a), (n !== g || s !== v || o !== x || l !== S) && (e.blendFuncSeparate(V[n], V[s], V[o], V[l]), g = n, v = s, x = o, S = l), (!1 === u.equals(A) || h !== _) && (e.blendColor(u.r, u.g, u.b, h), A.copy(u), _ = h), p = t, E = !1 } function j(t) { b !== t && (t ? e.frontFace(e.CW) : e.frontFace(e.CCW), b = t) } function Y(t) { t !== r.WNZ ? (z(e.CULL_FACE), t !== T && (t === r.Vb5 ? e.cullFace(e.BACK) : t === r.Jnc ? e.cullFace(e.FRONT) : e.cullFace(e.FRONT_AND_BACK))) : G(e.CULL_FACE), T = t } function X(t, i, r) { t ? (z(e.POLYGON_OFFSET_FILL), (M !== i || R !== r) && (e.polygonOffset(i, r), M = i, R = r)) : G(e.POLYGON_OFFSET_FILL) } return { buffers: { color: i, depth: n, stencil: s }, enable: z, disable: G, bindFramebuffer: function (t, i) { return u[t] !== i && (e.bindFramebuffer(t, i), u[t] = i, t === e.DRAW_FRAMEBUFFER && (u[e.FRAMEBUFFER] = i), t === e.FRAMEBUFFER && (u[e.DRAW_FRAMEBUFFER] = i), !0) }, drawBuffers: function (t, i) { let r = c, n = !1; if (t) { void 0 === (r = h.get(i)) && (r = [], h.set(i, r)); let s = t.textures; if (r.length !== s.length || r[0] !== e.COLOR_ATTACHMENT0) { for (let t = 0, i = s.length; t < i; t++)r[t] = e.COLOR_ATTACHMENT0 + t; r.length = s.length, n = !0 } } else r[0] !== e.BACK && (r[0] = e.BACK, n = !0); n && e.drawBuffers(r) }, useProgram: function (t) { return d !== t && (e.useProgram(t), d = t, !0) }, setBlending: W, setMaterial: function (t, a) { t.side === r.$EB ? G(e.CULL_FACE) : z(e.CULL_FACE); let o = t.side === r.hsX; a && (o = !o), j(o), t.blending === r.NTi && !1 === t.transparent ? W(r.XIg) : W(t.blending, t.blendEquation, t.blendSrc, t.blendDst, t.blendEquationAlpha, t.blendSrcAlpha, t.blendDstAlpha, t.blendColor, t.blendAlpha, t.premultipliedAlpha), n.setFunc(t.depthFunc), n.setTest(t.depthTest), n.setMask(t.depthWrite), i.setMask(t.colorWrite); let l = t.stencilWrite; s.setTest(l), l && (s.setMask(t.stencilWriteMask), s.setFunc(t.stencilFunc, t.stencilRef, t.stencilFuncMask), s.setOp(t.stencilFail, t.stencilZFail, t.stencilZPass)), X(t.polygonOffset, t.polygonOffsetFactor, t.polygonOffsetUnits), !0 === t.alphaToCoverage ? z(e.SAMPLE_ALPHA_TO_COVERAGE) : G(e.SAMPLE_ALPHA_TO_COVERAGE) }, setFlipSided: j, setCullFace: Y, setLineWidth: function (t) { t !== w && (I && e.lineWidth(t), w = t) }, setPolygonOffset: X, setScissorTest: function (t) { t ? z(e.SCISSOR_TEST) : G(e.SCISSOR_TEST) }, activeTexture: function (t) { void 0 === t && (t = e.TEXTURE0 + C - 1), P !== t && (e.activeTexture(t), P = t) }, bindTexture: function (t, i, r) { void 0 === r && (r = null === P ? e.TEXTURE0 + C - 1 : P); let n = D[r]; void 0 === n && (n = { type: void 0, texture: void 0 }, D[r] = n), (n.type !== t || n.texture !== i) && (P !== r && (e.activeTexture(r), P = r), e.bindTexture(t, i || B[t]), n.type = t, n.texture = i) }, unbindTexture: function () { let t = D[P]; void 0 !== t && void 0 !== t.type && (e.bindTexture(t.type, null), t.type = void 0, t.texture = void 0) }, compressedTexImage2D: function () { try { e.compressedTexImage2D(...arguments) } catch (e) { console.error("THREE.WebGLState:", e) } }, compressedTexImage3D: function () { try { e.compressedTexImage3D(...arguments) } catch (e) { console.error("THREE.WebGLState:", e) } }, texImage2D: function () { try { e.texImage2D(...arguments) } catch (e) { console.error("THREE.WebGLState:", e) } }, texImage3D: function () { try { e.texImage3D(...arguments) } catch (e) { console.error("THREE.WebGLState:", e) } }, updateUBOMapping: function (t, i) { let r = o.get(i); void 0 === r && (r = new WeakMap, o.set(i, r)); let n = r.get(t); void 0 === n && (n = e.getUniformBlockIndex(i, t.name), r.set(t, n)) }, uniformBlockBinding: function (t, i) { let r = o.get(i).get(t); a.get(i) !== r && (e.uniformBlockBinding(i, r, t.__bindingPointIndex), a.set(i, r)) }, texStorage2D: function () { try { e.texStorage2D(...arguments) } catch (e) { console.error("THREE.WebGLState:", e) } }, texStorage3D: function () { try { e.texStorage3D(...arguments) } catch (e) { console.error("THREE.WebGLState:", e) } }, texSubImage2D: function () { try { e.texSubImage2D(...arguments) } catch (e) { console.error("THREE.WebGLState:", e) } }, texSubImage3D: function () { try { e.texSubImage3D(...arguments) } catch (e) { console.error("THREE.WebGLState:", e) } }, compressedTexSubImage2D: function () { try { e.compressedTexSubImage2D(...arguments) } catch (e) { console.error("THREE.WebGLState:", e) } }, compressedTexSubImage3D: function () { try { e.compressedTexSubImage3D(...arguments) } catch (e) { console.error("THREE.WebGLState:", e) } }, scissor: function (t) { !1 === F.equals(t) && (e.scissor(t.x, t.y, t.z, t.w), F.copy(t)) }, viewport: function (t) { !1 === U.equals(t) && (e.viewport(t.x, t.y, t.z, t.w), U.copy(t)) }, reset: function () { e.disable(e.BLEND), e.disable(e.CULL_FACE), e.disable(e.DEPTH_TEST), e.disable(e.POLYGON_OFFSET_FILL), e.disable(e.SCISSOR_TEST), e.disable(e.STENCIL_TEST), e.disable(e.SAMPLE_ALPHA_TO_COVERAGE), e.blendEquation(e.FUNC_ADD), e.blendFunc(e.ONE, e.ZERO), e.blendFuncSeparate(e.ONE, e.ZERO, e.ONE, e.ZERO), e.blendColor(0, 0, 0, 0), e.colorMask(!0, !0, !0, !0), e.clearColor(0, 0, 0, 0), e.depthMask(!0), e.depthFunc(e.LESS), n.setReversed(!1), e.clearDepth(1), e.stencilMask(0xffffffff), e.stencilFunc(e.ALWAYS, 0, 0xffffffff), e.stencilOp(e.KEEP, e.KEEP, e.KEEP), e.clearStencil(0), e.cullFace(e.BACK), e.frontFace(e.CCW), e.polygonOffset(0, 0), e.activeTexture(e.TEXTURE0), e.bindFramebuffer(e.FRAMEBUFFER, null), e.bindFramebuffer(e.DRAW_FRAMEBUFFER, null), e.bindFramebuffer(e.READ_FRAMEBUFFER, null), e.useProgram(null), e.lineWidth(1), e.scissor(0, 0, e.canvas.width, e.canvas.height), e.viewport(0, 0, e.canvas.width, e.canvas.height), l = {}, P = null, D = {}, u = {}, h = new WeakMap, c = [], d = null, f = !1, p = null, m = null, g = null, v = null, y = null, x = null, S = null, A = new r.Q1f(0, 0, 0), _ = 0, E = !1, b = null, T = null, w = null, M = null, R = null, F.set(0, 0, e.canvas.width, e.canvas.height), U.set(0, 0, e.canvas.width, e.canvas.height), i.reset(), n.reset(), s.reset() } } } function tv(e, t, i, n, s, a, o) { let l; let u = t.has("WEBGL_multisampled_render_to_texture") ? t.get("WEBGL_multisampled_render_to_texture") : null, h = "undefined" != typeof navigator && /OculusBrowser/g.test(navigator.userAgent), c = new r.I9Y, d = new WeakMap, f = new WeakMap, p = !1; try { p = "undefined" != typeof OffscreenCanvas && null !== new OffscreenCanvas(1, 1).getContext("2d") } catch (e) { } function m(e, t) { return p ? new OffscreenCanvas(e, t) : (0, r.qq$)("canvas") } function g(e, t, i) { let r = 1, n = G(e); if ((n.width > i || n.height > i) && (r = i / Math.max(n.width, n.height)), r < 1) { if ("undefined" != typeof HTMLImageElement && e instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && e instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && e instanceof ImageBitmap || "undefined" != typeof VideoFrame && e instanceof VideoFrame) { let i = Math.floor(r * n.width), s = Math.floor(r * n.height); void 0 === l && (l = m(i, s)); let a = t ? m(i, s) : l; return a.width = i, a.height = s, a.getContext("2d").drawImage(e, 0, 0, i, s), console.warn("THREE.WebGLRenderer: Texture has been resized from (" + n.width + "x" + n.height + ") to (" + i + "x" + s + ")."), a } "data" in e && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + n.width + "x" + n.height + ").") } return e } function v(e) { return e.generateMipmaps } function y(t) { e.generateMipmap(t) } function x(i, n, s, a, o = !1) { if (null !== i) { if (void 0 !== e[i]) return e[i]; console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + i + "'") } let l = n; if (n === e.RED && (s === e.FLOAT && (l = e.R32F), s === e.HALF_FLOAT && (l = e.R16F), s === e.UNSIGNED_BYTE && (l = e.R8)), n === e.RED_INTEGER && (s === e.UNSIGNED_BYTE && (l = e.R8UI), s === e.UNSIGNED_SHORT && (l = e.R16UI), s === e.UNSIGNED_INT && (l = e.R32UI), s === e.BYTE && (l = e.R8I), s === e.SHORT && (l = e.R16I), s === e.INT && (l = e.R32I)), n === e.RG && (s === e.FLOAT && (l = e.RG32F), s === e.HALF_FLOAT && (l = e.RG16F), s === e.UNSIGNED_BYTE && (l = e.RG8)), n === e.RG_INTEGER && (s === e.UNSIGNED_BYTE && (l = e.RG8UI), s === e.UNSIGNED_SHORT && (l = e.RG16UI), s === e.UNSIGNED_INT && (l = e.RG32UI), s === e.BYTE && (l = e.RG8I), s === e.SHORT && (l = e.RG16I), s === e.INT && (l = e.RG32I)), n === e.RGB_INTEGER && (s === e.UNSIGNED_BYTE && (l = e.RGB8UI), s === e.UNSIGNED_SHORT && (l = e.RGB16UI), s === e.UNSIGNED_INT && (l = e.RGB32UI), s === e.BYTE && (l = e.RGB8I), s === e.SHORT && (l = e.RGB16I), s === e.INT && (l = e.RGB32I)), n === e.RGBA_INTEGER && (s === e.UNSIGNED_BYTE && (l = e.RGBA8UI), s === e.UNSIGNED_SHORT && (l = e.RGBA16UI), s === e.UNSIGNED_INT && (l = e.RGBA32UI), s === e.BYTE && (l = e.RGBA8I), s === e.SHORT && (l = e.RGBA16I), s === e.INT && (l = e.RGBA32I)), n === e.RGB && s === e.UNSIGNED_INT_5_9_9_9_REV && (l = e.RGB9_E5), n === e.RGBA) { let t = o ? r.VxR : r.ppV.getTransfer(a); s === e.FLOAT && (l = e.RGBA32F), s === e.HALF_FLOAT && (l = e.RGBA16F), s === e.UNSIGNED_BYTE && (l = t === r.KLL ? e.SRGB8_ALPHA8 : e.RGBA8), s === e.UNSIGNED_SHORT_4_4_4_4 && (l = e.RGBA4), s === e.UNSIGNED_SHORT_5_5_5_1 && (l = e.RGB5_A1) } return (l === e.R16F || l === e.R32F || l === e.RG16F || l === e.RG32F || l === e.RGBA16F || l === e.RGBA32F) && t.get("EXT_color_buffer_float"), l } function S(t, i) { let n; return t ? null === i || i === r.bkx || i === r.V3x ? n = e.DEPTH24_STENCIL8 : i === r.RQf ? n = e.DEPTH32F_STENCIL8 : i === r.cHt && (n = e.DEPTH24_STENCIL8, console.warn("DepthTexture: 16 bit depth attachment is not supported with stencil. Using 24-bit attachment.")) : null === i || i === r.bkx || i === r.V3x ? n = e.DEPTH_COMPONENT24 : i === r.RQf ? n = e.DEPTH_COMPONENT32F : i === r.cHt && (n = e.DEPTH_COMPONENT16), n } function A(e, t) { return !0 === v(e) || e.isFramebufferTexture && e.minFilter !== r.hxR && e.minFilter !== r.k6q ? Math.log2(Math.max(t.width, t.height)) + 1 : void 0 !== e.mipmaps && e.mipmaps.length > 0 ? e.mipmaps.length : e.isCompressedTexture && Array.isArray(e.image) ? t.mipmaps.length : 1 } function _(e) { let t = e.target; t.removeEventListener("dispose", _), function (e) { let t = n.get(e); if (void 0 === t.__webglInit) return; let i = e.source, r = f.get(i); if (r) { let n = r[t.__cacheKey]; n.usedTimes--, 0 === n.usedTimes && b(e), 0 === Object.keys(r).length && f.delete(i) } n.remove(e) }(t), t.isVideoTexture && d.delete(t) } function E(t) { let i = t.target; i.removeEventListener("dispose", E), function (t) { let i = n.get(t); if (t.depthTexture && (t.depthTexture.dispose(), n.remove(t.depthTexture)), t.isWebGLCubeRenderTarget) for (let t = 0; t < 6; t++) { if (Array.isArray(i.__webglFramebuffer[t])) for (let r = 0; r < i.__webglFramebuffer[t].length; r++)e.deleteFramebuffer(i.__webglFramebuffer[t][r]); else e.deleteFramebuffer(i.__webglFramebuffer[t]); i.__webglDepthbuffer && e.deleteRenderbuffer(i.__webglDepthbuffer[t]) } else { if (Array.isArray(i.__webglFramebuffer)) for (let t = 0; t < i.__webglFramebuffer.length; t++)e.deleteFramebuffer(i.__webglFramebuffer[t]); else e.deleteFramebuffer(i.__webglFramebuffer); if (i.__webglDepthbuffer && e.deleteRenderbuffer(i.__webglDepthbuffer), i.__webglMultisampledFramebuffer && e.deleteFramebuffer(i.__webglMultisampledFramebuffer), i.__webglColorRenderbuffer) for (let t = 0; t < i.__webglColorRenderbuffer.length; t++)i.__webglColorRenderbuffer[t] && e.deleteRenderbuffer(i.__webglColorRenderbuffer[t]); i.__webglDepthRenderbuffer && e.deleteRenderbuffer(i.__webglDepthRenderbuffer) } let r = t.textures; for (let t = 0, i = r.length; t < i; t++) { let i = n.get(r[t]); i.__webglTexture && (e.deleteTexture(i.__webglTexture), o.memory.textures--), n.remove(r[t]) } n.remove(t) }(i) } function b(t) { let i = n.get(t); e.deleteTexture(i.__webglTexture); let r = t.source, s = f.get(r); delete s[i.__cacheKey], o.memory.textures-- } let T = 0; function w(t, r) { let s = n.get(t); if (t.isVideoTexture && function (e) { let t = o.render.frame; d.get(e) !== t && (d.set(e, t), e.update()) }(t), !1 === t.isRenderTargetTexture && t.version > 0 && s.__version !== t.version) { let e = t.image; if (null === e) console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found."); else if (!1 === e.complete) console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete"); else { P(s, t, r); return } } i.bindTexture(e.TEXTURE_2D, s.__webglTexture, e.TEXTURE0 + r) } let M = { [r.GJx]: e.REPEAT, [r.ghU]: e.CLAMP_TO_EDGE, [r.kTW]: e.MIRRORED_REPEAT }, R = { [r.hxR]: e.NEAREST, [r.pHI]: e.NEAREST_MIPMAP_NEAREST, [r.Cfg]: e.NEAREST_MIPMAP_LINEAR, [r.k6q]: e.LINEAR, [r.kRr]: e.LINEAR_MIPMAP_NEAREST, [r.$_I]: e.LINEAR_MIPMAP_LINEAR }, C = { [r.amv]: e.NEVER, [r.FFZ]: e.ALWAYS, [r.vim]: e.LESS, [r.TiK]: e.LEQUAL, [r.kO0]: e.EQUAL, [r.gWB]: e.GEQUAL, [r.eoi]: e.GREATER, [r.jzd]: e.NOTEQUAL }; function I(i, a) { if (a.type === r.RQf && !1 === t.has("OES_texture_float_linear") && (a.magFilter === r.k6q || a.magFilter === r.kRr || a.magFilter === r.Cfg || a.magFilter === r.$_I || a.minFilter === r.k6q || a.minFilter === r.kRr || a.minFilter === r.Cfg || a.minFilter === r.$_I) && console.warn("THREE.WebGLRenderer: Unable to use linear filtering with floating point textures. OES_texture_float_linear not supported on this device."), e.texParameteri(i, e.TEXTURE_WRAP_S, M[a.wrapS]), e.texParameteri(i, e.TEXTURE_WRAP_T, M[a.wrapT]), (i === e.TEXTURE_3D || i === e.TEXTURE_2D_ARRAY) && e.texParameteri(i, e.TEXTURE_WRAP_R, M[a.wrapR]), e.texParameteri(i, e.TEXTURE_MAG_FILTER, R[a.magFilter]), e.texParameteri(i, e.TEXTURE_MIN_FILTER, R[a.minFilter]), a.compareFunction && (e.texParameteri(i, e.TEXTURE_COMPARE_MODE, e.COMPARE_REF_TO_TEXTURE), e.texParameteri(i, e.TEXTURE_COMPARE_FUNC, C[a.compareFunction])), !0 === t.has("EXT_texture_filter_anisotropic") && a.magFilter !== r.hxR && (a.minFilter === r.Cfg || a.minFilter === r.$_I) && (a.type !== r.RQf || !1 !== t.has("OES_texture_float_linear")) && (a.anisotropy > 1 || n.get(a).__currentAnisotropy)) { let r = t.get("EXT_texture_filter_anisotropic"); e.texParameterf(i, r.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(a.anisotropy, s.getMaxAnisotropy())), n.get(a).__currentAnisotropy = a.anisotropy } } function L(t, i) { let r = !1; void 0 === t.__webglInit && (t.__webglInit = !0, i.addEventListener("dispose", _)); let n = i.source, s = f.get(n); void 0 === s && (s = {}, f.set(n, s)); let a = function (e) { let t = []; return t.push(e.wrapS), t.push(e.wrapT), t.push(e.wrapR || 0), t.push(e.magFilter), t.push(e.minFilter), t.push(e.anisotropy), t.push(e.internalFormat), t.push(e.format), t.push(e.type), t.push(e.generateMipmaps), t.push(e.premultiplyAlpha), t.push(e.flipY), t.push(e.unpackAlignment), t.push(e.colorSpace), t.join() }(i); if (a !== t.__cacheKey) { void 0 === s[a] && (s[a] = { texture: e.createTexture(), usedTimes: 0 }, o.memory.textures++, r = !0), s[a].usedTimes++; let n = s[t.__cacheKey]; void 0 !== n && (s[t.__cacheKey].usedTimes--, 0 === n.usedTimes && b(i)), t.__cacheKey = a, t.__webglTexture = s[a].texture } return r } function P(t, o, l) { let u = e.TEXTURE_2D; (o.isDataArrayTexture || o.isCompressedArrayTexture) && (u = e.TEXTURE_2D_ARRAY), o.isData3DTexture && (u = e.TEXTURE_3D); let h = L(t, o), c = o.source; i.bindTexture(u, t.__webglTexture, e.TEXTURE0 + l); let d = n.get(c); if (c.version !== d.__version || !0 === h) { let t; i.activeTexture(e.TEXTURE0 + l); let n = r.ppV.getPrimaries(r.ppV.workingColorSpace), f = o.colorSpace === r.jf0 ? null : r.ppV.getPrimaries(o.colorSpace), p = o.colorSpace === r.jf0 || n === f ? e.NONE : e.BROWSER_DEFAULT_WEBGL; e.pixelStorei(e.UNPACK_FLIP_Y_WEBGL, o.flipY), e.pixelStorei(e.UNPACK_PREMULTIPLY_ALPHA_WEBGL, o.premultiplyAlpha), e.pixelStorei(e.UNPACK_ALIGNMENT, o.unpackAlignment), e.pixelStorei(e.UNPACK_COLORSPACE_CONVERSION_WEBGL, p); let m = g(o.image, !1, s.maxTextureSize); m = z(o, m); let _ = a.convert(o.format, o.colorSpace), E = a.convert(o.type), b = x(o.internalFormat, _, E, o.colorSpace, o.isVideoTexture); I(u, o); let T = o.mipmaps, w = !0 !== o.isVideoTexture, M = void 0 === d.__version || !0 === h, R = c.dataReady, C = A(o, m); if (o.isDepthTexture) b = S(o.format === r.dcC, o.type), M && (w ? i.texStorage2D(e.TEXTURE_2D, 1, b, m.width, m.height) : i.texImage2D(e.TEXTURE_2D, 0, b, m.width, m.height, 0, _, E, null)); else if (o.isDataTexture) { if (T.length > 0) { w && M && i.texStorage2D(e.TEXTURE_2D, C, b, T[0].width, T[0].height); for (let r = 0, n = T.length; r < n; r++)t = T[r], w ? R && i.texSubImage2D(e.TEXTURE_2D, r, 0, 0, t.width, t.height, _, E, t.data) : i.texImage2D(e.TEXTURE_2D, r, b, t.width, t.height, 0, _, E, t.data); o.generateMipmaps = !1 } else w ? (M && i.texStorage2D(e.TEXTURE_2D, C, b, m.width, m.height), R && i.texSubImage2D(e.TEXTURE_2D, 0, 0, 0, m.width, m.height, _, E, m.data)) : i.texImage2D(e.TEXTURE_2D, 0, b, m.width, m.height, 0, _, E, m.data) } else if (o.isCompressedTexture) { if (o.isCompressedArrayTexture) { w && M && i.texStorage3D(e.TEXTURE_2D_ARRAY, C, b, T[0].width, T[0].height, m.depth); for (let n = 0, s = T.length; n < s; n++)if (t = T[n], o.format !== r.GWd) { if (null !== _) { if (w) { if (R) { if (o.layerUpdates.size > 0) { let s = (0, r.Nex)(t.width, t.height, o.format, o.type); for (let r of o.layerUpdates) { let a = t.data.subarray(r * s / t.data.BYTES_PER_ELEMENT, (r + 1) * s / t.data.BYTES_PER_ELEMENT); i.compressedTexSubImage3D(e.TEXTURE_2D_ARRAY, n, 0, 0, r, t.width, t.height, 1, _, a) } o.clearLayerUpdates() } else i.compressedTexSubImage3D(e.TEXTURE_2D_ARRAY, n, 0, 0, 0, t.width, t.height, m.depth, _, t.data) } } else i.compressedTexImage3D(e.TEXTURE_2D_ARRAY, n, b, t.width, t.height, m.depth, 0, t.data, 0, 0) } else console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") } else w ? R && i.texSubImage3D(e.TEXTURE_2D_ARRAY, n, 0, 0, 0, t.width, t.height, m.depth, _, E, t.data) : i.texImage3D(e.TEXTURE_2D_ARRAY, n, b, t.width, t.height, m.depth, 0, _, E, t.data) } else { w && M && i.texStorage2D(e.TEXTURE_2D, C, b, T[0].width, T[0].height); for (let n = 0, s = T.length; n < s; n++)t = T[n], o.format !== r.GWd ? null !== _ ? w ? R && i.compressedTexSubImage2D(e.TEXTURE_2D, n, 0, 0, t.width, t.height, _, t.data) : i.compressedTexImage2D(e.TEXTURE_2D, n, b, t.width, t.height, 0, t.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : w ? R && i.texSubImage2D(e.TEXTURE_2D, n, 0, 0, t.width, t.height, _, E, t.data) : i.texImage2D(e.TEXTURE_2D, n, b, t.width, t.height, 0, _, E, t.data) } } else if (o.isDataArrayTexture) { if (w) { if (M && i.texStorage3D(e.TEXTURE_2D_ARRAY, C, b, m.width, m.height, m.depth), R) { if (o.layerUpdates.size > 0) { let t = (0, r.Nex)(m.width, m.height, o.format, o.type); for (let r of o.layerUpdates) { let n = m.data.subarray(r * t / m.data.BYTES_PER_ELEMENT, (r + 1) * t / m.data.BYTES_PER_ELEMENT); i.texSubImage3D(e.TEXTURE_2D_ARRAY, 0, 0, 0, r, m.width, m.height, 1, _, E, n) } o.clearLayerUpdates() } else i.texSubImage3D(e.TEXTURE_2D_ARRAY, 0, 0, 0, 0, m.width, m.height, m.depth, _, E, m.data) } } else i.texImage3D(e.TEXTURE_2D_ARRAY, 0, b, m.width, m.height, m.depth, 0, _, E, m.data) } else if (o.isData3DTexture) w ? (M && i.texStorage3D(e.TEXTURE_3D, C, b, m.width, m.height, m.depth), R && i.texSubImage3D(e.TEXTURE_3D, 0, 0, 0, 0, m.width, m.height, m.depth, _, E, m.data)) : i.texImage3D(e.TEXTURE_3D, 0, b, m.width, m.height, m.depth, 0, _, E, m.data); else if (o.isFramebufferTexture) { if (M) { if (w) i.texStorage2D(e.TEXTURE_2D, C, b, m.width, m.height); else { let t = m.width, r = m.height; for (let n = 0; n < C; n++)i.texImage2D(e.TEXTURE_2D, n, b, t, r, 0, _, E, null), t >>= 1, r >>= 1 } } } else if (T.length > 0) { if (w && M) { let t = G(T[0]); i.texStorage2D(e.TEXTURE_2D, C, b, t.width, t.height) } for (let r = 0, n = T.length; r < n; r++)t = T[r], w ? R && i.texSubImage2D(e.TEXTURE_2D, r, 0, 0, _, E, t) : i.texImage2D(e.TEXTURE_2D, r, b, _, E, t); o.generateMipmaps = !1 } else if (w) { if (M) { let t = G(m); i.texStorage2D(e.TEXTURE_2D, C, b, t.width, t.height) } R && i.texSubImage2D(e.TEXTURE_2D, 0, 0, 0, _, E, m) } else i.texImage2D(e.TEXTURE_2D, 0, b, _, E, m); v(o) && y(u), d.__version = c.version, o.onUpdate && o.onUpdate(o) } t.__version = o.version } function D(t, r, s, o, l, h) { let c = a.convert(s.format, s.colorSpace), d = a.convert(s.type), f = x(s.internalFormat, c, d, s.colorSpace), p = n.get(r), m = n.get(s); if (m.__renderTarget = r, !p.__hasExternalTextures) { let t = Math.max(1, r.width >> h), n = Math.max(1, r.height >> h); l === e.TEXTURE_3D || l === e.TEXTURE_2D_ARRAY ? i.texImage3D(l, h, f, t, n, r.depth, 0, c, d, null) : i.texImage2D(l, h, f, t, n, 0, c, d, null) } i.bindFramebuffer(e.FRAMEBUFFER, t), B(r) ? u.framebufferTexture2DMultisampleEXT(e.FRAMEBUFFER, o, l, m.__webglTexture, 0, N(r)) : (l === e.TEXTURE_2D || l >= e.TEXTURE_CUBE_MAP_POSITIVE_X && l <= e.TEXTURE_CUBE_MAP_NEGATIVE_Z) && e.framebufferTexture2D(e.FRAMEBUFFER, o, l, m.__webglTexture, h), i.bindFramebuffer(e.FRAMEBUFFER, null) } function O(t, i, r) { if (e.bindRenderbuffer(e.RENDERBUFFER, t), i.depthBuffer) { let n = i.depthTexture, s = n && n.isDepthTexture ? n.type : null, a = S(i.stencilBuffer, s), o = i.stencilBuffer ? e.DEPTH_STENCIL_ATTACHMENT : e.DEPTH_ATTACHMENT, l = N(i); B(i) ? u.renderbufferStorageMultisampleEXT(e.RENDERBUFFER, l, a, i.width, i.height) : r ? e.renderbufferStorageMultisample(e.RENDERBUFFER, l, a, i.width, i.height) : e.renderbufferStorage(e.RENDERBUFFER, a, i.width, i.height), e.framebufferRenderbuffer(e.FRAMEBUFFER, o, e.RENDERBUFFER, t) } else { let t = i.textures; for (let n = 0; n < t.length; n++) { let s = t[n], o = a.convert(s.format, s.colorSpace), l = a.convert(s.type), h = x(s.internalFormat, o, l, s.colorSpace), c = N(i); r && !1 === B(i) ? e.renderbufferStorageMultisample(e.RENDERBUFFER, c, h, i.width, i.height) : B(i) ? u.renderbufferStorageMultisampleEXT(e.RENDERBUFFER, c, h, i.width, i.height) : e.renderbufferStorage(e.RENDERBUFFER, h, i.width, i.height) } } e.bindRenderbuffer(e.RENDERBUFFER, null) } function k(t) { let s = n.get(t), a = !0 === t.isWebGLCubeRenderTarget; if (s.__boundDepthTexture !== t.depthTexture) { let e = t.depthTexture; if (s.__depthDisposeCallback && s.__depthDisposeCallback(), e) { let t = () => { delete s.__boundDepthTexture, delete s.__depthDisposeCallback, e.removeEventListener("dispose", t) }; e.addEventListener("dispose", t), s.__depthDisposeCallback = t } s.__boundDepthTexture = e } if (t.depthTexture && !s.__autoAllocateDepthBuffer) { if (a) throw Error("target.depthTexture not supported in Cube render targets"); !function (t, s) { if (s && s.isWebGLCubeRenderTarget) throw Error("Depth Texture with cube render targets is not supported"); if (i.bindFramebuffer(e.FRAMEBUFFER, t), !(s.depthTexture && s.depthTexture.isDepthTexture)) throw Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture"); let a = n.get(s.depthTexture); a.__renderTarget = s, a.__webglTexture && s.depthTexture.image.width === s.width && s.depthTexture.image.height === s.height || (s.depthTexture.image.width = s.width, s.depthTexture.image.height = s.height, s.depthTexture.needsUpdate = !0), w(s.depthTexture, 0); let o = a.__webglTexture, l = N(s); if (s.depthTexture.format === r.zdS) B(s) ? u.framebufferTexture2DMultisampleEXT(e.FRAMEBUFFER, e.DEPTH_ATTACHMENT, e.TEXTURE_2D, o, 0, l) : e.framebufferTexture2D(e.FRAMEBUFFER, e.DEPTH_ATTACHMENT, e.TEXTURE_2D, o, 0); else if (s.depthTexture.format === r.dcC) B(s) ? u.framebufferTexture2DMultisampleEXT(e.FRAMEBUFFER, e.DEPTH_STENCIL_ATTACHMENT, e.TEXTURE_2D, o, 0, l) : e.framebufferTexture2D(e.FRAMEBUFFER, e.DEPTH_STENCIL_ATTACHMENT, e.TEXTURE_2D, o, 0); else throw Error("Unknown depthTexture format") }(s.__webglFramebuffer, t) } else if (a) { s.__webglDepthbuffer = []; for (let r = 0; r < 6; r++)if (i.bindFramebuffer(e.FRAMEBUFFER, s.__webglFramebuffer[r]), void 0 === s.__webglDepthbuffer[r]) s.__webglDepthbuffer[r] = e.createRenderbuffer(), O(s.__webglDepthbuffer[r], t, !1); else { let i = t.stencilBuffer ? e.DEPTH_STENCIL_ATTACHMENT : e.DEPTH_ATTACHMENT, n = s.__webglDepthbuffer[r]; e.bindRenderbuffer(e.RENDERBUFFER, n), e.framebufferRenderbuffer(e.FRAMEBUFFER, i, e.RENDERBUFFER, n) } } else if (i.bindFramebuffer(e.FRAMEBUFFER, s.__webglFramebuffer), void 0 === s.__webglDepthbuffer) s.__webglDepthbuffer = e.createRenderbuffer(), O(s.__webglDepthbuffer, t, !1); else { let i = t.stencilBuffer ? e.DEPTH_STENCIL_ATTACHMENT : e.DEPTH_ATTACHMENT, r = s.__webglDepthbuffer; e.bindRenderbuffer(e.RENDERBUFFER, r), e.framebufferRenderbuffer(e.FRAMEBUFFER, i, e.RENDERBUFFER, r) } i.bindFramebuffer(e.FRAMEBUFFER, null) } let F = [], U = []; function N(e) { return Math.min(s.maxSamples, e.samples) } function B(e) { let i = n.get(e); return e.samples > 0 && !0 === t.has("WEBGL_multisampled_render_to_texture") && !1 !== i.__useRenderToTexture } function z(e, t) { let i = e.colorSpace, n = e.format, s = e.type; return !0 === e.isCompressedTexture || !0 === e.isVideoTexture || i !== r.Zr2 && i !== r.jf0 && (r.ppV.getTransfer(i) === r.KLL ? (n !== r.GWd || s !== r.OUM) && console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.") : console.error("THREE.WebGLTextures: Unsupported texture color space:", i)), t } function G(e) { return "undefined" != typeof HTMLImageElement && e instanceof HTMLImageElement ? (c.width = e.naturalWidth || e.width, c.height = e.naturalHeight || e.height) : "undefined" != typeof VideoFrame && e instanceof VideoFrame ? (c.width = e.displayWidth, c.height = e.displayHeight) : (c.width = e.width, c.height = e.height), c } this.allocateTextureUnit = function () { let e = T; return e >= s.maxTextures && console.warn("THREE.WebGLTextures: Trying to use " + e + " texture units while this GPU supports only " + s.maxTextures), T += 1, e }, this.resetTextureUnits = function () { T = 0 }, this.setTexture2D = w, this.setTexture2DArray = function (t, r) { let s = n.get(t); if (t.version > 0 && s.__version !== t.version) { P(s, t, r); return } i.bindTexture(e.TEXTURE_2D_ARRAY, s.__webglTexture, e.TEXTURE0 + r) }, this.setTexture3D = function (t, r) { let s = n.get(t); if (t.version > 0 && s.__version !== t.version) { P(s, t, r); return } i.bindTexture(e.TEXTURE_3D, s.__webglTexture, e.TEXTURE0 + r) }, this.setTextureCube = function (t, o) { let l = n.get(t); if (t.version > 0 && l.__version !== t.version) { (function (t, o, l) { if (6 !== o.image.length) return; let u = L(t, o), h = o.source; i.bindTexture(e.TEXTURE_CUBE_MAP, t.__webglTexture, e.TEXTURE0 + l); let c = n.get(h); if (h.version !== c.__version || !0 === u) { let t; i.activeTexture(e.TEXTURE0 + l); let n = r.ppV.getPrimaries(r.ppV.workingColorSpace), d = o.colorSpace === r.jf0 ? null : r.ppV.getPrimaries(o.colorSpace), f = o.colorSpace === r.jf0 || n === d ? e.NONE : e.BROWSER_DEFAULT_WEBGL; e.pixelStorei(e.UNPACK_FLIP_Y_WEBGL, o.flipY), e.pixelStorei(e.UNPACK_PREMULTIPLY_ALPHA_WEBGL, o.premultiplyAlpha), e.pixelStorei(e.UNPACK_ALIGNMENT, o.unpackAlignment), e.pixelStorei(e.UNPACK_COLORSPACE_CONVERSION_WEBGL, f); let p = o.isCompressedTexture || o.image[0].isCompressedTexture, m = o.image[0] && o.image[0].isDataTexture, S = []; for (let e = 0; e < 6; e++)p || m ? S[e] = m ? o.image[e].image : o.image[e] : S[e] = g(o.image[e], !0, s.maxCubemapSize), S[e] = z(o, S[e]); let _ = S[0], E = a.convert(o.format, o.colorSpace), b = a.convert(o.type), T = x(o.internalFormat, E, b, o.colorSpace), w = !0 !== o.isVideoTexture, M = void 0 === c.__version || !0 === u, R = h.dataReady, C = A(o, _); if (I(e.TEXTURE_CUBE_MAP, o), p) { w && M && i.texStorage2D(e.TEXTURE_CUBE_MAP, C, T, _.width, _.height); for (let n = 0; n < 6; n++) { t = S[n].mipmaps; for (let s = 0; s < t.length; s++) { let a = t[s]; o.format !== r.GWd ? null !== E ? w ? R && i.compressedTexSubImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + n, s, 0, 0, a.width, a.height, E, a.data) : i.compressedTexImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + n, s, T, a.width, a.height, 0, a.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : w ? R && i.texSubImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + n, s, 0, 0, a.width, a.height, E, b, a.data) : i.texImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + n, s, T, a.width, a.height, 0, E, b, a.data) } } } else { if (t = o.mipmaps, w && M) { t.length > 0 && C++; let r = G(S[0]); i.texStorage2D(e.TEXTURE_CUBE_MAP, C, T, r.width, r.height) } for (let r = 0; r < 6; r++)if (m) { w ? R && i.texSubImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + r, 0, 0, 0, S[r].width, S[r].height, E, b, S[r].data) : i.texImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + r, 0, T, S[r].width, S[r].height, 0, E, b, S[r].data); for (let n = 0; n < t.length; n++) { let s = t[n].image[r].image; w ? R && i.texSubImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + r, n + 1, 0, 0, s.width, s.height, E, b, s.data) : i.texImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + r, n + 1, T, s.width, s.height, 0, E, b, s.data) } } else { w ? R && i.texSubImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + r, 0, 0, 0, E, b, S[r]) : i.texImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + r, 0, T, E, b, S[r]); for (let n = 0; n < t.length; n++) { let s = t[n]; w ? R && i.texSubImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + r, n + 1, 0, 0, E, b, s.image[r]) : i.texImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + r, n + 1, T, E, b, s.image[r]) } } } v(o) && y(e.TEXTURE_CUBE_MAP), c.__version = h.version, o.onUpdate && o.onUpdate(o) } t.__version = o.version })(l, t, o); return } i.bindTexture(e.TEXTURE_CUBE_MAP, l.__webglTexture, e.TEXTURE0 + o) }, this.rebindTextures = function (t, i, r) { let s = n.get(t); void 0 !== i && D(s.__webglFramebuffer, t, t.texture, e.COLOR_ATTACHMENT0, e.TEXTURE_2D, 0), void 0 !== r && k(t) }, this.setupRenderTarget = function (t) { let r = t.texture, s = n.get(t), l = n.get(r); t.addEventListener("dispose", E); let u = t.textures, h = !0 === t.isWebGLCubeRenderTarget, c = u.length > 1; if (!c && (void 0 === l.__webglTexture && (l.__webglTexture = e.createTexture()), l.__version = r.version, o.memory.textures++), h) { s.__webglFramebuffer = []; for (let t = 0; t < 6; t++)if (r.mipmaps && r.mipmaps.length > 0) { s.__webglFramebuffer[t] = []; for (let i = 0; i < r.mipmaps.length; i++)s.__webglFramebuffer[t][i] = e.createFramebuffer() } else s.__webglFramebuffer[t] = e.createFramebuffer() } else { if (r.mipmaps && r.mipmaps.length > 0) { s.__webglFramebuffer = []; for (let t = 0; t < r.mipmaps.length; t++)s.__webglFramebuffer[t] = e.createFramebuffer() } else s.__webglFramebuffer = e.createFramebuffer(); if (c) for (let t = 0, i = u.length; t < i; t++) { let i = n.get(u[t]); void 0 === i.__webglTexture && (i.__webglTexture = e.createTexture(), o.memory.textures++) } if (t.samples > 0 && !1 === B(t)) { s.__webglMultisampledFramebuffer = e.createFramebuffer(), s.__webglColorRenderbuffer = [], i.bindFramebuffer(e.FRAMEBUFFER, s.__webglMultisampledFramebuffer); for (let i = 0; i < u.length; i++) { let r = u[i]; s.__webglColorRenderbuffer[i] = e.createRenderbuffer(), e.bindRenderbuffer(e.RENDERBUFFER, s.__webglColorRenderbuffer[i]); let n = a.convert(r.format, r.colorSpace), o = a.convert(r.type), l = x(r.internalFormat, n, o, r.colorSpace, !0 === t.isXRRenderTarget), h = N(t); e.renderbufferStorageMultisample(e.RENDERBUFFER, h, l, t.width, t.height), e.framebufferRenderbuffer(e.FRAMEBUFFER, e.COLOR_ATTACHMENT0 + i, e.RENDERBUFFER, s.__webglColorRenderbuffer[i]) } e.bindRenderbuffer(e.RENDERBUFFER, null), t.depthBuffer && (s.__webglDepthRenderbuffer = e.createRenderbuffer(), O(s.__webglDepthRenderbuffer, t, !0)), i.bindFramebuffer(e.FRAMEBUFFER, null) } } if (h) { i.bindTexture(e.TEXTURE_CUBE_MAP, l.__webglTexture), I(e.TEXTURE_CUBE_MAP, r); for (let i = 0; i < 6; i++)if (r.mipmaps && r.mipmaps.length > 0) for (let n = 0; n < r.mipmaps.length; n++)D(s.__webglFramebuffer[i][n], t, r, e.COLOR_ATTACHMENT0, e.TEXTURE_CUBE_MAP_POSITIVE_X + i, n); else D(s.__webglFramebuffer[i], t, r, e.COLOR_ATTACHMENT0, e.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0); v(r) && y(e.TEXTURE_CUBE_MAP), i.unbindTexture() } else if (c) { for (let r = 0, a = u.length; r < a; r++) { let a = u[r], o = n.get(a); i.bindTexture(e.TEXTURE_2D, o.__webglTexture), I(e.TEXTURE_2D, a), D(s.__webglFramebuffer, t, a, e.COLOR_ATTACHMENT0 + r, e.TEXTURE_2D, 0), v(a) && y(e.TEXTURE_2D) } i.unbindTexture() } else { let n = e.TEXTURE_2D; if ((t.isWebGL3DRenderTarget || t.isWebGLArrayRenderTarget) && (n = t.isWebGL3DRenderTarget ? e.TEXTURE_3D : e.TEXTURE_2D_ARRAY), i.bindTexture(n, l.__webglTexture), I(n, r), r.mipmaps && r.mipmaps.length > 0) for (let i = 0; i < r.mipmaps.length; i++)D(s.__webglFramebuffer[i], t, r, e.COLOR_ATTACHMENT0, n, i); else D(s.__webglFramebuffer, t, r, e.COLOR_ATTACHMENT0, n, 0); v(r) && y(n), i.unbindTexture() } t.depthBuffer && k(t) }, this.updateRenderTargetMipmap = function (t) { let r = t.textures; for (let s = 0, a = r.length; s < a; s++) { let a = r[s]; if (v(a)) { let r = t.isWebGLCubeRenderTarget ? e.TEXTURE_CUBE_MAP : t.isWebGL3DRenderTarget ? e.TEXTURE_3D : t.isWebGLArrayRenderTarget || t.isCompressedArrayTexture ? e.TEXTURE_2D_ARRAY : e.TEXTURE_2D, s = n.get(a).__webglTexture; i.bindTexture(r, s), y(r), i.unbindTexture() } } }, this.updateMultisampleRenderTarget = function (t) { if (t.samples > 0) { if (!1 === B(t)) { let r = t.textures, s = t.width, a = t.height, o = e.COLOR_BUFFER_BIT, l = t.stencilBuffer ? e.DEPTH_STENCIL_ATTACHMENT : e.DEPTH_ATTACHMENT, u = n.get(t), c = r.length > 1; if (c) for (let t = 0; t < r.length; t++)i.bindFramebuffer(e.FRAMEBUFFER, u.__webglMultisampledFramebuffer), e.framebufferRenderbuffer(e.FRAMEBUFFER, e.COLOR_ATTACHMENT0 + t, e.RENDERBUFFER, null), i.bindFramebuffer(e.FRAMEBUFFER, u.__webglFramebuffer), e.framebufferTexture2D(e.DRAW_FRAMEBUFFER, e.COLOR_ATTACHMENT0 + t, e.TEXTURE_2D, null, 0); i.bindFramebuffer(e.READ_FRAMEBUFFER, u.__webglMultisampledFramebuffer), i.bindFramebuffer(e.DRAW_FRAMEBUFFER, u.__webglFramebuffer); for (let i = 0; i < r.length; i++) { if (t.resolveDepthBuffer && (t.depthBuffer && (o |= e.DEPTH_BUFFER_BIT), t.stencilBuffer && t.resolveStencilBuffer && (o |= e.STENCIL_BUFFER_BIT)), c) { e.framebufferRenderbuffer(e.READ_FRAMEBUFFER, e.COLOR_ATTACHMENT0, e.RENDERBUFFER, u.__webglColorRenderbuffer[i]); let t = n.get(r[i]).__webglTexture; e.framebufferTexture2D(e.DRAW_FRAMEBUFFER, e.COLOR_ATTACHMENT0, e.TEXTURE_2D, t, 0) } e.blitFramebuffer(0, 0, s, a, 0, 0, s, a, o, e.NEAREST), !0 === h && (F.length = 0, U.length = 0, F.push(e.COLOR_ATTACHMENT0 + i), t.depthBuffer && !1 === t.resolveDepthBuffer && (F.push(l), U.push(l), e.invalidateFramebuffer(e.DRAW_FRAMEBUFFER, U)), e.invalidateFramebuffer(e.READ_FRAMEBUFFER, F)) } if (i.bindFramebuffer(e.READ_FRAMEBUFFER, null), i.bindFramebuffer(e.DRAW_FRAMEBUFFER, null), c) for (let t = 0; t < r.length; t++) { i.bindFramebuffer(e.FRAMEBUFFER, u.__webglMultisampledFramebuffer), e.framebufferRenderbuffer(e.FRAMEBUFFER, e.COLOR_ATTACHMENT0 + t, e.RENDERBUFFER, u.__webglColorRenderbuffer[t]); let s = n.get(r[t]).__webglTexture; i.bindFramebuffer(e.FRAMEBUFFER, u.__webglFramebuffer), e.framebufferTexture2D(e.DRAW_FRAMEBUFFER, e.COLOR_ATTACHMENT0 + t, e.TEXTURE_2D, s, 0) } i.bindFramebuffer(e.DRAW_FRAMEBUFFER, u.__webglMultisampledFramebuffer) } else if (t.depthBuffer && !1 === t.resolveDepthBuffer && h) { let i = t.stencilBuffer ? e.DEPTH_STENCIL_ATTACHMENT : e.DEPTH_ATTACHMENT; e.invalidateFramebuffer(e.DRAW_FRAMEBUFFER, [i]) } } }, this.setupDepthRenderbuffer = k, this.setupFrameBufferTexture = D, this.useMultisampledRTT = B } function ty(e, t) { return { convert: function (i, n = r.jf0) { let s; let a = r.ppV.getTransfer(n); if (i === r.OUM) return e.UNSIGNED_BYTE; if (i === r.Wew) return e.UNSIGNED_SHORT_4_4_4_4; if (i === r.gJ2) return e.UNSIGNED_SHORT_5_5_5_1; if (i === r.Dmk) return e.UNSIGNED_INT_5_9_9_9_REV; if (i === r.tJf) return e.BYTE; if (i === r.fBL) return e.SHORT; if (i === r.cHt) return e.UNSIGNED_SHORT; if (i === r.Yuy) return e.INT; if (i === r.bkx) return e.UNSIGNED_INT; if (i === r.RQf) return e.FLOAT; if (i === r.ix0) return e.HALF_FLOAT; if (i === r.wrO) return e.ALPHA; if (i === r.HIg) return e.RGB; if (i === r.GWd) return e.RGBA; if (i === r.Kzv) return e.LUMINANCE; if (i === r.CMB) return e.LUMINANCE_ALPHA; if (i === r.zdS) return e.DEPTH_COMPONENT; if (i === r.dcC) return e.DEPTH_STENCIL; if (i === r.VT0) return e.RED; if (i === r.ZQM) return e.RED_INTEGER; if (i === r.paN) return e.RG; if (i === r.TkQ) return e.RG_INTEGER; if (i === r.c90) return e.RGBA_INTEGER; if (i === r.IE4 || i === r.Nz6 || i === r.jR7 || i === r.BXX) { if (a === r.KLL) { if (null === (s = t.get("WEBGL_compressed_texture_s3tc_srgb"))) return null; if (i === r.IE4) return s.COMPRESSED_SRGB_S3TC_DXT1_EXT; if (i === r.Nz6) return s.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT; if (i === r.jR7) return s.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT; if (i === r.BXX) return s.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT } else { if (null === (s = t.get("WEBGL_compressed_texture_s3tc"))) return null; if (i === r.IE4) return s.COMPRESSED_RGB_S3TC_DXT1_EXT; if (i === r.Nz6) return s.COMPRESSED_RGBA_S3TC_DXT1_EXT; if (i === r.jR7) return s.COMPRESSED_RGBA_S3TC_DXT3_EXT; if (i === r.BXX) return s.COMPRESSED_RGBA_S3TC_DXT5_EXT } } if (i === r.k6Q || i === r.kTp || i === r.HXV || i === r.pBf) { if (null === (s = t.get("WEBGL_compressed_texture_pvrtc"))) return null; if (i === r.k6Q) return s.COMPRESSED_RGB_PVRTC_4BPPV1_IMG; if (i === r.kTp) return s.COMPRESSED_RGB_PVRTC_2BPPV1_IMG; if (i === r.HXV) return s.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG; if (i === r.pBf) return s.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG } if (i === r.CVz || i === r.Riy || i === r.KDk) { if (null === (s = t.get("WEBGL_compressed_texture_etc"))) return null; if (i === r.CVz || i === r.Riy) return a === r.KLL ? s.COMPRESSED_SRGB8_ETC2 : s.COMPRESSED_RGB8_ETC2; if (i === r.KDk) return a === r.KLL ? s.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : s.COMPRESSED_RGBA8_ETC2_EAC } if (i === r.qa3 || i === r.B_h || i === r.czI || i === r.rSH || i === r.Qrf || i === r.psI || i === r.a5J || i === r._QJ || i === r.uB5 || i === r.lyL || i === r.bC7 || i === r.y3Z || i === r.ojs || i === r.S$4) { if (null === (s = t.get("WEBGL_compressed_texture_astc"))) return null; if (i === r.qa3) return a === r.KLL ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : s.COMPRESSED_RGBA_ASTC_4x4_KHR; if (i === r.B_h) return a === r.KLL ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : s.COMPRESSED_RGBA_ASTC_5x4_KHR; if (i === r.czI) return a === r.KLL ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : s.COMPRESSED_RGBA_ASTC_5x5_KHR; if (i === r.rSH) return a === r.KLL ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : s.COMPRESSED_RGBA_ASTC_6x5_KHR; if (i === r.Qrf) return a === r.KLL ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : s.COMPRESSED_RGBA_ASTC_6x6_KHR; if (i === r.psI) return a === r.KLL ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : s.COMPRESSED_RGBA_ASTC_8x5_KHR; if (i === r.a5J) return a === r.KLL ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : s.COMPRESSED_RGBA_ASTC_8x6_KHR; if (i === r._QJ) return a === r.KLL ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : s.COMPRESSED_RGBA_ASTC_8x8_KHR; if (i === r.uB5) return a === r.KLL ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : s.COMPRESSED_RGBA_ASTC_10x5_KHR; if (i === r.lyL) return a === r.KLL ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : s.COMPRESSED_RGBA_ASTC_10x6_KHR; if (i === r.bC7) return a === r.KLL ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : s.COMPRESSED_RGBA_ASTC_10x8_KHR; if (i === r.y3Z) return a === r.KLL ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : s.COMPRESSED_RGBA_ASTC_10x10_KHR; if (i === r.ojs) return a === r.KLL ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : s.COMPRESSED_RGBA_ASTC_12x10_KHR; if (i === r.S$4) return a === r.KLL ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : s.COMPRESSED_RGBA_ASTC_12x12_KHR } if (i === r.Fn || i === r.H23 || i === r.W9U) { if (null === (s = t.get("EXT_texture_compression_bptc"))) return null; if (i === r.Fn) return a === r.KLL ? s.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : s.COMPRESSED_RGBA_BPTC_UNORM_EXT; if (i === r.H23) return s.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT; if (i === r.W9U) return s.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT } if (i === r.Kef || i === r.XG_ || i === r.HO_ || i === r.CWW) { if (null === (s = t.get("EXT_texture_compression_rgtc"))) return null; if (i === r.Fn) return s.COMPRESSED_RED_RGTC1_EXT; if (i === r.XG_) return s.COMPRESSED_SIGNED_RED_RGTC1_EXT; if (i === r.HO_) return s.COMPRESSED_RED_GREEN_RGTC2_EXT; if (i === r.CWW) return s.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT } return i === r.V3x ? e.UNSIGNED_INT_24_8 : void 0 !== e[i] ? e[i] : null } } } let tx = `
void main() {

	gl_Position = vec4( position, 1.0 );

}`, tS = `
uniform sampler2DArray depthColor;
uniform float depthWidth;
uniform float depthHeight;

void main() {

	vec2 coord = vec2( gl_FragCoord.x / depthWidth, gl_FragCoord.y / depthHeight );

	if ( coord.x >= 1.0 ) {

		gl_FragDepth = texture( depthColor, vec3( coord.x - 1.0, coord.y, 1 ) ).r;

	} else {

		gl_FragDepth = texture( depthColor, vec3( coord.x, coord.y, 0 ) ).r;

	}

}`; class tA { constructor() { this.texture = null, this.mesh = null, this.depthNear = 0, this.depthFar = 0 } init(e, t, i) { if (null === this.texture) { let n = new r.gPd; e.properties.get(n).__webglTexture = t.texture, (t.depthNear !== i.depthNear || t.depthFar !== i.depthFar) && (this.depthNear = t.depthNear, this.depthFar = t.depthFar), this.texture = n } } getMesh(e) { if (null !== this.texture && null === this.mesh) { let t = e.cameras[0].viewport, i = new r.BKk({ vertexShader: tx, fragmentShader: tS, uniforms: { depthColor: { value: this.texture }, depthWidth: { value: t.z }, depthHeight: { value: t.w } } }); this.mesh = new r.eaF(new r.bdM(20, 20), i) } return this.mesh } reset() { this.texture = null, this.mesh = null } getDepthTexture() { return this.texture } } class t_ extends r.Qev { constructor(e, t) { super(); let i = this, s = null, a = 1, o = null, l = "local-floor", u = 1, h = null, c = null, d = null, f = null, p = null, m = null, g = new tA, v = t.getContextAttributes(), y = null, x = null, S = [], A = [], _ = new r.I9Y, E = null, b = new r.ubm; b.viewport = new r.IUQ; let T = new r.ubm; T.viewport = new r.IUQ; let w = [b, T], M = new r.nZQ, R = null, C = null; function I(e) { let t = A.indexOf(e.inputSource); if (-1 === t) return; let i = S[t]; void 0 !== i && (i.update(e.inputSource, e.frame, h || o), i.dispatchEvent({ type: e.type, data: e.inputSource })) } function L() { s.removeEventListener("select", I), s.removeEventListener("selectstart", I), s.removeEventListener("selectend", I), s.removeEventListener("squeeze", I), s.removeEventListener("squeezestart", I), s.removeEventListener("squeezeend", I), s.removeEventListener("end", L), s.removeEventListener("inputsourceschange", P); for (let e = 0; e < S.length; e++) { let t = A[e]; null !== t && (A[e] = null, S[e].disconnect(t)) } R = null, C = null, g.reset(), e.setRenderTarget(y), p = null, f = null, d = null, s = null, x = null, U.stop(), i.isPresenting = !1, e.setPixelRatio(E), e.setSize(_.width, _.height, !1), i.dispatchEvent({ type: "sessionend" }) } function P(e) { for (let t = 0; t < e.removed.length; t++) { let i = e.removed[t], r = A.indexOf(i); r >= 0 && (A[r] = null, S[r].disconnect(i)) } for (let t = 0; t < e.added.length; t++) { let i = e.added[t], r = A.indexOf(i); if (-1 === r) { for (let e = 0; e < S.length; e++) { if (e >= A.length) { A.push(i), r = e; break } if (null === A[e]) { A[e] = i, r = e; break } } if (-1 === r) break } let n = S[r]; n && n.connect(i) } } this.cameraAutoUpdate = !0, this.enabled = !1, this.isPresenting = !1, this.getController = function (e) { let t = S[e]; return void 0 === t && (t = new r.R3r, S[e] = t), t.getTargetRaySpace() }, this.getControllerGrip = function (e) { let t = S[e]; return void 0 === t && (t = new r.R3r, S[e] = t), t.getGripSpace() }, this.getHand = function (e) { let t = S[e]; return void 0 === t && (t = new r.R3r, S[e] = t), t.getHandSpace() }, this.setFramebufferScaleFactor = function (e) { a = e, !0 === i.isPresenting && console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.") }, this.setReferenceSpaceType = function (e) { l = e, !0 === i.isPresenting && console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.") }, this.getReferenceSpace = function () { return h || o }, this.setReferenceSpace = function (e) { h = e }, this.getBaseLayer = function () { return null !== f ? f : p }, this.getBinding = function () { return d }, this.getFrame = function () { return m }, this.getSession = function () { return s }, this.setSession = async function (n) { if (null !== (s = n)) { if (y = e.getRenderTarget(), s.addEventListener("select", I), s.addEventListener("selectstart", I), s.addEventListener("selectend", I), s.addEventListener("squeeze", I), s.addEventListener("squeezestart", I), s.addEventListener("squeezeend", I), s.addEventListener("end", L), s.addEventListener("inputsourceschange", P), !0 !== v.xrCompatible && await t.makeXRCompatible(), E = e.getPixelRatio(), e.getSize(_), "undefined" != typeof XRWebGLBinding && "createProjectionLayer" in XRWebGLBinding.prototype) { let i = null, n = null, o = null; v.depth && (o = v.stencil ? t.DEPTH24_STENCIL8 : t.DEPTH_COMPONENT24, i = v.stencil ? r.dcC : r.zdS, n = v.stencil ? r.V3x : r.bkx); let l = { colorFormat: t.RGBA8, depthFormat: o, scaleFactor: a }; f = (d = new XRWebGLBinding(s, t)).createProjectionLayer(l), s.updateRenderState({ layers: [f] }), e.setPixelRatio(1), e.setSize(f.textureWidth, f.textureHeight, !1), x = new r.nWS(f.textureWidth, f.textureHeight, { format: r.GWd, type: r.OUM, depthTexture: new r.VCu(f.textureWidth, f.textureHeight, n, void 0, void 0, void 0, void 0, void 0, void 0, i), stencilBuffer: v.stencil, colorSpace: e.outputColorSpace, samples: v.antialias ? 4 : 0, resolveDepthBuffer: !1 === f.ignoreDepthValues, resolveStencilBuffer: !1 === f.ignoreDepthValues }) } else { let i = { antialias: v.antialias, alpha: !0, depth: v.depth, stencil: v.stencil, framebufferScaleFactor: a }; p = new XRWebGLLayer(s, t, i), s.updateRenderState({ baseLayer: p }), e.setPixelRatio(1), e.setSize(p.framebufferWidth, p.framebufferHeight, !1), x = new r.nWS(p.framebufferWidth, p.framebufferHeight, { format: r.GWd, type: r.OUM, colorSpace: e.outputColorSpace, stencilBuffer: v.stencil, resolveDepthBuffer: !1 === p.ignoreDepthValues, resolveStencilBuffer: !1 === p.ignoreDepthValues }) } x.isXRRenderTarget = !0, this.setFoveation(u), h = null, o = await s.requestReferenceSpace(l), U.setContext(s), U.start(), i.isPresenting = !0, i.dispatchEvent({ type: "sessionstart" }) } }, this.getEnvironmentBlendMode = function () { if (null !== s) return s.environmentBlendMode }, this.getDepthTexture = function () { return g.getDepthTexture() }; let D = new r.Pq0, O = new r.Pq0; function k(e, t) { null === t ? e.matrixWorld.copy(e.matrix) : e.matrixWorld.multiplyMatrices(t.matrixWorld, e.matrix), e.matrixWorldInverse.copy(e.matrixWorld).invert() } this.updateCamera = function (e) { if (null === s) return; let t = e.near, i = e.far; null !== g.texture && (g.depthNear > 0 && (t = g.depthNear), g.depthFar > 0 && (i = g.depthFar)), M.near = T.near = b.near = t, M.far = T.far = b.far = i, (R !== M.near || C !== M.far) && (s.updateRenderState({ depthNear: M.near, depthFar: M.far }), R = M.near, C = M.far), b.layers.mask = 2 | e.layers.mask, T.layers.mask = 4 | e.layers.mask, M.layers.mask = b.layers.mask | T.layers.mask; let n = e.parent, a = M.cameras; k(M, n); for (let e = 0; e < a.length; e++)k(a[e], n); 2 === a.length ? function (e, t, i) { D.setFromMatrixPosition(t.matrixWorld), O.setFromMatrixPosition(i.matrixWorld); let r = D.distanceTo(O), n = t.projectionMatrix.elements, s = i.projectionMatrix.elements, a = n[14] / (n[10] - 1), o = n[14] / (n[10] + 1), l = (n[9] + 1) / n[5], u = (n[9] - 1) / n[5], h = (n[8] - 1) / n[0], c = (s[8] + 1) / s[0], d = r / (-h + c), f = -(d * h); if (t.matrixWorld.decompose(e.position, e.quaternion, e.scale), e.translateX(f), e.translateZ(d), e.matrixWorld.compose(e.position, e.quaternion, e.scale), e.matrixWorldInverse.copy(e.matrixWorld).invert(), -1 === n[10]) e.projectionMatrix.copy(t.projectionMatrix), e.projectionMatrixInverse.copy(t.projectionMatrixInverse); else { let t = a + d, i = o + d; e.projectionMatrix.makePerspective(a * h - f, a * c + (r - f), l * o / i * t, u * o / i * t, t, i), e.projectionMatrixInverse.copy(e.projectionMatrix).invert() } }(M, b, T) : M.projectionMatrix.copy(b.projectionMatrix), null === n ? e.matrix.copy(M.matrixWorld) : (e.matrix.copy(n.matrixWorld), e.matrix.invert(), e.matrix.multiply(M.matrixWorld)), e.matrix.decompose(e.position, e.quaternion, e.scale), e.updateMatrixWorld(!0), e.projectionMatrix.copy(M.projectionMatrix), e.projectionMatrixInverse.copy(M.projectionMatrixInverse), e.isPerspectiveCamera && (e.fov = 2 * r.a55 * Math.atan(1 / e.projectionMatrix.elements[5]), e.zoom = 1) }, this.getCamera = function () { return M }, this.getFoveation = function () { if (null !== f || null !== p) return u }, this.setFoveation = function (e) { u = e, null !== f && (f.fixedFoveation = e), null !== p && void 0 !== p.fixedFoveation && (p.fixedFoveation = e) }, this.hasDepthSensing = function () { return null !== g.texture }, this.getDepthSensingMesh = function () { return g.getMesh(M) }; let F = null, U = new n; U.setAnimationLoop(function (t, n) { if (c = n.getViewerPose(h || o), m = n, null !== c) { let t = c.views; null !== p && (e.setRenderTargetFramebuffer(x, p.framebuffer), e.setRenderTarget(x)); let i = !1; t.length !== M.cameras.length && (M.cameras.length = 0, i = !0); for (let n = 0; n < t.length; n++) { let s = t[n], a = null; if (null !== p) a = p.getViewport(s); else { let t = d.getViewSubImage(f, s); a = t.viewport, 0 === n && (e.setRenderTargetTextures(x, t.colorTexture, f.ignoreDepthValues ? void 0 : t.depthStencilTexture), e.setRenderTarget(x)) } let o = w[n]; void 0 === o && ((o = new r.ubm).layers.enable(n), o.viewport = new r.IUQ, w[n] = o), o.matrix.fromArray(s.transform.matrix), o.matrix.decompose(o.position, o.quaternion, o.scale), o.projectionMatrix.fromArray(s.projectionMatrix), o.projectionMatrixInverse.copy(o.projectionMatrix).invert(), o.viewport.set(a.x, a.y, a.width, a.height), 0 === n && (M.matrix.copy(o.matrix), M.matrix.decompose(M.position, M.quaternion, M.scale)), !0 === i && M.cameras.push(o) } let n = s.enabledFeatures; if (n && n.includes("depth-sensing") && "gpu-optimized" == s.depthUsage && d) { let i = d.getDepthInformation(t[0]); i && i.isValid && i.texture && g.init(e, i, s.renderState) } } for (let e = 0; e < S.length; e++) { let t = A[e], i = S[e]; null !== t && void 0 !== i && i.update(t, n, h || o) } F && F(t, n), n.detectedPlanes && i.dispatchEvent({ type: "planesdetected", data: n }), m = null }), this.setAnimationLoop = function (e) { F = e }, this.dispose = function () { } } } let tE = new r.O9p, tb = new r.kn4; function tT(e, t) { function i(e, t) { !0 === e.matrixAutoUpdate && e.updateMatrix(), t.value.copy(e.matrix) } function n(e, n) { e.opacity.value = n.opacity, n.color && e.diffuse.value.copy(n.color), n.emissive && e.emissive.value.copy(n.emissive).multiplyScalar(n.emissiveIntensity), n.map && (e.map.value = n.map, i(n.map, e.mapTransform)), n.alphaMap && (e.alphaMap.value = n.alphaMap, i(n.alphaMap, e.alphaMapTransform)), n.bumpMap && (e.bumpMap.value = n.bumpMap, i(n.bumpMap, e.bumpMapTransform), e.bumpScale.value = n.bumpScale, n.side === r.hsX && (e.bumpScale.value *= -1)), n.normalMap && (e.normalMap.value = n.normalMap, i(n.normalMap, e.normalMapTransform), e.normalScale.value.copy(n.normalScale), n.side === r.hsX && e.normalScale.value.negate()), n.displacementMap && (e.displacementMap.value = n.displacementMap, i(n.displacementMap, e.displacementMapTransform), e.displacementScale.value = n.displacementScale, e.displacementBias.value = n.displacementBias), n.emissiveMap && (e.emissiveMap.value = n.emissiveMap, i(n.emissiveMap, e.emissiveMapTransform)), n.specularMap && (e.specularMap.value = n.specularMap, i(n.specularMap, e.specularMapTransform)), n.alphaTest > 0 && (e.alphaTest.value = n.alphaTest); let s = t.get(n), a = s.envMap, o = s.envMapRotation; a && (e.envMap.value = a, tE.copy(o), tE.x *= -1, tE.y *= -1, tE.z *= -1, a.isCubeTexture && !1 === a.isRenderTargetTexture && (tE.y *= -1, tE.z *= -1), e.envMapRotation.value.setFromMatrix4(tb.makeRotationFromEuler(tE)), e.flipEnvMap.value = a.isCubeTexture && !1 === a.isRenderTargetTexture ? -1 : 1, e.reflectivity.value = n.reflectivity, e.ior.value = n.ior, e.refractionRatio.value = n.refractionRatio), n.lightMap && (e.lightMap.value = n.lightMap, e.lightMapIntensity.value = n.lightMapIntensity, i(n.lightMap, e.lightMapTransform)), n.aoMap && (e.aoMap.value = n.aoMap, e.aoMapIntensity.value = n.aoMapIntensity, i(n.aoMap, e.aoMapTransform)) } return { refreshFogUniforms: function (t, i) { i.color.getRGB(t.fogColor.value, (0, r._Ut)(e)), i.isFog ? (t.fogNear.value = i.near, t.fogFar.value = i.far) : i.isFogExp2 && (t.fogDensity.value = i.density) }, refreshMaterialUniforms: function (e, s, a, o, l) { s.isMeshBasicMaterial ? n(e, s) : s.isMeshLambertMaterial ? n(e, s) : s.isMeshToonMaterial ? (n(e, s), s.gradientMap && (e.gradientMap.value = s.gradientMap)) : s.isMeshPhongMaterial ? (n(e, s), e.specular.value.copy(s.specular), e.shininess.value = Math.max(s.shininess, 1e-4)) : s.isMeshStandardMaterial ? (n(e, s), e.metalness.value = s.metalness, s.metalnessMap && (e.metalnessMap.value = s.metalnessMap, i(s.metalnessMap, e.metalnessMapTransform)), e.roughness.value = s.roughness, s.roughnessMap && (e.roughnessMap.value = s.roughnessMap, i(s.roughnessMap, e.roughnessMapTransform)), s.envMap && (e.envMapIntensity.value = s.envMapIntensity), s.isMeshPhysicalMaterial && (e.ior.value = s.ior, s.sheen > 0 && (e.sheenColor.value.copy(s.sheenColor).multiplyScalar(s.sheen), e.sheenRoughness.value = s.sheenRoughness, s.sheenColorMap && (e.sheenColorMap.value = s.sheenColorMap, i(s.sheenColorMap, e.sheenColorMapTransform)), s.sheenRoughnessMap && (e.sheenRoughnessMap.value = s.sheenRoughnessMap, i(s.sheenRoughnessMap, e.sheenRoughnessMapTransform))), s.clearcoat > 0 && (e.clearcoat.value = s.clearcoat, e.clearcoatRoughness.value = s.clearcoatRoughness, s.clearcoatMap && (e.clearcoatMap.value = s.clearcoatMap, i(s.clearcoatMap, e.clearcoatMapTransform)), s.clearcoatRoughnessMap && (e.clearcoatRoughnessMap.value = s.clearcoatRoughnessMap, i(s.clearcoatRoughnessMap, e.clearcoatRoughnessMapTransform)), s.clearcoatNormalMap && (e.clearcoatNormalMap.value = s.clearcoatNormalMap, i(s.clearcoatNormalMap, e.clearcoatNormalMapTransform), e.clearcoatNormalScale.value.copy(s.clearcoatNormalScale), s.side === r.hsX && e.clearcoatNormalScale.value.negate())), s.dispersion > 0 && (e.dispersion.value = s.dispersion), s.iridescence > 0 && (e.iridescence.value = s.iridescence, e.iridescenceIOR.value = s.iridescenceIOR, e.iridescenceThicknessMinimum.value = s.iridescenceThicknessRange[0], e.iridescenceThicknessMaximum.value = s.iridescenceThicknessRange[1], s.iridescenceMap && (e.iridescenceMap.value = s.iridescenceMap, i(s.iridescenceMap, e.iridescenceMapTransform)), s.iridescenceThicknessMap && (e.iridescenceThicknessMap.value = s.iridescenceThicknessMap, i(s.iridescenceThicknessMap, e.iridescenceThicknessMapTransform))), s.transmission > 0 && (e.transmission.value = s.transmission, e.transmissionSamplerMap.value = l.texture, e.transmissionSamplerSize.value.set(l.width, l.height), s.transmissionMap && (e.transmissionMap.value = s.transmissionMap, i(s.transmissionMap, e.transmissionMapTransform)), e.thickness.value = s.thickness, s.thicknessMap && (e.thicknessMap.value = s.thicknessMap, i(s.thicknessMap, e.thicknessMapTransform)), e.attenuationDistance.value = s.attenuationDistance, e.attenuationColor.value.copy(s.attenuationColor)), s.anisotropy > 0 && (e.anisotropyVector.value.set(s.anisotropy * Math.cos(s.anisotropyRotation), s.anisotropy * Math.sin(s.anisotropyRotation)), s.anisotropyMap && (e.anisotropyMap.value = s.anisotropyMap, i(s.anisotropyMap, e.anisotropyMapTransform))), e.specularIntensity.value = s.specularIntensity, e.specularColor.value.copy(s.specularColor), s.specularColorMap && (e.specularColorMap.value = s.specularColorMap, i(s.specularColorMap, e.specularColorMapTransform)), s.specularIntensityMap && (e.specularIntensityMap.value = s.specularIntensityMap, i(s.specularIntensityMap, e.specularIntensityMapTransform)))) : s.isMeshMatcapMaterial ? (n(e, s), s.matcap && (e.matcap.value = s.matcap)) : s.isMeshDepthMaterial ? n(e, s) : s.isMeshDistanceMaterial ? (n(e, s), function (e, i) { let r = t.get(i).light; e.referencePosition.value.setFromMatrixPosition(r.matrixWorld), e.nearDistance.value = r.shadow.camera.near, e.farDistance.value = r.shadow.camera.far }(e, s)) : s.isMeshNormalMaterial ? n(e, s) : s.isLineBasicMaterial ? (e.diffuse.value.copy(s.color), e.opacity.value = s.opacity, s.map && (e.map.value = s.map, i(s.map, e.mapTransform)), s.isLineDashedMaterial && (e.dashSize.value = s.dashSize, e.totalSize.value = s.dashSize + s.gapSize, e.scale.value = s.scale)) : s.isPointsMaterial ? (e.diffuse.value.copy(s.color), e.opacity.value = s.opacity, e.size.value = s.size * a, e.scale.value = .5 * o, s.map && (e.map.value = s.map, i(s.map, e.uvTransform)), s.alphaMap && (e.alphaMap.value = s.alphaMap, i(s.alphaMap, e.alphaMapTransform)), s.alphaTest > 0 && (e.alphaTest.value = s.alphaTest)) : s.isSpriteMaterial ? (e.diffuse.value.copy(s.color), e.opacity.value = s.opacity, e.rotation.value = s.rotation, s.map && (e.map.value = s.map, i(s.map, e.mapTransform)), s.alphaMap && (e.alphaMap.value = s.alphaMap, i(s.alphaMap, e.alphaMapTransform)), s.alphaTest > 0 && (e.alphaTest.value = s.alphaTest)) : s.isShadowMaterial ? (e.color.value.copy(s.color), e.opacity.value = s.opacity) : s.isShaderMaterial && (s.uniformsNeedUpdate = !1) } } } function tw(e, t, i, r) { let n = {}, s = {}, a = [], o = e.getParameter(e.MAX_UNIFORM_BUFFER_BINDINGS); function l(e) { let t = { boundary: 0, storage: 0 }; return "number" == typeof e || "boolean" == typeof e ? (t.boundary = 4, t.storage = 4) : e.isVector2 ? (t.boundary = 8, t.storage = 8) : e.isVector3 || e.isColor ? (t.boundary = 16, t.storage = 12) : e.isVector4 ? (t.boundary = 16, t.storage = 16) : e.isMatrix3 ? (t.boundary = 48, t.storage = 48) : e.isMatrix4 ? (t.boundary = 64, t.storage = 64) : e.isTexture ? console.warn("THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group.") : console.warn("THREE.WebGLRenderer: Unsupported uniform value type.", e), t } function u(t) { let i = t.target; i.removeEventListener("dispose", u); let r = a.indexOf(i.__bindingPointIndex); a.splice(r, 1), e.deleteBuffer(n[i.id]), delete n[i.id], delete s[i.id] } return { bind: function (e, t) { let i = t.program; r.uniformBlockBinding(e, i) }, update: function (i, h) { let c = n[i.id]; void 0 === c && (function (e) { let t = e.uniforms, i = 0; for (let e = 0, r = t.length; e < r; e++) { let r = Array.isArray(t[e]) ? t[e] : [t[e]]; for (let e = 0, t = r.length; e < t; e++) { let t = r[e], n = Array.isArray(t.value) ? t.value : [t.value]; for (let e = 0, r = n.length; e < r; e++) { let r = l(n[e]), s = i % 16, a = s % r.boundary, o = s + a; i += a, 0 !== o && 16 - o < r.storage && (i += 16 - o), t.__data = new Float32Array(r.storage / Float32Array.BYTES_PER_ELEMENT), t.__offset = i, i += r.storage } } } let r = i % 16; r > 0 && (i += 16 - r), e.__size = i, e.__cache = {} }(i), c = function (t) { let i = function () { for (let e = 0; e < o; e++)if (-1 === a.indexOf(e)) return a.push(e), e; return console.error("THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."), 0 }(); t.__bindingPointIndex = i; let r = e.createBuffer(), n = t.__size, s = t.usage; return e.bindBuffer(e.UNIFORM_BUFFER, r), e.bufferData(e.UNIFORM_BUFFER, n, s), e.bindBuffer(e.UNIFORM_BUFFER, null), e.bindBufferBase(e.UNIFORM_BUFFER, i, r), r }(i), n[i.id] = c, i.addEventListener("dispose", u)); let d = h.program; r.updateUBOMapping(i, d); let f = t.render.frame; s[i.id] !== f && (function (t) { let i = n[t.id], r = t.uniforms, s = t.__cache; e.bindBuffer(e.UNIFORM_BUFFER, i); for (let t = 0, i = r.length; t < i; t++) { let i = Array.isArray(r[t]) ? r[t] : [r[t]]; for (let r = 0, n = i.length; r < n; r++) { let n = i[r]; if (!0 === function (e, t, i, r) { let n = e.value, s = t + "_" + i; if (void 0 === r[s]) return "number" == typeof n || "boolean" == typeof n ? r[s] = n : r[s] = n.clone(), !0; { let e = r[s]; if ("number" == typeof n || "boolean" == typeof n) { if (e !== n) return r[s] = n, !0 } else if (!1 === e.equals(n)) return e.copy(n), !0 } return !1 }(n, t, r, s)) { let t = n.__offset, i = Array.isArray(n.value) ? n.value : [n.value], r = 0; for (let s = 0; s < i.length; s++) { let a = i[s], o = l(a); "number" == typeof a || "boolean" == typeof a ? (n.__data[0] = a, e.bufferSubData(e.UNIFORM_BUFFER, t + r, n.__data)) : a.isMatrix3 ? (n.__data[0] = a.elements[0], n.__data[1] = a.elements[1], n.__data[2] = a.elements[2], n.__data[3] = 0, n.__data[4] = a.elements[3], n.__data[5] = a.elements[4], n.__data[6] = a.elements[5], n.__data[7] = 0, n.__data[8] = a.elements[6], n.__data[9] = a.elements[7], n.__data[10] = a.elements[8], n.__data[11] = 0) : (a.toArray(n.__data, r), r += o.storage / Float32Array.BYTES_PER_ELEMENT) } e.bufferSubData(e.UNIFORM_BUFFER, t, n.__data) } } } e.bindBuffer(e.UNIFORM_BUFFER, null) }(i), s[i.id] = f) }, dispose: function () { for (let t in n) e.deleteBuffer(n[t]); a = [], n = {}, s = {} } } } class tM { constructor(e = {}) { let t, i, a, o, l, u, h, c, y, x, S, A, _, E, b, T, w, M, R, C, I, L, P, D, O; let { canvas: H = (0, r.lPF)(), context: V = null, depth: W = !0, stencil: j = !1, alpha: Y = !1, antialias: X = !1, premultipliedAlpha: K = !0, preserveDrawingBuffer: q = !1, powerPreference: Q = "default", failIfMajorPerformanceCaveat: Z = !1, reverseDepthBuffer: $ = !1 } = e; if (this.isWebGLRenderer = !0, null !== V) { if ("undefined" != typeof WebGLRenderingContext && V instanceof WebGLRenderingContext) throw Error("THREE.WebGLRenderer: WebGL 1 is not supported since r163."); t = V.getContextAttributes().alpha } else t = Y; let J = new Uint32Array(4), ee = new Int32Array(4), et = null, ei = null, er = [], en = []; this.domElement = H, this.debug = { checkShaderErrors: !0, onShaderError: null }, this.autoClear = !0, this.autoClearColor = !0, this.autoClearDepth = !0, this.autoClearStencil = !0, this.sortObjects = !0, this.clippingPlanes = [], this.localClippingEnabled = !1, this._outputColorSpace = r.er$, this.toneMapping = r.y_p, this.toneMappingExposure = 1; let es = this, ea = !1, eo = 0, el = 0, eu = null, eh = -1, ec = null, ed = new r.IUQ, ef = new r.IUQ, ep = null, em = new r.Q1f(0), eg = 0, ev = H.width, ey = H.height, ex = 1, eS = null, eA = null, e_ = new r.IUQ(0, 0, ev, ey), eE = new r.IUQ(0, 0, ev, ey), eb = !1, eT = new r.PPD, ew = !1, eM = !1; this.transmissionResolutionScale = 1; let eR = new r.kn4, eC = new r.kn4, eI = new r.Pq0, eL = new r.IUQ, eP = { background: null, fog: null, environment: null, overrideMaterial: null, isScene: !0 }, eD = !1; function eO() { return null === eu ? ex : 1 } let ek = V; function eF(e, t) { return H.getContext(e, t) } try { if ("setAttribute" in H && H.setAttribute("data-engine", `three.js r${r.sPf}`), H.addEventListener("webglcontextlost", eB, !1), H.addEventListener("webglcontextrestored", ez, !1), H.addEventListener("webglcontextcreationerror", eG, !1), null === ek) { let e = "webgl2"; if (ek = eF(e, { alpha: !0, depth: W, stencil: j, antialias: X, premultipliedAlpha: K, preserveDrawingBuffer: q, powerPreference: Q, failIfMajorPerformanceCaveat: Z }), null === ek) { if (eF(e)) throw Error("Error creating WebGL context with your selected attributes."); throw Error("Error creating WebGL context.") } } } catch (e) { throw console.error("THREE.WebGLRenderer: " + e.message), e } function eU() { (i = new F(ek)).init(), P = new ty(ek, i), a = new m(ek, i, e, P), o = new tg(ek, i), a.reverseDepthBuffer && $ && o.buffers.depth.setReversed(!0), l = new B(ek), u = new tr, h = new tv(ek, i, o, u, a, P, l), c = new v(es), y = new k(es), x = new s(ek), D = new f(ek, x), S = new U(ek, x, l, D), A = new G(ek, S, x, l), C = new z(ek, a, h), w = new g(u), _ = new ti(es, c, y, i, a, D, w), E = new tT(es, u), b = new to, T = new tf(i), R = new d(es, c, y, o, A, t, K), M = new tp(es, A, a), O = new tw(ek, l, a, o), I = new p(ek, i, l), L = new N(ek, i, l), l.programs = _.programs, es.capabilities = a, es.extensions = i, es.properties = u, es.renderLists = b, es.shadowMap = M, es.state = o, es.info = l } eU(); let eN = new t_(es, ek); function eB(e) { e.preventDefault(), console.log("THREE.WebGLRenderer: Context Lost."), ea = !0 } function ez() { console.log("THREE.WebGLRenderer: Context Restored."), ea = !1; let e = l.autoReset, t = M.enabled, i = M.autoUpdate, r = M.needsUpdate, n = M.type; eU(), l.autoReset = e, M.enabled = t, M.autoUpdate = i, M.needsUpdate = r, M.type = n } function eG(e) { console.error("THREE.WebGLRenderer: A WebGL context could not be created. Reason: ", e.statusMessage) } function eH(e) { let t = e.target; t.removeEventListener("dispose", eH), function (e) { let t = u.get(e).programs; void 0 !== t && (t.forEach(function (e) { _.releaseProgram(e) }), e.isShaderMaterial && _.releaseShaderCache(e)) }(t), u.remove(t) } function eV(e, t, i) { !0 === e.transparent && e.side === r.$EB && !1 === e.forceSinglePass ? (e.side = r.hsX, e.needsUpdate = !0, e0(e, t, i), e.side = r.hB5, e.needsUpdate = !0, e0(e, t, i), e.side = r.$EB) : e0(e, t, i) } this.xr = eN, this.getContext = function () { return ek }, this.getContextAttributes = function () { return ek.getContextAttributes() }, this.forceContextLoss = function () { let e = i.get("WEBGL_lose_context"); e && e.loseContext() }, this.forceContextRestore = function () { let e = i.get("WEBGL_lose_context"); e && e.restoreContext() }, this.getPixelRatio = function () { return ex }, this.setPixelRatio = function (e) { void 0 !== e && (ex = e, this.setSize(ev, ey, !1)) }, this.getSize = function (e) { return e.set(ev, ey) }, this.setSize = function (e, t, i = !0) { if (eN.isPresenting) { console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting."); return } ev = e, ey = t, H.width = Math.floor(e * ex), H.height = Math.floor(t * ex), !0 === i && (H.style.width = e + "px", H.style.height = t + "px"), this.setViewport(0, 0, e, t) }, this.getDrawingBufferSize = function (e) { return e.set(ev * ex, ey * ex).floor() }, this.setDrawingBufferSize = function (e, t, i) { ev = e, ey = t, ex = i, H.width = Math.floor(e * i), H.height = Math.floor(t * i), this.setViewport(0, 0, e, t) }, this.getCurrentViewport = function (e) { return e.copy(ed) }, this.getViewport = function (e) { return e.copy(e_) }, this.setViewport = function (e, t, i, r) { e.isVector4 ? e_.set(e.x, e.y, e.z, e.w) : e_.set(e, t, i, r), o.viewport(ed.copy(e_).multiplyScalar(ex).round()) }, this.getScissor = function (e) { return e.copy(eE) }, this.setScissor = function (e, t, i, r) { e.isVector4 ? eE.set(e.x, e.y, e.z, e.w) : eE.set(e, t, i, r), o.scissor(ef.copy(eE).multiplyScalar(ex).round()) }, this.getScissorTest = function () { return eb }, this.setScissorTest = function (e) { o.setScissorTest(eb = e) }, this.setOpaqueSort = function (e) { eS = e }, this.setTransparentSort = function (e) { eA = e }, this.getClearColor = function (e) { return e.copy(R.getClearColor()) }, this.setClearColor = function () { R.setClearColor(...arguments) }, this.getClearAlpha = function () { return R.getClearAlpha() }, this.setClearAlpha = function () { R.setClearAlpha(...arguments) }, this.clear = function (e = !0, t = !0, i = !0) { let n = 0; if (e) { let e = !1; if (null !== eu) { let t = eu.texture.format; e = t === r.c90 || t === r.TkQ || t === r.ZQM } if (e) { let e = eu.texture.type, t = e === r.OUM || e === r.bkx || e === r.cHt || e === r.V3x || e === r.Wew || e === r.gJ2, i = R.getClearColor(), n = R.getClearAlpha(), s = i.r, a = i.g, o = i.b; t ? (J[0] = s, J[1] = a, J[2] = o, J[3] = n, ek.clearBufferuiv(ek.COLOR, 0, J)) : (ee[0] = s, ee[1] = a, ee[2] = o, ee[3] = n, ek.clearBufferiv(ek.COLOR, 0, ee)) } else n |= ek.COLOR_BUFFER_BIT } t && (n |= ek.DEPTH_BUFFER_BIT), i && (n |= ek.STENCIL_BUFFER_BIT, this.state.buffers.stencil.setMask(0xffffffff)), ek.clear(n) }, this.clearColor = function () { this.clear(!0, !1, !1) }, this.clearDepth = function () { this.clear(!1, !0, !1) }, this.clearStencil = function () { this.clear(!1, !1, !0) }, this.dispose = function () { H.removeEventListener("webglcontextlost", eB, !1), H.removeEventListener("webglcontextrestored", ez, !1), H.removeEventListener("webglcontextcreationerror", eG, !1), R.dispose(), b.dispose(), T.dispose(), u.dispose(), c.dispose(), y.dispose(), A.dispose(), D.dispose(), O.dispose(), _.dispose(), eN.dispose(), eN.removeEventListener("sessionstart", eY), eN.removeEventListener("sessionend", eX), eK.stop() }, this.renderBufferDirect = function (e, t, n, s, l, d) { let f; null === t && (t = eP); let p = l.isMesh && 0 > l.matrixWorld.determinant(), m = function (e, t, i, n, s) { var l; !0 !== t.isScene && (t = eP), h.resetTextureUnits(); let d = t.fog, f = n.isMeshStandardMaterial ? t.environment : null, p = null === eu ? es.outputColorSpace : !0 === eu.isXRRenderTarget ? eu.texture.colorSpace : r.Zr2, m = (n.isMeshStandardMaterial ? y : c).get(n.envMap || f), g = !0 === n.vertexColors && !!i.attributes.color && 4 === i.attributes.color.itemSize, v = !!i.attributes.tangent && (!!n.normalMap || n.anisotropy > 0), x = !!i.morphAttributes.position, S = !!i.morphAttributes.normal, A = !!i.morphAttributes.color, _ = r.y_p; n.toneMapped && (null === eu || !0 === eu.isXRRenderTarget) && (_ = es.toneMapping); let b = i.morphAttributes.position || i.morphAttributes.normal || i.morphAttributes.color, T = void 0 !== b ? b.length : 0, M = u.get(n), R = ei.state.lights; if (!0 === ew && (!0 === eM || e !== ec)) { let t = e === ec && n.id === eh; w.setState(n, e, t) } let I = !1; n.version === M.__version ? M.needsLights && M.lightsStateVersion !== R.state.version ? I = !0 : M.outputColorSpace !== p ? I = !0 : s.isBatchedMesh && !1 === M.batching ? I = !0 : s.isBatchedMesh || !0 !== M.batching ? s.isBatchedMesh && !0 === M.batchingColor && null === s.colorTexture ? I = !0 : s.isBatchedMesh && !1 === M.batchingColor && null !== s.colorTexture ? I = !0 : s.isInstancedMesh && !1 === M.instancing ? I = !0 : s.isInstancedMesh || !0 !== M.instancing ? s.isSkinnedMesh && !1 === M.skinning ? I = !0 : s.isSkinnedMesh || !0 !== M.skinning ? s.isInstancedMesh && !0 === M.instancingColor && null === s.instanceColor ? I = !0 : s.isInstancedMesh && !1 === M.instancingColor && null !== s.instanceColor ? I = !0 : s.isInstancedMesh && !0 === M.instancingMorph && null === s.morphTexture ? I = !0 : s.isInstancedMesh && !1 === M.instancingMorph && null !== s.morphTexture ? I = !0 : M.envMap !== m ? I = !0 : !0 === n.fog && M.fog !== d ? I = !0 : void 0 !== M.numClippingPlanes && (M.numClippingPlanes !== w.numPlanes || M.numIntersection !== w.numIntersection) ? I = !0 : M.vertexAlphas !== g ? I = !0 : M.vertexTangents !== v ? I = !0 : M.morphTargets !== x ? I = !0 : M.morphNormals !== S ? I = !0 : M.morphColors !== A ? I = !0 : M.toneMapping !== _ ? I = !0 : M.morphTargetsCount !== T && (I = !0) : I = !0 : I = !0 : I = !0 : (I = !0, M.__version = n.version); let L = M.currentProgram; !0 === I && (L = e0(n, t, s)); let P = !1, D = !1, k = !1, F = L.getUniforms(), U = M.uniforms; if (o.useProgram(L.program) && (P = !0, D = !0, k = !0), n.id !== eh && (eh = n.id, D = !0), P || ec !== e) { o.buffers.depth.getReversed() ? (eR.copy(e.projectionMatrix), (0, r.xiE)(eR), (0, r.Mmk)(eR), F.setValue(ek, "projectionMatrix", eR)) : F.setValue(ek, "projectionMatrix", e.projectionMatrix), F.setValue(ek, "viewMatrix", e.matrixWorldInverse); let t = F.map.cameraPosition; void 0 !== t && t.setValue(ek, eI.setFromMatrixPosition(e.matrixWorld)), a.logarithmicDepthBuffer && F.setValue(ek, "logDepthBufFC", 2 / (Math.log(e.far + 1) / Math.LN2)), (n.isMeshPhongMaterial || n.isMeshToonMaterial || n.isMeshLambertMaterial || n.isMeshBasicMaterial || n.isMeshStandardMaterial || n.isShaderMaterial) && F.setValue(ek, "isOrthographic", !0 === e.isOrthographicCamera), ec !== e && (ec = e, D = !0, k = !0) } if (s.isSkinnedMesh) { F.setOptional(ek, s, "bindMatrix"), F.setOptional(ek, s, "bindMatrixInverse"); let e = s.skeleton; e && (null === e.boneTexture && e.computeBoneTexture(), F.setValue(ek, "boneTexture", e.boneTexture, h)) } s.isBatchedMesh && (F.setOptional(ek, s, "batchingTexture"), F.setValue(ek, "batchingTexture", s._matricesTexture, h), F.setOptional(ek, s, "batchingIdTexture"), F.setValue(ek, "batchingIdTexture", s._indirectTexture, h), F.setOptional(ek, s, "batchingColorTexture"), null !== s._colorsTexture && F.setValue(ek, "batchingColorTexture", s._colorsTexture, h)); let N = i.morphAttributes; if ((void 0 !== N.position || void 0 !== N.normal || void 0 !== N.color) && C.update(s, i, L), (D || M.receiveShadow !== s.receiveShadow) && (M.receiveShadow = s.receiveShadow, F.setValue(ek, "receiveShadow", s.receiveShadow)), n.isMeshGouraudMaterial && null !== n.envMap && (U.envMap.value = m, U.flipEnvMap.value = m.isCubeTexture && !1 === m.isRenderTargetTexture ? -1 : 1), n.isMeshStandardMaterial && null === n.envMap && null !== t.environment && (U.envMapIntensity.value = t.environmentIntensity), D && (F.setValue(ek, "toneMappingExposure", es.toneMappingExposure), M.needsLights && (l = k, U.ambientLightColor.needsUpdate = l, U.lightProbe.needsUpdate = l, U.directionalLights.needsUpdate = l, U.directionalLightShadows.needsUpdate = l, U.pointLights.needsUpdate = l, U.pointLightShadows.needsUpdate = l, U.spotLights.needsUpdate = l, U.spotLightShadows.needsUpdate = l, U.rectAreaLights.needsUpdate = l, U.hemisphereLights.needsUpdate = l), d && !0 === n.fog && E.refreshFogUniforms(U, d), E.refreshMaterialUniforms(U, n, ex, ey, ei.state.transmissionRenderTarget[e.id]), ej.upload(ek, e1(M), U, h)), n.isShaderMaterial && !0 === n.uniformsNeedUpdate && (ej.upload(ek, e1(M), U, h), n.uniformsNeedUpdate = !1), n.isSpriteMaterial && F.setValue(ek, "center", s.center), F.setValue(ek, "modelViewMatrix", s.modelViewMatrix), F.setValue(ek, "normalMatrix", s.normalMatrix), F.setValue(ek, "modelMatrix", s.matrixWorld), n.isShaderMaterial || n.isRawShaderMaterial) { let e = n.uniformsGroups; for (let t = 0, i = e.length; t < i; t++) { let i = e[t]; O.update(i, L), O.bind(i, L) } } return L }(e, t, n, s, l); o.setMaterial(s, p); let g = n.index, v = 1; if (!0 === s.wireframe) { if (void 0 === (g = S.getWireframeAttribute(n))) return; v = 2 } let A = n.drawRange, _ = n.attributes.position, b = A.start * v, T = (A.start + A.count) * v; null !== d && (b = Math.max(b, d.start * v), T = Math.min(T, (d.start + d.count) * v)), null !== g ? (b = Math.max(b, 0), T = Math.min(T, g.count)) : null != _ && (b = Math.max(b, 0), T = Math.min(T, _.count)); let M = T - b; if (M < 0 || M === 1 / 0) return; D.setup(l, s, m, n, g); let R = I; if (null !== g && (f = x.get(g), (R = L).setIndex(f)), l.isMesh) !0 === s.wireframe ? (o.setLineWidth(s.wireframeLinewidth * eO()), R.setMode(ek.LINES)) : R.setMode(ek.TRIANGLES); else if (l.isLine) { let e = s.linewidth; void 0 === e && (e = 1), o.setLineWidth(e * eO()), l.isLineSegments ? R.setMode(ek.LINES) : l.isLineLoop ? R.setMode(ek.LINE_LOOP) : R.setMode(ek.LINE_STRIP) } else l.isPoints ? R.setMode(ek.POINTS) : l.isSprite && R.setMode(ek.TRIANGLES); if (l.isBatchedMesh) { if (null !== l._multiDrawInstances) (0, r.mcG)("THREE.WebGLRenderer: renderMultiDrawInstances has been deprecated and will be removed in r184. Append to renderMultiDraw arguments and use indirection."), R.renderMultiDrawInstances(l._multiDrawStarts, l._multiDrawCounts, l._multiDrawCount, l._multiDrawInstances); else if (i.get("WEBGL_multi_draw")) R.renderMultiDraw(l._multiDrawStarts, l._multiDrawCounts, l._multiDrawCount); else { let e = l._multiDrawStarts, t = l._multiDrawCounts, i = l._multiDrawCount, r = g ? x.get(g).bytesPerElement : 1, n = u.get(s).currentProgram.getUniforms(); for (let s = 0; s < i; s++)n.setValue(ek, "_gl_DrawID", s), R.render(e[s] / r, t[s]) } } else if (l.isInstancedMesh) R.renderInstances(b, M, l.count); else if (n.isInstancedBufferGeometry) { let e = void 0 !== n._maxInstanceCount ? n._maxInstanceCount : 1 / 0, t = Math.min(n.instanceCount, e); R.renderInstances(b, M, t) } else R.render(b, M) }, this.compile = function (e, t, i = null) { null === i && (i = e), (ei = T.get(i)).init(t), en.push(ei), i.traverseVisible(function (e) { e.isLight && e.layers.test(t.layers) && (ei.pushLight(e), e.castShadow && ei.pushShadow(e)) }), e !== i && e.traverseVisible(function (e) { e.isLight && e.layers.test(t.layers) && (ei.pushLight(e), e.castShadow && ei.pushShadow(e)) }), ei.setupLights(); let r = new Set; return e.traverse(function (e) { if (!(e.isMesh || e.isPoints || e.isLine || e.isSprite)) return; let t = e.material; if (t) { if (Array.isArray(t)) for (let n = 0; n < t.length; n++) { let s = t[n]; eV(s, i, e), r.add(s) } else eV(t, i, e), r.add(t) } }), ei = en.pop(), r }, this.compileAsync = function (e, t, r = null) { let n = this.compile(e, t, r); return new Promise(t => { function r() { if (n.forEach(function (e) { u.get(e).currentProgram.isReady() && n.delete(e) }), 0 === n.size) { t(e); return } setTimeout(r, 10) } null !== i.get("KHR_parallel_shader_compile") ? r() : setTimeout(r, 10) }) }; let eW = null; function eY() { eK.stop() } function eX() { eK.start() } let eK = new n; function eq(e, t, i, r) { if (!1 === e.visible) return; if (e.layers.test(t.layers)) { if (e.isGroup) i = e.renderOrder; else if (e.isLOD) !0 === e.autoUpdate && e.update(t); else if (e.isLight) ei.pushLight(e), e.castShadow && ei.pushShadow(e); else if (e.isSprite) { if (!e.frustumCulled || eT.intersectsSprite(e)) { r && eL.setFromMatrixPosition(e.matrixWorld).applyMatrix4(eC); let t = A.update(e), n = e.material; n.visible && et.push(e, t, n, i, eL.z, null) } } else if ((e.isMesh || e.isLine || e.isPoints) && (!e.frustumCulled || eT.intersectsObject(e))) { let t = A.update(e), n = e.material; if (r && (void 0 !== e.boundingSphere ? (null === e.boundingSphere && e.computeBoundingSphere(), eL.copy(e.boundingSphere.center)) : (null === t.boundingSphere && t.computeBoundingSphere(), eL.copy(t.boundingSphere.center)), eL.applyMatrix4(e.matrixWorld).applyMatrix4(eC)), Array.isArray(n)) { let r = t.groups; for (let s = 0, a = r.length; s < a; s++) { let a = r[s], o = n[a.materialIndex]; o && o.visible && et.push(e, t, o, i, eL.z, a) } } else n.visible && et.push(e, t, n, i, eL.z, null) } } let n = e.children; for (let e = 0, s = n.length; e < s; e++)eq(n[e], t, i, r) } function eQ(e, t, i, r) { let n = e.opaque, s = e.transmissive, a = e.transparent; ei.setupLightsView(i), !0 === ew && w.setGlobalState(es.clippingPlanes, i), r && o.viewport(ed.copy(r)), n.length > 0 && e$(n, t, i), s.length > 0 && e$(s, t, i), a.length > 0 && e$(a, t, i), o.buffers.depth.setTest(!0), o.buffers.depth.setMask(!0), o.buffers.color.setMask(!0), o.setPolygonOffset(!1) } function eZ(e, t, n, s) { if (null !== (!0 === n.isScene ? n.overrideMaterial : null)) return; void 0 === ei.state.transmissionRenderTarget[s.id] && (ei.state.transmissionRenderTarget[s.id] = new r.nWS(1, 1, { generateMipmaps: !0, type: i.has("EXT_color_buffer_half_float") || i.has("EXT_color_buffer_float") ? r.ix0 : r.OUM, minFilter: r.$_I, samples: 4, stencilBuffer: j, resolveDepthBuffer: !1, resolveStencilBuffer: !1, colorSpace: r.ppV.workingColorSpace })); let a = ei.state.transmissionRenderTarget[s.id], o = s.viewport || ed; a.setSize(o.z * es.transmissionResolutionScale, o.w * es.transmissionResolutionScale); let l = es.getRenderTarget(); es.setRenderTarget(a), es.getClearColor(em), (eg = es.getClearAlpha()) < 1 && es.setClearColor(0xffffff, .5), es.clear(), eD && R.render(n); let u = es.toneMapping; es.toneMapping = r.y_p; let c = s.viewport; if (void 0 !== s.viewport && (s.viewport = void 0), ei.setupLightsView(s), !0 === ew && w.setGlobalState(es.clippingPlanes, s), e$(e, n, s), h.updateMultisampleRenderTarget(a), h.updateRenderTargetMipmap(a), !1 === i.has("WEBGL_multisampled_render_to_texture")) { let e = !1; for (let i = 0, a = t.length; i < a; i++) { let a = t[i], o = a.object, l = a.geometry, u = a.material, h = a.group; if (u.side === r.$EB && o.layers.test(s.layers)) { let t = u.side; u.side = r.hsX, u.needsUpdate = !0, eJ(o, n, s, l, u, h), u.side = t, u.needsUpdate = !0, e = !0 } } !0 === e && (h.updateMultisampleRenderTarget(a), h.updateRenderTargetMipmap(a)) } es.setRenderTarget(l), es.setClearColor(em, eg), void 0 !== c && (s.viewport = c), es.toneMapping = u } function e$(e, t, i) { let r = !0 === t.isScene ? t.overrideMaterial : null; for (let n = 0, s = e.length; n < s; n++) { let s = e[n], a = s.object, o = s.geometry, l = null === r ? s.material : r, u = s.group; a.layers.test(i.layers) && eJ(a, t, i, o, l, u) } } function eJ(e, t, i, n, s, a) { e.onBeforeRender(es, t, i, n, s, a), e.modelViewMatrix.multiplyMatrices(i.matrixWorldInverse, e.matrixWorld), e.normalMatrix.getNormalMatrix(e.modelViewMatrix), s.onBeforeRender(es, t, i, n, e, a), !0 === s.transparent && s.side === r.$EB && !1 === s.forceSinglePass ? (s.side = r.hsX, s.needsUpdate = !0, es.renderBufferDirect(i, t, n, s, e, a), s.side = r.hB5, s.needsUpdate = !0, es.renderBufferDirect(i, t, n, s, e, a), s.side = r.$EB) : es.renderBufferDirect(i, t, n, s, e, a), e.onAfterRender(es, t, i, n, s, a) } function e0(e, t, i) { !0 !== t.isScene && (t = eP); let r = u.get(e), n = ei.state.lights, s = ei.state.shadowsArray, a = n.state.version, o = _.getParameters(e, n.state, s, t, i), l = _.getProgramCacheKey(o), h = r.programs; r.environment = e.isMeshStandardMaterial ? t.environment : null, r.fog = t.fog, r.envMap = (e.isMeshStandardMaterial ? y : c).get(e.envMap || r.environment), r.envMapRotation = null !== r.environment && null === e.envMap ? t.environmentRotation : e.envMapRotation, void 0 === h && (e.addEventListener("dispose", eH), h = new Map, r.programs = h); let d = h.get(l); if (void 0 !== d) { if (r.currentProgram === d && r.lightsStateVersion === a) return e2(e, o), d } else o.uniforms = _.getUniforms(e), e.onBeforeCompile(o, es), d = _.acquireProgram(o, l), h.set(l, d), r.uniforms = o.uniforms; let f = r.uniforms; return (e.isShaderMaterial || e.isRawShaderMaterial) && !0 !== e.clipping || (f.clippingPlanes = w.uniform), e2(e, o), r.needsLights = e.isMeshLambertMaterial || e.isMeshToonMaterial || e.isMeshPhongMaterial || e.isMeshStandardMaterial || e.isShadowMaterial || e.isShaderMaterial && !0 === e.lights, r.lightsStateVersion = a, r.needsLights && (f.ambientLightColor.value = n.state.ambient, f.lightProbe.value = n.state.probe, f.directionalLights.value = n.state.directional, f.directionalLightShadows.value = n.state.directionalShadow, f.spotLights.value = n.state.spot, f.spotLightShadows.value = n.state.spotShadow, f.rectAreaLights.value = n.state.rectArea, f.ltc_1.value = n.state.rectAreaLTC1, f.ltc_2.value = n.state.rectAreaLTC2, f.pointLights.value = n.state.point, f.pointLightShadows.value = n.state.pointShadow, f.hemisphereLights.value = n.state.hemi, f.directionalShadowMap.value = n.state.directionalShadowMap, f.directionalShadowMatrix.value = n.state.directionalShadowMatrix, f.spotShadowMap.value = n.state.spotShadowMap, f.spotLightMatrix.value = n.state.spotLightMatrix, f.spotLightMap.value = n.state.spotLightMap, f.pointShadowMap.value = n.state.pointShadowMap, f.pointShadowMatrix.value = n.state.pointShadowMatrix), r.currentProgram = d, r.uniformsList = null, d } function e1(e) { if (null === e.uniformsList) { let t = e.currentProgram.getUniforms(); e.uniformsList = ej.seqWithValue(t.seq, e.uniforms) } return e.uniformsList } function e2(e, t) { let i = u.get(e); i.outputColorSpace = t.outputColorSpace, i.batching = t.batching, i.batchingColor = t.batchingColor, i.instancing = t.instancing, i.instancingColor = t.instancingColor, i.instancingMorph = t.instancingMorph, i.skinning = t.skinning, i.morphTargets = t.morphTargets, i.morphNormals = t.morphNormals, i.morphColors = t.morphColors, i.morphTargetsCount = t.morphTargetsCount, i.numClippingPlanes = t.numClippingPlanes, i.numIntersection = t.numClipIntersection, i.vertexAlphas = t.vertexAlphas, i.vertexTangents = t.vertexTangents, i.toneMapping = t.toneMapping } eK.setAnimationLoop(function (e) { eW && eW(e) }), "undefined" != typeof self && eK.setContext(self), this.setAnimationLoop = function (e) { eW = e, eN.setAnimationLoop(e), null === e ? eK.stop() : eK.start() }, eN.addEventListener("sessionstart", eY), eN.addEventListener("sessionend", eX), this.render = function (e, t) { if (void 0 !== t && !0 !== t.isCamera) { console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera."); return } if (!0 === ea) return; if (!0 === e.matrixWorldAutoUpdate && e.updateMatrixWorld(), null === t.parent && !0 === t.matrixWorldAutoUpdate && t.updateMatrixWorld(), !0 === eN.enabled && !0 === eN.isPresenting && (!0 === eN.cameraAutoUpdate && eN.updateCamera(t), t = eN.getCamera()), !0 === e.isScene && e.onBeforeRender(es, e, t, eu), (ei = T.get(e, en.length)).init(t), en.push(ei), eC.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse), eT.setFromProjectionMatrix(eC), eM = this.localClippingEnabled, ew = w.init(this.clippingPlanes, eM), (et = b.get(e, er.length)).init(), er.push(et), !0 === eN.enabled && !0 === eN.isPresenting) { let e = es.xr.getDepthSensingMesh(); null !== e && eq(e, t, -1 / 0, es.sortObjects) } eq(e, t, 0, es.sortObjects), et.finish(), !0 === es.sortObjects && et.sort(eS, eA), (eD = !1 === eN.enabled || !1 === eN.isPresenting || !1 === eN.hasDepthSensing()) && R.addToRenderList(et, e), this.info.render.frame++, !0 === ew && w.beginShadows(); let i = ei.state.shadowsArray; M.render(i, e, t), !0 === ew && w.endShadows(), !0 === this.info.autoReset && this.info.reset(); let r = et.opaque, n = et.transmissive; if (ei.setupLights(), t.isArrayCamera) { let i = t.cameras; if (n.length > 0) for (let t = 0, s = i.length; t < s; t++)eZ(r, n, e, i[t]); eD && R.render(e); for (let t = 0, r = i.length; t < r; t++) { let r = i[t]; eQ(et, e, r, r.viewport) } } else n.length > 0 && eZ(r, n, e, t), eD && R.render(e), eQ(et, e, t); null !== eu && 0 === el && (h.updateMultisampleRenderTarget(eu), h.updateRenderTargetMipmap(eu)), !0 === e.isScene && e.onAfterRender(es, e, t), D.resetDefaultState(), eh = -1, ec = null, en.pop(), en.length > 0 ? (ei = en[en.length - 1], !0 === ew && w.setGlobalState(es.clippingPlanes, ei.state.camera)) : ei = null, er.pop(), et = er.length > 0 ? er[er.length - 1] : null }, this.getActiveCubeFace = function () { return eo }, this.getActiveMipmapLevel = function () { return el }, this.getRenderTarget = function () { return eu }, this.setRenderTargetTextures = function (e, t, r) { u.get(e.texture).__webglTexture = t, u.get(e.depthTexture).__webglTexture = r; let n = u.get(e); n.__hasExternalTextures = !0, n.__autoAllocateDepthBuffer = void 0 === r, n.__autoAllocateDepthBuffer || !0 !== i.has("WEBGL_multisampled_render_to_texture") || (console.warn("THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"), n.__useRenderToTexture = !1) }, this.setRenderTargetFramebuffer = function (e, t) { let i = u.get(e); i.__webglFramebuffer = t, i.__useDefaultFramebuffer = void 0 === t }; let e3 = ek.createFramebuffer(); this.setRenderTarget = function (e, t = 0, i = 0) { eu = e, eo = t, el = i; let r = !0, n = null, s = !1, a = !1; if (e) { let l = u.get(e); if (void 0 !== l.__useDefaultFramebuffer) o.bindFramebuffer(ek.FRAMEBUFFER, null), r = !1; else if (void 0 === l.__webglFramebuffer) h.setupRenderTarget(e); else if (l.__hasExternalTextures) h.rebindTextures(e, u.get(e.texture).__webglTexture, u.get(e.depthTexture).__webglTexture); else if (e.depthBuffer) { let t = e.depthTexture; if (l.__boundDepthTexture !== t) { if (null !== t && u.has(t) && (e.width !== t.image.width || e.height !== t.image.height)) throw Error("WebGLRenderTarget: Attached DepthTexture is initialized to the incorrect size."); h.setupDepthRenderbuffer(e) } } let c = e.texture; (c.isData3DTexture || c.isDataArrayTexture || c.isCompressedArrayTexture) && (a = !0); let d = u.get(e).__webglFramebuffer; e.isWebGLCubeRenderTarget ? (n = Array.isArray(d[t]) ? d[t][i] : d[t], s = !0) : n = e.samples > 0 && !1 === h.useMultisampledRTT(e) ? u.get(e).__webglMultisampledFramebuffer : Array.isArray(d) ? d[i] : d, ed.copy(e.viewport), ef.copy(e.scissor), ep = e.scissorTest } else ed.copy(e_).multiplyScalar(ex).floor(), ef.copy(eE).multiplyScalar(ex).floor(), ep = eb; if (0 !== i && (n = e3), o.bindFramebuffer(ek.FRAMEBUFFER, n) && r && o.drawBuffers(e, n), o.viewport(ed), o.scissor(ef), o.setScissorTest(ep), s) { let r = u.get(e.texture); ek.framebufferTexture2D(ek.FRAMEBUFFER, ek.COLOR_ATTACHMENT0, ek.TEXTURE_CUBE_MAP_POSITIVE_X + t, r.__webglTexture, i) } else if (a) { let r = u.get(e.texture); ek.framebufferTextureLayer(ek.FRAMEBUFFER, ek.COLOR_ATTACHMENT0, r.__webglTexture, i, t) } else if (null !== e && 0 !== i) { let t = u.get(e.texture); ek.framebufferTexture2D(ek.FRAMEBUFFER, ek.COLOR_ATTACHMENT0, ek.TEXTURE_2D, t.__webglTexture, i) } eh = -1 }, this.readRenderTargetPixels = function (e, t, i, r, n, s, l) { if (!(e && e.isWebGLRenderTarget)) { console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget."); return } let h = u.get(e).__webglFramebuffer; if (e.isWebGLCubeRenderTarget && void 0 !== l && (h = h[l]), h) { o.bindFramebuffer(ek.FRAMEBUFFER, h); try { let o = e.texture, l = o.format, u = o.type; if (!a.textureFormatReadable(l)) { console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format."); return } if (!a.textureTypeReadable(u)) { console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type."); return } t >= 0 && t <= e.width - r && i >= 0 && i <= e.height - n && ek.readPixels(t, i, r, n, P.convert(l), P.convert(u), s) } finally { let e = null !== eu ? u.get(eu).__webglFramebuffer : null; o.bindFramebuffer(ek.FRAMEBUFFER, e) } } }, this.readRenderTargetPixelsAsync = async function (e, t, i, n, s, l, h) { if (!(e && e.isWebGLRenderTarget)) throw Error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget."); let c = u.get(e).__webglFramebuffer; if (e.isWebGLCubeRenderTarget && void 0 !== h && (c = c[h]), c) { let h = e.texture, d = h.format, f = h.type; if (!a.textureFormatReadable(d)) throw Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in RGBA or implementation defined format."); if (!a.textureTypeReadable(f)) throw Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in UnsignedByteType or implementation defined type."); if (t >= 0 && t <= e.width - n && i >= 0 && i <= e.height - s) { o.bindFramebuffer(ek.FRAMEBUFFER, c); let e = ek.createBuffer(); ek.bindBuffer(ek.PIXEL_PACK_BUFFER, e), ek.bufferData(ek.PIXEL_PACK_BUFFER, l.byteLength, ek.STREAM_READ), ek.readPixels(t, i, n, s, P.convert(d), P.convert(f), 0); let a = null !== eu ? u.get(eu).__webglFramebuffer : null; o.bindFramebuffer(ek.FRAMEBUFFER, a); let h = ek.fenceSync(ek.SYNC_GPU_COMMANDS_COMPLETE, 0); return ek.flush(), await (0, r.jej)(ek, h, 4), ek.bindBuffer(ek.PIXEL_PACK_BUFFER, e), ek.getBufferSubData(ek.PIXEL_PACK_BUFFER, 0, l), ek.deleteBuffer(e), ek.deleteSync(h), l } throw Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: requested read bounds are out of range.") } }, this.copyFramebufferToTexture = function (e, t = null, i = 0) { !0 !== e.isTexture && ((0, r.mcG)("WebGLRenderer: copyFramebufferToTexture function signature has changed."), t = arguments[0] || null, e = arguments[1]); let n = Math.pow(2, -i), s = Math.floor(e.image.width * n), a = Math.floor(e.image.height * n), l = null !== t ? t.x : 0, u = null !== t ? t.y : 0; h.setTexture2D(e, 0), ek.copyTexSubImage2D(ek.TEXTURE_2D, i, 0, 0, l, u, s, a), o.unbindTexture() }; let e4 = ek.createFramebuffer(), e5 = ek.createFramebuffer(); this.copyTextureToTexture = function (e, t, i = null, n = null, s = 0, a = null) { let l, c, d, f, p, m, g, v, y, x; !0 !== e.isTexture && ((0, r.mcG)("WebGLRenderer: copyTextureToTexture function signature has changed."), n = arguments[0] || null, e = arguments[1], t = arguments[2], a = arguments[3] || 0, i = null), null === a && (0 !== s ? ((0, r.mcG)("WebGLRenderer: copyTextureToTexture function signature has changed to support src and dst mipmap levels."), a = s, s = 0) : a = 0); let S = e.isCompressedTexture ? e.mipmaps[a] : e.image; if (null !== i) l = i.max.x - i.min.x, c = i.max.y - i.min.y, d = i.isBox3 ? i.max.z - i.min.z : 1, f = i.min.x, p = i.min.y, m = i.isBox3 ? i.min.z : 0; else { let t = Math.pow(2, -s); l = Math.floor(S.width * t), c = Math.floor(S.height * t), d = e.isDataArrayTexture ? S.depth : e.isData3DTexture ? Math.floor(S.depth * t) : 1, f = 0, p = 0, m = 0 } null !== n ? (g = n.x, v = n.y, y = n.z) : (g = 0, v = 0, y = 0); let A = P.convert(t.format), _ = P.convert(t.type); t.isData3DTexture ? (h.setTexture3D(t, 0), x = ek.TEXTURE_3D) : t.isDataArrayTexture || t.isCompressedArrayTexture ? (h.setTexture2DArray(t, 0), x = ek.TEXTURE_2D_ARRAY) : (h.setTexture2D(t, 0), x = ek.TEXTURE_2D), ek.pixelStorei(ek.UNPACK_FLIP_Y_WEBGL, t.flipY), ek.pixelStorei(ek.UNPACK_PREMULTIPLY_ALPHA_WEBGL, t.premultiplyAlpha), ek.pixelStorei(ek.UNPACK_ALIGNMENT, t.unpackAlignment); let E = ek.getParameter(ek.UNPACK_ROW_LENGTH), b = ek.getParameter(ek.UNPACK_IMAGE_HEIGHT), T = ek.getParameter(ek.UNPACK_SKIP_PIXELS), w = ek.getParameter(ek.UNPACK_SKIP_ROWS), M = ek.getParameter(ek.UNPACK_SKIP_IMAGES); ek.pixelStorei(ek.UNPACK_ROW_LENGTH, S.width), ek.pixelStorei(ek.UNPACK_IMAGE_HEIGHT, S.height), ek.pixelStorei(ek.UNPACK_SKIP_PIXELS, f), ek.pixelStorei(ek.UNPACK_SKIP_ROWS, p), ek.pixelStorei(ek.UNPACK_SKIP_IMAGES, m); let R = e.isDataArrayTexture || e.isData3DTexture, C = t.isDataArrayTexture || t.isData3DTexture; if (e.isDepthTexture) { let i = u.get(e), r = u.get(t), n = u.get(i.__renderTarget), h = u.get(r.__renderTarget); o.bindFramebuffer(ek.READ_FRAMEBUFFER, n.__webglFramebuffer), o.bindFramebuffer(ek.DRAW_FRAMEBUFFER, h.__webglFramebuffer); for (let i = 0; i < d; i++)R && (ek.framebufferTextureLayer(ek.READ_FRAMEBUFFER, ek.COLOR_ATTACHMENT0, u.get(e).__webglTexture, s, m + i), ek.framebufferTextureLayer(ek.DRAW_FRAMEBUFFER, ek.COLOR_ATTACHMENT0, u.get(t).__webglTexture, a, y + i)), ek.blitFramebuffer(f, p, l, c, g, v, l, c, ek.DEPTH_BUFFER_BIT, ek.NEAREST); o.bindFramebuffer(ek.READ_FRAMEBUFFER, null), o.bindFramebuffer(ek.DRAW_FRAMEBUFFER, null) } else if (0 !== s || e.isRenderTargetTexture || u.has(e)) { let i = u.get(e), r = u.get(t); o.bindFramebuffer(ek.READ_FRAMEBUFFER, e4), o.bindFramebuffer(ek.DRAW_FRAMEBUFFER, e5); for (let e = 0; e < d; e++)R ? ek.framebufferTextureLayer(ek.READ_FRAMEBUFFER, ek.COLOR_ATTACHMENT0, i.__webglTexture, s, m + e) : ek.framebufferTexture2D(ek.READ_FRAMEBUFFER, ek.COLOR_ATTACHMENT0, ek.TEXTURE_2D, i.__webglTexture, s), C ? ek.framebufferTextureLayer(ek.DRAW_FRAMEBUFFER, ek.COLOR_ATTACHMENT0, r.__webglTexture, a, y + e) : ek.framebufferTexture2D(ek.DRAW_FRAMEBUFFER, ek.COLOR_ATTACHMENT0, ek.TEXTURE_2D, r.__webglTexture, a), 0 !== s ? ek.blitFramebuffer(f, p, l, c, g, v, l, c, ek.COLOR_BUFFER_BIT, ek.NEAREST) : C ? ek.copyTexSubImage3D(x, a, g, v, y + e, f, p, l, c) : ek.copyTexSubImage2D(x, a, g, v, f, p, l, c); o.bindFramebuffer(ek.READ_FRAMEBUFFER, null), o.bindFramebuffer(ek.DRAW_FRAMEBUFFER, null) } else C ? e.isDataTexture || e.isData3DTexture ? ek.texSubImage3D(x, a, g, v, y, l, c, d, A, _, S.data) : t.isCompressedArrayTexture ? ek.compressedTexSubImage3D(x, a, g, v, y, l, c, d, A, S.data) : ek.texSubImage3D(x, a, g, v, y, l, c, d, A, _, S) : e.isDataTexture ? ek.texSubImage2D(ek.TEXTURE_2D, a, g, v, l, c, A, _, S.data) : e.isCompressedTexture ? ek.compressedTexSubImage2D(ek.TEXTURE_2D, a, g, v, S.width, S.height, A, S.data) : ek.texSubImage2D(ek.TEXTURE_2D, a, g, v, l, c, A, _, S); ek.pixelStorei(ek.UNPACK_ROW_LENGTH, E), ek.pixelStorei(ek.UNPACK_IMAGE_HEIGHT, b), ek.pixelStorei(ek.UNPACK_SKIP_PIXELS, T), ek.pixelStorei(ek.UNPACK_SKIP_ROWS, w), ek.pixelStorei(ek.UNPACK_SKIP_IMAGES, M), 0 === a && t.generateMipmaps && ek.generateMipmap(x), o.unbindTexture() }, this.copyTextureToTexture3D = function (e, t, i = null, n = null, s = 0) { return !0 !== e.isTexture && ((0, r.mcG)("WebGLRenderer: copyTextureToTexture3D function signature has changed."), i = arguments[0] || null, n = arguments[1] || null, e = arguments[2], t = arguments[3], s = arguments[4] || 0), (0, r.mcG)('WebGLRenderer: copyTextureToTexture3D function has been deprecated. Use "copyTextureToTexture" instead.'), this.copyTextureToTexture(e, t, i, n, s) }, this.initRenderTarget = function (e) { void 0 === u.get(e).__webglFramebuffer && h.setupRenderTarget(e) }, this.initTexture = function (e) { e.isCubeTexture ? h.setTextureCube(e, 0) : e.isData3DTexture ? h.setTexture3D(e, 0) : e.isDataArrayTexture || e.isCompressedArrayTexture ? h.setTexture2DArray(e, 0) : h.setTexture2D(e, 0), o.unbindTexture() }, this.resetState = function () { eo = 0, el = 0, eu = null, o.reset(), D.reset() }, "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this })) } get coordinateSystem() { return r.TdN } get outputColorSpace() { return this._outputColorSpace } set outputColorSpace(e) { this._outputColorSpace = e; let t = this.getContext(); t.drawingBufferColorspace = r.ppV._getDrawingBufferColorSpace(e), t.unpackColorSpace = r.ppV._getUnpackColorSpace() } }
  }, 9931: (e, t, i) => { "use strict"; i.d(t, { d: () => l }); var r = i(4922); let n = new r.qUd(-1, 1, 1, -1, 0, 1); class s extends r.LoY { constructor() { super(), this.setAttribute("position", new r.qtW([-1, 3, 0, -1, -1, 0, 3, -1, 0], 3)), this.setAttribute("uv", new r.qtW([0, 2, 0, 0, 2, 0], 2)) } } let a = new s; class o { constructor(e) { this._mesh = new r.eaF(a, e) } dispose() { this._mesh.geometry.dispose() } render(e) { e.render(this._mesh, n) } get material() { return this._mesh.material } set material(e) { this._mesh.material = e } } class l { constructor(e, t, i) { this.variables = [], this.currentTextureIndex = 0; let n = r.RQf, s = { passThruTexture: { value: null } }, a = h("uniform sampler2D passThruTexture;\n\nvoid main() {\n\n	vec2 uv = gl_FragCoord.xy / resolution.xy;\n\n	gl_FragColor = texture2D( passThruTexture, uv );\n\n}\n", s), l = new o(a); function u(i) { i.defines.resolution = "vec2( " + e.toFixed(1) + ", " + t.toFixed(1) + " )" } function h(e, t) { t = t || {}; let i = new r.BKk({ name: "GPUComputationShader", uniforms: t, vertexShader: "void main()	{\n\n	gl_Position = vec4( position, 1.0 );\n\n}\n", fragmentShader: e }); return u(i), i } this.setDataType = function (e) { return n = e, this }, this.addVariable = function (e, t, i) { let n = { name: e, initialValueTexture: i, material: this.createShaderMaterial(t), dependencies: null, renderTargets: [], wrapS: null, wrapT: null, minFilter: r.hxR, magFilter: r.hxR }; return this.variables.push(n), n }, this.setVariableDependencies = function (e, t) { e.dependencies = t }, this.init = function () { if (0 === i.capabilities.maxVertexTextures) return "No support for vertex shader textures."; for (let i = 0; i < this.variables.length; i++) { let r = this.variables[i]; r.renderTargets[0] = this.createRenderTarget(e, t, r.wrapS, r.wrapT, r.minFilter, r.magFilter), r.renderTargets[1] = this.createRenderTarget(e, t, r.wrapS, r.wrapT, r.minFilter, r.magFilter), this.renderTexture(r.initialValueTexture, r.renderTargets[0]), this.renderTexture(r.initialValueTexture, r.renderTargets[1]); let n = r.material, s = n.uniforms; if (null !== r.dependencies) for (let e = 0; e < r.dependencies.length; e++) { let t = r.dependencies[e]; if (t.name !== r.name) { let e = !1; for (let i = 0; i < this.variables.length; i++)if (t.name === this.variables[i].name) { e = !0; break } if (!e) return "Variable dependency not found. Variable=" + r.name + ", dependency=" + t.name } s[t.name] = { value: null }, n.fragmentShader = "\nuniform sampler2D " + t.name + ";\n" + n.fragmentShader } } return this.currentTextureIndex = 0, null }, this.compute = function () { let e = this.currentTextureIndex, t = 0 === this.currentTextureIndex ? 1 : 0; for (let i = 0, r = this.variables.length; i < r; i++) { let r = this.variables[i]; if (null !== r.dependencies) { let t = r.material.uniforms; for (let i = 0, n = r.dependencies.length; i < n; i++) { let n = r.dependencies[i]; t[n.name].value = n.renderTargets[e].texture } } this.doRenderTarget(r.material, r.renderTargets[t]) } this.currentTextureIndex = t }, this.getCurrentRenderTarget = function (e) { return e.renderTargets[this.currentTextureIndex] }, this.getAlternateRenderTarget = function (e) { return e.renderTargets[0 === this.currentTextureIndex ? 1 : 0] }, this.dispose = function () { l.dispose(); let e = this.variables; for (let t = 0; t < e.length; t++) { let i = e[t]; i.initialValueTexture && i.initialValueTexture.dispose(); let r = i.renderTargets; for (let e = 0; e < r.length; e++)r[e].dispose() } }, this.addResolutionDefine = u, this.createShaderMaterial = h, this.createRenderTarget = function (i, s, a, o, l, u) { return i = i || e, s = s || t, a = a || r.ghU, o = o || r.ghU, l = l || r.hxR, u = u || r.hxR, new r.nWS(i, s, { wrapS: a, wrapT: o, minFilter: l, magFilter: u, format: r.GWd, type: n, depthBuffer: !1 }) }, this.createTexture = function () { let i = new Float32Array(e * t * 4), n = new r.GYF(i, e, t, r.GWd, r.RQf); return n.needsUpdate = !0, n }, this.renderTexture = function (e, t) { s.passThruTexture.value = e, this.doRenderTarget(a, t), s.passThruTexture.value = null }, this.doRenderTarget = function (e, t) { let r = i.getRenderTarget(), n = i.xr.enabled, s = i.shadowMap.autoUpdate; i.xr.enabled = !1, i.shadowMap.autoUpdate = !1, l.material = e, i.setRenderTarget(t), l.render(i), l.material = a, i.xr.enabled = n, i.shadowMap.autoUpdate = s, i.setRenderTarget(r) } } } }, 8823: (e, t, i) => { "use strict"; i.d(t, { Cc: () => u, L2: () => h, U4: () => l, YR: () => c, fs: () => d, lk: () => s, my: () => o, pu: () => f, qE: () => a }); let r = ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "0a", "0b", "0c", "0d", "0e", "0f", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "1a", "1b", "1c", "1d", "1e", "1f", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "2a", "2b", "2c", "2d", "2e", "2f", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "3a", "3b", "3c", "3d", "3e", "3f", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "4a", "4b", "4c", "4d", "4e", "4f", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "5a", "5b", "5c", "5d", "5e", "5f", "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "6a", "6b", "6c", "6d", "6e", "6f", "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "7a", "7b", "7c", "7d", "7e", "7f", "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "8a", "8b", "8c", "8d", "8e", "8f", "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "9a", "9b", "9c", "9d", "9e", "9f", "a0", "a1", "a2", "a3", "a4", "a5", "a6", "a7", "a8", "a9", "aa", "ab", "ac", "ad", "ae", "af", "b0", "b1", "b2", "b3", "b4", "b5", "b6", "b7", "b8", "b9", "ba", "bb", "bc", "bd", "be", "bf", "c0", "c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9", "ca", "cb", "cc", "cd", "ce", "cf", "d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7", "d8", "d9", "da", "db", "dc", "dd", "de", "df", "e0", "e1", "e2", "e3", "e4", "e5", "e6", "e7", "e8", "e9", "ea", "eb", "ec", "ed", "ee", "ef", "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "fa", "fb", "fc", "fd", "fe", "ff"], n = Math.PI / 180; function s() { let e = 0xffffffff * Math.random() | 0, t = 0xffffffff * Math.random() | 0, i = 0xffffffff * Math.random() | 0, n = 0xffffffff * Math.random() | 0; return (r[255 & e] + r[e >> 8 & 255] + r[e >> 16 & 255] + r[e >> 24 & 255] + "-" + r[255 & t] + r[t >> 8 & 255] + "-" + r[t >> 16 & 15 | 64] + r[t >> 24 & 255] + "-" + r[63 & i | 128] + r[i >> 8 & 255] + "-" + r[i >> 16 & 255] + r[i >> 24 & 255] + r[255 & n] + r[n >> 8 & 255] + r[n >> 16 & 255] + r[n >> 24 & 255]).toLowerCase() } function a(e, t, i) { return Math.max(t, Math.min(i, e)) } function o(e, t, i, r, n) { return r + (e - t) * (n - r) / (i - t) } function l(e, t, i) { return e !== t ? (i - e) / (t - e) : 0 } function u(e, t, i) { return (1 - i) * e + i * t } function h(e, t, i, r) { return u(e, t, 1 - Math.exp(-i * r)) } function c(e, t) { return e + Math.random() * (t - e) } function d(e) { return e * (.5 - Math.random()) } function f(e) { return e * n } }, 7134: (e, t, i) => { "use strict"; i.d(t, { eh: () => r }); let r = e => (t, i, r) => { let n = r.subscribe; return r.subscribe = (e, t, i) => { let s = e; if (t) { let n = (null == i ? void 0 : i.equalityFn) || Object.is, a = e(r.getState()); s = i => { let r = e(i); if (!n(a, r)) { let e = a; t(a = r, e) } }, (null == i ? void 0 : i.fireImmediately) && t(a, a) } return n(s) }, e(t, i, r) } }, 1323: (e, t, i) => { "use strict"; i.d(t, { v: () => o }); var r = i(6540), n = i(7283); let s = e => e, a = e => { let t = (0, n.y)(e), i = e => (function (e, t = s) { let i = r.useSyncExternalStore(e.subscribe, () => t(e.getState()), () => t(e.getInitialState())); return r.useDebugValue(i), i })(t, e); return Object.assign(i, t), i }, o = e => e ? a(e) : a }, 7283: (e, t, i) => { "use strict"; i.d(t, { y: () => n }); let r = e => { let t; let i = new Set, r = (e, r) => { let n = "function" == typeof e ? e(t) : e; if (!Object.is(n, t)) { let e = t; t = (null != r ? r : "object" != typeof n || null === n) ? n : Object.assign({}, t, n), i.forEach(i => i(t, e)) } }, n = () => t, s = { setState: r, getState: n, getInitialState: () => a, subscribe: e => (i.add(e), () => i.delete(e)) }, a = t = e(r, n, s); return s }, n = e => e ? r(e) : r }
}, e => { var t = t => e(e.s = t); e.O(0, [593, 792], () => (t(8424), t(8440))), _N_E = e.O() }]);